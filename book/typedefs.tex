\documentclass[conc-doc]{subfiles}

\begin{document}
	
	\chapter[Typedefs]{Typedefs}
	\label{chap:typedefs}
	
Concurnas provides a convenient mechanism for referring to type definitions. This is particularly useful for long qualified generic types. Typedefs can be used anywhere one would normally use a type. They enable us to translate the following, very verbose code:
\begin{lstlisting}
ArrayList<Set<HashMap<ArrayList<String>, Set<int>>>> myDataStructureInstance = new ArrayList<Set<HashMap<ArrayList<String>, Set<int>>>>(10)
\end{lstlisting}
Into the following, far easier to read (but functionally identical) form:
\begin{lstlisting}
typedef DataStructure = ArrayList<Set<HashMap<ArrayList<String>, Set<Integer>>>>

myDataStructureInstance DataStructure = new DataStructure(10)
\end{lstlisting}

This greatly improves the readability of code as well as increasing code reuse and reducing errors since less code needs to be written.

Typedefs go beyond traditional macro or type macro offerings seen in earlier languages in providing quantifiable type defs, this is particularly useful when defining typedefs on generic types where we wish to defer the generic type qualification. The syntax should feel familiar to that for using generic types: 
\begin{lstlisting}
typedef MyHashMap<X, Y> = HashMap<X, Y>

ml = new MyHashMap<int, String>()
\end{lstlisting}

Typedefs may refer to other typedefs like so:
\begin{lstlisting}
typedef MyList<X> = ArrayList<X>
typedef StringList = MyList<String>
\end{lstlisting}

Typedefs may also refer to other typedefs during qualification of generic types:
\begin{lstlisting}
typedef MyHashMap<X, Y> = HashMap<X, Y>
typedef MyList<X> = ArrayList<X>

item = MyList<MyHashMap<int, String>>()
\end{lstlisting}


\section{Default typedefs}
A typedef may be qualified with a default type. This default type overrides the typedef's type when it's used in order to create a new instance object (e.g. via the \lstinline{new} keyword). This is a useful feature for instances where one wishes to make use of a typedef to create concrete instances objects, but also use the typedef in order to encompass a more broad array of types than the default type, say an abstract class, trait or interface (e.g. \lstinline{List<X>} vs \lstinline{ArrayList<X>}). Consider the following:
\begin{lstlisting}
from java.util import List, ArrayList

typedef li<X> = List<X> default ArrayList<X>
\end{lstlisting}

Above, the \lstinline{li<X>} typedef is qualified with a default type of \lstinline{ArrayList<X>}. Hence, new instance objects created which refer to the \lstinline{li<X>} typedef will be created as instances of \lstinline{ArrayList<X>}, e.g.:
\begin{lstlisting}
inst li<String> = new li<String>()
\end{lstlisting}

Now, \lstinline{inst} is a \lstinline{ArrayList<String>} instance object which itself is compatible with the type of \lstinline{inst} - the \lstinline{li<X>} typedef since this resolves to \lstinline{List<String>} which is a superclass of \lstinline{ArrayList<String>}.
\end{document}