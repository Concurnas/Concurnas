

def int|double|long|String plus10times(a int) => this + (a*10)

def doings(){
	"" + [ "" + (2.01 plus10times 10), "" + (2 plus10times 10), "" + ("2" plus10times 10)]
}



/*
typedef numerical = int|long|short|float|double|char|byte
typedef aString = String
def thing(ab numerical) => ab

def doings(){
	a aString? = null
	"" + thing(2)
}
//should be ok, not overriding as private
*/

/*private enum AsyncComponentStatus{
	NOT_STARTED, RUNNING, TERMINATING, TERMINATED, STARTFAIL;
}


client String:? = null
runState AsyncComponentStatus = AsyncComponentStatus.RUNNING

def doSend(){
	while(runState == AsyncComponentStatus.RUNNING){
		client = null
	}
	
}

def doings() => "ok"
*/




/*

class GPURef<X>(type Class<?>[], ~event int) < com.concurnas.runtime.ref.Local<X>(type){
	public this(type Class<?>[]){
		this(type, 0)
	}

}

class NoZeroARgOne<X>(type Class<?>[], ~event int) < com.concurnas.runtime.ref.Local<X>(type)


def ok(a Object) Object:GPURef? {
	null//no cannot do this
}

def fail(a Object) Object:NoZeroARgOne? {
	null//no cannot do this
}

def doings(){
	what1 = try{ok("fail"); 'ok'}catch(e){'fail' + e}
	what2 = try{fail("fail"); 'fail' }catch(e){e.getMessage()}
	"" + [what1, what2] 
}
*/

/*
class GPURef<X>(type Class<?>[], ~event int) < com.concurnas.runtime.ref.Local<X>(type){
}


def ok<Typex>(a Typex) Typex:? {
	null
}

def fail<Typex>(a Typex) Typex:GPURef? {
	null//no cannot do this
}

def doings(){
	ok("hi")
	msg = try{
		fail("hi"); 'fail'
	}catch(e) { e getMessage }
	"fine " + msg 
}
*/


/*

def doings(){
	aa1 java.lang.Integer:? = null//ok

	""+ aa1
}
//wait forever
*/









/*
typedef li = List default ArrayList
typedef li<X> = List<X> default ArrayList<X>


def doings(){
	my li<String> = new li<String>(); 
	"" + my
}
*/


/*
def forEach<X, Y>(items X[], apply (X) Y) list<Y>{
	sz = items.length
	if(sz == 0){
		throw IllegalArgumentException("Input array is empty")
	}
	apply(item) for item in items
}
*/

//build, run tests and do:


//+ add to release notes


//document default for typedef
//add default for typedef to release notes





//defaults for typedefs
//typedef list<X> = List<X> default ArrayList<X>


//fix below @ module level and in docs

/*
tally1 = 2:
tally2 = 2:

finalCount = async{
pre{
count = 0
}

every(tally1){
count += tally1
}		

onchange(tally2){
count += tally2		
}

post{
count//return this value
}

}

tally1 = 9; tally1 = 10; tally1 = 10
tally2 = 45; tally2 = 3; tally2 = 53

tally1:close(); tally2:close()

await(finalCount)
//finalCount == 132
*/


//fix recording of nullable support on here
/*
from java.util import Optional

class HasOpti<Y?>{
	def thing<X?>(x X) => 12
}


def doings(){//java type may be qualified with nullable generic
	//even though its generic qualification is not nullable
	//local generic may be qualified in this way
	x = Optional.ofNullable<String?>("ok")
	y = HasOpti<String?>().thing<String?>("ok")

	//check for class level generics

	"ok " + (x, y)
}


def MyClass<X>(x X) {//not nullable
	x.toString()
}

def doings(){
	mc1 = MyClass<String?>('aString')//no cannot use this as thing is nullable but gen says not ok
}
*/





/*Support this:

new String?[10](null)


x String? = null
new String?[10, 2](x)
new String?[10, 2](null)
*/



//dist is still broken





////////////////




//todo: add homebrew to build
//upgrade gradle
//targetCompatibility=9-check on java 8







//improve error message on no method found
//fix michael work/tmp
//prevent run in vanilla java
//permit spawn from java


//add * and ? for classpath entries

//add conc repo to sublime pkg
//jypter
//default types for ifaces and typedefs


/*
docugen...

add to datautils:
[0]*10
a, b = 1, 2
x[0], x[1] = x[1], x[0]

operator overloading on bigdecimal etc
a * (x * x) + b * x + c;

*/




/*
//fix this...

$ conc -cp "joda-time-2.9.4.jar"
Welcome to Concurnas 1.14.020 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_251).
Currently running in REPL mode. For help type: /help

conc> import org.joda.time.DateTime
|  ERROR 1:0 Imported name: org.joda.time.DateTime cannot be resolved to a type

conc> from org.joda.time import DateTime
|  ERROR 1:0 Imported name: org.joda.time.DateTime cannot be resolved to a type

conc>


*/






//support repl comments
//fix the ctrl+c problem

//call conc from java, java from conc




//gpu java 8 support





/*
from java.net import URL, HttpURLConnection
from java.io import InputStreamReader, BufferedReader

url = new URL("http://google.com")

con = url.openConnection() as HttpURLConnection
try{
	status = with(con){//methods below implicitly called on con
		setRequestMethod("GET")
		setConnectTimeout(5000)
		setReadTimeout(5000)
		getResponseCode()//last called statement is returned from with
	}
	System.out.println(status)
	
	content = new StringBuffer()//StringBuffer is auto imported
	
	try(inp = new BufferedReader(new InputStreamReader(con.getInputStream()))){
		inputLine String? = ""//nullable as readLine can return null
		
		inputLine = inp.readLine()
		while (inputLine <> null) {
		    content.append(inputLine)
		    inputLine = inp.readLine()
		}
	}//inp.close() implicitly called at end of try block, even if exception thrown
	
	System.out.println(content)
}finally{//connection always closed if above code throws exception
	con.disconnect()
}


def doings(){
	"ok"
}
*/

/*
//bug on onchange generation below, as standalone and in repl

instances = 10000

def inc(input int:) => {input+1}!

head int:;
cur = head:;

for(x in 0 to instances){
	cur := inc(cur)
}

onchange(cur){
	System.out.println("{cur}")
}


head = 100; System.out.println("{cur}")
*/




//jypter - make work in conc













/*
//this doesnt work correctly in the REPL:

class CounterHolder(public -n int)

counter = CounterHolder(10)

countDownStr := sync{
	{
	    ret = StringBuilder()
	    while(counter.n-- > 0){//we are changing the value of n
	        ret.append(counter.n)
	    }
	    ret.toString()//return a String
	}!
}


System.out.println("countdown from: {counter.n} == {countDownStr}")

*/



//default for arraylist for typedefs, so we can do new List()...

/*
//expr list doesn't like this:
def thing<X>(apply (X, X) X, a X, b X) X{
	apply a b
}
*/