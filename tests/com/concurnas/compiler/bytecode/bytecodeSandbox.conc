
def doings() => "ok"


/*
from java.util import Optional

class HasOpti<Y?>{
	def thing<X?>(x X) => 12
}


def doings(){//java type may be qualified with nullable generic
	//even though its generic qualification is not nullable
	//local generic may be qualified in this way
	x = Optional.ofNullable<String?>("ok")
	y = HasOpti<String?>().thing<String?>("ok")

	//check for class level generics

	"ok " + (x, y)
}


def MyClass<X>(x X) {//not nullable
	x.toString()
}

def doings(){
	mc1 = MyClass<String?>('aString')//no cannot use this as thing is nullable but gen says not ok
}
*/








/*Support this:

new String?[10](null)


x String? = null
new String?[10, 2](x)
new String?[10, 2](null)
*/

//support repl comments
//fix the ctrl+c problem

//call conc from java, java from conc




//gpu java 8 support





////////////////




//todo: add homebrew to build
//upgrade gradle
//targetCompatibility=9-check on java 8


/*
fix:

BIT_SHIFT_X = SIZE_BITS_X = SIZE_BITS_Y = BIT_SHIFT_Z = SIZE_BITS_Z = 2

typedef BlockPos = long
def BlockPos x() int => (this << 64 - BIT_SHIFT_X - SIZE_BITS_X >> 64 - SIZE_BITS_X) as int
def BlockPos y() int => (this << 64 - SIZE_BITS_Y >> 64 - SIZE_BITS_Y) as int
def BlockPos z() int => (this << 64 - BIT_SHIFT_Z - SIZE_BITS_Z >> 64 - SIZE_BITS_Z) as int


def doings() => "" + ( 123123L x) 


//and document this

*/







//more datautils, print, sum, all, any, min, max, map, fold, foldr, foldl, avg, mean, mode
//improve error message on no method found
//fix michael work/tmp
//prevent run in vanilla java
//permit spawn from java


//add * and ? for classpath entries

//add conc repo to sublime pkg
//jypter
//default types for ifaces and typedefs


/*
docugen...

add to datautils:
print
map
all
reduce
left fold, right fold
any
min
max
sum
[0]*10
a, b = 1, 2
x[0], x[1] = x[1], x[0]

operator overloading on bigdecimal etc
a * (x * x) + b * x + c;

*/




/*
//fix this...

$ conc -cp "joda-time-2.9.4.jar"
Welcome to Concurnas 1.14.020 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_251).
Currently running in REPL mode. For help type: /help

conc> import org.joda.time.DateTime
|  ERROR 1:0 Imported name: org.joda.time.DateTime cannot be resolved to a type

conc> from org.joda.time import DateTime
|  ERROR 1:0 Imported name: org.joda.time.DateTime cannot be resolved to a type

conc>


*/









/*
from java.net import URL, HttpURLConnection
from java.io import InputStreamReader, BufferedReader

url = new URL("http://google.com")

con = url.openConnection() as HttpURLConnection
try{
	status = with(con){//methods below implicitly called on con
		setRequestMethod("GET")
		setConnectTimeout(5000)
		setReadTimeout(5000)
		getResponseCode()//last called statement is returned from with
	}
	System.out.println(status)
	
	content = new StringBuffer()//StringBuffer is auto imported
	
	try(inp = new BufferedReader(new InputStreamReader(con.getInputStream()))){
		inputLine String? = ""//nullable as readLine can return null
		
		inputLine = inp.readLine()
		while (inputLine <> null) {
		    content.append(inputLine)
		    inputLine = inp.readLine()
		}
	}//inp.close() implicitly called at end of try block, even if exception thrown
	
	System.out.println(content)
}finally{//connection always closed if above code throws exception
	con.disconnect()
}


def doings(){
	"ok"
}
*/

/*
//bug on onchange generation below, as standalone and in repl

instances = 10000

def inc(input int:) => {input+1}!

head int:;
cur = head:;

for(x in 0 to instances){
	cur := inc(cur)
}

onchange(cur){
	System.out.println("{cur}")
}


head = 100; System.out.println("{cur}")
*/



//default types for interfaces?


//jypter - make work in conc













/*
//this doesnt work correctly in the REPL:

class CounterHolder(public -n int)

counter = CounterHolder(10)

countDownStr := sync{
	{
	    ret = StringBuilder()
	    while(counter.n-- > 0){//we are changing the value of n
	        ret.append(counter.n)
	    }
	    ret.toString()//return a String
	}!
}


System.out.println("countdown from: {counter.n} == {countDownStr}")

*/

/*
def doings(){
	gps = gpus.GPU()
	deviceGrp = gps.getGPUDevices()[0]
	summary = deviceGrp getSummary()
	device = deviceGrp.devices[0]
	inoutGPU = device.makeOffHeapArrayMixed<int[]>(int[].class, 10)
	copyComplete boolean:gpus.GPURef = inoutGPU.writeToBuffer([1 2 3 4 5 6 7 8 9 10])
	await(copyComplete)
	"compl: " + copyComplete
}

//should be ok
//try on gralvm

*/



