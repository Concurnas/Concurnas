class MyHolder(public a int){
	override toString() => "MyHolder({a})"
}


shared shar = [456]
top1 = 123
top2 = Integer 123
holder = MyHolder(66)
myThings int: = 93//implicitly shared


def doings(){
	v1 = { (++top1, ++top2, ++holder.a, ++shar[0], ++myThings) }!
	await(v1)
	v2 = { (top1, top2, holder.a, shar[0], myThings)  }!
	await(v2)


	"ok" + (v1, v2)
}





/*
tally1 int: = 6969

finalCount := async{
	pre{
		count  = 0
	}
	every(tally1){
		count += tally1
	}
	post{
		count//return this value
	}
}

def doings(){
	tally1:close()
	"" + finalCount
}
*/



/*tally1 = 2:
tally2 = 2:

finalCount = async{
	pre{
		count = 0
	}
	
	every(tally1){
		count += tally1
	}		
	
	onchange(tally2){
		count += tally2		
	}
	
	post{
		count//return this value
	}

}

tally1 = 9; tally1 = 10; tally1 = 10
tally2 = 45; tally2 = 3; tally2 = 53


//finalCount == 132

def doings(){
	print("got here1")
	tally1:close(); tally2:close()
	print("got here2")
	await(finalCount)
	print("got here3")
	"" + finalCount
}
*/



/*Support this:

new String[10]//defaults to null, complain about this!


new String?[10](null)


x String? = null
new String?[10, 2](x)
new String?[10, 2](null)
*/



//map iterator should be on entry set, not key set


/*
//fix this...

$ conc -cp "joda-time-2.9.4.jar"
Welcome to Concurnas 1.14.020 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_251).
Currently running in REPL mode. For help type: /help

conc> import org.joda.time.DateTime
|  ERROR 1:0 Imported name: org.joda.time.DateTime cannot be resolved to a type

conc> from org.joda.time import DateTime
|  ERROR 1:0 Imported name: org.joda.time.DateTime cannot be resolved to a type

conc>


*/





//support repl comments




//fix recording of nullable support on here
/*
from java.util import Optional

class HasOpti<Y?>{
	def thing<X?>(x X) => 12
}


def doings(){//java type may be qualified with nullable generic
	//even though its generic qualification is not nullable
	//local generic may be qualified in this way
	x = Optional.ofNullable<String?>("ok")
	y = HasOpti<String?>().thing<String?>("ok")

	//check for class level generics

	"ok " + (x, y)
}


def MyClass<X>(x X) {//not nullable
	x.toString()
}

def doings(){
	mc1 = MyClass<String?>('aString')//no cannot use this as thing is nullable but gen says not ok
}
*/




//fix michael work/tmp
//fix other classloader related bug


//nasty bug setting thing to null on if branch






////////////////




//todo: add homebrew to build
//upgrade gradle
//targetCompatibility=9-check on java 8







//improve error message on no method found


//prevent run in vanilla java
//permit spawn from java


//add * and ? for classpath entries

//add conc repo to sublime pkg


/*
docugen...

add to datautils:
[0]*10
a, b = 1, 2
x[0], x[1] = x[1], x[0]

operator overloading on bigdecimal etc
a * (x * x) + b * x + c;
*/


//jypter



//fix the ctrl+c problem

//call conc from java, java from conc




//gpu java 8 support





/*
from java.net import URL, HttpURLConnection
from java.io import InputStreamReader, BufferedReader

url = new URL("http://google.com")

con = url.openConnection() as HttpURLConnection
try{
	status = with(con){//methods below implicitly called on con
		setRequestMethod("GET")
		setConnectTimeout(5000)
		setReadTimeout(5000)
		getResponseCode()//last called statement is returned from with
	}
	System.out.println(status)
	
	content = new StringBuffer()//StringBuffer is auto imported
	
	try(inp = new BufferedReader(new InputStreamReader(con.getInputStream()))){
		inputLine String? = ""//nullable as readLine can return null
		
		inputLine = inp.readLine()
		while (inputLine <> null) {
		    content.append(inputLine)
		    inputLine = inp.readLine()
		}
	}//inp.close() implicitly called at end of try block, even if exception thrown
	
	System.out.println(content)
}finally{//connection always closed if above code throws exception
	con.disconnect()
}


def doings(){
	"ok"
}
*/

/*
//bug on onchange generation below, as standalone and in repl

instances = 10000

def inc(input int:) => {input+1}!

head int:;
cur = head:;

for(x in 0 to instances){
	cur := inc(cur)
}

onchange(cur){
	System.out.println("{cur}")
}


head = 100; System.out.println("{cur}")
*/




//jypter - make work in conc













/*
//this doesnt work correctly in the REPL:

class CounterHolder(public -n int)

counter = CounterHolder(10)

countDownStr := sync{
	{
	    ret = StringBuilder()
	    while(counter.n-- > 0){//we are changing the value of n
	        ret.append(counter.n)
	    }
	    ret.toString()//return a String
	}!
}


System.out.println("countdown from: {counter.n} == {countDownStr}")

*/



/*
//expr list doesn't like this:
def thing<X>(apply (X, X) X, a X, b X) X{
	apply a b
}
//on lambda?

//also a problem:
print "got here"

*/