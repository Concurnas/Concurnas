//##1. basic declarations
a2 int:: =9  //int:
def doings() String{
	a int:  =9  //int:
	return "" + [a is int:,  a2 is int::]
}

~~~~~
//##1b. basic declarations
def doings() String{
	a double:  =9.0  //double:
	return "" + [a is double:]
}

~~~~~
//##1.c double check
def doings() String{
	a double: 
	a=9.0
	b=a
	return "" + [a is double:]  + ":" + a +":"+b
}

~~~~~
//##2. basic declarations - no assignment

def doings() String{
	a int: 
	return "" + [a is int:]
}

~~~~~
//##2b. basic declarations - no assignment

def doings() String{
	a double: 
	return "" + [a is double:]
}

~~~~~
//##3. basic assignment

def doings() String{
	a int: 
	a=9
	return "" + [a is int:]
}

~~~~~
//##3b. basic assignment

def doings() String{
	a double: 
	a=9.0
	return "" + [a is double:]
}

~~~~~
//##4.1.a preable
def doings() String{
	ref1 := 5
	ref2 := ref1:
	ref3 := 5
	five = 5
	
	z = ref1 == ref2
	z2 = ref1 == ref3
	z3 = ref1 == five
	
	return "" + [z, z2, z3] 
}

~~~~~
//##4.1.b preable
def doings() String{
	ref1 int:= 5
	five = 5
	
	z = five == ref1 
	z2 = ref1 == five
	
	return "" + [z, z2]
	
}

~~~~~
//##4.1.c preable
def doings() String{
	ref1 := 5
	five = 5
	return "" + [ref1 == five, five == ref1]
}

~~~~~
//##4.1.d preable more

def doings() String{
	a := 1
	
	z1 = a &<> a:
	z2 = a: &<> a
	z3 = a <> a:
	z4 = a: <> a
	
	return "" + [z1, z2, z3, z4]
}

~~~~~
//##4.1.e preamble not variant

def doings() String{
	a := true
	b := false
	
	z3 = a <> b:
	
	return "" + [ a <> b:, a: <> b, a== (not b), not b == a  ]
}

~~~~~
//##4.1.f final preamble

class MyCls{}

def doings() String{
	myOne = new MyCls()

	a := myOne
	b := myOne
	
	return "" + [ [ a &== b, a &<> b:, a: &<> b, a: &<> b: ], [ a == b, a <> b:, a: <> b, a: == b: ] ]
}

~~~~~
//##4. implicit type declaration
def doings() String{
	a :  =9  //int:
	return "" + [a is int:]
}

~~~~~
//##4.b implicit type declaration

def doings() String{
	ref1 := 5
	ref2 := ref1:
	
	x = ref1 is int:
	y = ref2 is int:
	z = ref1 &== ref2 //true, same underlying obj
	z2 = ref1 == ref2 //true, same underlying value
	z3 = ref1: &== ref2: //same refernce
	z4 = ref1: &<> ref2  //ref != contained value
	
	//d = [x,y, z, z2]
	
	return "" +  [x,y, z, z2, z3, z4]
}

~~~~~
//##4.c implicit type declaration
def doings() String{
	ref1 := 5
	ref2 int:= ref1: //different code path
	
	x = ref1 is int:
	y = ref2 is int:
	z = ref1 &== ref2
	
	//d = [x,y, z ]
	
	return "" +  [x,y, z ]
}

~~~~~
//##4.d implicit type declaration

def doings() String{
	ref1 := 5
	ref2 := ref1 //implicit implicit
	
	return "" + [ref2 is int:, ref1 &== ref2] 
}

~~~~~
//##5. basic function calls

c=0
def functo(a int:) {
c++
 }

def doings() String{
	ref1 := 5
	ref2 int:= ref1
	ref3 := ref1
	
	functo(ref2:)
	functo(ref3:)
	
	return "" + [ref1 is int:, ref2 is int:, ref3 is int:, ref1 &== ref2, ref1 &== ref3, c==2] //+ c 
}

~~~~~
//##5.b basic function calls

def gogo(a int:) {}

def doings() String{
	ref1 int:= 5
	newChild2 : = ref1//just refname -> make new ref, get contents of ref1
	
	gogo(ref1)
	gogo(newChild2)
	
	return "k" 
}

~~~~~
//##6.a basic gets
def doings() String{
	a int: =9  
	return "" + a
}

~~~~~
//##6.b gets
def doings() String{
	a int: =9   //int:
	
	b = a
	c2 Integer 
	c Integer = a
	c2  = a
	
	d = a * b	
	e = a:get() + a //implicit pulls out the value of the ref, a.get()
	f = a + a:get() //is this a bug or a feature? hmmm
	
	g=a+1
	h=1+a
				
	return "" + [b is Integer, c is Integer] + " " + [b, c, c2, d, e, f,g,h]
}

~~~~~
//##7. str ops
def doings() String{
	a int: = 9
	one = "" + a
	two = a + ""
	
	three = "" + a: //the toString fucntion gets called!
	four  = a: + "" 
		
	return "" + [one=="9", two=="9", "9:" == three, "9:" == four ]
}

~~~~~
//##8. array casting str
def doings() String{
	a int: =9   //int:
	ar = [400, a]//type -> int[]
	ar2 = [4, a:]// -> int:[]
	ar3 = [a,a]// -> int[]
	
	return "" + ar2 + ":" + ar + ":" + ar3
}

~~~~~
//##8.b array casting str
def doings() String{
	a double: = 9   
	ar = [400, a]
	ar2 = [4, a:]
	ar3 = [a,a]
	
	return "" + ar + "~~" + ar2 + "~~" + ar3
}

~~~~~
//##11.a instanceof check
def doings() String{
	a int: =9   //int:
	b = a
	c Integer = a
				
	return "" + [a is int:, b is Integer, c is Integer]//autoextracts
}

~~~~~
//##11.b instanceof check
def doings() String{
	ref1 := 5
	return "" + [(ref1: as Object) isnot Float:, (ref1: as Object) is Integer:]
}

~~~~~
//##11.c instanceof check - simpler
//this test is a great big mess because really going from double: to object: is not something you'd want to sensibly do
//so the cast is expected to fail
def doings() String{
	a double: 
	o Object = (a: as Object) //have to keep it as a ref, if converted to Object then we loose the type information
	//^ the above blows up as type must match 1:1
	asO Object = o as Object
	
	return ""  + [asO is double:, asO isnot int:]
}


~~~~~
//##12. arrays of refs

def doings() String{
	ax  int:[] = a[8:, 8:]
	b  = a[8:, 8:]
	z = ax[1]
	z2 = ax[0]:
	ax[0] = 9
	f = ax is int:[]
		
	return "" + [ax,b] + "" + [""+z, ""+z2] + "@" + [f]
}

~~~~~
//##13. comparison operations

def doings() String{
	a := 1
	
	z1 = a &<> a:
	z2 = a: &<> a
	z3 = not (a &== a:)
	z4 = not (a: &== a)
	
	return "" + [z1, z2, z3, z4]
}

~~~~~
//##14. refs from external locations

from com.concurnas.lang.precompiled import RefHelper

def doings() String{
	r1 = RefHelper.getIntegerRef(62): //force this to stay as a ref
	r2 := RefHelper.getIntegerRef(62):
	r3 int:= RefHelper.getIntegerRef(62):
		
	return "" + [r1 is int:, r2 is int:, r3 is int:]   +  ":"  +  [""+r1, ""+r2, ""+r3]
}

~~~~~
//##14.b refs from external locations

from com.concurnas.lang.precompiled import RefHelper

def doings() String{
	r1 = RefHelper.getIntegerRef(62): //force this to stay as a ref
	r2 := RefHelper.getIntegerRef(62)
	r3 int:= RefHelper.getIntegerRef(62)
		
	return "" +  [r1 is int:, r2 is int:, r3 is int:]   +  ":"  +  [""+r1, ""+r2, ""+r3]
}

~~~~~
//##15. null ref handle ok

from com.concurnas.lang.precompiled import RefHelper

def doings() String{
	ref3 int:= RefHelper.getNullRef2()
	ref4 int:= RefHelper.getNullRef2()
	
	z = try{
	 g=[null &== ref3, ref3 &== null]
	 false
	}catch(e NullPointerException){
		true //we expect a npe
	}
	
	z2 = [null &== ref3:, ref3: &== null]
	//both value and raw thing are null
	return "" + [z, z2] //+ [ null == ref3, ref1 == ref3       ]
}

~~~~~
//##16. implicit and explicit cast

def doings() String{
	ref1 := 5
	
	o Object = ref1: as Object
	cont Object = ref1 as Object
	
	// 2nd variant
	o2 Object = ref1: 
	cont2 Object = ref1 
	
	// 3rd variant
	o3  = ref1: as Object
	cont3 = ref1 as Object
		
	return "" + [o isnot Float:, o is Integer:, cont isnot Float, cont is Integer] +"\n" \ 
			  + [o2 isnot Float:, o2 is Integer:, cont2 isnot Float, cont2 is Integer] +"\n" \ 
			  + [o2 isnot Float:, o2 is Integer:, cont2 isnot Float, cont2 is Integer]  
}

~~~~~
//##17. another cast check

def doings() String{
	z int: = 9
	o = z	//int
	
	return "" + [ o is Integer,  o is not Integer:] //can technically be either, intercangable useage
}

~~~~~
//##18. more cast check

def doings() String{
	z Object: = 9
	o2  = z as Object:	//int:
	o3 Object: = (z: as Object)

	check =  o2: &== z:
	check2 =  o3: &== z: //no crazy copying going on
	return "" +  [check, check2]
}

~~~~~
//##19. print out ok

def doings() String{
	z int: = 9
	o  = z as Integer	//int
		
	return "" + o + "," + z + "," + z:
}

~~~~~
//##19.a print out ok

def doings() String{
	z := 9
	f = z as Integer:
	return "" + z
}

~~~~~
//##19.b print out ok

def doings() String{
	z int: = 9
	o = z as Integer:	//int
	
	z=10
	
	return "" + o: + "," + o
}

~~~~~
//##20. cast exception on ref to int even if otherwise ok

from com.concurnas.lang.precompiled.RefHelper import getIntegerRef, getIntegerRefAsObject

def doings() String{
	try{
	 	tg = 9
		refasObj1 Object = getIntegerRefAsObject(7)
		
		directfail = refasObj1 as Integer
		
		return "fail" 
	}
	catch (e){
		return "okexcep"
	}
}

~~~~~
//##21. check cast from obj etc
from com.concurnas.lang.precompiled.RefHelper import getIntegerRef, getIntegerRefAsObject

def doings() String{
 	tg = 9
	refasObj1 Object = getIntegerRefAsObject(7)
	
	refasObj1IntRef  = refasObj1 as Integer:
	asInt = refasObj1IntRef as Integer
	
	asRefNotLocked = (refasObj1 as Integer:)
	asInt2 = asRefNotLocked as Integer

	ohLocked = "its ok" 
	try{
		asInt2 = (refasObj1 as Integer:) as Integer //ur locking the ref in place
	}
	catch(e Exception){
		ohLocked = "" + e
	}
	
	//can go from I: to Obj to I but has to go via ref cast
	
	return "" + refasObj1IntRef + "" + refasObj1IntRef: + "]]" + [asInt, asInt2]  + ":~:" + [refasObj1 is Integer:, refasObj1IntRef is  Integer:, asInt is Integer, asInt2 is Integer] + "\nonlockedExpect: " + ohLocked
}

~~~~~
//##22. check cast from obj etc 2 - more complex cases, ref to raw, raw to ref via cast

from com.concurnas.lang.precompiled.RefHelper import getIntegerRef, getIntegerRefAsObject

def doings() String{
 	tg = 9
	refasObj1 Object = getIntegerRefAsObject(7)
	
	//from int: -> Obj to Integer
	notInt = refasObj1 isnot Integer
	itsok  = (refasObj1 as int:) is Integer //this is ok - its an int cos can be used as one
	itsok2  = (refasObj1 as int:) is int: //this is ok - its an int cos can be used as one
	
	//from int to int: via cast
	seven Integer = 7
	sevend Object = new Double(7)
	isCanBeRef = seven is not Integer: //cannot upgrdate it
	isCanBeRef2 = sevend isnot Integer:
	asRef = seven as Integer:
	itsokmore = asRef is int:
	
	return "" + [""+notInt, ""+itsok, ""+itsok2, ""+isCanBeRef, ""+isCanBeRef2, ""+itsokmore, ""+asRef:]
	
}

~~~~~
//##23. check cast unref etc

def doings() String{
	z int: = 9
	o  = z as Object	//int
		
	xxx2 = o is Integer   //it's a int: but also a int....?... yes, yes it is...
	xxx3 = (z as Object) is Integer
	
	return "" + [xxx2, xxx3]
}

~~~~~
//##24. another set of casts

def doings() String{
	z Object: = 9
	o  = z as Object	//int
	o2  = z as Object:	//int:
	
	xxx2 = o is Integer
	xxx3 = (z as Object) is Integer
	
	xxx4 = o2 is Object:
	xxx5 = (z as Object:) is Object:
	
	check =  o2: &== z://no weird copying going on
	check2 = o &== z
	
	return "" + [z is Object:, xxx2, xxx3, xxx4, xxx5, check, check2] // + xxx// [ o is Integer,  o isnot Integer:]
}

~~~~~
//##25. simple array casts:

def doings() String{
	ax  int:[] = [8: 8:] //init
	
	b int: = ax[0]       //get
	ax[0] = 7:           //set
	
	z = ax as Object
	
	f = z is int:[] //is
	
	g = z as int:[] //as
	
	return "" + ax + "@" + b: + "" + f + "" + g
}

~~~~~
//##25.b simple array casts: - advanced

from com.concurnas.lang.precompiled.RefHelper import getRefArray, getRefArrayNull, getRefArrayNull2

def doings() String{//wrong needs to be fixed
	z Object= getRefArray()
	
	ok = z is int:[] 
	
	notok = z isnot double:[]
	
	notok3 = (getRefArrayNull() as Object)  isnot int:[]
	notok4 = (getRefArrayNull2() as Object) isnot int:[]
	
	
	castok = z as int:[] 
	
	
	castnotok  = false
	
	try{
		qq=z as double:[]
	}
	catch(e Exception){
		castnotok=true
	}
		
	return "" + [ok, notok, notok3, notok4, castok, castnotok]
}

~~~~~
//##26.a refs of arrays - get

def doings() String{
	b = [1,2]:
	return "" + b[0]
}

~~~~~
//##26.b refs of arrays - set

import com.concurnas.runtime.ref.RefArray
ax int:RefArray = [Integer(1) 2]
b = [1,2]:

def doings() String{
	ax[0]=23
	b[0]=23//doesnt work as it operates on extracted COPY of data
	return "" + [ax, b]
}

~~~~~
//##26.c refs of arrays - explicit type dec probably other usese

def doings() String{
	b int[]:= [1 2]:
	return "" + b[0]
}

~~~~~
//##26.d refs of arrays - simple print, ref all
def getAr() int[]:[]{
	return a[[1 2]: , [1 2]:]
}

def doings() String{
	ax int[]:[] = getAr()
	b  =  a[[1 2]: , [1 2]:]
	
	z = ax[0]
	z2 = z[0]
	
	z3 = ax[0,0]
	z4 = ax[0][0] // int[]:[] -> int[]:
	
	return "" + ax + "===" + ax[0]:+ ">" + [""+ z, ""+ z2, "" + z3, ""+ z4]
}

~~~~~
//##26.e refs of arrays - ok check u can make an array of these ref arrays

def getAr() int:[]{
	return [1: 2:]
}

def doings() String{
	ax int:[] = getAr()
	
	z = [ax,ax] //so it's ax int:[][] // i.e. generic axrraxy, generic axrraxy...
	ax[0]=9
	
	return "" + z
}

~~~~~
//##26.f refs of arrays - ok check u can make an array of these ref arrays more complex
def getAr() int[]:[]{
	return a[[1 2]: , [1 2]:]
}

def doings() String{
	ax int[]:[] = getAr()
	
	z = [ax,ax] //so it's a int[]:[][] // i.e. generic array, generic array...
	
	return "" + z
}

~~~~~
//##26.g.1 getting silly now

def doings() String{
	xxx = [[1:, 2:]:, [3:, 4:]:] //wow
	
	return "" + xxx
}

~~~~~
//##26.g.2 getting silly now 2

def doings() String{
	xxx = [[1:, 2:]:, [3:, 4:]:]: //wow
	
	return "" + xxx:
}

~~~~~
//##26.g.3 getting silly now

def doings() String{
	a int[]: = [1  2]:
	a2 := [1  2]:
	
	xxx  = [a a2]:
	xxx2 int[2]: = [a a2]: //just one
	xxx3 int[]:[]: = [a: a2:]: //just one
	
	return "" + xxx + "==" + xxx2 + "\n" + xxx3+ "\n" + xxx3:+ "\n" + xxx3[0]+ "\n" + xxx3[0]:
}

~~~~~
//##26.g.4 getting silly now

def doings() String{
	a int[]: = [1  2]:
	
	xxx2 int[]:[]: = [a: a]: //just one tagged as ref
	y = [12: 5 6]//same here
	
	return "" + xxx2 + "==" + y
}

~~~~~
//##27.a arr assignment 2d cases

def doings() String{
	ax int[]: = [1  2]:
	b := [10  20]:
		
	xxx  = [ax: ax ax]:
	
	ax[1]=81
	xxx[0][0]=9
	
	xxx[1]=b:
		
	return "" + xxx
}

~~~~~
//##27.b arr assignment 3d cases

def doings() String{
	oned = a[1: , 2:]:
	twod = [oned  oned  oned:]:
	threed = a[twod , twod , [a[10: , 27:]:]: ]:
		
	threed[0] = a[a[3:,4:]: , a[3:,4:]:]:
	threed[1][0] = a[30:, 40:]:
	threed[2][0][0] = 300 //ah, u even get an autoconvert to ref type
			
	return "" + threed
}

~~~~~
//##28. i thought this was a bug but clearly i was wrong

def doings() String{
	jj = new Integer(9)
	return "" + (jj is not int:) + "->"  + (jj as int:):
}


~~~~~
//##29.1 revisit as logic
from java.util import HashMap

def doings() String{
	z  = (new HashMap<String, Integer>())!
	
	//thing being as-ed is a ref already
	asObj = z as HashMap<String, Integer>:
	
	failExpect = "fail"
	try{
		asdasd = (asObj as Object) as Integer: //fail as incompatbile, throw exception
	}
	catch(e Exception){
		failExpect = "" + e
	}
			
	return "" + asObj + "" + failExpect
}

~~~~~
//##29.2 revisit as logic
from java.util import HashMap

def doings() String{
	origMap = new HashMap<String, Integer>()

	z  = (origMap)!
	
	asObjRef = z: as Object //this is a ref
	asObjRef2 Object = z: //this is a ref
	asObj1 = z as Object //this extracts the object
	asObj2 = z as HashMap<String, Integer> //as does this
		
	return "" + ["" + asObjRef, "" + asObjRef2,  "" + asObj1, "" + asObj2] \ 
			 + "" + [asObjRef &<> origMap, asObjRef2 &<> origMap,  asObj1 &<> origMap, asObj2 &<> origMap    ]
			 //last two would normally be false but cos we copy the thing so as to presever isolation, its not
}


~~~~~
//##29.3 revisit as logic
from java.util import HashMap

def rrr(o Object) int{
	return System.identityHashCode(o)
}

def doings() String{
	origZ = new HashMap<String, Integer>()
	z  = origZ:
	zObj Object = origZ
	asObj Object = z:
	
	asA := z  //check can be cast
	asA2 = origZ as HashMap<String, Integer>: //create a new ref
	asA3 = (asObj as Object) as HashMap<String, Integer>: //check ref, cast to type, check type
	asA4 = asObj as HashMap<String, Integer>: //check ref, cast to type, check type
	
	theexcep = "fail"
	try{
		sdf = (asObj as Object) as Integer: //check can be cast
	}
	catch(e){
		theexcep =""+ e
	}
	
	theexcep2 = "fail"
	try{
		sdf = zObj as Integer: //check can be cast
	}
	catch(e){
		theexcep2 =""+ e
	}
		
	return "" + [ "" + asA:,  "" + asA2:,  "" + asA3:, "" + asA4: ] \ 
	  		+ "\n" + theexcep \ 
	  		+ "\n" + theexcep2 \ 
	  		+ "\n" +[ rrr(asA:) == rrr(z:),  rrr(asA2:) <> rrr(origZ:), rrr(asA3:) == rrr(z:), rrr(asA4:) == rrr(z:)  ]
	  		//again, isolation copy
}



~~~~~
//##29.4 revisit as logic - ensure autobox up

from java.util import HashMap

def doings() String{
	x = 5 as Object:
	
	return "" + x:
}

~~~~~
//##29.5 some other tests

from java.util import HashMap

def doings() String{
	a double: 
	o Object: = 2.0 //should blow up
	
	z  = (new HashMap<String, Integer>())!
	
	asobj = (z as HashMap<String, Integer>:)
	//asobj2 := (z as Integer:) <- should blow up
		
	check = (asobj: as Object) is HashMap<String, Integer>:
	
	bo = o: as Object //o: is an Object
		
	return "" + [check, bo is not double:, bo is not Double, bo isnot int:, (z: as Object) is HashMap<String, Integer>:, (z: as Object) isnot HashMap<String, String>:  ]
}


~~~~~
//##30. module level fields

y int: = 8
z := 6

def doings() String{
	y = 5
	z = 5
	
	return "Hello world" + [y,z:]
}

~~~~~
//##31. clsas level fields

class K{
	//public y : = 8
	public y := 8
	public var y2 := 8 
	public z int:= 6
}

//above as classdef args

def doings() String{
	k = new K()
	k.y = 5
	k.y2 = 5
	k.z = 5
	
	return "Hello world"  + [k.y, k.y2, k.z:]
}


~~~~~
//##32.a class fields

class Ksdfdsf{
	public y int:
	public z int:
	
	this(ay int, az int ){
		this.y=ay;
		this.z=az;
	}
}

def doings() String{
	k = new Ksdfdsf(12, 13)
	return "Hello world"  + [k\.y, k\.z:]
}

~~~~~
//##32.b class fields more

class Klass{
	public ~y int:
	public ~z String:
	
	this(ay int:, z String){ 
		y=ay;
		this.z=z
	}
	
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
}

class Glass2(public ~y int:, public ~z String: )  { }

//class Fass(public ~y int:, public ~z : )  { }
class Fass( public ~z : )  { }


def doings() String{
	k = new Klass(12, "mate")
	g = new Glass2(12, "mate")
	f = new Fass(  "mate")
	
	a= ""  + [k\.y, k\.z, k.y, k.z] + \ 
			"\n" + [g\.y, g\.z, g.y, g.z] + \ 
			"\n" + [f.z]
	b = ""  + [k\.y, k\.z, k.y, k.z:] + \  //these  get upcast to ref,
			"\n" + ([g\.y g\.z g.y g.z:] is java.lang.Comparable<Object>:[]) + \ //see, proof!
			"\n" + [g\.y, g\.z, g.y, g.z:] + \ //these dont get upcast to ref, instead everything gets upcast to Object
			"\n" + [f.z:]//naugthy double test, this lot gets upcast
	return a + "~" +b 
}

~~~~~
//##33.a module field correct behavour - simple case


def doings() String{
	z String: = "initial"
	z2 String: = "initial2"
	anotherRef String:= "newValue"
	
	asVal = z
	asVal2 = z2
	
	refToPrev := z //copy pointer to ref
	refToPrev2 := z2
			
	z = anotherRef //replace VALUE only
	z2 := anotherRef //replace whole REF!
	
	anotherRef = "newValue2"
	
		
	return "" + [""+z, ""+z2] +  \ 
		   "\n" + [""+asVal, "" + asVal2] + \ 
		   "\n" + [ ""  + refToPrev:, "" + refToPrev2]
}

~~~~~
//##33.1.a module field correct behavour

def doings1() String{
	z : ="initial"

	asVal = z
	refToPrev := z
	z = ("newValue")
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings2() String{
	z : ="initial"

	asVal = z
	refToPrev := z
	z := "newValue" //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings3() String{
	z : ="initial"

	asVal = z
	refToPrev := z
	z = "newValue": //rhs locked as ref thus write over the z ref
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings3b() String{
	z : ="initial"

	asVal = z
	refToPrev := z
	tweakOnVar = "newValue":
	z = tweakOnVar //rhs is not locked as ref thus just write over value
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings4() String{
	z : ="initial"

	asVal = z
	refToPrev := z
	
	anotherRef = "newValue":
	z := anotherRef //replace ref
	
	anotherRef = "more stuff"
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##33.1.b module field correct behavour - with int

def doings1() String{
	z : = 1

	asVal = z
	refToPrev := z
	z = (2)
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings2() String{
	z : =1

	asVal = z
	refToPrev := z
	z := 2 //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings3() String{
	z : =1

	asVal = z
	refToPrev := z
	z = 2: //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings3b() String{
	z : =1

	asVal = z
	refToPrev := z
	f = 2:
	z = f //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings4() String{
	z : =1

	asVal = z
	refToPrev := z
	
	anotherRef = 2:
	z := anotherRef //replace ref
	
	anotherRef = 3
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z, "" + anotherRef]
}

def doings() String{
	return "" + doings1() + "\n" + doings2() + "\n" + doings3() + "\n" + doings3b() + "\n" + doings4()
}



~~~~~
//##33.1 module field correct behavour - as mod

z1 : ="initial"
z2 : ="initial"
z3 : ="initial"
z3b : ="initial"
z4 : ="initial"


def doings1() String{

	asVal = z1
	refToPrev := z1
	z1 = ("newValue")
	return "" + [""+asVal, ""  + refToPrev: , "" + z1]
}

def doings2() String{

	asVal = z2
	refToPrev := z2
	z2 := "newValue" //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + z2]
}

def doings3() String{

	asVal = z3
	refToPrev := z3
	z3 = "newValue": //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z3]
}

def doings3b() String{

	asVal = z3b
	refToPrev := z3b
	j = "newValue":
	z3b = j //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z3b]
}

def doings4() String{

	asVal = z4
	refToPrev := z4
	
	anotherRef = "newValue":
	z4 := anotherRef //replace ref
	
	anotherRef = "more stuff"
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z4, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##33.2 module field correct behavour - as mod int
z1 : =1
z2 : =1
z3 : =1
z3b : =1
z4 : =1


def doings1() String{

	asVal = z1
	refToPrev := z1
	z1 = (2)
	return "" + [""+asVal, ""  + refToPrev: , "" + z1]
}

def doings2() String{

	asVal = z2
	refToPrev := z2
	z2 := 2 //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + z2]
}

def doings3() String{

	asVal = z3
	refToPrev := z3
	z3 = 2: //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z3]
}

def doings3b() String{

	asVal = z3b
	refToPrev := z3b
	g = 2:
	z3b = g //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z3b]
}

def doings4() String{

	asVal = z4
	refToPrev := z4
	
	anotherRef = 2:
	z4 := anotherRef //replace ref
	
	anotherRef = 3
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z4, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##34. sneak in double check

def doings() String{
	z = ("newValue")! //locked as ref!
	z2 = ("newValue")! as String: //also locked as ref
	
	return "" + z: + " " + z2:
}


~~~~~
//##33.1 as module fields in clinit

doings1 ="fail"
doings2 ="fail"
doings3 ="fail"
doings3b ="fail"
doings4 ="fail"

{
	z1 : ="initial"
	
	asVal = z1
	refToPrev := z1
	z1 = ("newValue")
	doings1 = "" + [""+asVal, ""  + refToPrev: , "" + z1]
}

{
	z2 : ="initial"
	
	asVal = z2
	refToPrev := z2
	z2 := "newValue" //this is a new ref
		 
	doings2 = "" + [""+asVal, ""  + refToPrev: , "" + z2]
}

{
	z3 : ="initial"
	
	asVal = z3
	refToPrev := z3
	z3 = "newValue": //z takes value from rhs ref, but not override
	//u must use : for that
		
	doings3 = "" + [""+asVal, ""  + refToPrev: , "" + z3]
}

{
	z3 : ="initial"
	
	asVal = z3
	refToPrev := z3
	git = "newValue":
	z3 = git //z takes value from rhs ref, but not override
	//u must use : for that
		
	doings3b = "" + [""+asVal, ""  + refToPrev: , "" + z3]
}

{
	z4 : ="initial"

	asVal = z4
	refToPrev := z4
	
	anotherRef = "newValue":
	z4 := anotherRef //replace ref
	
	anotherRef = "more stuff"
		
	doings4 = "" + [""+asVal, ""  + refToPrev: , "" + z4, "" + anotherRef]
}

def doings() String{
	return "" + doings1 \ 
			+ "\n" + doings2 \ 
			+ "\n" + doings3 \ 
			+ "\n" + doings3b \ 
			+ "\n" + doings4
}

~~~~~
//##33.2 as module fields in clinit - as int

doings1 ="fail"
doings2 ="fail"
doings3 ="fail"
doings3b ="fail"
doings4 ="fail"

{
	z1 : =1
	
	asVal = z1
	refToPrev := z1
	z1 = (2)
	doings1 = "" + [""+asVal, ""  + refToPrev: , "" + z1]
}

{
	z2 : =1
	
	asVal = z2
	refToPrev := z2
	z2 := 2 //this is a new ref
		 
	doings2 = "" + [""+asVal, ""  + refToPrev: , "" + z2]
}

{
	z3 : =1
	
	asVal = z3
	refToPrev := z3
	z3 = 2: //z takes value from rhs ref, but not override
	//u must use : for that
		
	doings3 = "" + [""+asVal, ""  + refToPrev: , "" + z3]
}

{
	z3 : =1
	
	asVal = z3
	refToPrev := z3
	g=2:
	z3 = g //z takes value from rhs ref, but not override
	//u must use : for that
		
	doings3b = "" + [""+asVal, ""  + refToPrev: , "" + z3]
}

{
	z4 : =1

	asVal = z4
	refToPrev := z4
	
	anotherRef = 2:
	z4 := anotherRef //replace ref
	
	anotherRef = 3
		
	doings4 = "" + [""+asVal, ""  + refToPrev: , "" + z4, "" + anotherRef]
}

def doings() String{
	return "" + doings1 \ 
			+ "\n" + doings2 \ 
			+ "\n" + doings3 \ 
			+ "\n" + doings3b \ 
			+ "\n" + doings4
}

~~~~~
//##33.2 as class fields direct access - ext

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 : ="initial"
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = ("newValue")
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 := "newValue" //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = "newValue": //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3b() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	g = "newValue":
	mycls.z1 = g //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	
	anotherRef = "newValue":
	mycls.z1 := anotherRef //replace ref
	
	anotherRef = "more stuff"
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##33.2.b as class fields direct access - ext as int

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 : =1
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = 2
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 := 2 //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = 2: //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3b() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	g=2:
	mycls.z1 = g //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	
	anotherRef = 2:
	mycls.z1 := anotherRef //replace ref
	
	anotherRef = 3
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##33.3 as class fields direct access - internal

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 : ="initial"
		
	def doings1() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 = ("newValue")
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings2() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 := "newValue" //this is a new ref
			 
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings3() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 = "newValue": //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings3b() String{
		asVal = this.z1
		refToPrev := this.z1
		g = "newValue":
		this.z1 = g //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings4() String{
		asVal = this.z1
		refToPrev := this.z1
		
		anotherRef = "newValue":
		this.z1 := anotherRef //replace ref
		
		anotherRef = "more stuff"
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:, "" + anotherRef]
	}
}

def doings() String{
	return "" + new MyCls().doings1() \ 
			+ "\n" + new MyCls().doings2() \ 
			+ "\n" + new MyCls().doings3() \ 
			+ "\n" + new MyCls().doings3b() \ 
			+ "\n" + new MyCls().doings4()
}

~~~~~
//##33.3.b as class fields direct access - internal - int

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 : =1
		
	def doings1() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 = (2)
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings2() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 := 2 //this is a new ref
			 
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings3() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 = 2: //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings3b() String{
		asVal = this.z1
		refToPrev := this.z1
		b=2:
		this.z1 = b //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings4() String{
		asVal = this.z1
		refToPrev := this.z1
		
		anotherRef = 2:
		this.z1 := anotherRef //replace ref
		
		anotherRef = 3
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:, "" + anotherRef]
	}
}

def doings() String{
	return "" + new MyCls().doings1() \ 
			+ "\n" + new MyCls().doings2() \ 
			+ "\n" + new MyCls().doings3() \ 
			+ "\n" + new MyCls().doings3b() \ 
			+ "\n" + new MyCls().doings4()
}



~~~~~
//##34 the class is a ref

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 : ="initial"
		
	def doings1() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 = ("newValue")
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings2() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 := "newValue" //this is a new ref
			 
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings3() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 = "newValue": //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings3b() String{
		asVal = this.z1
		refToPrev := this.z1
		b = "newValue":
		this.z1 = b //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings4() String{
		asVal = this.z1
		refToPrev := this.z1
		
		anotherRef = "newValue":
		this.z1 := anotherRef //replace ref
		
		anotherRef = "more stuff"
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:, "" + anotherRef]
	}
}

def doings() String{
	r1 := new MyCls()
	r2 := new MyCls()
	r3 := new MyCls()
	r3b := new MyCls()
	r4 := new MyCls()

	return "" + r1.doings1() \ 
			+ "\n" + r2.doings2() \ 
			+ "\n" + r3.doings3() \ 
			+ "\n" + r3b.doings3b() \ 
			+ "\n" + r4.doings4()
}

~~~~~
//##34.b the class is a ref - int

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 : =1
		
	def doings1() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 = (2)
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings2() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 := 2 //this is a new ref
			 
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings3() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 = 2: //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings3b() String{
		asVal = this.z1
		refToPrev := this.z1
		b=2:
		this.z1 = b //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings4() String{
		asVal = this.z1
		refToPrev := this.z1
		
		anotherRef = 2:
		this.z1 := anotherRef //replace ref
		
		anotherRef = 3
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:, "" + anotherRef]
	}
}

def doings() String{
	r1 := new MyCls()
	r2 := new MyCls()
	r3 := new MyCls()
	r3b := new MyCls()
	r4 := new MyCls()

	return "" + r1.doings1() \ 
			+ "\n" + r2.doings2() \ 
			+ "\n" + r3.doings3() \ 
			+ "\n" + r3b.doings3b() \ 
			+ "\n" + r4.doings4()
}


~~~~~
//##35. class via getter setter

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	private ~z1 : ="initial"
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = ("newValue")
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 := "newValue" //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = "newValue": //z takes value from rhs ref, DOES override, because rhs is locked as ref
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3b() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	g="newValue":
	mycls.z1 = g //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	
	anotherRef = "newValue":
	mycls.z1 := anotherRef //replace ref
	
	anotherRef = "more stuff"
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##35. class via getter setter - int


class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	private ~z1 : =1
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = (2)
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 := 2 //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = 2: //see above
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3b() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	d=2:
	mycls.z1 = d  //see above
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	
	anotherRef = 2:
	mycls.z1 := anotherRef //replace ref
	
	anotherRef = 3
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##36. ensure correct function called when many choices
def takes(a String: ) String { return "ref" }
def takes(a String ) String { return "normal" }
def takes(a Object ) String { return "obj" + a }

def noref(a String ) String { return "normal" }
def noref(a Object ) String { return "obj" + a }

def doings() String{
	a String: = "str"
	//ensure correct function called
	return "" + [takes(a), takes(a as String), takes(a as Object), takes(a:)]  \ 
			+"\n" + [noref(a), noref(a as String), noref(a:)]
}


~~~~~
//##37. esnure correct setter called

from java.util import LinkedList as LiLi

called = new LiLi<String>()

class MyClas{
	var x: = "orig"
	
	def getX() String: {
		called.add("getX")
		return x
	}

	def setX(a String)  {
		called.add("setX")
		x = a
	}
	
	def setX(a String:)  {
		called.add("setX:")
		x := a
	}
}


def doings() String{
	mc = new MyClas()
	a String: = "str"
	
	s = ""+ mc.x
	
	mc.x := a //call ref variant
	mc.x = a: //call ref variant
	mc.x = a //dont call ref variant, call normal
	
	s2 = ""+ mc.x
	
	return "" + called
}


~~~~~
//##37. esnure correct setter called - missing direct

from java.util import LinkedList as LiLi

called = new LiLi<String>()

class MyClas{
	var x: = "orig"
	
	def getX() String: {
		called.add("getX")
		return x
	}
	
	def setX(a String:)  {
		called.add("setX:")
		x := a
	}
}


def doings() String{
	mc = new MyClas()
	a String: = "str"
	
	s = ""+ mc.x
	
	mc.x := a //call ref variant
	mc.x = a: //call ref variant
	mc.x = a //dont call ref variant, call normal
	
	s2 = ""+ mc.x
	
	return "" + called
}

~~~~~
//##38. esnure correct setter called part 2 

class MyClas{
	var ~x String: = "orig"
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
}

def doings() String{
	mc = new MyClas()
	
	origRef := mc.x
	mc.x = "orig"
	
	firstMatch = origRef == mc.x 
	
	mc.x := "newRef" 
	
	secondDonttMatch = origRef: &<> mc.x: 
	
	return "" + [firstMatch, secondDonttMatch] + "" + [origRef:, mc.x:]
}

~~~~~
//##38. esnure correct setter called part 3

class MyClas{
	var ~x Object: = "orig"
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
}

def doings() String{
	mc = new MyClas()
	
	orig := mc.x
	
	matcStart = orig: &==  mc.x:
	
	mc.x = "newRef" //weird, ensure correct setter gets called - object setter!
	
	stillMatch = orig: &==  mc.x:
	
	mc.x := "newRef2" //weird, ensure correct setter gets called
	
	
	nomatch = orig: &<>  mc.x:
		
	return "" + [matcStart, stillMatch, nomatch] + "" + mc.x:
}

~~~~~
//##38. esnure correct setter called part 4

class MyClas{
	var ~x Object: =12 //works ok
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
}

def doings() String{
	mc = new MyClas()
	
	orig := mc.x
	
	matcStart = orig: &==  mc.x:
	
	mc.x = "newRef" //weird, shouldnt be making a new ref... could be cast problem...?
	
	stillMatch = orig: &==  mc.x:
	
	mc.x := "newRef2" //weird, shouldnt be making a new ref... could be cast problem...?
	
	nomatch = orig: &<>  mc.x:
		
	return "" + [matcStart, stillMatch, nomatch] + "" + mc.x
}

~~~~~
//##39. ref of array

def doings1() String{
	z : = ["initial"]

	asVal = z
	refToPrev := z
	z = [("newValue")]
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings2() String{
	z : = ["initial"]

	asVal = z
	refToPrev := z
	z := ["newValue"] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings3() String{
	z : = ["initial"]

	asVal = z
	refToPrev := z
	z = ["newValue"]: //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings3b() String{
	z : = ["initial"]

	asVal = z
	refToPrev := z
	g = ["newValue"]:
	z = g //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings4() String{
	z : = ["initial"]

	asVal = z
	refToPrev := z
	
	anotherRef = ["newValue"]:
	z := anotherRef //replace ref
	
	anotherRef = ["more stuff"]
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##39. ref of array - int

def doings1() String{
	z : = [1]

	asVal = z
	refToPrev := z
	z = [2]
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings2() String{
	z : = [1]

	asVal = z
	refToPrev := z
	z := [2] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings3() String{
	z : = [1]

	asVal = z
	refToPrev := z
	z = [2]: //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings3b() String{
	z : = [1]

	asVal = z
	refToPrev := z
	g = [2]:
	z = g //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings4() String{
	z : = [1]

	asVal = z
	refToPrev := z
	
	anotherRef = [2]:
	z := anotherRef //replace ref
	
	anotherRef = [3]
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##39. ref of array - module

z1 : = ["initial"]
z2 : = ["initial"]
z3 : = ["initial"]
z4 : = ["initial"]


def doings1() String{
	

	asVal = z1
	refToPrev := z1
	z1 = [("newValue")]
	return "" + [""+asVal, ""  + refToPrev: , "" + z1]
}

def doings2() String{

	asVal = z2
	refToPrev := z2
	z2 := ["newValue"] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + z2]
}

def doings3() String{

	asVal = z3
	refToPrev := z3
	z3 = ["newValue"]: //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z3]
}
def doings3b() String{

	asVal = z3
	refToPrev := z3
	g = ["newValue"]:
	z3 = g //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z3]
}

def doings4() String{

	asVal = z4
	refToPrev := z4
	
	anotherRef = ["newValue"]:
	z4 := anotherRef //replace ref
	
	anotherRef = ["more stuff"]
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z4, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##39. ref of array - module - int

z1 : = [1]
z2 : = [1]
z3 : = [1]
z4 : = [1]


def doings1() String{
	

	asVal = z1
	refToPrev := z1
	z1 = [2]
	return "" + [""+asVal, ""  + refToPrev: , "" + z1]
}

def doings2() String{

	asVal = z2
	refToPrev := z2
	z2 := [2] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + z2]
}

def doings3() String{

	asVal = z3
	refToPrev := z3
	z3 = [2]: //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z3]
}

def doings3b() String{

	asVal = z3
	refToPrev := z3
	g = [2]:
	z3 = g //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z3]
}

def doings4() String{

	asVal = z4
	refToPrev := z4
	
	anotherRef = [2]:
	z4 := anotherRef //replace ref
	
	anotherRef = [3]
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z4, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##39. ref of array - class - internal

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 : = ["initial"]
		
	def doings1() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 = ["newValue"]
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings2() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 := ["newValue"] //this is a new ref
			 
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings3() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 = ["newValue"]: //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings3b() String{
		asVal = this.z1
		refToPrev := this.z1
		g = ["newValue"]:
		this.z1 = g  //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings4() String{
		asVal = this.z1
		refToPrev := this.z1
		
		anotherRef = ["newValue"]:
		this.z1 := anotherRef //replace ref
		
		anotherRef = ["more stuff"]
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:, "" + anotherRef]
	}
}

def doings() String{
	r1 := new MyCls()
	r2 := new MyCls()
	r3 := new MyCls()
	r3b := new MyCls()
	r4 := new MyCls()

	return "" + r1.doings1() \ 
			+ "\n" + r2.doings2() \ 
			+ "\n" + r3.doings3() \ 
			+ "\n" + r3b.doings3b() \ 
			+ "\n" + r4.doings4()
}

~~~~~
//##39. ref of array - class - internal - int

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 : = [1]
		
	def doings1() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 = [2]
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings2() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 := [2] //this is a new ref
			 
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings3() String{
		asVal = this.z1
		refToPrev := this.z1
		this.z1 = [2]: //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings3b() String{
		asVal = this.z1
		refToPrev := this.z1
		g=[2]:
		this.z1 = g //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:]
	}
	
	def doings4() String{
		asVal = this.z1
		refToPrev := this.z1
		
		anotherRef = [2]:
		this.z1 := anotherRef //replace ref
		
		anotherRef = [3]
			
		return "" + [""+asVal, ""  + refToPrev: , "" + this.z1:, "" + anotherRef]
	}
}

def doings() String{
	r1 := new MyCls()
	r2 := new MyCls()
	r3 := new MyCls()
	r3b := new MyCls()
	r4 := new MyCls()

	return "" + r1.doings1() \ 
			+ "\n" + r2.doings2() \ 
			+ "\n" + r3.doings3() \ 
			+ "\n" + r3b.doings3b() \ 
			+ "\n" + r4.doings4()
}

~~~~~
//##39. ref of array - class - external

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 : = ["initial"]
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [("newValue")]
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 := ["newValue"] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = ["newValue"]: //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3b() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	g = ["newValue"]:
	mycls.z1 = g //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	
	anotherRef = ["newValue"]:
	mycls.z1 := anotherRef //replace ref
	
	anotherRef = ["more stuff"]
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##39. ref of array - class - external - int

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 : = [1]
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [(2)]
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 := [2] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [2]: //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3b() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	g = [2]:
	mycls.z1 = g //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	
	anotherRef = [2]:
	mycls.z1 := anotherRef //replace ref
	
	anotherRef = [3]
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##39. ref of array - class - external - getter setter

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	~z1 : = ["initial"]
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [("newValue")]
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 := ["newValue"] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = ["newValue"]: //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	
	anotherRef = ["newValue"]:
	mycls.z1 := anotherRef //replace ref
	
	anotherRef = ["more stuff"]
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings4()
}

~~~~~
//##39. ref of array - class - external - int - getter setter

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	~z1 : = [1]
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [(2)]
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 := [2] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [2]: //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	
	anotherRef = [2]:
	mycls.z1 := anotherRef //replace ref
	
	anotherRef = [3]
		
	return "" + [""+asVal, ""  + refToPrev: , "" + mycls.z1:, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings4()
}

~~~~~
//##40. array of ref - local vars
def doings1() String{
	z = ["initial":]

	asVal = z
	refToPrev = z
	z = [("newValue":)]
	return "" + [""+asVal, ""  + refToPrev , "" + z]
}

def doings2() String{
	z  = ["initial":]

	asVal = z
	refToPrev := z
	z = ["newValue":] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings3() String{
	z  = ["initial":]

	asVal = z
	refToPrev := z
	z = ["newValue":] //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings4() String{
	z  = ["initial":]

	asVal = z
	refToPrev := z
	
	anotherRef = ["newValue":]
	z = anotherRef //replace ref
	
	anotherRef = ["more stuff":]
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z, "" + anotherRef]
}

def doings() String{
	return "" + doings1() + "\n" + doings2() + "\n" + doings3()	+ "\n" + doings4()
}

~~~~~
//##40. array of ref - local vars - int 

def doings1() String{
	z = [1:]

	asVal = z
	refToPrev = z
	z = [(2:)]
	return "" + [""+asVal, ""  + refToPrev , "" + z]
}

def doings2() String{
	z  = [1:]

	asVal = z
	refToPrev := z
	z = [2:] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings3() String{
	z  = [1:]

	asVal = z
	refToPrev := z
	z = [2:] //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z]
}

def doings4() String{
	z  = [1:]

	asVal = z
	refToPrev := z
	
	anotherRef = [2:]
	z = anotherRef //replace ref
	
	anotherRef = [3:]
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z, "" + anotherRef]
}

def doings() String{
	return "" + doings1() + "\n" + doings2() + "\n" + doings3()	+ "\n" + doings4()
}


~~~~~
//##40. array of ref - module vars
z1 = ["initial":]
z2 = ["initial":]
z3 = ["initial":]
z4 = ["initial":]

def doings1() String{
	asVal = z1
	refToPrev = z1
	z1 = [("newValue":)]
	return "" + [""+asVal, ""  + refToPrev , "" + z1]
}

def doings2() String{
	asVal = z2
	refToPrev := z2
	z2 = ["newValue":] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + z2]
}

def doings3() String{
	asVal = z3
	refToPrev := z3
	z3 = ["newValue":] //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z3]
}

def doings4() String{
	asVal = z4
	refToPrev := z4
	
	anotherRef = ["newValue":]
	z4 = anotherRef //replace ref
	
	anotherRef = ["more stuff":]
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z4, "" + anotherRef]
}

def doings() String{
	return "" + doings1() + "\n" + doings2() + "\n" + doings3()	+ "\n" + doings4()
}

~~~~~
//##40. array of ref - module vars - int 
z1 = [1:]
z2 = [1:]
z3 = [1:]
z4 = [1:]

def doings1() String{
	asVal = z1
	refToPrev = z1
	z1 = [(2:)]
	return "" + [""+asVal, ""  + refToPrev , "" + z1]
}

def doings2() String{
	asVal = z2
	refToPrev := z2
	z2 = [2:] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev: , "" + z2]
}

def doings3() String{
	asVal = z3
	refToPrev := z3
	z3 = [2:] //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z3]
}

def doings4() String{
	asVal = z4
	refToPrev := z4
	
	anotherRef = [2:]
	z4 = anotherRef //replace ref
	
	anotherRef = [3:]
		
	return "" + [""+asVal, ""  + refToPrev: , "" + z4, "" + anotherRef]
}

def doings() String{
	return "" + doings1() + "\n" + doings2() + "\n" + doings3()	+ "\n" + doings4()
}

~~~~~
//##40. array of ref - class internal
class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1  = ["initial":]
		
	def doings1() String{
		asVal = this.z1
		refToPrev = this.z1
		this.z1 = ["newValue":]
		return "" + [""+asVal, ""  + refToPrev , "" + this.z1]
	}
	
	def doings2() String{
		asVal = this.z1
		refToPrev = this.z1
		this.z1 = ["newValue":] //this is a new ref
			 
		return "" + [""+asVal, ""  + refToPrev , "" + this.z1]
	}
	
	def doings3() String{
		asVal = this.z1
		refToPrev = this.z1
		this.z1 = ["newValue":] //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev , "" + this.z1]
	}
	
	def doings4() String{
		asVal = this.z1
		refToPrev = this.z1
		
		anotherRef = ["newValue":]:
		this.z1 = anotherRef //replace ref
		
		anotherRef = ["more stuff":]
			
		return "" + [""+asVal, ""  + refToPrev , "" + this.z1, "" + anotherRef]
	}
}

def doings() String{
	r1 := new MyCls()
	r2 := new MyCls()
	r3 := new MyCls()
	r4 := new MyCls()

	return "" + r1.doings1() \ 
			+ "\n" + r2.doings2() \ 
			+ "\n" + r3.doings3() \ 
			+ "\n" + r4.doings4()
}
 
~~~~~
//##40. array of ref - class internal - int 

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1  = [1:]
		
	def doings1() String{
		asVal = this.z1
		refToPrev = this.z1
		this.z1 = [2:]
		return "" + [""+asVal, ""  + refToPrev , "" + this.z1]
	}
	
	def doings2() String{
		asVal = this.z1
		refToPrev = this.z1
		this.z1 = [2:] //this is a new ref
			 
		return "" + [""+asVal, ""  + refToPrev , "" + this.z1]
	}
	
	def doings3() String{
		asVal = this.z1
		refToPrev = this.z1
		this.z1 = [2:] //z takes value from rhs ref, but not override - u must use : for that
			
		return "" + [""+asVal, ""  + refToPrev , "" + this.z1]
	}
	
	def doings4() String{
		asVal = this.z1
		refToPrev = this.z1
		
		anotherRef = [2:]:
		this.z1 = anotherRef //replace ref
		
		anotherRef = [3:]
			
		return "" + [""+asVal, ""  + refToPrev , "" + this.z1, "" + anotherRef]
	}
}

def doings() String{
	r1 := new MyCls()
	r2 := new MyCls()
	r3 := new MyCls()
	r4 := new MyCls()

	return "" + r1.doings1() \ 
			+ "\n" + r2.doings2() \ 
			+ "\n" + r3.doings3() \ 
			+ "\n" + r4.doings4()
}


~~~~~
//##40. array of ref - external class

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1  = ["initial":]
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [("newValue":)]
	return "" + [""+asVal, ""  + refToPrev , "" + mycls.z1]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = ["newValue":] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev , "" + mycls.z1]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = ["newValue":] //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev , "" + mycls.z1]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	
	anotherRef = ["newValue":]:
	mycls.z1 = anotherRef //replace ref
	
	anotherRef = ["more stuff":]
		
	return "" + [""+asVal, ""  + refToPrev , "" + mycls.z1, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings4()
}
 
~~~~~
//##40. array of ref - external class - int
class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1  = [1:]
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [(2:)]
	return "" + [""+asVal, ""  + refToPrev , "" + mycls.z1]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [2:] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev , "" + mycls.z1]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [2:] //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev , "" + mycls.z1]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	
	anotherRef = [2:]:
	mycls.z1 = anotherRef //replace ref
	
	anotherRef = [3:]
		
	return "" + [""+asVal, ""  + refToPrev, "" + mycls.z1, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings4()
}



~~~~~
//##40. array of ref - external class -gs
class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	~z1  = ["initial":]
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [("newValue":)]
	return "" + [""+asVal, ""  + refToPrev , "" + mycls.z1]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = ["newValue":] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev , "" + mycls.z1]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = ["newValue":] //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev , "" + mycls.z1]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	
	anotherRef = ["newValue":]
	mycls.z1 = anotherRef //replace ref
	
	anotherRef = ["more stuff":]
		
	return "" + [""+asVal, ""  + refToPrev , "" + mycls.z1, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings4()
}

~~~~~
//##40. array of ref - external class  -gs - int

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	~z1  = [1:]
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [(2:)]
	return "" + [""+asVal, ""  + refToPrev , "" + mycls.z1]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [2:] //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev , "" + mycls.z1]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	mycls.z1 = [2:] //z takes value from rhs ref, but not override - u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev, "" + mycls.z1]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev := mycls.z1
	
	anotherRef = [2:]
	mycls.z1 = anotherRef //replace ref
	
	anotherRef = [3:]
		
	return "" + [""+asVal, ""  + refToPrev, "" + mycls.z1, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings4()
}

~~~~~
//##40. array of ref - minor bug

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	~z1  = 22
	~z2  = [1:]
}

def doings() String{
	mycls = new MyCls()
	
	anotherRef1 = 66:
	mycls.z1 = anotherRef1
	
	anotherRef2 = [2:]:
	mycls.z2 = anotherRef2 //gets de refed
	
	
	return "" + [mycls.z1, mycls.z2]
}

~~~~~
//##41. ref of array index operations

module = [1 2 3 4 5 6 7 8 9 10]:

class AClass{
	public field = [1 2 3 4 5 6 7 8 9 10]:
	~field2 = [1 2 3 4 5 6 7 8 9 10]:
	
	def onTheInside() String {
		item = this.field[0]
		field[2] = 44
	
		return "" + [""+item, ""+this.field]
	}
}

def testLocal() String{
	localx = [1 2 3 4 5 6 7 8 9 10]:
	
	item = localx[0]
	localx[2] = 44
	
	return "" + [""+item, ""+localx]
}


def testMod() String{
	item = module[0]
	module[2] = 44
	
	return "" + [""+item, ""+module]
}


def testClassExt() String{
	aaa = new AClass()
	
	item = aaa.field[0]
	aaa.field[2] = 44
	
	return "" + [""+item, ""+aaa.field]
}

def testClassExtGetSet() String{
	aaa = new AClass()
	
	item = aaa.field2[0]
	aaa.field2[2] = 44
	
	//note that in the next line the field is auto unrefed!
	return "" + [""+item, ""+aaa.field2, ""+aaa.field2:]
	//so i added ""+aaa.field2: above to prove that it's a ref!
}

def pretty(ina String[]) String{
	ret = ""
	for(s in ina){
		ret += s + "\n"
	}
	return ret
}

def doings() String{
	bbb = new AClass()
	
	return "" + pretty(a[testLocal(), testMod() ,
						testClassExt(),
						bbb.onTheInside() ,
						testClassExtGetSet() ])
	//external via getter setter
}

~~~~~
//##42. array of ref index operations

module = a[1:, 2:, 3:,4:,5:,6:7:,8:,9:,10:]

class AClass{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public field = a[1:, 2:, 3:,4:,5:,6:7:,8:,9:,10:]
	~field2 = a[1:, 2:, 3:,4:,5:,6:7:,8:,9:,10:]
	
	def onTheInside() String {
		item = this.field[0]
		field[2] = 44
	
		return "" + [""+item, ""+this.field]
	}
}

def testLocal() String{
	localx = a[1:, 2:, 3:,4:,5:,6:7:,8:,9:,10:]
	
	item = localx[0]
	localx[2] = 44
	
	return "" + [""+item, ""+localx]
}


def testMod() String{
	item = module[0]
	module[2] = 44
	
	return "" + [""+item, ""+module]
}


def testClassExt() String{
	aaa = new AClass()
	
	item = aaa.field[0]
	aaa.field[2] = 44
	
	return "" + [""+item, ""+aaa.field]
}

def testClassExtGetSet() String{
	aaa = new AClass()
	
	item = aaa.field2[0]
	aaa.field2[2] = 44
	aaa.field2[3] = 48:
	
	return "" + [""+item, ""+aaa.field2, ""+aaa.field2]
}

def pretty(ina String[]) String{
	ret = ""
	for(s in ina){
		ret += s + "\n"
	}
	return ret
}

def doings() String{
	bbb = new AClass()
	
	return "" + pretty(a[testLocal(), testMod(), 
						testClassExt(),
						bbb.onTheInside() ,
						testClassExtGetSet() ])
	//external via getter setter
}

~~~~~
//##43. ref of array of ref 

module = a[1:, 2:, 3:,4:,5:,6:7:,8:,9:,10:]:

class AClass{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public field = a[1:, 2:, 3:,4:,5:,6:7:,8:,9:,10:]:
	~field2 = a[1:, 2:, 3:,4:,5:,6:7:,8:,9:,10:]:
	
	def onTheInside() String {
		item = this.field[0]
		field[2] = 44
	
		return "" + [""+item, ""+this.field]
	}
}

def testLocal() String{
	localx = a[1:, 2:, 3:,4:,5:,6:7:,8:,9:,10:]:
	
	item = localx[0]
	localx[2] = 44
	
	return "" + [""+item, ""+localx]
}


def testMod() String{
	item = module[0]
	module[2] = 44
	
	return "" + [""+item, ""+module]
}


def testClassExt() String{
	aaa = new AClass()
	
	item = aaa.field[0]
	aaa.field[2] = 44
	
	return "" + [""+item, ""+aaa.field]
}

def testClassExtGetSet() String{
	aaa = new AClass()
	
	item = aaa.field2[0]
	aaa.field2[2] = 44
	aaa.field2[3] = 48:
	
	return "" + [""+item, ""+aaa.field2, ""+aaa.field2:]
}

def pretty(ina String[]) String{
	ret = ""
	for(s in ina){
		ret += s + "\n"
	}
	return ret
}

def doings() String{
	bbb = new AClass()
	
	return "" + pretty(a[testLocal(), testMod(), 
						testClassExt(),
						bbb.onTheInside() ,
						testClassExtGetSet() ])
	//external via getter setter
}


~~~~~
//##44. array of ref - some op fail

class AClass{
	public field = [1:,2:,3:,4:,5:,6:,7:,8:,9:,10:]
	~field2 = [1:,2:,3:,4:,5:,6:,7:,8:,9:,10:]
}

def doings() String{
	bbb = new AClass()
	return "" + ["" + bbb.field, "" + bbb.field2]
}

~~~~~
//##44.b array of ref - some op fail more

def doings() String{
	a Object = [1: 2:]
	b = a as Integer:[] //ok
	c = a is Number:[] //cannot upcast these
		
	return "" + b + "=>" + c
}

~~~~~
//##44.c array of ref - the special case catered for

dude = ""

def g(a Object[]) { dude += "dude called" } 


def doings() String{
	orig = [1: 2:]
	asObj = orig as Object
	
	g(orig)
	
	//xxx = orig as Number:[] //ok
	xxx2 = orig as Integer:[] //only case where this is ok
	xxx3 = asObj as Integer:[] //ok
	
	xxx4 = asObj as Object[] //this is also ok
	
	return "" + ["" + orig, "" +xxx2, "" +xxx3, "" +xxx4, dude] 
}

~~~~~
//##44.d array of ref - so now these are ok too
//prevsoiuly the call to equalifier for object arrays was failing

class AClass{
	//override equals(o Object) boolean {return true;}
	//override hashCode() int {return 6;}

	public field = [1,2,new Integer(3)]: // [1:,2:,3:,4:,5:,6:,7:,8:,9:,10:]
	~field2 = [1,2,new Integer(3)]: // [1:,2:,3:,4:,5:,6:,7:,8:,9:,10:]
	
}

def doings() String{
	bbb = new AClass()
	return ""  + [bbb.field, bbb.field2:]
}

~~~~~
//##45. simple inc

def getRef() int:{
	return 5:
}

def doings() String{
	a1 := 5;	 
	a2 := getRef();	 
	a3 := 5;	 
	a4 := 5;	 
	
	a1++
	++a2
	a3--
	--a4
	
	return "" + [a1:,a2:,a3:,a4:]
}

~~~~~
//##45.b simple inc - with assignment

def getRef() int:{
	return 5:
}

def doings() String{
	a1 := 5;	 
	a2 := getRef();	 
	a3 := 5;	 
	a4 := 5;	 
	
	b1 = a1++
	b2 = ++a2
	b3 = a3--
	b4 = --a4
	
	return "" + [a1:,a2:,a3:,a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

~~~~~
//##45.c simple inc - with assignment - copy refs correctly

def getRef() int:{
	return 5:
}

def doings() String{
	a1 := 5;	 
	a2 := getRef();	 
	a3 := 5;	 
	a4 := 5;	 
	
	b1 := a1++
	b2 := ++a2
	b3 := a3--
	b4 := --a4
	
	return "" + [a1:,a2:,a3:,a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:] \ 
	  			+ "" + [a1:&==b1:, a2:&==b2:, a3:&==b3:, a4:&==b4:]
	//prefix ok, postfix not
}

~~~~~
//##45.d simple inc - in place operations

def getRef() int:{
	return 5:
}

def doings() String{
	a1 := 5;	 
	a2 := getRef();	 
	a3 := 5;	 
	
	a1 += 1
	a2 -= 1
	a3 *= 2
	
	return "" + [a1:,a2:,a3:] 
	//prefix ok, postfix not
}

~~~~~
//##45.d simple inc - string concatenation

def getRef() String:{
	return "5":
}

def doings() String{
	a1 := getRef();	 
	a1 += "hi"
	
	return "" + a1
}


~~~~~
//##46. inc operations - module level

def getRef() int:{
	return 5:
}

def getRefStr() String:{
	return "5":
}

d1a1 := 5;	 
d1a2 := getRef();	 
d1a3 := 5;	 
d1a4 := 5;	 

def doings1() String{
	d1a1++
	++d1a2
	d1a3--
	--d1a4
	
	return "" + [d1a1:, d1a2:, d1a3:, d1a4:]
}

d2a1 := 5;	 
d2a2 := getRef();	 
d2a3 := 5;	 
d2a4 := 5;	 

def doings2() String{
	
	b1 = d2a1++
	b2 = ++d2a2
	b3 = d2a3--
	b4 = --d2a4
	
	return "" + [d2a1:,d2a2:,d2a3:,d2a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}


d3a1 := 5;	 
d3a2 := getRef();	 
d3a3 := 5;	 
d3a4 := 5;

def doings3() String{	
	b1 := d3a1++
	b2 := ++d3a2
	b3 := d3a3--
	b4 := --d3a4
	
	return "" + [d3a1:,d3a2:,d3a3:,d3a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:] \ 
	  			+ "" + [d3a1:&==b1:, d3a2:&==b2:, d3a3:&==b3:, d3a4:&==b4:]
	//prefix ok, postfix not
}

d4a1 := 5;	 
d4a2 := getRef();	 
d4a3 := 5;	 

def doings4() String{

	d4a1 += 1
	d4a2 -= 1
	d4a3 *= 2
	
	return "" + [d4a1:,d4a2:,d4a3:] 
	//prefix ok, postfix not
}

d5a1 := getRefStr();	

def doings5() String{ 
	d5a1 += "hi"
	
	return "" + d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##47. inc operations - class inner level

class Inner{
def getRef() int:{
	return 5:
}

def getRefStr() String:{
	return "5":
}

d1a1 := 5;	 
d1a2 := getRef();	 
d1a3 := 5;	 
d1a4 := 5;	 

def doings1() String{
	d1a1++
	++d1a2
	d1a3--
	--d1a4
	
	return "" + [d1a1:,d1a2:,d1a3:,d1a4:]
}

d1a1t := 5;	 
d1a2t := getRef();	 
d1a3t := 5;	 
d1a4t := 5;	

def doings1this() String{
	this.d1a1t++
	++this.d1a2t
	this.d1a3t--
	--this.d1a4t
	
	return "" + [this.d1a1t:,this.d1a2t:,this.d1a3t:,this.d1a4t:]
}

d2a1 := 5;	 
d2a2 := getRef();	 
d2a3 := 5;	 
d2a4 := 5;	 

def doings2() String{
		
	b1 = d2a1++
	b2 = ++d2a2
	b3 = d2a3--
	b4 = --d2a4
	
	return "" + [d2a1:,d2a2:,d2a3:,d2a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}


d3a1 := 5;	 
d3a2 := getRef();	 
d3a3 := 5;	 
d3a4 := 5;

def doings3() String{	
	b1 := d3a1++
	b2 := ++d3a2
	b3 := d3a3--
	b4 := --d3a4
	
	return "" + [d3a1:,d3a2:,d3a3:,d3a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:] \ 
	  			+ "" + [d3a1:&==b1:, d3a2:&==b2:, d3a3:&==b3:, d3a4:&==b4:]
	//prefix ok, postfix not
}

d4a1 := 5;	 
d4a2 := getRef();	 
d4a3 := 5;	 

def doings4() String{

	d4a1 += 1
	d4a2 -= 1
	d4a3 *= 2
	
	return "" + [d4a1:,d4a2:,d4a3:] 
	//prefix ok, postfix not
}

d5a1 := getRefStr();	

def doings5() String{ 
	d5a1 += "hi"
	
	return "" + d5a1
}



}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	i = new Inner()
	return join( [i.doings1()  i.doings2()  i.doings3()  i.doings4()  i.doings5()  i.doings1this()]  )
}


~~~~~
//##48. inc operations - class field

class Inner{
	def getRef() int:{
		return 5:
	}
	
	def getRefStr() String:{
		return "5":
	}
	
	public d1a1 := 5;	 
	public d1a2 := getRef();	 
	public d1a3 := 5;	 
	public d1a4 := 5;	
	 
	public d2a1 := 5;	 
	public d2a2 := getRef();	 
	public d2a3 := 5;	 
	public d2a4 := 5;	 
			
	public d3a1 := 5;	 
	public d3a2 := getRef();	 
	public d3a3 := 5;	 
	public d3a4 := 5;

	
	public d4a1 := 5;	 
	public d4a2 := getRef();	 
	public d4a3 := 5;	 

	public d5a1 := getRefStr();	
}


child = new Inner()



def doings1() String{
	child.d1a1++
	++child.d1a2
	child.d1a3--
	--child.d1a4
	
	return "" + [child.d1a1:,child.d1a2:,child.d1a3:,child.d1a4:]
}

def doings2() String{
	b1 = child.d2a1++
	b2 = ++child.d2a2
	b3 = child.d2a3--
	b4 = --child.d2a4
	
	return "" + [child.d2a1:,child.d2a2:,child.d2a3:,child.d2a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{	
	b1 := child.d3a1++
	b2 := ++child.d3a2
	b3 := child.d3a3--
	b4 := --child.d3a4
	
	return "" + [child.d3a1:,child.d3a2:,child.d3a3:,child.d3a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:] \ 
	  			+ "" + [child.d3a1:&==b1:, child.d3a2:&==b2:, child.d3a3:&==b3:, child.d3a4:&==b4:]
	//prefix ok, postfix not
}

def doings4() String{

	child.d4a1 += 1
	child.d4a2 -= 1
	child.d4a3 *= 2
	
	return "" + [child.d4a1:,child.d4a2:,child.d4a3:] 
	//prefix ok, postfix not
}


def doings5() String{ 
	child.d5a1 += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##49. inc operations - class field get set


class Inner{
	def getRef() int:{
		return 5:
	}
	
	def getRefStr() String:{
		return "5":
	}
	
	~d1a1 := 5;	 
	~d1a2 := getRef();	 
	~d1a3 := 5;	 
	~d1a4 := 5;	
	 
	~d2a1 := 5;	 
	~d2a2 := getRef();	 
	~d2a3 := 5;	 
	~d2a4 := 5;	 
			
	~d3a1 := 5;	 
	~d3a2 := getRef();	 
	~d3a3 := 5;	 
	~d3a4 := 5;

	
	~d4a1 := 5;	 
	~d4a2 := getRef();	 
	~d4a3 := 5;	 

	~d5a1 := getRefStr();	
}


child = new Inner()



def doings1() String{
	child.d1a1++
	++child.d1a2
	child.d1a3--
	--child.d1a4
	
	return "" + [child.d1a1:,child.d1a2:,child.d1a3:,child.d1a4:]
}

def doings2() String{
	b1 = child.d2a1++
	b2 = ++child.d2a2
	b3 = child.d2a3--
	b4 = --child.d2a4
	
	return "" + [child.d2a1:,child.d2a2:,child.d2a3:,child.d2a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{	
	b1 := child.d3a1++
	b2 := ++child.d3a2
	b3 := child.d3a3--
	b4 := --child.d3a4
	
	return "" + [child.d3a1:,child.d3a2:,child.d3a3:,child.d3a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:] \ 
	  			+ "" + [child.d3a1:&==b1:, child.d3a2:&==b2:, child.d3a3:&==b3:, child.d3a4:&==b4:]
	//prefix ok, postfix not
}

def doings4() String{

	child.d4a1 += 1
	child.d4a2 -= 1
	child.d4a3 *= 2
	
	return "" + [child.d4a1:,child.d4a2:,child.d4a3:] 
	//prefix ok, postfix not
}


def doings5() String{ 
	child.d5a1 += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##50. inc operations - class field get only


//get only
class Inner{
	def getRef() int:{
		return 5:
	}
	
	def getRefStr() String:{
		return "5":
	}
	
	public -d1a1 := 5;	 
	public -d1a2 := getRef();	 
	public -d1a3 := 5;	 
	public -d1a4 := 5;	
	 
	public -d2a1 := 5;	 
	public -d2a2 := getRef();	 
	public -d2a3 := 5;	 
	public -d2a4 := 5;	 
			
	public -d3a1 := 5;	 
	public -d3a2 := getRef();	 
	public -d3a3 := 5;	 
	public -d3a4 := 5;

	
	public -d4a1 := 5;	 
	public -d4a2 := getRef();	 
	public -d4a3 := 5;	 

	public -d5a1 := getRefStr();	
}


child = new Inner()



def doings1() String{
	child.d1a1++
	++child.d1a2
	child.d1a3--
	--child.d1a4
	
	return "" + [child.d1a1:,child.d1a2:,child.d1a3:,child.d1a4:]
}

def doings2() String{
	b1 = child.d2a1++
	b2 = ++child.d2a2
	b3 = child.d2a3--
	b4 = --child.d2a4
	
	return "" + [child.d2a1:,child.d2a2:,child.d2a3:,child.d2a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{	
	b1 := child.d3a1++
	b2 := ++child.d3a2
	b3 := child.d3a3--
	b4 := --child.d3a4
	
	return "" + [child.d3a1:,child.d3a2:,child.d3a3:,child.d3a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:] \ 
	  			+ "" + [child.d3a1:&==b1:, child.d3a2:&==b2:, child.d3a3:&==b3:, child.d3a4:&==b4:]
	//prefix ok, postfix not
}

def doings4() String{

	child.d4a1 += 1
	child.d4a2 -= 1
	child.d4a3 *= 2
	
	return "" + [child.d4a1:,child.d4a2:,child.d4a3:] 
	//prefix ok, postfix not
}


def doings5() String{ 
	child.d5a1 += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##51. inc operations - class field set only


//get only
class Inner{
	def getRef() int:{
		return 5:
	}
	
	def getRefStr() String:{
		return "5":
	}
	
	public +d1a1 := 5;	 
	public +d1a2 := getRef();	 
	public +d1a3 := 5;	 
	public +d1a4 := 5;	
	 
	public +d2a1 := 5;	 
	public +d2a2 := getRef();	 
	public +d2a3 := 5;	 
	public +d2a4 := 5;	 
			
	public +d3a1 := 5;	 
	public +d3a2 := getRef();	 
	public +d3a3 := 5;	 
	public +d3a4 := 5;

	
	public +d4a1 := 5;	 
	public +d4a2 := getRef();	 
	public +d4a3 := 5;	 

	public +d5a1 := getRefStr();	
}


child = new Inner()


def doings1() String{
	child.d1a1++
	++child.d1a2
	child.d1a3--
	--child.d1a4
	
	return "" + [child.d1a1:,child.d1a2:,child.d1a3:,child.d1a4:]
}

def doings2() String{
	b1 = child.d2a1++
	b2 = ++child.d2a2
	b3 = child.d2a3--
	b4 = --child.d2a4
	
	return "" + [child.d2a1:,child.d2a2:,child.d2a3:,child.d2a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{	
	b1 := child.d3a1++
	b2 := ++child.d3a2
	b3 := child.d3a3--
	b4 := --child.d3a4
	
	return "" + [child.d3a1:,child.d3a2:,child.d3a3:,child.d3a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:] \ 
	  			+ "" + [child.d3a1:&==b1:, child.d3a2:&==b2:, child.d3a3:&==b3:, child.d3a4:&==b4:]
	//prefix ok, postfix not
}

def doings4() String{

	child.d4a1 += 1
	child.d4a2 -= 1
	child.d4a3 *= 2
	
	return "" + [child.d4a1:,child.d4a2:,child.d4a3:] 
	//prefix ok, postfix not
}


def doings5() String{ 
	child.d5a1 += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##52.a inc operations - ref of array - local

def getRef() int[]:{
	return [5 5 5 5]:
}

def getRefStr() String[]:{
	return ["5" "5" "5" "5"]:
}

def doings1() String{
	a1 := getRef();	  
	a2 := getRef();	 
	a3 := getRef();	  
	a4 := getRef();	 	 
	
	a1[0]++
	++a2[0]
	a3[0]--
	--a4[0]
	
	return "" + [a1:,a2:,a3:,a4:]
}


def doings2() String{
	a1 := getRef();	 	 
	a2 := getRef();	 
	a3 := getRef();	 	 
	a4 := getRef();	 	 
	
	b1 = a1[0]++
	b2 = ++a2[0]
	b3 = a3[0]--
	b4 = --a4[0]
	
	return "" + [a1:,a2:,a3:,a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}


def doings3() String{
	a1 := getRef();	 	 
	a2 := getRef();	 
	a3 := getRef();	 	 
	a4 := getRef();	  
	
	b1 := a1[0]++
	b2 := ++a2[0]
	b3 := a3[0]--
	b4 := --a4[0]
	
	return "" + [a1:,a2:,a3:,a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}


def doings4() String{
	a1 := getRef();	  
	a2 := getRef();	 
	a3 := getRef();	 	 
	
	a1[0] += 1
	a2[0] -= 1
	a3[0] *= 2
	
	return "" + [a1:,a2:,a3:] 
	//prefix ok, postfix not
}

def doings5() String{
	a1 := getRefStr();	 
	a1[0] += "hi"
	
	return "" + a1
}


def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##52.b inc operations - ref of array - module


def getRef() int[]:{
	return [5 5 5 5]:
}

def getRefStr() String[]:{
	return ["5" "5" "5" "5"]:
}

d1a1 := getRef();	  
d1a2 := getRef();	 
d1a3 := getRef();	  
d1a4 := getRef();	 	 

d2a1 := getRef();	 	 
d2a2 := getRef();	 
d2a3 := getRef();	 	 
d2a4 := getRef();	 	

d3a1 := getRef();	 	 
d3a2 := getRef();	 
d3a3 := getRef();	 	 
d3a4 := getRef();	
 
d4a1 := getRef();	  
d4a2 := getRef();	 
d4a3 := getRef();	 	

d5a1 := getRefStr();	 

def doings1() String{
	
	d1a1[0]++
	++d1a2[0]
	d1a3[0]--
	--d1a4[0]
	
	return "" + [d1a1:,d1a2:,d1a3:,d1a4:]
}


def doings2() String{
	b1 = d2a1[0]++
	b2 = ++d2a2[0]
	b3 = d2a3[0]--
	b4 = --d2a4[0]
	
	return "" + [d2a1:,d2a2:,d2a3:,d2a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}


def doings3() String{ 
	
	b1 := d3a1[0]++
	b2 := ++d3a2[0]
	b3 := d3a3[0]--
	b4 := --d3a4[0]
	
	return "" + [d3a1:,d3a2:,d3a3:,d3a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}


def doings4() String{ 
	
	d4a1[0] += 1
	d4a2[0] -= 1
	d4a3[0] *= 2
	
	return "" + [d4a1:,d4a2:,d4a3:] 
	//prefix ok, postfix not
}

def doings5() String{
	d5a1[0] += "hi"
	
	return "" + d5a1
}


def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##52.c inc operations - ref of array - class inner

class Inner{
	def getRef() int[]:{
		return [5 5 5 5]:
	}
	
	def getRefStr() String[]:{
		return ["5" "5" "5" "5"]:
	}
	
	d1a1 := getRef();	  
	d1a2 := getRef();	 
	d1a3 := getRef();	  
	d1a4 := getRef();	 	 
	
	d2a1 := getRef();	 	 
	d2a2 := getRef();	 
	d2a3 := getRef();	 	 
	d2a4 := getRef();	 	
	
	d3a1 := getRef();	 	 
	d3a2 := getRef();	 
	d3a3 := getRef();	 	 
	d3a4 := getRef();	
	 
	d4a1 := getRef();	  
	d4a2 := getRef();	 
	d4a3 := getRef();	 	
	
	d5a1 := getRefStr();	 
	
	def doings1() String{
		
		d1a1[0]++
		++d1a2[0]
		d1a3[0]--
		--d1a4[0]
		
		return "" + [d1a1:,d1a2:,d1a3:,d1a4:]
	}
	
	
	def doings2() String{
		b1 = d2a1[0]++
		b2 = ++d2a2[0]
		b3 = d2a3[0]--
		b4 = --d2a4[0]
		
		return "" + [d2a1:,d2a2:,d2a3:,d2a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
		//prefix ok, postfix not
	}
	
	
	def doings3() String{ 
		
		b1 := d3a1[0]++
		b2 := ++d3a2[0]
		b3 := d3a3[0]--
		b4 := --d3a4[0]
		
		return "" + [d3a1:,d3a2:,d3a3:,d3a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
		//prefix ok, postfix not
	}
	
	
	def doings4() String{ 
		
		d4a1[0] += 1
		d4a2[0] -= 1
		d4a3[0] *= 2
		
		return "" + [d4a1:,d4a2:,d4a3:] 
		//prefix ok, postfix not
	}
	
	def doings5() String{
		d5a1[0] += "hi"
		
		return "" + d5a1
	}
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

child = new Inner()

def doings() String{
	
	return join( [child.doings1()  child.doings2()  child.doings3()  child.doings4()  child.doings5()]  )
}

~~~~~
//##52.d inc operations - ref of array - class field
def getRef() int[]:{
	return [5 5 5 5]:
}

def getRefStr() String[]:{
	return ["5" "5" "5" "5"]:
}

class Inner{
	public d1a1 := getRef();	  
	public d1a2 := getRef();	 
	public d1a3 := getRef();	  
	public d1a4 := getRef();	 	 
	
	public d2a1 := getRef();	 	 
	public d2a2 := getRef();	 
	public d2a3 := getRef();	 	 
	public d2a4 := getRef();	 	
	
	public d3a1 := getRef();	 	 
	public d3a2 := getRef();	 
	public d3a3 := getRef();	 	 
	public d3a4 := getRef();	
	 
	public d4a1 := getRef();	  
	public d4a2 := getRef();	 
	public d4a3 := getRef();	 	
	
	public d5a1 := getRefStr();	 
	
}

child = new Inner()

def doings1() String{
	
	child.d1a1[0]++
	++child.d1a2[0]
	child.d1a3[0]--
	--child.d1a4[0]
	
	return "" + [child.d1a1:,child.d1a2:,child.d1a3:,child.d1a4:]
}


def doings2() String{
	b1 = child.d2a1[0]++
	b2 = ++child.d2a2[0]
	b3 = child.d2a3[0]--
	b4 = --child.d2a4[0]
	
	return "" + [child.d2a1:,child.d2a2:,child.d2a3:,child.d2a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}


def doings3() String{ 
	
	b1 := child.d3a1[0]++
	b2 := ++child.d3a2[0]
	b3 := child.d3a3[0]--
	b4 := --child.d3a4[0]
	
	return "" + [child.d3a1:,child.d3a2:,child.d3a3:,child.d3a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}


def doings4() String{ 
	
	child.d4a1[0] += 1
	child.d4a2[0] -= 1
	child.d4a3[0] *= 2
	
	return "" + [child.d4a1:,child.d4a2:,child.d4a3:] 
	//prefix ok, postfix not
}

def doings5() String{
	child.d5a1[0] += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##52.e inc operations - ref of array - class getter and setter

def getRef() int[]:{
	return [5 5 5 5]:
}

def getRefStr() String[]:{
	return ["5" "5" "5" "5"]:
}

class Inner{
	~d1a1 := getRef();	  
	~d1a2 := getRef();	 
	~d1a3 := getRef();	  
	~d1a4 := getRef();	 	 
	
	~d2a1 := getRef();	 	 
	~d2a2 := getRef();	 
	~d2a3 := getRef();	 	 
	~d2a4 := getRef();	 	
	
	~d3a1 := getRef();	 	 
	~d3a2 := getRef();	 
	~d3a3 := getRef();	 	 
	~d3a4 := getRef();	
	 
	~d4a1 := getRef();	  
	~d4a2 := getRef();	 
	~d4a3 := getRef();	 	
	
	~d5a1 := getRefStr();	 
	
}

child = new Inner()

def doings1() String{
	
	child.d1a1[0]++
	++child.d1a2[0]
	child.d1a3[0]--
	--child.d1a4[0]
	
	return "" + [child.d1a1:,child.d1a2:,child.d1a3:,child.d1a4:]
}


def doings2() String{
	b1 = child.d2a1[0]++
	b2 = ++child.d2a2[0]
	b3 = child.d2a3[0]--
	b4 = --child.d2a4[0]
	
	return "" + [child.d2a1:,child.d2a2:,child.d2a3:,child.d2a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}


def doings3() String{ 
	
	b1 := child.d3a1[0]++
	b2 := ++child.d3a2[0]
	b3 := child.d3a3[0]--
	b4 := --child.d3a4[0]
	
	return "" + [child.d3a1:,child.d3a2:,child.d3a3:,child.d3a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}


def doings4() String{ 
	
	child.d4a1[0] += 1
	child.d4a2[0] -= 1
	child.d4a3[0] *= 2
	
	return "" + [child.d4a1:,child.d4a2:,child.d4a3:] 
	//prefix ok, postfix not
}

def doings5() String{
	child.d5a1[0] += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##555 intermission - respect pre post ops

def doings() String{
	a1 := 5
	a2 := 5
	
	x1 = ++a1
	x2 = a2++
	
	return "" + [x1,x2] //should be 6, 5
}

~~~~~
//##555.2 intermission - auto extract ref thing

def doings() String{
	a7 int:= 5
	
	x7 Integer[] = [a7] //has to be this way for now
	x72 Integer:[] = [a7:] //
	
	return "" + ["" + x7, "" + x72]
}

~~~~~
//##555.3 intermission - ensure that keys and values in maps are cast approperiatly in bytecode

def doings() String{
	a := 5
	y java.util.Map<Integer:, Integer> = {a: -> a}
	return "" + y[a:]
}

~~~~~
//##555.4 intermission - another one

def doings() String{
	a := 5
	
	y java.util.Map<Integer, Integer> = {a -> a}
	
	return "" + y[5]
}

~~~~~
//##555.5 intermission - array index use ref as arg unref the int man

def doings() String{
	a := 5
	
	x15 = [0,0,0,0,0,5,0,0][a]
	
	return "" + x15
}

~~~~~
//##555.6 intermission - use of refs inside pow op

def doings() String{
	a27 := 5
	a28 := 5
	a29 := 5
	a30 := 5

	x27 = a27 ** 5 
	x28 = 15 ** a27
	x29 = a27 ** a27
	//x29 = a27 ** a27
	
	
	return "" + [x27, x28, x29] + [a27, a28, a29, a30]
}

~~~~~
//##555.7 intermission - ensure that postfix operator returns thing being refered to - a
def ttt()=>true
def fff()=>false
public y int := 5

public y2 int := 5

open class Moi(public x int){
	this(){
		this(y++)
	}
}


class Moi2() extends Moi(y2++) {} 

class MyCls(-x4 int) {} 

def myFunc(x int) int {
	return x
}

def echo(x int) int { return x }

//a1 := 5
a1 int:= 5
a2 int:= 5
a3 int:= 5
a4 int:= 5
a5 int:= 5
a6 int:= 5
a7 int:= 5
a8 int:= 5
a9 int:= 5
a10 int:= 5
a11 int:=5

a12 int:=5
a13 int:=5
a14 int:=4

a15 int:=5
a16 int:=5
a17 int:=6
a18 int:=5

a19 := 0
a20 := 0
a21 := 0
a22 := 5

a23 := 5
a24 := 5
a25 := 5
a26 := 5

a27 := 5
a28 := 5
a29 := 5
a30 := 5

a31 := 5
a32 := 5
a33 := 5
a34 := 5

a35 := 5 
a36 := 5 
a37 := 5
a38 := 5
//x1 = ++a1
x1 int = a1++
x2 = a2++
x5 = a5++ if ttt() else a5++; //tweak to ret type has to cascade down
x6 = a6++ if fff() else a6++;
x7 = [a7++]
x8 Integer[2] = [[a8++]] //really should be int[2]//todo:
x9 = a9++ as Integer 
x10 = (a10@)++ as Integer //check copy works, unrelated test sneak it in naughty
x11 = {a11: -> a11++}

x12 java.util.Map<Integer:, Integer> = {a12: -> a12++}//value
x13 := {a13: -> a13++}//value
x14 java.util.Map<Integer, Integer:> = {a14++ -> a14:}//key

x15 = [0 0 0 0 0 5 0 0][a15++]
x16 = [0 0 0 0 0 5 0 0][a16++...][0]
x17 = [0 0 0 0 0 5 0 0][...a17++][5]
x18 = [0 0 0 0 0 5 0 0][a18++...a18++][0]

def deli(){

	m = new Moi()
	m2 = new Moi2()
}

def doings() String{
	
	x3 = myFunc(a3++)
	x4 = (new MyCls(a4++)).x4
	
	//TODO: nasty the code above cannot be included because it takes us above 64kb post concurnification
	
	x23 = a23++ * 5
	x24 = 5 * a24++
	x25 = a25++ * a26++ 
	
	x27 = a27++ ** 5
	x28 = 5 ** a28++
	x29 = a29++ ** a30++ 
	
	x31 = a31++ == 5 == true
	x32 = 5 == a32++ == true
	x33 = a33++ == a34++ == true
	
	ref = echo&(? int)
	
	x35 = ref(a35++)
	x36 = echo&(? int)(a36++)
	ref2 = echo&(a37++)
	x37 = ref2()
	x38 = echo&(a38++)()
	
	//postfix op we know that we want the value, so dont return the ref at all
	//even better u can copy the prevalue of the ref
	//mark as taggedtype
	
	deli()
	
	""+ [x1 x2  x3  x4  x5  x6  x7[0]  x8[0,0]  x9  x10  x11[a11:]  x12[a12:]  x13[a13:]  x14[4]  x15  x16  x17  x18  (x23-20)  (x24-20)  (x25-20)  x27**.2 as int  x28**.2 as int  x29**.2 as int  x31]
}

~~~~~
//##555.7 intermission - ensure that postfix operator returns thing being refered to - b
public y int := 5

public y2 int := 5

open class Moi(public x int){
	this(){
		this(y++)
	}
}


class Moi2() extends Moi(y2++) {} 

class MyCls(-x4 int) {} 

def myFunc(x int) int {
	return x
}

def echo(x int) int { return x }

a19 := 0
a20 := 0
a21 := 0
a22 := 5
a31 := 5
a32 := 5
a33 := 5
a34 := 5

a35 := 5 
a36 := 5 
a37 := 5
a38 := 5

x19 = a19++ + 5
x20 = 5 + a20++
x21 = a21++ + a22++ 

def doings() => {
	ref2 = echo&(a37++)

	x31 = a31++ == 5 == true
	x32 = 5 == a32++ == true
	x33 = a33++ == a34++ == true
	
	ref = echo&(? int)
	
	x35 = ref(a35++)
	x36 = echo&(? int)(a36++)
	ref2 = echo&(a37++)
	x37 = ref2()
	x38 = echo&(a38++)()
	
	
	//postfix op we know that we want the value, so dont return the ref at all
	//even better u can copy the prevalue of the ref
	//mark as taggedtype
	
	m = new Moi()
	m2 = new Moi2()
	
	
	"" + [ x19, x20, x21, x31, x32, x33, m.x, y-1, m2.x, y2-1, x35, x36, x37, x38 ] //should be 6, 5
}

~~~~~
//##555.8 intermission - private static field which happens to be a ref

private y int := 5

class Moi(public x int){
	 
	this(){
		this(5)
		y =  9
		y +=  9
		y ++
	}
}

def doings() String{
	m = new Moi()
	return "" + [m.x, y]
}







~~~~~
//##53.a inc operations - array of ref - local


def getRef() int:[]{
	return a[5:, 5:, 5:, 5:]
}

def getRefStr() String:[]{
	return a["5":, "5":, "5":, "5":]
}

def doings1() String{
	a1 := getRef();	  
	a2 := getRef();	 
	a3 := getRef();	  
	a4 := getRef();	 	 
	
	a1[0]++
	++a2[0]
	a3[0]--
	--a4[0]
	
	return "" + [a1:,a2:,a3:,a4:]
}


def doings2() String{
	a1 := getRef();	 	 
	a2 := getRef();	 
	a3 := getRef();	 	 
	a4 := getRef();	 	 
	
	b1 = a1[0]++
	b2 = ++a2[0]
	b3 = a3[0]--
	b4 = --a4[0]
	
	return "" + [a1:,a2:,a3:,a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}


def doings3() String{
	a1 := getRef();	 	 
	a2 := getRef();	 
	a3 := getRef();	 	 
	a4 := getRef();	  
	
	b1 := a1[0]++
	b2 := ++a2[0]
	b3 := a3[0]--
	b4 := --a4[0]
	
	return "" + [a1:,a2:,a3:,a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}


def doings4() String{
	a1 := getRef();	  
	a2 := getRef();	 
	a3 := getRef();	 	 
	
	a1[0] += 1
	a2[0] -= 1
	a3[0] *= 2
	
	return "" + [a1:,a2:,a3:] 
	//prefix ok, postfix not
}

def doings5() String{
	a1 := getRefStr();	 
	a1[0] += "hi"
	
	return "" + a1
}


def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##53.b inc operations - array of ref - module
def getRef() int:[]{
	return a[5:, 5:, 5:, 5:]
}

def getRefStr() String:[]{
	return a["5":, "5":, "5":, "5":]
}

a1d1 := getRef();	  
a2d1 := getRef();	 
a3d1 := getRef();	  
a4d1 := getRef();	

def doings1() String{
	
	a1d1[0]++
	++a2d1[0]
	a3d1[0]--
	--a4d1[0]
	
	return "" + [a1d1:,a2d1:,a3d1:,a4d1:]
}

a1d2 := getRef();	 	 
a2d2 := getRef();	 
a3d2 := getRef();	 	 
a4d2 := getRef();	 

def doings2() String{
	 
	
	b1 = a1d2[0]++
	b2 = ++a2d2[0]
	b3 = a3d2[0]--
	b4 = --a4d2[0]
	
	return "" + [a1d2:,a2d2:,a3d2:,a4d2:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

a1d3 := getRef();	 	 
a2d3 := getRef();	 
a3d3 := getRef();	 	 
a4d3 := getRef();	  

def doings3() String{

	b1 := a1d3[0]++
	b2 := ++a2d3[0]
	b3 := a3d3[0]--
	b4 := --a4d3[0]
	
	return "" + [a1d3:,a2d3:,a3d3:,a4d3:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}

a1d4 := getRef();	  
a2d4 := getRef();	 
a3d4 := getRef();	

def doings4() String{
 	 
	
	a1d4[0] += 1
	a2d4[0] -= 1
	a3d4[0] *= 2
	
	return "" + [a1d4:,a2d4:,a3d4:] 
	//prefix ok, postfix not
}

a1a1d5 := getRefStr();	 

def doings5() String{
	
	a1a1d5[0] += "hi"
	
	return "" + a1a1d5
}


def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##53.c inc operations - array of ref - class local


class MyClass{
	def getRef() int:[]{
		return a[5:, 5:, 5:, 5:]
	}
	
	def getRefStr() String:[]{
		return a["5":, "5":, "5":, "5":]
	}
	
	a1d1 := getRef();	  
	a2d1 := getRef();	 
	a3d1 := getRef();	  
	a4d1 := getRef();	
	
	def doings1() String{
		
		a1d1[0]++
		++a2d1[0]
		a3d1[0]--
		--a4d1[0]
		
		return "" + [a1d1:,a2d1:,a3d1:,a4d1:]
	}
	
	a1d2 := getRef();	 	 
	a2d2 := getRef();	 
	a3d2 := getRef();	 	 
	a4d2 := getRef();	 
	
	def doings2() String{
		 
		
		b1 = a1d2[0]++
		b2 = ++a2d2[0]
		b3 = a3d2[0]--
		b4 = --a4d2[0]
		
		return "" + [a1d2:,a2d2:,a3d2:,a4d2:] + "[" + [""+b1,""+b2,""+b3,""+b4]
		//prefix ok, postfix not
	}
	
	a1d3 := getRef();	 	 
	a2d3 := getRef();	 
	a3d3 := getRef();	 	 
	a4d3 := getRef();	  
	
	def doings3() String{
	
		b1 := a1d3[0]++
		b2 := ++a2d3[0]
		b3 := a3d3[0]--
		b4 := --a4d3[0]
		
		return "" + [a1d3:,a2d3:,a3d3:,a4d3:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
		//prefix ok, postfix not
	}
	
	a1d4 := getRef();	  
	a2d4 := getRef();	 
	a3d4 := getRef();	
	
	def doings4() String{
	 	 
		
		a1d4[0] += 1
		a2d4[0] -= 1
		a3d4[0] *= 2
		
		return "" + [a1d4:,a2d4:,a3d4:] 
		//prefix ok, postfix not
	}
	
	a1a1d5 := getRefStr();	 
	
	def doings5() String{
		
		a1a1d5[0] += "hi"
		
		return "" + a1a1d5
	}

}


def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	mc = new MyClass()

	return join( [mc.doings1()  mc.doings2()  mc.doings3()  mc.doings4()  mc.doings5()]  )
}


~~~~~
//##53.d inc operations - array of ref - class field

class MyClass{
	def getRef() int:[]{
		return a[5:, 5:, 5:, 5:]
	}
	
	def getRefStr() String:[]{
		return a["5":, "5":, "5":, "5":]
	}
	
	public a1d1 := getRef();	  
	public a2d1 := getRef();	 
	public a3d1 := getRef();	  
	public a4d1 := getRef();	
	
	public a1d2 := getRef();	 	 
	public a2d2 := getRef();	 
	public a3d2 := getRef();	 	 
	public a4d2 := getRef();	 
	
	public a1d3 := getRef();	 	 
	public a2d3 := getRef();	 
	public a3d3 := getRef();	 	 
	public a4d3 := getRef();	  
	
	public a1d4 := getRef();	  
	public a2d4 := getRef();	 
	public a3d4 := getRef();	
	
	public a1a1d5 := getRefStr();	 
}
	
def doings1() String{
	mc = new MyClass()
	
	mc.a1d1[0]++
	++mc.a2d1[0]
	mc.a3d1[0]--
	--mc.a4d1[0]
	
	return "" + [mc.a1d1:,mc.a2d1:,mc.a3d1:,mc.a4d1:]
}


def doings2() String{
	mc = new MyClass()
	
	b1 = mc.a1d2[0]++
	b2 = ++mc.a2d2[0]
	b3 = mc.a3d2[0]--
	b4 = --mc.a4d2[0]
	
	return "" + [mc.a1d2:,mc.a2d2:,mc.a3d2:,mc.a4d2:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{
	mc = new MyClass()
	
	b1 := mc.a1d3[0]++
	b2 := ++mc.a2d3[0]
	b3 := mc.a3d3[0]--
	b4 := --mc.a4d3[0]
	
	return "" + [mc.a1d3:,mc.a2d3:,mc.a3d3:,mc.a4d3:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}

def doings4() String{
 	mc = new MyClass()
	
	mc.a1d4[0] += 1
	mc.a2d4[0] -= 1
	mc.a3d4[0] *= 2
	
	return "" + [mc.a1d4:,mc.a2d4:,mc.a3d4:] 
	//prefix ok, postfix not
}

def doings5() String{
	mc = new MyClass()
	
	mc.a1a1d5[0] += "hi"
	
	return "" + mc.a1a1d5
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##53.e inc operations - array of ref - class getter setter

class MyClass{
	def getRef() int:[]{
		return a[5:, 5:, 5:, 5:]
	}
	
	def getRefStr() String:[]{
		return a["5":, "5":, "5":, "5":]
	}
	
	~a1d1 := getRef();	  
	~a2d1 := getRef();	 
	~a3d1 := getRef();	  
	~a4d1 := getRef();	
	
	~a1d2 := getRef();	 	 
	~a2d2 := getRef();	 
	~a3d2 := getRef();	 	 
	~a4d2 := getRef();	 
	
	~a1d3 := getRef();	 	 
	~a2d3 := getRef();	 
	~a3d3 := getRef();	 	 
	~a4d3 := getRef();	  
	
	~a1d4 := getRef();	  
	~a2d4 := getRef();	 
	~a3d4 := getRef();	
	
	~a1a1d5 := getRefStr();	 
}
	
def doings1() String{
	mc = new MyClass()
	
	mc.a1d1[0]++
	++mc.a2d1[0]
	mc.a3d1[0]--
	--mc.a4d1[0]
	
	return "" + [mc.a1d1:,mc.a2d1:,mc.a3d1:,mc.a4d1:]
}


def doings2() String{
	mc = new MyClass()
	
	b1 = mc.a1d2[0]++
	b2 = ++mc.a2d2[0]
	b3 = mc.a3d2[0]--
	b4 = --mc.a4d2[0]
	
	return "" + [mc.a1d2:,mc.a2d2:,mc.a3d2:,mc.a4d2:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{
	mc = new MyClass()
	
	b1 := mc.a1d3[0]++
	b2 := ++mc.a2d3[0]
	b3 := mc.a3d3[0]--
	b4 := --mc.a4d3[0]
	
	return "" + [mc.a1d3:,mc.a2d3:,mc.a3d3:,mc.a4d3:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}

def doings4() String{
 	mc = new MyClass()
	
	mc.a1d4[0] += 1
	mc.a2d4[0] -= 1
	mc.a3d4[0] *= 2
	
	return "" + [mc.a1d4:,mc.a2d4:,mc.a3d4:] 
	//prefix ok, postfix not
}

def doings5() String{
	mc = new MyClass()
	
	mc.a1a1d5[0] += "hi"
	
	return "" + mc.a1a1d5
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##53.f inc operations - array of ref - class getter only


class MyClass{
	def getRef() int:[]{
		return a[5:, 5:, 5:, 5:]
	}
	
	def getRefStr() String:[]{
		return a["5":, "5":, "5":, "5":]
	}
	
	-a1d1 := getRef();	  
	-a2d1 := getRef();	 
	-a3d1 := getRef();	  
	-a4d1 := getRef();	
	
	-a1d2 := getRef();	 	 
	-a2d2 := getRef();	 
	-a3d2 := getRef();	 	 
	-a4d2 := getRef();	 
	
	-a1d3 := getRef();	 	 
	-a2d3 := getRef();	 
	-a3d3 := getRef();	 	 
	-a4d3 := getRef();	  
	
	-a1d4 := getRef();	  
	-a2d4 := getRef();	 
	-a3d4 := getRef();	
	
	-a1a1d5 := getRefStr();	 
}
	
def doings1() String{
	mc = new MyClass()
	
	mc.a1d1[0]++
	++mc.a2d1[0]
	mc.a3d1[0]--
	--mc.a4d1[0]
	
	return "" + [mc.a1d1:,mc.a2d1:,mc.a3d1:,mc.a4d1:]
}


def doings2() String{
	mc = new MyClass()
	
	b1 = mc.a1d2[0]++
	b2 = ++mc.a2d2[0]
	b3 = mc.a3d2[0]--
	b4 = --mc.a4d2[0]
	
	return "" + [mc.a1d2:,mc.a2d2:,mc.a3d2:,mc.a4d2:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{
	mc = new MyClass()
	
	b1 := mc.a1d3[0]++
	b2 := ++mc.a2d3[0]
	b3 := mc.a3d3[0]--
	b4 := --mc.a4d3[0]
	
	return "" + [mc.a1d3:,mc.a2d3:,mc.a3d3:,mc.a4d3:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}

def doings4() String{
 	mc = new MyClass()
	
	mc.a1d4[0] += 1
	mc.a2d4[0] -= 1
	mc.a3d4[0] *= 2
	
	return "" + [mc.a1d4:,mc.a2d4:,mc.a3d4:] 
	//prefix ok, postfix not
}

def doings5() String{
	mc = new MyClass()
	
	mc.a1a1d5[0] += "hi"
	
	return "" + mc.a1a1d5
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##53.g inc operations - array of ref - class setter only


class MyClass{
	def getRef() int:[]{
		return a[5:, 5:, 5:, 5:]
	}
	
	def getRefStr() String:[]{
		return a["5":, "5":, "5":, "5":]
	}
	
	public +a1d1 := getRef();	  
	public +a2d1 := getRef();	 
	public +a3d1 := getRef();	  
	public +a4d1 := getRef();	
	
	public +a1d2 := getRef();	 	 
	public +a2d2 := getRef();	 
	public +a3d2 := getRef();	 	 
	public +a4d2 := getRef();	 
	
	public +a1d3 := getRef();	 	 
	public +a2d3 := getRef();	 
	public +a3d3 := getRef();	 	 
	public +a4d3 := getRef();	  
	
	public +a1d4 := getRef();	  
	public +a2d4 := getRef();	 
	public +a3d4 := getRef();	
	
	public +a1a1d5 := getRefStr();	 
}
	
def doings1() String{
	mc = new MyClass()
	
	mc.a1d1[0]++
	++mc.a2d1[0]
	mc.a3d1[0]--
	--mc.a4d1[0]
	
	return "" + [mc.a1d1:,mc.a2d1:,mc.a3d1:,mc.a4d1:]
}


def doings2() String{
	mc = new MyClass()
	
	b1 = mc.a1d2[0]++
	b2 = ++mc.a2d2[0]
	b3 = mc.a3d2[0]--
	b4 = --mc.a4d2[0]
	
	return "" + [mc.a1d2:,mc.a2d2:,mc.a3d2:,mc.a4d2:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{
	mc = new MyClass()
	
	b1 := mc.a1d3[0]++
	b2 := ++mc.a2d3[0]
	b3 := mc.a3d3[0]--
	b4 := --mc.a4d3[0]
	
	return "" + [mc.a1d3:,mc.a2d3:,mc.a3d3:,mc.a4d3:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}

def doings4() String{
 	mc = new MyClass()
	
	mc.a1d4[0] += 1
	mc.a2d4[0] -= 1
	mc.a3d4[0] *= 2
	
	return "" + [mc.a1d4:,mc.a2d4:,mc.a3d4:] 
	//prefix ok, postfix not
}

def doings5() String{
	mc = new MyClass()
	
	mc.a1a1d5[0] += "hi"
	
	return "" + mc.a1a1d5
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##54.a inc operations - ref of array of ref - local


def getRef() int:[]:{
	return a[5:, 5:, 5:, 5:]:
}

def getRefStr() String:[]:{
	return a["5":, "5":, "5":, "5":]:
}

def doings1() String{
	a1 := getRef();	  
	a2 := getRef();	 
	a3 := getRef();	  
	a4 := getRef();	 	 
	
	a1[0]++
	++a2[0]
	a3[0]--
	--a4[0]
	
	return "" + [a1:,a2:,a3:,a4:]
}


def doings2() String{
	a1 := getRef();	 	 
	a2 := getRef();	 
	a3 := getRef();	 	 
	a4 := getRef();	 	 
	
	b1 = a1[0]++
	b2 = ++a2[0]
	b3 = a3[0]--
	b4 = --a4[0]
	
	return "" + [a1:,a2:,a3:,a4:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}


def doings3() String{
	a1 := getRef();	 	 
	a2 := getRef();	 
	a3 := getRef();	 	 
	a4 := getRef();	  
	
	b1 := a1[0]++
	b2 := ++a2[0]
	b3 := a3[0]--
	b4 := --a4[0]
	
	return "" + [a1:,a2:,a3:,a4:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}


def doings4() String{
	a1 := getRef();	  
	a2 := getRef();	 
	a3 := getRef();	 	 
	
	a1[0] += 1
	a2[0] -= 1
	a3[0] *= 2
	
	return "" + [a1:,a2:,a3:] 
	//prefix ok, postfix not
}

def doings5() String{
	a1 := getRefStr();	 
	a1[0] += "hi"
	
	return "" + a1
}


def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##54.b inc operations - ref of array of ref - module
def getRef() int:[]:{
	return a[5:, 5:, 5:, 5:]:
}

def getRefStr() String:[]:{
	return a["5":, "5":, "5":, "5":]:
}

a1d1 := getRef();	  
a2d1 := getRef();	 
a3d1 := getRef();	  
a4d1 := getRef();	

def doings1() String{
	
	a1d1[0]++
	++a2d1[0]
	a3d1[0]--
	--a4d1[0]
	
	return "" + [a1d1:,a2d1:,a3d1:,a4d1:]
}

a1d2 := getRef();	 	 
a2d2 := getRef();	 
a3d2 := getRef();	 	 
a4d2 := getRef();	 

def doings2() String{
	 
	
	b1 = a1d2[0]++
	b2 = ++a2d2[0]
	b3 = a3d2[0]--
	b4 = --a4d2[0]
	
	return "" + [a1d2:,a2d2:,a3d2:,a4d2:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

a1d3 := getRef();	 	 
a2d3 := getRef();	 
a3d3 := getRef();	 	 
a4d3 := getRef();	  

def doings3() String{

	b1 := a1d3[0]++
	b2 := ++a2d3[0]
	b3 := a3d3[0]--
	b4 := --a4d3[0]
	
	return "" + [a1d3:,a2d3:,a3d3:,a4d3:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}

a1d4 := getRef();	  
a2d4 := getRef();	 
a3d4 := getRef();	

def doings4() String{
 	 
	
	a1d4[0] += 1
	a2d4[0] -= 1
	a3d4[0] *= 2
	
	return "" + [a1d4:,a2d4:,a3d4:] 
	//prefix ok, postfix not
}

a1a1d5 := getRefStr();	 

def doings5() String{
	
	a1a1d5[0] += "hi"
	
	return "" + a1a1d5
}


def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##54.c inc operations - ref of array of ref - class local


class MyClass{
	def getRef() int:[]:{
		return a[5:, 5:, 5:, 5:]:
	}
	
	def getRefStr() String:[]:{
		return a["5":, "5":, "5":, "5":]:
	}
	
	a1d1 := getRef();	  
	a2d1 := getRef();	 
	a3d1 := getRef();	  
	a4d1 := getRef();	
	
	def doings1() String{
		
		a1d1[0]++
		++a2d1[0]
		a3d1[0]--
		--a4d1[0]
		
		return "" + [a1d1:,a2d1:,a3d1:,a4d1:]
	}
	
	a1d2 := getRef();	 	 
	a2d2 := getRef();	 
	a3d2 := getRef();	 	 
	a4d2 := getRef();	 
	
	def doings2() String{
		 
		
		b1 = a1d2[0]++
		b2 = ++a2d2[0]
		b3 = a3d2[0]--
		b4 = --a4d2[0]
		
		return "" + [a1d2:,a2d2:,a3d2:,a4d2:] + "[" + [""+b1,""+b2,""+b3,""+b4]
		//prefix ok, postfix not
	}
	
	a1d3 := getRef();	 	 
	a2d3 := getRef();	 
	a3d3 := getRef();	 	 
	a4d3 := getRef();	  
	
	def doings3() String{
	
		b1 := a1d3[0]++
		b2 := ++a2d3[0]
		b3 := a3d3[0]--
		b4 := --a4d3[0]
		
		return "" + [a1d3:,a2d3:,a3d3:,a4d3:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
		//prefix ok, postfix not
	}
	
	a1d4 := getRef();	  
	a2d4 := getRef();	 
	a3d4 := getRef();	
	
	def doings4() String{
	 	 
		
		a1d4[0] += 1
		a2d4[0] -= 1
		a3d4[0] *= 2
		
		return "" + [a1d4:,a2d4:,a3d4:] 
		//prefix ok, postfix not
	}
	
	a1a1d5 := getRefStr();	 
	
	def doings5() String{
		
		a1a1d5[0] += "hi"
		
		return "" + a1a1d5
	}

}


def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	mc = new MyClass()

	return join( [mc.doings1()  mc.doings2()  mc.doings3()  mc.doings4()  mc.doings5()]  )
}


~~~~~
//##54.d inc operations - ref of array of ref - class field

class MyClass{
	def getRef() int:[]:{
		return a[5:, 5:, 5:, 5:]:
	}
	
	def getRefStr() String:[]:{
		return a["5":, "5":, "5":, "5":]:
	}
	
	public a1d1 := getRef();	  
	public a2d1 := getRef();	 
	public a3d1 := getRef();	  
	public a4d1 := getRef();	
	
	public a1d2 := getRef();	 	 
	public a2d2 := getRef();	 
	public a3d2 := getRef();	 	 
	public a4d2 := getRef();	 
	
	public a1d3 := getRef();	 	 
	public a2d3 := getRef();	 
	public a3d3 := getRef();	 	 
	public a4d3 := getRef();	  
	
	public a1d4 := getRef();	  
	public a2d4 := getRef();	 
	public a3d4 := getRef();	
	
	public a1a1d5 := getRefStr();	 
}
	
def doings1() String{
	mc = new MyClass()
	
	mc.a1d1[0]++
	++mc.a2d1[0]
	mc.a3d1[0]--
	--mc.a4d1[0]
	
	return "" + [mc.a1d1:,mc.a2d1:,mc.a3d1:,mc.a4d1:]
}


def doings2() String{
	mc = new MyClass()
	
	b1 = mc.a1d2[0]++
	b2 = ++mc.a2d2[0]
	b3 = mc.a3d2[0]--
	b4 = --mc.a4d2[0]
	
	return "" + [mc.a1d2:,mc.a2d2:,mc.a3d2:,mc.a4d2:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{
	mc = new MyClass()
	
	b1 := mc.a1d3[0]++
	b2 := ++mc.a2d3[0]
	b3 := mc.a3d3[0]--
	b4 := --mc.a4d3[0]
	
	return "" + [mc.a1d3:,mc.a2d3:,mc.a3d3:,mc.a4d3:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}

def doings4() String{
 	mc = new MyClass()
	
	mc.a1d4[0] += 1
	mc.a2d4[0] -= 1
	mc.a3d4[0] *= 2
	
	return "" + [mc.a1d4:,mc.a2d4:,mc.a3d4:] 
	//prefix ok, postfix not
}

def doings5() String{
	mc = new MyClass()
	
	mc.a1a1d5[0] += "hi"
	
	return "" + mc.a1a1d5
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##54.e inc operations - ref of array of ref - class getter setter

class MyClass{
	def getRef() int:[]:{
		return a[5:, 5:, 5:, 5:]:
	}
	
	def getRefStr() String:[]:{
		return a["5":, "5":, "5":, "5":]:
	}
	
	~a1d1 := getRef();	  
	~a2d1 := getRef();	 
	~a3d1 := getRef();	  
	~a4d1 := getRef();	
	
	~a1d2 := getRef();	 	 
	~a2d2 := getRef();	 
	~a3d2 := getRef();	 	 
	~a4d2 := getRef();	 
	
	~a1d3 := getRef();	 	 
	~a2d3 := getRef();	 
	~a3d3 := getRef();	 	 
	~a4d3 := getRef();	  
	
	~a1d4 := getRef();	  
	~a2d4 := getRef();	 
	~a3d4 := getRef();	
	
	~a1a1d5 := getRefStr();	 
}
	
def doings1() String{
	mc = new MyClass()
	
	mc.a1d1[0]++
	++mc.a2d1[0]
	mc.a3d1[0]--
	--mc.a4d1[0]
	
	return "" + [mc.a1d1:,mc.a2d1:,mc.a3d1:,mc.a4d1:]
}


def doings2() String{
	mc = new MyClass()
	
	b1 = mc.a1d2[0]++
	b2 = ++mc.a2d2[0]
	b3 = mc.a3d2[0]--
	b4 = --mc.a4d2[0]
	
	return "" + [mc.a1d2:,mc.a2d2:,mc.a3d2:,mc.a4d2:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{
	mc = new MyClass()
	
	b1 := mc.a1d3[0]++
	b2 := ++mc.a2d3[0]
	b3 := mc.a3d3[0]--
	b4 := --mc.a4d3[0]
	
	return "" + [mc.a1d3:,mc.a2d3:,mc.a3d3:,mc.a4d3:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}

def doings4() String{
 	mc = new MyClass()
	
	mc.a1d4[0] += 1
	mc.a2d4[0] -= 1
	mc.a3d4[0] *= 2
	
	return "" + [mc.a1d4:,mc.a2d4:,mc.a3d4:] 
	//prefix ok, postfix not
}

def doings5() String{
	mc = new MyClass()
	
	mc.a1a1d5[0] += "hi"
	
	return "" + mc.a1a1d5
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##54.f inc operations - ref of array of ref - class getter only


class MyClass{
	def getRef() int:[]:{
		return a[5:, 5:, 5:, 5:]:
	}
	
	def getRefStr() String:[]:{
		return a["5":, "5":, "5":, "5":]:
	}
	
	-a1d1 := getRef();	  
	-a2d1 := getRef();	 
	-a3d1 := getRef();	  
	-a4d1 := getRef();	
	
	-a1d2 := getRef();	 	 
	-a2d2 := getRef();	 
	-a3d2 := getRef();	 	 
	-a4d2 := getRef();	 
	
	-a1d3 := getRef();	 	 
	-a2d3 := getRef();	 
	-a3d3 := getRef();	 	 
	-a4d3 := getRef();	  
	
	-a1d4 := getRef();	  
	-a2d4 := getRef();	 
	-a3d4 := getRef();	
	
	-a1a1d5 := getRefStr();	 
}
	
def doings1() String{
	mc = new MyClass()
	
	mc.a1d1[0]++
	++mc.a2d1[0]
	mc.a3d1[0]--
	--mc.a4d1[0]
	
	return "" + [mc.a1d1:,mc.a2d1:,mc.a3d1:,mc.a4d1:]
}


def doings2() String{
	mc = new MyClass()
	
	b1 = mc.a1d2[0]++
	b2 = ++mc.a2d2[0]
	b3 = mc.a3d2[0]--
	b4 = --mc.a4d2[0]
	
	return "" + [mc.a1d2:,mc.a2d2:,mc.a3d2:,mc.a4d2:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{
	mc = new MyClass()
	
	b1 := mc.a1d3[0]++
	b2 := ++mc.a2d3[0]
	b3 := mc.a3d3[0]--
	b4 := --mc.a4d3[0]
	
	return "" + [mc.a1d3:,mc.a2d3:,mc.a3d3:,mc.a4d3:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}

def doings4() String{
 	mc = new MyClass()
	
	mc.a1d4[0] += 1
	mc.a2d4[0] -= 1
	mc.a3d4[0] *= 2
	
	return "" + [mc.a1d4:,mc.a2d4:,mc.a3d4:] 
	//prefix ok, postfix not
}

def doings5() String{
	mc = new MyClass()
	
	mc.a1a1d5[0] += "hi"
	
	return "" + mc.a1a1d5
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##54.g inc operations - ref of array of ref - class setter only


class MyClass{
	def getRef() int:[]:{
		return a[5:, 5:, 5:, 5:]:
	}
	
	def getRefStr() String:[]:{
		return a["5":, "5":, "5":, "5":]:
	}
	
	public +a1d1 := getRef();	  
	public +a2d1 := getRef();	 
	public +a3d1 := getRef();	  
	public +a4d1 := getRef();	
	
	public +a1d2 := getRef();	 	 
	public +a2d2 := getRef();	 
	public +a3d2 := getRef();	 	 
	public +a4d2 := getRef();	 
	
	public +a1d3 := getRef();	 	 
	public +a2d3 := getRef();	 
	public +a3d3 := getRef();	 	 
	public +a4d3 := getRef();	  
	
	public +a1d4 := getRef();	  
	public +a2d4 := getRef();	 
	public +a3d4 := getRef();	
	
	public +a1a1d5 := getRefStr();	 
}
	
def doings1() String{
	mc = new MyClass()
	
	mc.a1d1[0]++
	++mc.a2d1[0]
	mc.a3d1[0]--
	--mc.a4d1[0]
	
	return "" + [mc.a1d1:,mc.a2d1:,mc.a3d1:,mc.a4d1:]
}


def doings2() String{
	mc = new MyClass()
	
	b1 = mc.a1d2[0]++
	b2 = ++mc.a2d2[0]
	b3 = mc.a3d2[0]--
	b4 = --mc.a4d2[0]
	
	return "" + [mc.a1d2:,mc.a2d2:,mc.a3d2:,mc.a4d2:] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{
	mc = new MyClass()
	
	b1 := mc.a1d3[0]++
	b2 := ++mc.a2d3[0]
	b3 := mc.a3d3[0]--
	b4 := --mc.a4d3[0]
	
	return "" + [mc.a1d3:,mc.a2d3:,mc.a3d3:,mc.a4d3:] + "[]" + [""+b1:,""+b2:,""+b3:,""+b4:]
	//prefix ok, postfix not
}

def doings4() String{
 	mc = new MyClass()
	
	mc.a1d4[0] += 1
	mc.a2d4[0] -= 1
	mc.a3d4[0] *= 2
	
	return "" + [mc.a1d4:,mc.a2d4:,mc.a3d4:] 
	//prefix ok, postfix not
}

def doings5() String{
	mc = new MyClass()
	
	mc.a1a1d5[0] += "hi"
	
	return "" + mc.a1a1d5
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##55 intermission, funcs lock types now

def functo() int:{ return 454: }

class XX(~x int:){}

def doings() String{
	xx = new XX(12)
	xxx1 = functo()
	xxx2 Integer = functo():get()
	xxx3 int = functo():get()
	xxx4  = xx.x
	return "" + xxx1 + "$" +  xxx2 + "$" +  xxx3 + "$" + (xxx4 as Object)
}

~~~~~
//##56.1. nested refs

class Outer{	
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	private a1 = [8:,8,8]:

	public class Inner{
		override equals(o Object) boolean {return true;}
		override hashCode() int {return 6;}
		
		def getter() String{
			//a1 += 2
			return "" + a1[0]
		}
		
		def setter() String{
			a1=[8:,8,8]:
			a1[0] = 2
			return "" + a1[0]
		}
		
		def getandset() String{
			a1[0] += 1
			a1[0]++
			++a1[0]
			
			c1 = a1[0]++
			c2 = ++a1[0]
			
			return "" + a1[0]: + "" + [c1,c2]
		}
	}
}

def doings() String{
	Inn = new Outer().new Inner() 
	return "" +  [Inn.getter(), Inn.setter(), Inn.getandset() ]
}

~~~~~
//##56.2. nested refs - double check module level

private a1 = [8:,8,8]:

class Outer{	
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}

	public class Inner{
		override equals(o Object) boolean {return true;}
		override hashCode() int {return 6;}
		
		def getter() String{
			//a1 += 2
			return "" + a1[0]
		}
		
		def setter() String{
			a1=[8:,8,8]://check that can be totally overriden
			a1[0] = 2
			return "" + a1[0]
		}
		
		def getandset() String{
			a1[0] += 1
			a1[0]++
			++a1[0]
			
			c1 = a1[0]++
			c2 = ++a1[0]
			
			return "" + a1[0]: + "" + [c1,c2]
		}
	}
}

def doings() String{
	Inn = new Outer().new Inner() 
	return "" +  [Inn.getter(), Inn.setter(), Inn.getandset() ]
}

~~~~~
//##56.3. nested refs x2 - three levels 

class Outer2{
	public class Outer{	
		private a1 := 8
		private a2 = [8:, 8:]
		private a3 := [8, 8]
		private a4 := [8:, 8:]
	
		public class Inner{
			def doings() String{
				a1 += 2
				a2[0] += 2
				a3[0] += 2
				a4[0] += 2
				return "" + [a1, a2, a3, a4]
			}
			
		}
	}
}

def doings() String{
	return "" + new Outer2().new Outer().new Inner().doings()
}

~~~~~
//##57. refs to lambdas

x2 := (def () String{ return "hi" + (7*500);})

class MC(){
	public x3 := (def () String{ return "hi" + (7*500);})
	~x4 := (def () String{ return "hi" + (7*501);})
	
	def insideMe() String {
		return x3() + "==" + x4()
	}
	
	def checkla() => x3() == x4()
}

def invoke() String{
	
	x1 := (def () String{ return "hi" + (7*500);})
	
	m = new MC()
	
	return "" + [x1(), x2(), m.x3(), m.x4()]
}

def replaceAndInvoke() String{
	
	repl = (def () String{ return "new one";})
	
	x1 := (def () String{ return "hi" + (7*500);})
	x1 = repl
	
	x2 = repl
	
	m = new MC()
	
	m.x3 = repl
	m.x4 = repl
	
	anotherM = new MC()
	
	return "" + [x1(), x2(), m.x3(), m.x4(), m.insideMe(), m.checkla(), anotherM.insideMe(), anotherM.checkla()]
}


def doings() String{
	return "" + [invoke(), replaceAndInvoke()]
}

~~~~~
//##57.b refs to lambdas - as funrefs

x2 := (def () String{ return "hi" + (7*500);})

class MC(){
	public x3 := (def () String{ return "hi" + (7*500);})
	public ~x4 = (def () String{ return "hi" + (7*500);})
	
	def insideMe() String {
		return x3() + "==" + x4()
	}
}

def doings() String{
	
	x1 := (def () String{ return "hi" + (7*500);})
	
	m = new MC()
	
	a1 = x1&()
	a2 = x2&()
	a3 = m.x3&()
	a4 = m.x4&()
	
	
	return "" + [a1(), a2(), a3(), a4()]
}

~~~~~
//##58. double refs

def doings() String{
	
	x1 int:
	x2 int::
	
	return "" + x1:get(true) + ", " + x2:get(true):get(true) //no wait
}

~~~~~
//##59. module level ref init correctly

x1 int: 

def doings() String{
	x1 = 8
	return "" + x1
}

~~~~~
//##60. basic double ref set

x1 int::
def doings() String{
	x2 int::
	x1 = 8
	x2 = 8
	
	return "" + [x1, x2]
}

~~~~~
//##60.a basic double initial

x1 int:: = 8
def doings() String{
	x2 int:: = 8
	
	return "" + [x1, x2]
}
~~~~~
//##60.b basic double initial - already ref on rhs so dont wipe it out

x1 int: = 8:

def doings() String{

	return "" +x1 //+ [x1, x2]
}

~~~~~
//##61. two level init
x1 = ((8):):

def doings() String{
	x2 =((8):):
	return "" + [""+x1, ""+x2]
}

~~~~~
//##61.b two level init -keep ref

x1 = ((8):):

def doings() String{
	x2 =((8):):
	return "" + [x1::, x2::]
}

~~~~~
//##61.c two level init -keep ref new

x1 int::= 8::

def doings() String{
	x2 int:: =8::
	return "" + [x1::, x2::]
}

~~~~~
//##61.d two level init -keep ref new

x1 int::= 8::

def doings() String{
	x2 int:: =8::
	return "" + [""+x1, ""+x2]
}

~~~~~
//##61.e two level init -keep ref new

x1 int::= 8::

def doings() String{
	x2 int:: =8::
	return "" + [x1::, x2]
}

~~~~~
//##61.f reassign

def doings() String{
	x2 int:: =8::
	x2 = 9::
	
	return "" + x2::
}

~~~~~
//##62. explicit cast
def doings() String{
	x2  = 8:: as int::
	
	return "" + x2::
}

~~~~~
//##63. up ref
y1 int:: = 8
y2 :: =  8

def doings() String{
	x1 int::  = 8
	x2 ::= 8
	
	return "" + [x1::, x2::, y1::, y2::]
}

~~~~~
//##64. down ref
y1 int: = 8:: as int:
y2 : = 8:: as int:

def doings() String{
	x1 int:  = 8:: as int:
	x2 := 8:: as int:
	
	return "" + [x1:, x2:, y1:, y2:]
}

~~~~~
//##64.a down ref - simple 1

g=(8:):

def doings() String{
	x1 int:= g //call get
	
	return "" + x1:
}

~~~~~
//##64.a down ref - simple 2

g int::=8::

def doings() String{
	x2 := g //call get
	return "" + x2:
}


~~~~~
//##64.a down ref - note 3

def doings1() String{
	x1 int:  = 8:: as int://note that locking the rhs implicity does not force lhs to ::
	return "" + x1:
}

g int::= 8::

def doings2() String{
	x1 int:  = g: //note that locking the rhs implicity does not force lhs to ::
	return "" + x1:
}

def doings() String{
	return "" + [doings1(), doings2()]
}
~~~~~
//##64.a down ref - simple 3

g=8::
y1 int: = g
def doings() String{
	return "" + y1: 
}

~~~~~
//##64.a down ref - note 2

g=8::
y1 : = g
y12 : = g@ //y12 and g are the same cos copy operation does not dupe refs
def doings() String{
	return "" + y1: +"" + (g::get() &== y1:) +"," + (g::get() &== y12:)//last one is the same, copy from ref to ref, cos ref itself is isolated
	//first one is same ref, second one is a copy
}


~~~~~
//##65. explicit cast

x = 8::

def doings() String{
	
	y = x as int://down
	z = y as int:://up

	return ""  + [""+x::,""+y:,""+z::] + "~" + [x is int::,y is int:,z is int::]
}

~~~~~
//##66. implicit cast

x = 8::

def doings() String{
	
	y := x //down
	z int::= y //up
	z2 ::= y //up

	return ""  + [x is int::,y is int:,z is int::,z2 is int::] +"\n"+ \ 
			 [""+x::, ""+y:,""+z::,""+z2::]
}

~~~~~
//##66.b implicit cast

x = 8::
y = 8

def f1(x int:) String{
	return "int:"
}

def f2(x int::) String{
	return "int::"
}

def doings() String{
	return "" + [f1(x), f1(y)] + "~" + [f2(x), f2(y)] + "\n" \ 
		      + [f1(x as int:), f1(y as int:)] + "~" + [f2(x as int::), f2(y as int::)]
}


~~~~~
//##66.c implicit cast

y = 8
d = y as int::

def doings() String{

	ay int: = d //implicit downcast
	
	return "" + ay: //this is ok
}

~~~~~
//##67. minor details

y = 8

def doings() String{

	d = y as int:: //not being created right now
	
	return "" + d:: //this is ok
}

~~~~~
//##68. ensure that unrefing occurs to correct levels on multirefs

x = (8:):

def doings() String{
	f1 = "" + x::
	f2 = "" + x:
	f3 = "" + x

	return "" +[f1, f2, f3] 
}

~~~~~
//##69. gets correctly on multilevels

g=8::
def doings() String{
	gotRef = g:get() //ref
	notRef = g::get() //notref
	
	return "" + [ notRef is Integer, gotRef is int:]
}

~~~~~
//##70.a double get -prelem

g=8::
def doings() String{
	x := g:get()
	gotRef = x:get() is Integer
	
	return "" + gotRef
}

~~~~~
//##70.b double get 

g=8::
def doings() String{
	gotRef = g::get():get() is Integer
	return "" + gotRef
}

~~~~~
//##71. minor point

def fSame(x2 int:) boolean {
	//ensure when entering new function that the type of the argument is correctly recorded
	y int:= x2
	return (x2: &== y:)
}

def doings() String{
	return "" + fSame(7:)
}

~~~~~
//##72. minor point - simple constr set

class Fass (public ~z Object:){  }


def doings() String{
	f Fass = new Fass(7)
	return "" + [f\.z, f.z, ""+f\.z:, ""+f.z:]
}

~~~~~
//##73. implicit up and down

def xyq(g int::) String {
	return "called" + g::
}

def xyq2(g int:) String {
	return "called" + g:
}


a int:= 8
b int::=8 

def doings() String{
	return ""  + xyq(a) + xyq2(b)
}

~~~~~
//##73. explicit up and down


a int:= 8
b int::=8 

def doings() String{
	z1 int:: = a as int:: //up explicit
	z2 int: = b as int: //down explicit

	return "" + [""+z1::, ""+z2:]
}

~~~~~
//##73.b explicit up and down - change type -> sub to sup

a Object = 8 as int::
b Object = 8 as int:

def doings() String{
	z1 = a as int: //down
	z2 = b as int:: //up
	
	return "" + z1: + "" + z2::
}

~~~~~
//##73.c explicit up and down - change type -> sup to sub
a Object = new Integer(8) as int::
b Object = new Integer(8) as int:

def doings() String{
	z1 = a as int: //down
	z2 = b as int:: //up
	
	return "" + z1: + "" + z2::
}

~~~~~
//##73.d explicit up and down - change type -> sup to sub - initial null

//create initial - null
orig1 Number::
orig2 Number:

a Object = orig1::
b Object = orig2:

def doings() String{
	f1="fail"
	f2="fail"
	
	//we fail because we revert back to the defined type, of Number, not the actual type which may be a subtype of Number (cos there aint one:)
		
	try{ z1 = a as int: } catch(e) { f1 = e.getMessage() } //down
	try{ z2 = b as int:: } catch(e) {f2 = e.getMessage()} //up
	
	return "" + [f1, f2]
}

~~~~~
//##73.e explicit up and down - change type -> sub to sup- initial null

//create initial
orig1 int::
orig2 int:

a Object = orig1::
b Object = orig2:

def doings() String{
	f1="ok"
	f2="ok"
	try{ z1 = a as int: } catch(e) { f1 = e.getMessage() } //down
	try{ z2 = b as int:: } catch(e) {f2 = e.getMessage()} //up
	
	//we be ok as going from int to Number when not initially set 

	return "" + [f1, f2]
}

~~~~~
//##74. spot check

a Object = new Integer(8) as Number:
def doings() String{
	z1 = a as Number:
	return "" + z1://should be ok
}

~~~~~
//##74.a conv correctly sup to sub

a Object = new Integer(8) as int:
b Object = new Double(8.0) as double:

def doings() String{
	f1="ok"
	f2="fail"
	try{ z1 = a as Integer: } catch(e) { f1 = e.getMessage() }
	try{ z2 = b as Integer: } catch(e) { f2 = e.getMessage()}//expect fail 
	
	return "" + [f1, f2]
}


~~~~~
//##74.b conv correctly sup to sub - alternate form

a Object = new Integer(8) as int:
b Object = new Double(8.0) as double:

def doings() String{
	f1="ok"
	f2="fail"
	try{ z1 = a as Integer: } catch(e) { f1 = e.getMessage() }
	try{ z2 = b as Integer: } catch(e) { f2 = e.getMessage()}//expect fail 
	
	return "" + [f1, f2]
}

~~~~~
//##75. another thing to check

def getter() int:: { return 8:: }


y1 int: = getter() 
y2 : = getter() 

def doings() {
	y3 int: = getter()
	y4 : = getter()

	"" + [y1:, y2:, y3, y4:]
}

~~~~~
//##76. minor syntax problem that doesnt belong here meh

class Fass
{
	public -z Object: 
	
	public f = 9
	//note that newline here doesnt mean that the - gets consumed
	-g=68.0
	
}

def doings() String{
	a = new Fass()
	a.z=9
	return "" + [a.z, a.f, a.g]
}

~~~~~
//##77. so, youve manged to wrap up a ref inside an object

from com.concurnas.lang.precompiled.RefHelper import getIntegerRefAsObject

def getObj() Object => 	getIntegerRefAsObject(8)  //this will make 8:

def doings() String{
	asObj = getObj()
	
	refasObj1IntRef  = asObj as int:
	refasObj1IntRef2  = asObj as int::
	
	return "" + refasObj1IntRef:: + "~" + refasObj1IntRef2:: + "=>" + (asObj is Integer:)
}

~~~~~
//##78. double check

def doings() String{
	x ::= 8 
	a2 String = ""+x::get():get()
	
	return a2
}

~~~~~
//##79. double check 2

def doings() String{
	ref1 := 5
	ref2 int:= ref1: //different code path

	z = ref1 &== ref2
	
	return "" +  ref2 + " " + z //should be same
}

~~~~~
//##80. to number is ok

a Object = 8 as Number::
b Object = 8 as Number:

def doings() String{
	return "" + a + "~" + b
}

~~~~~
//##81. module level fields

y int:: = 8
z ::= 6

def doings() String{
	y = 5
	z = 5
	
	return "Hello world" + [y,z::]
}

~~~~~
//##81. clsas level fields

class K{
	//public y : = 8
	public y ::= 8
	public var y2 ::= 8 
	public z int::= 6
}

//above as classdef args

def doings() String{
	k = new K()
	k.y = 5
	k.y2 = 5
	k.z = 5
	
	return "Hello world"  + [k.y, k.y2, k.z::]
}


~~~~~
//##81.a class fields

class Ksdfdsf{
	public y int::
	public z int::
	
	this(ay int, az int ){
		this.y=ay;
		this.z=az;
	}
}

def doings() String{
	k = new Ksdfdsf(12, 13)
	return "Hello world"  + [k\.y, k\.z::]
}

~~~~~
//##81.b class fields more

class Klass{
	public ~y int::
	public ~z String::
	
	this(ay int::, z String){ 
		y=ay;
		this.z=z
	}
	
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
}

class Glass2(public ~y int::, public ~z String:: )  { }

class Fass( public ~z :: )  { }


def doings() String{
	k = new Klass(12, "mate")
	g = new Glass2(12, "mate")
	f = new Fass(  "mate")
	
	a= ""  + [k\.y, k\.z, k.y, k.z] + \ 
			"\n" + [g\.y, g\.z, g.y, g.z] + \ 
			"\n" + [f.z]
	b = ""  + [k\.y, k\.z, k.y, k.z::] + \ 
			"\n" + [g\.y, g\.z, g.y, g.z::] + \ 
			"\n" + [f.z::]//naugthy double test, this lot gets upcast
	return a + "~" +b 
}

~~~~~
//##81.a module field correct behavour - simple case


def doings() String{
	z String:: = "initial"
	z2 String:: = "initial2"
	anotherRef String::= "newValue"
	
	asVal = z
	asVal2 = z2
	
	refToPrev ::= z //copy pointer to ref
	refToPrev2 ::= z2
			
	z = anotherRef //replace VALUE only
	z2 ::= anotherRef //replace whole REF:
	
	//there are better tests later which explore this concept
	anotherRef = "newValue2"
	
		
	return "" + [""+z, ""+z2] +  \ 
		   "\n" + [""+asVal, "" + asVal2] + \ 
		   "\n" + [ ""  + refToPrev::, "" + refToPrev2]
}


~~~~~
//##81.1.a module field correct behavour

def doings1() String{
	z :: ="initial"

	asVal = z
	refToPrev ::= z
	z = ("newValue")
	return "" + [""+asVal, ""  + refToPrev:: , "" + z]
}

def doings2() String{
	z :: ="initial"

	asVal = z
	refToPrev ::= z
	z ::= "newValue" //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev:: , "" + z]
}

def doings3() String{
	z :: ="initial"

	asVal = z
	refToPrev ::= z
	z = "newValue":: //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + z]
}

def doings3b() String{
	z :: ="initial"

	asVal = z
	refToPrev ::= z
	g = "newValue":
	z = g //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + z]
}

def doings4() String{
	z :: ="initial"

	asVal = z
	refToPrev ::= z
	
	anotherRef = "newValue":
	z ::= anotherRef //replace ref
	
	anotherRef = "more stuff"
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + z, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##81.1.b module field correct behavour - with int

def doings1() String{
	z :: = 1

	asVal = z
	refToPrev ::= z
	z = (2)
	return "" + [""+asVal, ""  + refToPrev:: , "" + z]
}

def doings2() String{
	z :: =1

	asVal = z
	refToPrev ::= z
	z ::= 2 //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev:: , "" + z]
}

def doings3() String{
	z :: =1

	asVal = z
	refToPrev ::= z
	z = 2:: //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + z]
}

def doings3b() String{
	z :: =1

	asVal = z
	refToPrev ::= z
	g = 2:
	z = g:: //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + z]
}

def doings4() String{
	z :: =1

	asVal = z
	refToPrev ::= z
	
	anotherRef = 2:
	z ::= anotherRef //replace ref
	
	anotherRef = 3
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + z, "" + anotherRef]
}

def doings() String{
	return "" + doings1() + "\n" + doings2() + "\n" + doings3() + "\n" + doings3b() + "\n" + doings4()
}



~~~~~
//##81.1 module field correct behavour - as mod

z1 :: ="initial"
z2 :: ="initial"
z3 :: ="initial"
z4 :: ="initial"


def doings1() String{

	asVal = z1
	refToPrev ::= z1
	z1 = ("newValue")
	return "" + [""+asVal, ""  + refToPrev:: , "" + z1]
}

def doings2() String{

	asVal = z2
	refToPrev ::= z2
	z2 ::= "newValue" //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev:: , "" + z2]
}

def doings3() String{

	asVal = z3
	refToPrev ::= z3
	z3 = "newValue":: //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + z3]
}

def doings3b() String{

	asVal = z3
	refToPrev ::= z3
	g = "newValue":
	z3 = g //z takes value from rhs ref, but not override
	//u must use : for that
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + z3]
}

def doings4() String{

	asVal = z4
	refToPrev ::= z4
	
	anotherRef = "newValue":
	z4 ::= anotherRef //replace ref
	
	anotherRef = "more stuff"
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + z4, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##81.2 module field correct behavour - as mod int
z1 :: =1
z2 :: =1
z3 :: =1
z4 :: =1


def doings1() String{

	asVal = z1
	refToPrev ::= z1
	z1 = (2)
	return "" + [""+asVal, ""  + refToPrev:: , "" + z1]
}

def doings2() String{

	asVal = z2
	refToPrev ::= z2
	z2 ::= 2 //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev:: , "" + z2]
}

def doings3() String{

	asVal = z3
	refToPrev ::= z3
	z3 = 2:: //z takes value from rhs ref, but not override
	//u must use :: for that
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + z3]
}

def doings3b() String{

	asVal = z3
	refToPrev ::= z3
	g = 2:
	z3 = g //z takes value from rhs ref, but not override
	//u must use :: for that
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + z3]
}

def doings4() String{

	asVal = z4
	refToPrev ::= z4
	
	anotherRef = (2:):
	z4 ::= anotherRef //replace ref
	
	anotherRef = 3
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + z4, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##81. sneak in double check

def doings() String{
	z = ("newValue"): //locked as ref:
	z2 = ("newValue"): as String:: //also locked as ref
	
	return "" + z: + " " + z2::
}


~~~~~
//##81.1 as module fields in clinit

doings1 ="fail"
doings2 ="fail"
doings3 ="fail"
doings3b ="fail"
doings4 ="fail"

{
	z1 :: ="initial"
	
	asVal = z1
	refToPrev ::= z1
	z1 = ("newValue")
	doings1 = "" + [""+asVal, ""  + refToPrev:: , "" + z1]
}

{
	z2 :: ="initial"
	
	asVal = z2
	refToPrev ::= z2
	z2 ::= "newValue" //this is a new ref
		 
	doings2 = "" + [""+asVal, ""  + refToPrev:: , "" + z2]
}

{
	z3 :: ="initial"
	
	asVal = z3
	refToPrev ::= z3
	z3 = "newValue":: //z takes value from rhs ref, but not override
	//u must use :: for that
		
	doings3 = "" + [""+asVal, ""  + refToPrev:: , "" + z3]
}

{
	z3b :: ="initial"
	
	asVal = z3b
	refToPrev ::= z3b
	g = "newValue":
	z3b = g //z takes value from rhs ref, but not override
	//u must use :: for that
		
	doings3b = "" + [""+asVal, ""  + refToPrev:: , "" + z3b]
}

{
	z4 :: ="initial"

	asVal = z4
	refToPrev ::= z4
	
	anotherRef = "newValue":
	z4 ::= anotherRef //replace ref
	
	anotherRef = "more stuff"
		
	doings4 = "" + [""+asVal, ""  + refToPrev:: , "" + z4, "" + anotherRef]
}

def doings() String{
	return "" + doings1 \ 
			+ "\n" + doings2 \ 
			+ "\n" + doings3 \ 
			+ "\n" + doings3b \ 
			+ "\n" + doings4
}

~~~~~
//##81.2 as module fields in clinit - as int

doings1 ="fail"
doings2 ="fail"
doings3 ="fail"
doings3b ="fail"
doings4 ="fail"

{
	z1 :: =1
	
	asVal = z1
	refToPrev ::= z1
	z1 = (2)
	doings1 = "" + [""+asVal, ""  + refToPrev:: , "" + z1]
}

{
	z2 :: =1
	
	asVal = z2
	refToPrev ::= z2
	z2 ::= 2 //this is a new ref
		 
	doings2 = "" + [""+asVal, ""  + refToPrev:: , "" + z2]
}

{
	z3 :: =1
	
	asVal = z3
	refToPrev ::= z3
	z3 = 2:: //z takes value from rhs ref, but not override
	//u must use :: for that
		
	doings3 = "" + [""+asVal, ""  + refToPrev:: , "" + z3]
}

{
	z3b :: =1
	
	asVal = z3b
	refToPrev ::= z3b
	g= 2:
	z3b =g //z takes value from rhs ref, but not override
	//u must use :: for that
		
	doings3b = "" + [""+asVal, ""  + refToPrev:: , "" + z3b]
}

{
	z4 :: =1

	asVal = z4
	refToPrev ::= z4
	
	anotherRef = 2:
	z4 ::= anotherRef //replace ref
	
	anotherRef = 3
		
	doings4 = "" + [""+asVal, ""  + refToPrev:: , "" + z4, "" + anotherRef]
}

def doings() String{
	return "" + doings1 \ 
			+ "\n" + doings2 \ 
			+ "\n" + doings3 \ 
			+ "\n" + doings3b \ 
			+ "\n" + doings4
}

~~~~~
//##81.2 as class fields direct access - ext

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 :: ="initial"
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev ::= mycls.z1
	mycls.z1 = ("newValue")
	return "" + [""+asVal, ""  + refToPrev:: , "" + mycls.z1::]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev ::= mycls.z1
	mycls.z1 ::= "newValue" //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev:: , "" + mycls.z1::]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev ::= mycls.z1
	mycls.z1 = "newValue":: //z takes value from rhs ref, but not override - u must use :: for that
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + mycls.z1::]
}

def doings3b() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev ::= mycls.z1
	g="newValue":
	mycls.z1 = g //z takes value from rhs ref, but not override - u must use :: for that
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + mycls.z1::]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev ::= mycls.z1
	
	anotherRef = "newValue":
	mycls.z1 ::= anotherRef //replace ref
	
	anotherRef = "more stuff"
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + mycls.z1::, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##81.2.b as class fields direct access - ext as int

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 :: =1
}

def doings1() String{
	mycls = new MyCls()
	
	asVal = mycls.z1
	refToPrev ::= mycls.z1
	mycls.z1 = 2
	return "" + [""+asVal, ""  + refToPrev:: , "" + mycls.z1::]
}

def doings2() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev ::= mycls.z1
	mycls.z1 ::= 2 //this is a new ref
		 
	return "" + [""+asVal, ""  + refToPrev:: , "" + mycls.z1::]
}

def doings3() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev ::= mycls.z1
	mycls.z1 = 2:: //z takes value from rhs ref, but not override - u must use :: for that
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + mycls.z1::]
}

def doings3b() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev ::= mycls.z1
	g = 2:
	mycls.z1 = g //z takes value from rhs ref, but not override - u must use :: for that
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + mycls.z1::]
}

def doings4() String{
	mycls = new MyCls()

	asVal = mycls.z1
	refToPrev ::= mycls.z1
	
	anotherRef = 2:
	mycls.z1 ::= anotherRef //replace ref
	
	anotherRef = 3
		
	return "" + [""+asVal, ""  + refToPrev:: , "" + mycls.z1::, "" + anotherRef]
}

def doings() String{
	return "" + doings1() \ 
			+ "\n" + doings2() \ 
			+ "\n" + doings3() \ 
			+ "\n" + doings3b() \ 
			+ "\n" + doings4()
}

~~~~~
//##81.3 as class fields direct access - internal

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 :: ="initial"
		
	def doings1() String{
		asVal = this.z1
		refToPrev ::= this.z1
		this.z1 = ("newValue")
		return "" + [""+asVal, ""  + refToPrev:: , "" + this.z1::]
	}
	
	def doings2() String{
		asVal = this.z1
		refToPrev ::= this.z1
		this.z1 ::= "newValue" //this is a new ref
			 
		return "" + [""+asVal, ""  + refToPrev:: , "" + this.z1::]
	}
	
	def doings3() String{
		asVal = this.z1
		refToPrev ::= this.z1
		this.z1 = "newValue":: //z takes value from rhs ref, but not override - u must use :: for that
			
		return "" + [""+asVal, ""  + refToPrev:: , "" + this.z1::]
	}
	
	def doings3b() String{
		asVal = this.z1
		refToPrev ::= this.z1
		g = "newValue"::
		this.z1 = g //z takes value from rhs ref, but not override - u must use :: for that
			
		return "" + [""+asVal, ""  + refToPrev:: , "" + this.z1::]
	}
	
	def doings4() String{
		asVal = this.z1
		refToPrev ::= this.z1
		
		anotherRef = "newValue":
		this.z1 ::= anotherRef //replace ref
		
		anotherRef = "more stuff"
			
		return "" + [""+asVal, ""  + refToPrev:: , "" + this.z1::, "" + anotherRef]
	}
}

def doings() String{
	return "" + new MyCls().doings1() \ 
			+ "\n" + new MyCls().doings2() \ 
			+ "\n" + new MyCls().doings3() \ 
			+ "\n" + new MyCls().doings3b() \ 
			+ "\n" + new MyCls().doings4()
}

~~~~~
//##81.3.b as class fields direct access - internal - int

class MyCls{
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public z1 :: =1
		
	def doings1() String{
		asVal = this.z1
		refToPrev ::= this.z1
		this.z1 = (2)
		return "" + [""+asVal, ""  + refToPrev:: , "" + this.z1::]
	}
	
	def doings2() String{
		asVal = this.z1
		refToPrev ::= this.z1
		this.z1 ::= 2 //this is a new ref
			 
		return "" + [""+asVal, ""  + refToPrev:: , "" + this.z1::]
	}
	
	def doings3() String{
		asVal = this.z1
		refToPrev ::= this.z1
		this.z1 = 2:: //z takes value from rhs ref, but not override - u must use :: for that
			
		return "" + [""+asVal, ""  + refToPrev:: , "" + this.z1::]
	}
	
	def doings3b() String{
		asVal = this.z1
		refToPrev ::= this.z1
		g= 2:
		this.z1 =g //z takes value from rhs ref, but not override - u must use :: for that
			
		return "" + [""+asVal, ""  + refToPrev:: , "" + this.z1::]
	}
	
	def doings4() String{
		asVal = this.z1
		refToPrev ::= this.z1
		
		anotherRef = 2:
		this.z1 ::= anotherRef //replace ref
		
		anotherRef = 3
			
		return "" + [""+asVal, ""  + refToPrev:: , "" + this.z1::, "" + anotherRef]
	}
}

def doings() String{
	return "" + new MyCls().doings1() \ 
			+ "\n" + new MyCls().doings2() \ 
			+ "\n" + new MyCls().doings3() \ 
			+ "\n" + new MyCls().doings3b() \ 
			+ "\n" + new MyCls().doings4()
}

~~~~~
//##82. overwrite n level ref - module
z int:: =1
z2 int:: =1

def doings() String{
	a = 2: 
	
	z = a //extracts value and sets
	z2 ::= a //overwrites ref
	
	return "" + z + " " + (z: &<> a: ) + "\n" \
			  + z2 + " " + (z2: &== a: ) 
}

~~~~~
//##82.b overwrite n level ref - local


def doings() String{
	z int:: =1
	z2 int:: =1

	a = 2: 
	
	z = a //extracts value and sets
	z2 ::= a //overwrites ref
	
	return "" + z + " " + (z: &<> a: ) + "\n" \
			  + z2 + " " + (z2: &== a: ) 
}

~~~~~
//##82.CC overwrite n level ref - sneak this in here

class MyClass{
	public z2 int:: =1

}

m=new MyClass()
a = 2: 

def doings() String{
	
	m.z2 ::= a //overwrites ref mostly sort of
	
	return "" + m.z2 + " " + (m.z2: &== a: )
}

~~~~~
//##82.c overwrite n level ref - class var

class MyClass{
	public z int:: =1
	public z2 int:: =1

}

def doings() String{
	m=new MyClass()
	
	a = 2: 
	
	m.z = a //extracts value and sets
	m.z2 ::= a //overwrites ref
	
	return "" + m.z + " " + (m.z: &<> a: ) + "\n" \
			  + m.z2 + " " + (m.z2: &== a: ) 
}

~~~~~
//##82.d overwrite n level ref - class priv get set

class MyClass{
	~z int:: =1
	~z2 int:: =1

}

def doings() String{
	m=new MyClass()
	
	a = 2: 
	
	m.z = a //extracts value and sets
	m.z2 ::= a //overwrites ref
	
	return "" + m.z + " " + (m.z: &<> a: ) + "\n" \
			  + m.z2 + " " + (m.z2: &== a: ) 
}

~~~~~
//##83. simple inc

def getRef() int::{
	return 5::
}

def doings() String{
	a1 ::= 5;	 
	a2 ::= getRef();	 
	a3 ::= 5;	 
	a4 ::= 5;	 
	
	a1++
	++a2
	a3--
	--a4
	
	return "" + [a1::,a2::,a3::,a4::]
}

~~~~~
//##83.b simple inc - with assignment

def getRef() int::{
	return 5::
}

def doings() String{
	a1 ::= 5;	 
	a2 ::= getRef();	 
	a3 ::= 5;	 
	a4 ::= 5;	 
	
	b1 = a1++
	b2 = ++a2
	b3 = a3--
	b4 = --a4
	
	return "" + [a1::,a2::,a3::,a4::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

~~~~~
//##83.c simple inc - with assignment - copy refs correctly

def getRef() int::{
	return 5::
}

def doings() String{
	a1 ::= 5;	 
	a2 ::= getRef();	 
	a3 ::= 5;	 
	a4 ::= 5;	 
	
	b1 ::= a1++
	b2 ::= ++a2
	b3 ::= a3--
	b4 ::= --a4
	
	return "" + [a1::,a2::,a3::,a4::] + "[]" + [""+b1::,""+b2::,""+b3::,""+b4::] \ 
	  			+ "" + [a1::&==b1::, a2::&==b2::, a3::&==b3::, a4::&==b4::]
	//prefix ok, postfix not
}

~~~~~
//##83.d simple inc - in place operations

def getRef() int::{
	return 5::
}

def doings() String{
	a1 ::= 5;	 
	a2 ::= getRef();	 
	a3 ::= 5;	 
	
	a1 += 1
	a2 -= 1
	a3 *= 2
	
	return "" + [a1::,a2::,a3::] 
	//prefix ok, postfix not
}

~~~~~
//##83.d simple inc - string concatenation

def getRef() String::{
	return "5"::
}

def doings() String{
	a1 ::= getRef();	 
	a1 += "hi"
	
	return "" + a1
}


~~~~~
//##83. inc operations - module level

def getRef() int::{
	return 5::
}

def getRefStr() String::{
	return "5"::
}

d1a1 ::= 5;	 
d1a2 ::= getRef();	 
d1a3 ::= 5;	 
d1a4 ::= 5;	 

def doings1() String{
	d1a1++
	++d1a2
	d1a3--
	--d1a4
	
	return "" + [d1a1::,d1a2::,d1a3::,d1a4::]
}

d2a1 ::= 5;	 
d2a2 ::= getRef();	 
d2a3 ::= 5;	 
d2a4 ::= 5;	 

def doings2() String{
	
	b1 = d2a1++
	b2 = ++d2a2
	b3 = d2a3--
	b4 = --d2a4
	
	return "" + [d2a1::,d2a2::,d2a3::,d2a4::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}


d3a1 ::= 5;	 
d3a2 ::= getRef();	 
d3a3 ::= 5;	 
d3a4 ::= 5;

def doings3() String{	
	b1 ::= d3a1++
	b2 ::= ++d3a2
	b3 ::= d3a3--
	b4 ::= --d3a4
	
	return "" + [d3a1::,d3a2::,d3a3::,d3a4::] + "[]" + [""+b1::,""+b2::,""+b3::,""+b4::] \ 
	  			+ "" + [d3a1::&==b1::, d3a2::&==b2::, d3a3::&==b3::, d3a4::&==b4::]
	//prefix ok, postfix not
}

d4a1 ::= 5;	 
d4a2 ::= getRef();	 
d4a3 ::= 5;	 

def doings4() String{

	d4a1 += 1
	d4a2 -= 1
	d4a3 *= 2
	
	return "" + [d4a1::,d4a2::,d4a3::] 
	//prefix ok, postfix not
}

d5a1 ::= getRefStr();	

def doings5() String{ 
	d5a1 += "hi"
	
	return "" + d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##83. inc operations - class inner level

class Inner{
def getRef() int::{
	return 5::
}

def getRefStr() String::{
	return "5"::
}

d1a1 ::= 5;	 
d1a2 ::= getRef();	 
d1a3 ::= 5;	 
d1a4 ::= 5;	 

def doings1() String{
	d1a1++
	++d1a2
	d1a3--
	--d1a4
	
	return "" + [d1a1::,d1a2::,d1a3::,d1a4::]
}

d1a1t ::= 5;	 
d1a2t ::= getRef();	 
d1a3t ::= 5;	 
d1a4t ::= 5;	

def doings1this() String{
	this.d1a1t++
	++this.d1a2t
	this.d1a3t--
	--this.d1a4t
	
	return "" + [this.d1a1t::,this.d1a2t::,this.d1a3t::,this.d1a4t::]
}

d2a1 ::= 5;	 
d2a2 ::= getRef();	 
d2a3 ::= 5;	 
d2a4 ::= 5;	 

def doings2() String{
		
	b1 = d2a1++
	b2 = ++d2a2
	b3 = d2a3--
	b4 = --d2a4
	
	return "" + [d2a1::,d2a2::,d2a3::,d2a4::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}


d3a1 ::= 5;	 
d3a2 ::= getRef();	 
d3a3 ::= 5;	 
d3a4 ::= 5;

def doings3() String{	
	b1 ::= d3a1++
	b2 ::= ++d3a2
	b3 ::= d3a3--
	b4 ::= --d3a4
	
	return "" + [d3a1::,d3a2::,d3a3::,d3a4::] + "[]" + [""+b1::,""+b2::,""+b3::,""+b4::] \ 
	  			+ "" + [d3a1::&==b1::, d3a2::&==b2::, d3a3::&==b3::, d3a4::&==b4::]
	//prefix ok, postfix not
}

d4a1 ::= 5;	 
d4a2 ::= getRef();	 
d4a3 ::= 5;	 

def doings4() String{

	d4a1 += 1
	d4a2 -= 1
	d4a3 *= 2
	
	return "" + [d4a1::,d4a2::,d4a3::] 
	//prefix ok, postfix not
}

d5a1 ::= getRefStr();	

def doings5() String{ 
	d5a1 += "hi"
	
	return "" + d5a1
}



}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	i = new Inner()
	return join( [i.doings1()  i.doings2()  i.doings3()  i.doings4()  i.doings5()  i.doings1this()]  )
}


~~~~~
//##83. inc operations - class field

class Inner{
	def getRef() int::{
		return 5::
	}
	
	def getRefStr() String::{
		return "5"::
	}
	
	public d1a1 ::= 5;	 
	public d1a2 ::= getRef();	 
	public d1a3 ::= 5;	 
	public d1a4 ::= 5;	
	 
	public d2a1 ::= 5;	 
	public d2a2 ::= getRef();	 
	public d2a3 ::= 5;	 
	public d2a4 ::= 5;	 
			
	public d3a1 ::= 5;	 
	public d3a2 ::= getRef();	 
	public d3a3 ::= 5;	 
	public d3a4 ::= 5;

	
	public d4a1 ::= 5;	 
	public d4a2 ::= getRef();	 
	public d4a3 ::= 5;	 

	public d5a1 ::= getRefStr();	
}


child = new Inner()



def doings1() String{
	child.d1a1++
	++child.d1a2
	child.d1a3--
	--child.d1a4
	
	return "" + [child.d1a1::,child.d1a2::,child.d1a3::,child.d1a4::]
}

def doings2() String{
	b1 = child.d2a1++
	b2 = ++child.d2a2
	b3 = child.d2a3--
	b4 = --child.d2a4
	
	return "" + [child.d2a1::,child.d2a2::,child.d2a3::,child.d2a4::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{	
	b1 ::= child.d3a1++
	b2 ::= ++child.d3a2
	b3 ::= child.d3a3--
	b4 ::= --child.d3a4
	
	return "" + [child.d3a1::,child.d3a2::,child.d3a3::,child.d3a4::] + "[]" + [""+b1::,""+b2::,""+b3::,""+b4::] \ 
	  			+ "" + [child.d3a1::&==b1::, child.d3a2::&==b2::, child.d3a3::&==b3::, child.d3a4::&==b4::]
	//prefix ok, postfix not
}

def doings4() String{

	child.d4a1 += 1
	child.d4a2 -= 1
	child.d4a3 *= 2
	
	return "" + [child.d4a1::,child.d4a2::,child.d4a3::] 
	//prefix ok, postfix not
}


def doings5() String{ 
	child.d5a1 += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##83. inc operations - class field get set


class Inner{
	def getRef() int::{
		return 5::
	}
	
	def getRefStr() String::{
		return "5"::
	}
	
	~d1a1 ::= 5;	 
	~d1a2 ::= getRef();	 
	~d1a3 ::= 5;	 
	~d1a4 ::= 5;	
	 
	~d2a1 ::= 5;	 
	~d2a2 ::= getRef();	 
	~d2a3 ::= 5;	 
	~d2a4 ::= 5;	 
			
	~d3a1 ::= 5;	 
	~d3a2 ::= getRef();	 
	~d3a3 ::= 5;	 
	~d3a4 ::= 5;

	
	~d4a1 ::= 5;	 
	~d4a2 ::= getRef();	 
	~d4a3 ::= 5;	 

	~d5a1 ::= getRefStr();	
}


child = new Inner()



def doings1() String{
	child.d1a1++
	++child.d1a2
	child.d1a3--
	--child.d1a4
	
	return "" + [child.d1a1::,child.d1a2::,child.d1a3::,child.d1a4::]
}

def doings2() String{
	b1 = child.d2a1++
	b2 = ++child.d2a2
	b3 = child.d2a3--
	b4 = --child.d2a4
	
	return "" + [child.d2a1::,child.d2a2::,child.d2a3::,child.d2a4::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{	
	b1 ::= child.d3a1++
	b2 ::= ++child.d3a2
	b3 ::= child.d3a3--
	b4 ::= --child.d3a4
	
	return "" + [child.d3a1::,child.d3a2::,child.d3a3::,child.d3a4::] + "[]" + [""+b1::,""+b2::,""+b3::,""+b4::] \ 
	  			+ "" + [child.d3a1::&==b1::, child.d3a2::&==b2::, child.d3a3::&==b3::, child.d3a4::&==b4::]
	//prefix ok, postfix not
}

def doings4() String{

	child.d4a1 += 1
	child.d4a2 -= 1
	child.d4a3 *= 2
	
	return "" + [child.d4a1::,child.d4a2::,child.d4a3::] 
	//prefix ok, postfix not
}


def doings5() String{ 
	child.d5a1 += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##83. inc operations - class field get only


//get only
class Inner{
	def getRef() int::{
		return 5::
	}
	
	def getRefStr() String::{
		return "5"::
	}
	
	public -d1a1 ::= 5;	 
	public -d1a2 ::= getRef();	 
	public -d1a3 ::= 5;	 
	public -d1a4 ::= 5;	
	 
	public -d2a1 ::= 5;	 
	public -d2a2 ::= getRef();	 
	public -d2a3 ::= 5;	 
	public -d2a4 ::= 5;	 
			
	public -d3a1 ::= 5;	 
	public -d3a2 ::= getRef();	 
	public -d3a3 ::= 5;	 
	public -d3a4 ::= 5;

	
	public -d4a1 ::= 5;	 
	public -d4a2 ::= getRef();	 
	public -d4a3 ::= 5;	 

	public -d5a1 ::= getRefStr();	
}


child = new Inner()



def doings1() String{
	child.d1a1++
	++child.d1a2
	child.d1a3--
	--child.d1a4
	
	return "" + [child.d1a1::,child.d1a2::,child.d1a3::,child.d1a4::]
}

def doings2() String{
	b1 = child.d2a1++
	b2 = ++child.d2a2
	b3 = child.d2a3--
	b4 = --child.d2a4
	
	return "" + [child.d2a1::,child.d2a2::,child.d2a3::,child.d2a4::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{	
	b1 ::= child.d3a1++
	b2 ::= ++child.d3a2
	b3 ::= child.d3a3--
	b4 ::= --child.d3a4
	
	return "" + [child.d3a1::,child.d3a2::,child.d3a3::,child.d3a4::] + "[]" + [""+b1::,""+b2::,""+b3::,""+b4::] \ 
	  			+ "" + [child.d3a1::&==b1::, child.d3a2::&==b2::, child.d3a3::&==b3::, child.d3a4::&==b4::]
	//prefix ok, postfix not
}

def doings4() String{

	child.d4a1 += 1
	child.d4a2 -= 1
	child.d4a3 *= 2
	
	return "" + [child.d4a1::,child.d4a2::,child.d4a3::] 
	//prefix ok, postfix not
}


def doings5() String{ 
	child.d5a1 += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##83. inc operations - class field set only


//get only
class Inner{
	def getRef() int::{
		return 5::
	}
	
	def getRefStr() String::{
		return "5"::
	}
	
	public +d1a1 ::= 5;	 
	public +d1a2 ::= getRef();	 
	public +d1a3 ::= 5;	 
	public +d1a4 ::= 5;	
	 
	public +d2a1 ::= 5;	 
	public +d2a2 ::= getRef();	 
	public +d2a3 ::= 5;	 
	public +d2a4 ::= 5;	 
			
	public +d3a1 ::= 5;	 
	public +d3a2 ::= getRef();	 
	public +d3a3 ::= 5;	 
	public +d3a4 ::= 5;

	
	public +d4a1 ::= 5;	 
	public +d4a2 ::= getRef();	 
	public +d4a3 ::= 5;	 

	public +d5a1 ::= getRefStr();	
}


child = new Inner()


def doings1() String{
	child.d1a1++
	++child.d1a2
	child.d1a3--
	--child.d1a4
	
	return "" + [child.d1a1::,child.d1a2::,child.d1a3::,child.d1a4::]
}

def doings2() String{
	b1 = child.d2a1++
	b2 = ++child.d2a2
	b3 = child.d2a3--
	b4 = --child.d2a4
	
	return "" + [child.d2a1::,child.d2a2::,child.d2a3::,child.d2a4::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{	
	b1 ::= child.d3a1++
	b2 ::= ++child.d3a2
	b3 ::= child.d3a3--
	b4 ::= --child.d3a4
	
	return "" + [child.d3a1::,child.d3a2::,child.d3a3::,child.d3a4::] + "[]" + [""+b1::,""+b2::,""+b3::,""+b4::] \ 
	  			+ "" + [child.d3a1::&==b1::, child.d3a2::&==b2::, child.d3a3::&==b3::, child.d3a4::&==b4::]
	//prefix ok, postfix not
}

def doings4() String{

	child.d4a1 += 1
	child.d4a2 -= 1
	child.d4a3 *= 2
	
	return "" + [child.d4a1::,child.d4a2::,child.d4a3::] 
	//prefix ok, postfix not
}


def doings5() String{ 
	child.d5a1 += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##84. baby steps fix postfix ops - 1

class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d1a1 := 5;	
	~d1a2 := 5;	
}

child = new Inner()

def doings() String{
	f = child.d1a1++
	child.d1a2++

	return "" + [f, child.d1a1, child.d1a2]
}

~~~~~
//##84. baby steps fix postfix ops - 2

class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d1a1 := "5";	
}

child = new Inner()

def doings() String{
	f= child.d1a1++

	return "" + [f, child.d1a1]
}

~~~~~
//##84. baby steps fix postfix ops - 3


class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d1a1 ::= 5;	
}

child = new Inner()

def doings() String{
	f::=child.d1a1++
	f2:=child.d1a1++
	f3=child.d1a1++
	
	g::=++child.d1a1
	g2:=++child.d1a1
	g3=++child.d1a1
	
	child.d1a1++

	return "" + [""+f::, ""+f2:, ""+f3, ""+g::, ""+g2:, ""+g3, ""+child.d1a1]
}

~~~~~
//##84. baby steps fix postfix ops - 4

class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d1a1 := "5";	
}

child = new Inner()

def doings() String{
	f::=child.d1a1++
	f2:=child.d1a1++
	f3=child.d1a1++
	
	g::=++child.d1a1
	g2:=++child.d1a1
	g3=++child.d1a1
	
	child.d1a1++

	return "" + [""+f::, ""+f2:, ""+f3, ""+g::, ""+g2:, ""+g3, ""+child.d1a1]
}

~~~~~
//##84. baby steps fix postfix ops - 5


class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d1a1 ::= "5";	
}

child = new Inner()

def doings() String{
	f::=child.d1a1++
	f2:=child.d1a1++
	f3=child.d1a1++
	
	g::=++child.d1a1
	g2:=++child.d1a1
	g3=++child.d1a1
	
	child.d1a1++

	return "" + [""+f::, ""+f2:, ""+f3, ""+g::, ""+g2:, ""+g3, ""+child.d1a1]
}

~~~~~
//##85. int is subtype of int: on ret
def getRef() int:{
	x int: = 9;
	return 7
}

def doings() String {	
	return "" + getRef():
}

~~~~~
//##383. simple inc

def getRef() int:::{
	return 5:::
}

def doings() String{
	a1 int:::=7
	a12 int::: =61
	
	a2 :::= getRef();	 
	a3 :::= 5;	 
	a4 :::= 5;	 
	
	a1++
	++a2
	a3--
	--a4
	
	return "" + [a1:::, a12:::,a2:::,a3:::,a4:::]
}

~~~~~
//##383.b simple inc - with assignment

def getRef() int:::{
	return 5:::
}

def doings() String{
	a1 :::= 5;	 
	a2 :::= getRef();	 
	a3 :::= 5;	 
	a4 :::= 5;	 
	
	b1 = a1++
	b2 = ++a2
	b3 = a3--
	b4 = --a4
	
	return "" + [a1:::,a2:::,a3:::,a4:::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

~~~~~
//##383.c simple inc - with assignment - copy refs correctly

def getRef() int:::{
	return 5:::
}

def doings() String{
	a1 :::= 5;	 
	a2 :::= getRef();	 
	a3 :::= 5;	 
	a4 :::= 5;	 
	
	b1 :::= a1++
	b2 :::= ++a2
	b3 :::= a3--
	b4 :::= --a4
	
	return "" + [a1:::,a2:::,a3:::,a4:::] + "[]" + [""+b1:::,""+b2:::,""+b3:::,""+b4:::] \ 
	  			+ "" + [a1:::&==b1:::, a2:::&==b2:::, a3:::&==b3:::, a4:::&==b4:::]
	//prefix ok, postfix not
}

~~~~~
//##383.d simple inc - in place operations

def getRef() int:::{
	return 5:::
}

def doings() String{
	a1 :::= 5;	 
	a2 :::= getRef();	 
	a3 :::= 5;	 
	
	a1 += 1
	a2 -= 1
	a3 *= 2
	
	return "" + [a1:::,a2:::,a3:::] 
	//prefix ok, postfix not
}

~~~~~
//##383.d simple inc - string concatenation

def getRef() String:::{
	return "5":::
}

def doings() String{
	a1 :::= getRef();	 
	a1 += "hi"
	
	return "" + a1
}


~~~~~
//##383. inc operations - module level

def getRef() int:::{
	return 5:::
}

def getRefStr() String:::{
	return "5":::
}

d1a1 :::= 5;	 
d1a2 :::= getRef();	 
d1a3 :::= 5;	 
d1a4 :::= 5;	 

def doings1() String{
	d1a1++
	++d1a2
	d1a3--
	--d1a4
	
	return "" + [d1a1:::,d1a2:::,d1a3:::,d1a4:::]
}

d2a1 :::= 5;	 
d2a2 :::= getRef();	 
d2a3 :::= 5;	 
d2a4 :::= 5;	 

def doings2() String{
	
	b1 = d2a1++
	b2 = ++d2a2
	b3 = d2a3--
	b4 = --d2a4
	
	return "" + [d2a1:::,d2a2:::,d2a3:::,d2a4:::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}


d3a1 :::= 5;	 
d3a2 :::= getRef();	 
d3a3 :::= 5;	 
d3a4 :::= 5;

def doings3() String{	
	b1 :::= d3a1++
	b2 :::= ++d3a2
	b3 :::= d3a3--
	b4 :::= --d3a4
	
	return "" + [d3a1:::,d3a2:::,d3a3:::,d3a4:::] + "[]" + [""+b1:::,""+b2:::,""+b3:::,""+b4:::] \ 
	  			+ "" + [d3a1:::&==b1:::, d3a2:::&==b2:::, d3a3:::&==b3:::, d3a4:::&==b4:::]
	//prefix ok, postfix not
}

d4a1 :::= 5;	 
d4a2 :::= getRef();	 
d4a3 :::= 5;	 

def doings4() String{

	d4a1 += 1
	d4a2 -= 1
	d4a3 *= 2
	
	return "" + [d4a1:::,d4a2:::,d4a3:::] 
	//prefix ok, postfix not
}

d5a1 :::= getRefStr();	

def doings5() String{ 
	d5a1 += "hi"
	
	return "" + d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##383. inc operations - class inner level

class Inner{
def getRef() int:::{
	return 5:::
}

def getRefStr() String:::{
	return "5":::
}

d1a1 :::= 5;	 
d1a2 :::= getRef();	 
d1a3 :::= 5;	 
d1a4 :::= 5;	 

def doings1() String{
	d1a1++
	++d1a2
	d1a3--
	--d1a4
	
	return "" + [d1a1:::,d1a2:::,d1a3:::,d1a4:::]
}

d1a1t :::= 5;	 
d1a2t :::= getRef();	 
d1a3t :::= 5;	 
d1a4t :::= 5;	

def doings1this() String{
	this.d1a1t++
	++this.d1a2t
	this.d1a3t--
	--this.d1a4t
	
	return "" + [this.d1a1t:::,this.d1a2t:::,this.d1a3t:::,this.d1a4t:::]
}

d2a1 :::= 5;	 
d2a2 :::= getRef();	 
d2a3 :::= 5;	 
d2a4 :::= 5;	 

def doings2() String{
		
	b1 = d2a1++
	b2 = ++d2a2
	b3 = d2a3--
	b4 = --d2a4
	
	return "" + [d2a1:::,d2a2:::,d2a3:::,d2a4:::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}


d3a1 :::= 5;	 
d3a2 :::= getRef();	 
d3a3 :::= 5;	 
d3a4 :::= 5;

def doings3() String{	
	b1 :::= d3a1++
	b2 :::= ++d3a2
	b3 :::= d3a3--
	b4 :::= --d3a4
	
	return "" + [d3a1:::,d3a2:::,d3a3:::,d3a4:::] + "[]" + [""+b1:::,""+b2:::,""+b3:::,""+b4:::] \ 
	  			+ "" + [d3a1:::&==b1:::, d3a2:::&==b2:::, d3a3:::&==b3:::, d3a4:::&==b4:::]
	//prefix ok, postfix not
}

d4a1 :::= 5;	 
d4a2 :::= getRef();	 
d4a3 :::= 5;	 

def doings4() String{

	d4a1 += 1
	d4a2 -= 1
	d4a3 *= 2
	
	return "" + [d4a1:::,d4a2:::,d4a3:::] 
	//prefix ok, postfix not
}

d5a1 :::= getRefStr();	

def doings5() String{ 
	d5a1 += "hi"
	
	return "" + d5a1
}



}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	i = new Inner()
	return join( [i.doings1()  i.doings2()  i.doings3()  i.doings4()  i.doings5()  i.doings1this()]  )
}


~~~~~
//##383. inc operations - class field

class Inner{
	def getRef() int:::{
		return 5:::
	}
	
	def getRefStr() String:::{
		return "5":::
	}
	
	public d1a1 :::= 5;	 
	public d1a2 :::= getRef();	 
	public d1a3 :::= 5;	 
	public d1a4 :::= 5;	
	 
	public d2a1 :::= 5;	 
	public d2a2 :::= getRef();	 
	public d2a3 :::= 5;	 
	public d2a4 :::= 5;	 
			
	public d3a1 :::= 5;	 
	public d3a2 :::= getRef();	 
	public d3a3 :::= 5;	 
	public d3a4 :::= 5;

	
	public d4a1 :::= 5;	 
	public d4a2 :::= getRef();	 
	public d4a3 :::= 5;	 

	public d5a1 :::= getRefStr();	
}


child = new Inner()



def doings1() String{
	child.d1a1++
	++child.d1a2
	child.d1a3--
	--child.d1a4
	
	return "" + [child.d1a1:::,child.d1a2:::,child.d1a3:::,child.d1a4:::]
}

def doings2() String{
	b1 = child.d2a1++
	b2 = ++child.d2a2
	b3 = child.d2a3--
	b4 = --child.d2a4
	
	return "" + [child.d2a1:::,child.d2a2:::,child.d2a3:::,child.d2a4:::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{	
	b1 :::= child.d3a1++
	b2 :::= ++child.d3a2
	b3 :::= child.d3a3--
	b4 :::= --child.d3a4
	
	return "" + [child.d3a1:::,child.d3a2:::,child.d3a3:::,child.d3a4:::] + "[]" + [""+b1:::,""+b2:::,""+b3:::,""+b4:::] \ 
	  			+ "" + [child.d3a1:::&==b1:::, child.d3a2:::&==b2:::, child.d3a3:::&==b3:::, child.d3a4:::&==b4:::]
	//prefix ok, postfix not
}

def doings4() String{

	child.d4a1 += 1
	child.d4a2 -= 1
	child.d4a3 *= 2
	
	return "" + [child.d4a1:::,child.d4a2:::,child.d4a3:::] 
	//prefix ok, postfix not
}


def doings5() String{ 
	child.d5a1 += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##383. inc operations - class field get set


class Inner{
	def getRef() int:::{
		return 5:::
	}
	
	def getRefStr() String:::{
		return "5":::
	}
	
	~d1a1 :::= 5;	 
	~d1a2 :::= getRef();	 
	~d1a3 :::= 5;	 
	~d1a4 :::= 5;	
	 
	~d2a1 :::= 5;	 
	~d2a2 :::= getRef();	 
	~d2a3 :::= 5;	 
	~d2a4 :::= 5;	 
			
	~d3a1 :::= 5;	 
	~d3a2 :::= getRef();	 
	~d3a3 :::= 5;	 
	~d3a4 :::= 5;

	
	~d4a1 :::= 5;	 
	~d4a2 :::= getRef();	 
	~d4a3 :::= 5;	 

	~d5a1 :::= getRefStr();	
}


child = new Inner()



def doings1() String{
	child.d1a1++
	++child.d1a2
	child.d1a3--
	--child.d1a4
	
	return "" + [child.d1a1:::,child.d1a2:::,child.d1a3:::,child.d1a4:::]
}

def doings2() String{
	b1 = child.d2a1++
	b2 = ++child.d2a2
	b3 = child.d2a3--
	b4 = --child.d2a4
	
	return "" + [child.d2a1:::,child.d2a2:::,child.d2a3:::,child.d2a4:::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{	
	b1 :::= child.d3a1++
	b2 :::= ++child.d3a2
	b3 :::= child.d3a3--
	b4 :::= --child.d3a4
	
	return "" + [child.d3a1:::,child.d3a2:::,child.d3a3:::,child.d3a4:::] + "[]" + [""+b1:::,""+b2:::,""+b3:::,""+b4:::] \ 
	  			+ "" + [child.d3a1:::&==b1:::, child.d3a2:::&==b2:::, child.d3a3:::&==b3:::, child.d3a4:::&==b4:::]
	//prefix ok, postfix not
}

def doings4() String{

	child.d4a1 += 1
	child.d4a2 -= 1
	child.d4a3 *= 2
	
	return "" + [child.d4a1:::,child.d4a2:::,child.d4a3:::] 
	//prefix ok, postfix not
}


def doings5() String{ 
	child.d5a1 += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}


~~~~~
//##383. inc operations - class field get only


//get only
class Inner{
	def getRef() int:::{
		return 5:::
	}
	
	def getRefStr() String:::{
		return "5":::
	}
	
	public -d1a1 :::= 5;	 
	public -d1a2 :::= getRef();	 
	public -d1a3 :::= 5;	 
	public -d1a4 :::= 5;	
	 
	public -d2a1 :::= 5;	 
	public -d2a2 :::= getRef();	 
	public -d2a3 :::= 5;	 
	public -d2a4 :::= 5;	 
			
	public -d3a1 :::= 5;	 
	public -d3a2 :::= getRef();	 
	public -d3a3 :::= 5;	 
	public -d3a4 :::= 5;

	
	public -d4a1 :::= 5;	 
	public -d4a2 :::= getRef();	 
	public -d4a3 :::= 5;	 

	public -d5a1 :::= getRefStr();	
}


child = new Inner()



def doings1() String{
	child.d1a1++
	++child.d1a2
	child.d1a3--
	--child.d1a4
	
	return "" + [child.d1a1:::,child.d1a2:::,child.d1a3:::,child.d1a4:::]
}

def doings2() String{
	b1 = child.d2a1++
	b2 = ++child.d2a2
	b3 = child.d2a3--
	b4 = --child.d2a4
	
	return "" + [child.d2a1:::,child.d2a2:::,child.d2a3:::,child.d2a4:::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{	
	b1 :::= child.d3a1++
	b2 :::= ++child.d3a2
	b3 :::= child.d3a3--
	b4 :::= --child.d3a4
	
	return "" + [child.d3a1:::,child.d3a2:::,child.d3a3:::,child.d3a4:::] + "[]" + [""+b1:::,""+b2:::,""+b3:::,""+b4:::] \ 
	  			+ "" + [child.d3a1:::&==b1:::, child.d3a2:::&==b2:::, child.d3a3:::&==b3:::, child.d3a4:::&==b4:::]
	//prefix ok, postfix not
}

def doings4() String{

	child.d4a1 += 1
	child.d4a2 -= 1
	child.d4a3 *= 2
	
	return "" + [child.d4a1:::,child.d4a2:::,child.d4a3:::] 
	//prefix ok, postfix not
}


def doings5() String{ 
	child.d5a1 += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##383. inc operations - class field set only


//get only
class Inner{
	def getRef() int:::{
		return 5:::
	}
	
	def getRefStr() String:::{
		return "5":::
	}
	
	public +d1a1 :::= 5;	 
	public +d1a2 :::= getRef();	 
	public +d1a3 :::= 5;	 
	public +d1a4 :::= 5;	
	 
	public +d2a1 :::= 5;	 
	public +d2a2 :::= getRef();	 
	public +d2a3 :::= 5;	 
	public +d2a4 :::= 5;	 
			
	public +d3a1 :::= 5;	 
	public +d3a2 :::= getRef();	 
	public +d3a3 :::= 5;	 
	public +d3a4 :::= 5;

	
	public +d4a1 :::= 5;	 
	public +d4a2 :::= getRef();	 
	public +d4a3 :::= 5;	 

	public +d5a1 :::= getRefStr();	
}


child = new Inner()


def doings1() String{
	child.d1a1++
	++child.d1a2
	child.d1a3--
	--child.d1a4
	
	return "" + [child.d1a1:::,child.d1a2:::,child.d1a3:::,child.d1a4:::]
}

def doings2() String{
	b1 = child.d2a1++
	b2 = ++child.d2a2
	b3 = child.d2a3--
	b4 = --child.d2a4
	
	return "" + [child.d2a1:::,child.d2a2:::,child.d2a3:::,child.d2a4:::] + "[" + [""+b1,""+b2,""+b3,""+b4]
	//prefix ok, postfix not
}

def doings3() String{	
	b1 :::= child.d3a1++
	b2 :::= ++child.d3a2
	b3 :::= child.d3a3--
	b4 :::= --child.d3a4
	
	return "" + [child.d3a1:::,child.d3a2:::,child.d3a3:::,child.d3a4:::] + "[]" + [""+b1:::,""+b2:::,""+b3:::,""+b4:::] \ 
	  			+ "" + [child.d3a1:::&==b1:::, child.d3a2:::&==b2:::, child.d3a3:::&==b3:::, child.d3a4:::&==b4:::]
	//prefix ok, postfix not
}

def doings4() String{

	child.d4a1 += 1
	child.d4a2 -= 1
	child.d4a3 *= 2
	
	return "" + [child.d4a1:::,child.d4a2:::,child.d4a3:::] 
	//prefix ok, postfix not
}


def doings5() String{ 
	child.d5a1 += "hi"
	
	return "" + child.d5a1
}

def join(ass String[]) String {
	xxx = ""
	for(a in ass){
		xxx += a + "\n"
	}
	return xxx
}

def doings() String{
	
	return join( [doings1()  doings2()  doings3()  doings4()  doings5()]  )
}

~~~~~
//##384. baby steps fix postfix ops - 1

class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d1a1 := 5;	
	~d1a2 := 5;	
}

child = new Inner()

def doings() String{
	f = child.d1a1++
	child.d1a2++

	return "" + [f, child.d1a1, child.d1a2]
}

~~~~~
//##384. baby steps fix postfix ops - 2

class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d1a1 := "5";	
}

child = new Inner()

def doings() String{
	f= child.d1a1++

	return "" + [f, child.d1a1]
}

~~~~~
//##384. baby steps fix postfix ops - 3


class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d1a1 :::= 5;	
}

child = new Inner()

def doings() String{
	f:::=child.d1a1++
	f2:=child.d1a1++
	f3=child.d1a1++
	
	g:::=++child.d1a1
	g2:=++child.d1a1
	g3=++child.d1a1
	
	child.d1a1++

	return "" + [""+f:::, ""+f2:, ""+f3, ""+g:::, ""+g2:, ""+g3, ""+child.d1a1]
}

~~~~~
//##384. baby steps fix postfix ops - 4

class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d1a1 := "5";	
}

child = new Inner()

def doings() String{
	f:::=child.d1a1++
	f2:=child.d1a1++
	f3=child.d1a1++
	
	g:::=++child.d1a1
	g2:=++child.d1a1
	g3=++child.d1a1
	
	child.d1a1++

	return "" + [""+f:::, ""+f2:, ""+f3, ""+g:::, ""+g2:, ""+g3, ""+child.d1a1]
}

~~~~~
//##384. baby steps fix postfix ops - 5


class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d1a1 :::= "5";	
}

child = new Inner()

def doings() String{
	f:::=child.d1a1++
	f2:=child.d1a1++
	f3=child.d1a1++
	
	g:::=++child.d1a1
	g2:=++child.d1a1
	g3=++child.d1a1
	
	child.d1a1++

	return "" + [""+f:::, ""+f2:, ""+f3, ""+g:::, ""+g2:, ""+g3, ""+child.d1a1]
}

~~~~~
//##400. tidy - presever nested ref structure, dont replace

class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d2a1 ::= 5;	 
}

child = new Inner()

def doings() String{
	a ::= child.d2a1
	aid = System.identityHashCode(a::)
	child.d2a1++ //this operator must not replace the thingy
	bid = System.identityHashCode(a::)
	c ::= child.d2a1
	cid = System.identityHashCode(a::)
		
	return "" + [aid==bid, bid==cid, cid==aid]
}

~~~~~
//##400.b tidy - presever nested ref structure, dont replace

class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d2a1 ::= 5;	 
}

child = new Inner()

def doings() String{
	a ::= child.d2a1
	aid = System.identityHashCode(a::)
	b ::= child.d2a1++ //this operator must not replace the thingy
	bid = System.identityHashCode(a::)
	c ::= child.d2a1
	cid = System.identityHashCode(a::)
		
	return "" + [aid==bid, bid==cid, cid==aid]
}


~~~~~
//##401. tidy against all odds

from com.concurnas.lang.precompiled.TestHelperClasses import countRefLevels

class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d2a1 := 5;
	~d2a2 ::= 5;
	~d2a3 :::= 5;
}

child = new Inner()


def doings() String{
	d1 := child.d2a1++
	d2 ::= child.d2a2++
	d3 :::= child.d2a3++
		
	return ""  + ["" + d1:, "" + d2::, "" + d3:::, ""+ child.d2a1:, ""+ child.d2a2::,""+  child.d2a3:::]
}

~~~~~
//##401.b tidy against all odds - str

from com.concurnas.lang.precompiled.TestHelperClasses import countRefLevels

class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	~d2a1 := 5;
	~d2a2 ::= 5;
	~d2a3 :::= 5;
}

child = new Inner()


def doings() String{
	d1 := child.d2a1++
	d2 ::= child.d2a2++
	d3 :::= child.d2a3++
		
	return ""  + ["" + d1:, "" + d2::, "" + d3:::, ""+ child.d2a1:, ""+ child.d2a2::,""+  child.d2a3:::]
}


~~~~~
//##402. some more tidy of the monster

from com.concurnas.lang.precompiled.TestHelperClasses import countRefLevels

class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	public d2a1 int::: = 6;
	
	def cxxx ( xxx int:: )  {
      this.d2a1 :: = xxx ;//levels should match
    }
    
    def cxxx2 ( xxx int: )  {
      this.d2a1 :: = xxx ;//levels should match
    }
	
}

child = new Inner()

def doings() String{
	b4 = "" + child.d2a1:::
	child.cxxx(55)
	mow = "" + child.d2a1:::
	child.cxxx2(67)
	after = "" + child.d2a1:::
	
	return "" + [b4, mow, after]
}

~~~~~
//##403. some more tidy of the monster

def doings() String {
	aRef := 1:
	
	aRef2 int:
	aRef3 int:
	
	aRef2 = aRef//should unref this
	aRef3 := aRef//should not unref this
	
	return "" + [aRef: &== aRef2:,  aRef: &== aRef3: ]
}

~~~~~
//##404. some more tidy of the monster

def doings() String {
	obj := 1
	a = obj as Object
	b = obj: as Object
	
	return "" + [""+obj:, ""+a, "" + b] 
}

~~~~~
//##405. some more tidy of the monster

def doings() String {
	x1 int::= 1: as int:: ; 
	x2 = x1::get():get()
	return "" + x2
}

~~~~~
//##406. some more tidy of the monster

def doings() String{
	a := 8
	b  = (a):
	c  = (a:):

	return "" + [a,b,c]
}

~~~~~
//##407.mmonster - double ref level array extract

def doings() String{

	sdf = [ 0::, 3::]::
	sdf[0]  = 9
	
	return "" + sdf
}

~~~~~
//##408. dunno what this test proves

class Inner{
	def getRef() int:{
		return 5:
	}
	 
	public d1a2 int::= 5;
	public d1a3 int::= getRef();
}


def doings() String{
	i = new Inner()
		
	return "" + [i.d1a2, i.d1a3]
}

~~~~~
//##408.b dunno what this test proves

class AClass{
	~field2 := [1,2,3,4,5,6,7,8,9,10]:
}

def doings() String{
	i = new AClass()
		
	return "" + [i.field2]
}

~~~~~
//##408.c dunno what this test proves

def doings() String{
	refAr = [1,2,3,4,5,6,7,8,9,10]:
	
	item = refAr[0]
	
	return "" + [item, refAr]
}

~~~~~
//##409. explainable behavour

def doings() String{
	//2nd entry upcast to ref
	//first entry also upcast to ref because it starts off as a string... so then u get a ref of a string whcih is formatted to appear as a ref of a ref
	x = a[""+ (5): , 23 , (456):]//um, its an object list:
	return "" + x + "=>" + (x is Object:[]) + "" + [x[0]:get() is String, x[1]]
}

~~~~~
//##410. check ref setting

//in these tests we wish to avoid accidentally creating a new ref (disentagling the ref)

def asLocal() String{
	ref int:= 9
	ref2 int: =ref
	ref2b int: =ref:
	ref3 : = ref //assign esisting rhs locked as ref
	ref3b : = ref: //assign esisting rhs locked as ref
		
	x1 = System.identityHashCode(ref:)
	x2 = System.identityHashCode(ref2:)
	x2b = System.identityHashCode(ref2b:)
	x3 = System.identityHashCode(ref3:)
	x3b = System.identityHashCode(ref3b:)
	
	return "" + [x1 == x2 and x1 ==x3 and x1 ==x2b and x1 ==x3b]
}

class FieldHolder {
	public ref int:
}

def asField() String{
	h1 = new FieldHolder()
	h2 = new FieldHolder()
	h3 = new FieldHolder()
	ref int: =9 
	h1.ref : =  ref
	h2.ref : = ref:
	h3.ref : = h1.ref //assign esisting rhs locked as ref
		
	x1 = System.identityHashCode(h1.ref:)
	x2 = System.identityHashCode(h2.ref:)
	x3 = System.identityHashCode(h3.ref:)
	
	return "" + [x1 == x2 and x1 ==x3]
}

class FieldHolderSAndG {
	private ~ref int:
}

def asFieldVSetGet() String{
	h1 = new FieldHolderSAndG()
	h2 = new FieldHolderSAndG()
	h3 = new FieldHolderSAndG()
	ref int: =9 
	h1.ref :=  ref
	h2.ref : = ref
	h3.ref : = h1.ref //assign esisting rhs locked as ref
		
	x = System.identityHashCode(ref:)
	x1 = System.identityHashCode(h1.ref:)
	x2 = System.identityHashCode(h2.ref:)
	x3 = System.identityHashCode(h3.ref:)
	
	return "" + [x==x1 and x1 == x2 and x1 ==x3]
}

class asConstruCls () {
	private -ref int:
	this(x int:){
		ref := x 
	}
}

def asConstru() String{
	ref int: =9 

	h1 = new asConstruCls(ref)
	h2 = new asConstruCls(ref:)
	h3 = new asConstruCls(h1.ref)
	h4 = new asConstruCls(h1.ref:)
		
	x = System.identityHashCode(ref:)
	x1 = System.identityHashCode(h1.ref:)
	x2 = System.identityHashCode(h2.ref:)
	x3 = System.identityHashCode(h3.ref:)
	x4 = System.identityHashCode(h4.ref:)
	
	return "" + [x==x1 and x1 == x2 and x1 ==x3 and x1 ==x4]
}

class AsConstruAutoCls (private -ref int:) {
}

def asConstruAuto() String{
	ref int: =9 

	h1 = new AsConstruAutoCls(ref)
	h2 = new AsConstruAutoCls(ref:)
	h3 = new AsConstruAutoCls(h1.ref)
	h4 = new AsConstruAutoCls(h1.ref:)
		
	x = System.identityHashCode(ref:)
	x1 = System.identityHashCode(h1.ref:)
	x2 = System.identityHashCode(h2.ref:)
	x3 = System.identityHashCode(h3.ref:)
	x4 = System.identityHashCode(h4.ref:)
	
	//return "" + [x, x1, x2, x3]
	return "" + [x==x1 and x1 == x2 and x1 ==x3 and x1 ==x4]
}


class AsConstruAutoClsDI (public ref int:) {
}

def asConstruAutoDI() String{
	ref int: =9 

	h1 = new AsConstruAutoClsDI(ref)
	h2 = new AsConstruAutoClsDI(ref:)
	h3 = new AsConstruAutoClsDI(h1.ref)
	h4 = new AsConstruAutoClsDI(h1.ref:)
		
	x = System.identityHashCode(ref:)
	x1 = System.identityHashCode(h1.ref:)
	x2 = System.identityHashCode(h2.ref:)
	x3 = System.identityHashCode(h3.ref:)
	x4 = System.identityHashCode(h4.ref:)
	
	//return "" + [x, x1, x2, x3]
	return "" + [x==x1 and x1 == x2 and x1 ==x3 and x1 ==x4]
}

def doings() String{
	dudes = [asLocal&(), asField&(), asFieldVSetGet&(), asConstru&(), asConstruAuto&(), asConstruAutoDI&() ]

	return "" + for(x in dudes){ x() }
}


~~~~~
//##411. dunno what this proves

def doings() String{
	ref := 9
	ref2 : =9
	ref2 := ref //assign esisting rhs locked as ref
	cpy = ref:
	x = System.identityHashCode(ref:)
	x2 = System.identityHashCode(ref2:)
	c = System.identityHashCode(cpy:)
	
	return "" + [ref, ref2, x == x2, x == c]
}

~~~~~
//##412. remove uneeded dup


def doings() String{
	obj Object: //no extra dup on creation required for this (used to blow up before)
	
	try{
		obj = "hi" 
	} catch(e){
	}
	
	return "" + obj
}


~~~~~
//##413. dont throw exception on null instsanceof check

def doings() String{
	a double: = 9
	
	o Object = a as Object //o is now null - as we extract out the ref contentx (use a: to keep it as a ref)
	z = (o is Double)
	
	return "" + (z, (o as double:):get())
}

~~~~~
//##413. dont accidentally create a new ref

def doings() String{//i dunno about identityHashCode tho... probably good enough
	z Object: = 9
	
	o = z: as Object
	
	o2  = o as Object:	//int:
	o3 Object: = o
	
	
	check =  System.identityHashCode(o2:) == System.identityHashCode(z:) //you cannot even compare these two lol
	check2 =  System.identityHashCode(o3:) == System.identityHashCode(z:) //no crazy copying going on
	
	return "" +  [check, check2]
}

~~~~~
//##414. cast edge cases

from java.util import HashMap

def doings() String{
	
	z  = (new HashMap<String, Integer>()):
	
	//extracted in first, kept as ref in 2nd
	return "" + [ (z as Object) is HashMap<String, Integer>:, (z as Object) is HashMap<String, Integer>:,\
				  (z: as Object) is HashMap<String, Integer>:, (z: as Object) is not HashMap<String, String>:
	  ]
}

~~~~~
//##415.a - taken from scope and type checks - 42.b no refied types thus following cast IS possible

from java.util import HashMap

z  = (new HashMap<String, Integer>()):
o = (z: as Object) //extracted

def doings() String{
	f = o is HashMap<String, Integer>: //should return true at runtime (go via ref checker as rhs is a ref)
	f2 = o is not HashMap<String, String>: //should return false at runtime (go via ref checker as rhs is a ref)
			
	return "" + [f, f2]
}

~~~~~
//##415.b - taken from scope and type checks - 42.c no refied types thus following cast IS possible - null not ref

from java.util import HashMap

o = null

def doings() String{
	f = o is HashMap<String, Integer>: //should return true at runtime (go via ref checker as rhs is a ref)
	f2 = o is not HashMap<String, String>: //should return false at runtime (go via ref checker as rhs is a ref)
			
	return "" + [f, f2]
}

~~~~~
//##415.c - taken from scope and type checks - 42.c no refied types thus following cast IS possible - null not ref MORE

from java.util import HashMap

o = (null): //double check created as Object:
o2 := (null): 
o3 Object:= (null): 

def doings() String{
	f = (o: as Object) is HashMap<String, Integer>: //should return true at runtime (go via ref checker as rhs is a ref)
	f2 = (o: as Object) is not HashMap<String, String>: //should return false at runtime (go via ref checker as rhs is a ref)
			
	f3 = (o2: as Object)  is HashMap<String, Integer>: //should return true at runtime (go via ref checker as rhs is a ref)
	f4 = (o2: as Object)  is not HashMap<String, String>: //should return false at runtime (go via ref checker as rhs is a ref)
			
	f5 = (o3: as Object)  is HashMap<String, Integer>: //should return true at runtime (go via ref checker as rhs is a ref)
	f6 = (o3: as Object)  is not HashMap<String, String>: //should return false at runtime (go via ref checker as rhs is a ref)
			
	return "" + [f, f2, f3, f4, f5, f6]
}

~~~~~
//##416. exception cases

from java.util import HashMap

def doings() String{
	z  = (new HashMap<String, Integer>()):
	
	//thing being as-ed is a ref already
	asObj = z as HashMap<String, Integer>:
	
	failExpect1 = "fail"
	try{
		asdasd = (asObj: as Object) as Integer: //fail as incompatbile, throw exception
	}//exception holds the stack trace
	catch(e Exception){
		failExpect1 = "" + e
	}
	
	failExpect2 = "fail"
	try{
		asdasd = (asObj as Object) as Integer: //fail as incompatbile, throw exception
	}
	catch(e Exception){
		failExpect2 = "" + e
	}
			
	return "" + asObj + "\n" + failExpect1 + "\n" + failExpect2
}

~~~~~
//##417a. from sac - 43. cast checks -sac - bc

def takesO(arg Object:) {}

def doings() String{
	a := 9
	//all these should be ok:
	f1 = "ok"
	f2 = "ok"
	f3 = "ok"
	f4 = "ok"
	try{ o Object: = (a: as Object) } catch(e) { f1 = e.getMessage() } //fail
	try{ o = (a: as Object) as Object: } catch(e) { f2 = e.getMessage() } //fail
	try{ takesO((a: as Object)) } catch(e) { f3 = e.getMessage() } //fail
	
	try{ o Object:: = (a: as Object) } catch(e) { f4 = e.getMessage() } //fail
	o Integer: = (a: as Object) as Integer: //ok:
	
	return "" + for(x in [f1, f2, f3, f4]){ "\n" + x } + "\n==>" + ""+ o
}

~~~~~
//##418. double check break at mod vs local var level
class C{
	public ref3 :=5
}

ref1 := 5

def doings() String{
	c = new C()

	ref2 := 5
	
	o Object = ref1: as Object
	o2 Object = ref2: as Object
	o3 Object = c.ref3: as Object
	
	return ""  + [o is Integer:, o2 is Integer:, o3 is Integer:]
}

~~~~~
//##419. double check ref creation type

z Object:: = 9

def doings() String{
	f = z is Object: //its an object now an integer
	return "" +  f
}

~~~~~
//##420. ensure generic type chosen correctly on refs

a := 4.0
b:= 4

def doings() String{
	z = [a: b:] is Number:[]//just an object array not Number:[] // cos component types are not themselves object:
	z2 = [a: 4] is Number:[]//just an object array not Object:[] // cos component types are not themselves object:
	z3 = [a: a:] is int:[]//just an object array not Object:[] // cos component types are not themselves object:
	
	return "" + [z, z2] + [a:,4]
}

~~~~~
//##421. avoid accidental double ref
//only way i can think of of someone engineering this break - break at runtime
def doings() String{
	b1 = "ok"
	b2 = "ok"

	z=try{	a Object: = ("empty":): as Object; a} catch(e) { b1 = e.getMessage(); null } 
	z2 = try{	b Object:: = ("empty":): as Object; b } catch(e) { b2 = e.getMessage(); null } 
	
	
	return "" + b1 + "\n" + b2 + " -> " + [z, z2]
}

~~~~~
//##422. dont blow up when casting ref on null obj

class Fass( public ~z Integer:? )  { 
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
}


def doings() String{
	f2 = new Fass(  null )

	 return "" + f2.z: + "->" + f2.z
}


~~~~~
//##423. null ref
def ttt() => true
def xx(a String:) boolean {
	return (a: as Object) is String:
}

def doings() String{
	// 
	ok1 String:=(null):
	ok2 String:=(null): as String:
	ok3 String:=(null:) if ttt() else (null):
	ok4 String:=("":) if ttt() else (null):

	return "" + [xx(null:), ok1 is String:, ok2 is String:, ok3 is String:, ok4 is String:] //expect true, the null ref is created as Str:
}

~~~~~
//##424. null ref part 2

def doings() String{
	
	orig := null:
	orig := (null):
	
	orig2 Object:= null:
	orig2 := null:
		
	return "" + [orig, orig2] 
}

~~~~~
//##425. npe gets thrown as expected

from com.concurnas.lang.precompiled.RefHelper import getNullRef2

x int:=getNullRef2()

def doings() String{
	was = "fail"
	try{
		hh int = x
	}
	catch(e NullPointerException){
		was = "npe expected ok"
	}
	
	return "" + was
}

~~~~~
//##425. when passing a null to something expecting a ref, consider it of the wanted type

def doIt(a String:?) String {
	g = a //deref it
	return g
}

def doings() String{
	asa = doIt(null)
	
	return "its fine no npe thrown=> " + asa
}

~~~~~
//##426. ensure that field setter doesnt invent any extra code

class Cls(){
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public ref int:?
	def set1 ( refa Integer : ) {
      	ref : = refa ;
    }
	def set2 ( refa Integer : ) {
      	this.ref : = refa ;//with this
    }
    
    public ref2 int::
	def setRef21 ( refa Integer : ) {
      	ref2 :: = refa ;
    }
	def setRef22 ( refa Integer : ) {
      	this.ref2 :: = refa ;//with this
    }
}

def doings() String{
	c Cls = new Cls()
	/*
	c.set1(null)
	ok = c.ref is int: and c.ref==null
	
	c.set2(null)
	ok2 = c.ref is int: and c.ref==null
	
	c.setRef21(null)
	ok3 = c.ref2 is int:: and c.ref2==null
	
	c.setRef22(null)
	ok4 = c.ref2 is int:: and c.ref2==null
	 */
	return "its fine no npe thrown x2"// + [ok, ok2, ok3, ok4]
}

~~~~~
//##427. ensure refs get created correctly

class Cls(){
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public ref int:?
	def set1 ( refa Integer : ) {
      	ref : = refa ;
    }
    
	public ref2 int::?
	def set12 ( refa Integer :: ) {
      	ref2 :: = refa ;
    }
}

def doings() String{

	c Cls = new Cls()
	
	c.set1(12) //ref created here
	ok1 = c.ref: is int: and c.ref==12
	
	//c.set1(null)//and here
	//ok2 = c.ref: is int: and c.ref==null
	
		
	c.set12(12)//etc
	ok3 = c.ref2:: is int:: and c.ref2==12
	
	//c.set12(null)
	//ok4 = c.ref2:: is int:: and c.ref2==null

	return "" + [ok1, true, ok3, true]
}

~~~~~
//##428. minor bug fix on referencings for multilevel

class Cls(){
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	public ref int::?
	def set1 ( refa Integer : ) {
      	//ref :::: = refa ; //should be invalid
      	ref : = refa ; //figure me out
    }
    
    
	def set2 ( refa Integer : ) {
      	this.ref  := refa ;//with this
    }
    
    
}

def doings() String{
	c Cls = new Cls()
	
	//c.set1(null)
	//ok = c.ref: is int: and c.ref==null
	
	//c.set2(null)
	//ok2 = c.ref: is int: and c.ref==null
	
	return "its fine no npe thrown x2"// + [ok, ok2]
}

~~~~~
//##429.a up down refing - on new

orig :: = (8:):

up :::= orig //ok - uprefs to the level we want
up2 int:::= orig //ok - uprefs to the level we want
dw := orig //ok - down to the level we want
dw2 int:= orig //ok - down to the level we want

x int::

def doings() String{
	vars = "" +[up:::, up2:::] + "=>" + [dw:, dw2:]
	eqs = ""  +[up:: &== orig::, up2:: &== orig::] + "=>" + [dw: &== orig:, dw2: &== orig:]
	inv = ""  +[up:: &<> orig::, up2:: &<> orig::] + "=>" + [dw: &<> orig:, dw2: &<> orig:]
	return "" + [vars, eqs, inv]
}

~~~~~
//##429.b up down refing - on assign existing

orig int:: = 90
x int:: = orig

from java.util import ArrayList

checks = new ArrayList<Boolean>();

def doings() String{
	raw = 8
	ref1l = 8:
	ref2l = 8::

	rawAOnes = [def () boolean { x ::= raw; return x==raw }, 
			  def () boolean { x := raw; return x==raw },
			  def () boolean { x = raw; return x==raw } ]
	
	l1ones =  [def () boolean { x ::= ref1l; return x:&==ref1l: and x::&<>ref1l:: },
				def () boolean { x := ref1l; return x::&==orig:: and x:&==ref1l: and x::&<>ref1l:: },
				def () boolean { x = ref1l; return x::&==orig:: and x==ref1l and x:&<>ref1l: and x::&<>ref1l:: } ]
	
	l2ones =  [def () boolean { x ::= ref2l; return x::&==ref2l:: },
			def () boolean { x := ref2l; return x::&==orig:: and x:&==ref2l: },
			def () boolean { x = ref2l; return x::&==orig:: and x == ref2l and x:&<>ref2l } ]
	
	proc = def ( funcl () boolean ) boolean 
			{  { orig ::= 90::
				x ::= orig; 
				raw = 8
				ref1l = 8:
				ref2l = 8::
				}//reset
			return funcl(); }//reset then do
	
	//res = for (group in [rawAOnes, l1ones, l2ones ] ) { for( test in group) { proc(test) } }
	
	res = ""+ for( test in rawAOnes) { proc(test) } +"\n"
	res += ( for( test in l1ones) { proc(test) } )  
	res += "\n" + (for( test in l2ones) { proc(test) }) 
	
	return "" + res
}

~~~~~
//##430. on assign existing ensure ref levels ok

def doings() String{
	newone1 = 90:
	newone2 = 90:
	newone3 int: = 90:
	
	orig := 90
	
	x := orig
	x = 91:	//overrite existing, use lhs levels as locked, dont touch the orig
		
	return "" + [newone1:, newone2:, newone3:, x:, orig==90] //orig unchanged
}

~~~~~
//##431. misc - dunno how what this does something about null maybe

from com.concurnas.lang.precompiled.RefHelper import getNullRef2

x int:=getNullRef2()


def doings() String{

	ref int:
	hhh = "HIHGGG"

	x := ref
	
	ref = 9
	
	return "" + x + "=>" + x:
}

~~~~~
//##432. ensure no arbitary creation of refs going on

class Fass(  )  { 
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	public ~a int:
	
	def setMe(g int:){
		a:=g
	}
	
	def setMe2(g int:){
		this.a:=g
	}
}

x:=11
x2:=11
x3:=11

def doings() String{
	f = new Fass()
	f.a := x
	
	f2 = new Fass()
	f2.setMe(x2)
	
	f3 = new Fass()
	f3.setMe2( x3)
	
	return "" + [f.a: &== x:, f2.a: &== x2:, f3.a: &== x3:]
}


~~~~~
//##433. double check that u cannot stick a String into an int ref etc

class A(public a int:){
	def do() int{
		return a*2
	}
} //should not gennerate psar - and doesnt:

def doings() String{
	ref := 9
	aa = new A(ref)
	aa.a=ref
	
	one = "" + aa.do()
	
	worked = "fail"
	
	obj Object: 
	
	try{
		obj: = (ref: as Object) as Object: //this as should blow up
		//sandtchecker
		obj = "hi" 
	} catch(e){
		worked="ok exception expected"
	}
	
	two = try{ 	 "" + aa.do() } catch(e) {  "mega fail " + e.getMessage()  }
	
	return "" + [one, two, worked]//, ref]
}

~~~~~
//##434. ensure that ClassCastException tacktrace just refers to conc code

from java.util import HashMap

origZ = new HashMap<String, Integer>()
z  = origZ:
zObj Object = origZ

def doings() String{
	theexcep2 = "fail"
	try{
		sdf = zObj as Integer: //check can be cast
	}
	catch(e){
		theexcep2 =""+ e.getStackTrace()[0]
	}
	return "" + theexcep2
}

~~~~~
//##435. there is special logic to ensure that Object to refType: doesnt blow up

class MyClas{
	public var ~x Object: = ("orig" as Object) //as Object:
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
}

def doings() String{
	mc = new MyClas()
	return "" + mc.x:
}

~~~~~
//##436. another thing to clean up

def takesO(arg Object:) boolean { 
	return true 
}

a Object:= 9
def doings() String{
	k := (a: as Object) as Object: //if already match then ret the ref being converted to immediatly

	return "" + [k:&==a:, takesO((a: as Object))]
}

~~~~~
//##437. ref with generics


class A<X> (a X:){
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}

	def do() X{
		return a
	}
	
	def do2() X:{
		return a
	}
}

def doings() String{
	ref := 9
	aa = new A<Integer>(ref)
	
	return "" + aa.do() + "=>" + aa.do2():
}

~~~~~
//##500. oops sort out isolation - mutable obj

from java.util import ArrayList

ar = new ArrayList<String>()

def doings() String{
	a ArrayList<String>:= {ar}!
	b := {ar}!
	c = {ar}!
	//3 seperate ways of doing the copy
	
	return "" + [ a &<> ar, b &<> ar, c &<> ar ] 
	//the ar is mutable, therefore we have a copy going into both the ref and coming out - TO maintain isolation
}

~~~~~
//##501. oops sort out isolation - simple immutables 

b=1:

def doings() String{
	b +=2
	
	return "" + b + ", " + b: 
}

~~~~~
//##501. oops sort out isolation - simple immutables - double 

b={1:}:

def doings() String{
	b +=2
	
	return "" + b + ", " + b: 
}

~~~~~
//##502. oops sort out isolation - array inc

b={[1,2,3]}:

def doings() String{
	b[0]+=98
	
	"" + b + ", " + b: 
}


~~~~~
//##503. oops sort out isolation - array inc - double

b={{[1,2,3]}:}:

def doings() String{
	b[0]+=98
	
	"" + b + ", " + b: 
}

~~~~~
//##504. oops sort out isolation - array str concat

b={["_", "_"]}:
b2={{["_", "_"]}:}::

def doings() String{
	b[0]+=98
	b2[0]+=98
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] 
}

~~~~~
//##505. oops sort out isolation - array postfix

b={[1,1]}:
b2={{[1,2]}:}:

def doings() String{
	b[0]++
	b2[0]++
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] 
}

~~~~~
//##506. oops sort out isolation - array prefix

b={[1,1]}:
b2={{[1,2]}:}:

def doings() String{
	++b[0]
	++b2[0]
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] 
}

~~~~~
//##507. oops sort out isolation - array postfix with ret

b={[1,1]}:
b2={{[1,2]}:}:

def doings() String{
	j1 = b[0]++
	j2 = b2[0]++
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] +"->" + [j1, j2]
}

~~~~~
//##508. oops sort out isolation - array prefix with ret

b={[1,1]}:
b2={{[1,2]}:}:

def doings() String{
	j1 = ++b[0]
	j2 = ++b2[0]
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] +"->" + [j1, j2]
}

~~~~~
//##509. oops sort out isolation - all variants with list
from java.util import ArrayList

ar = new ArrayList<int>()
ar.add(1)
ar.add(1)

ar2 = new ArrayList<String>()
ar2.add("_")
ar2.add("_")

def doings1() String{
	b={ar}:
	b2={{ar}:}:

	b[0]+=98
	b2[0]+=98
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] 
}

def doings1str() String{
	b={ar2}:
	b2={{ar2}:}:

	b[0]+=98
	b2[0]+=98
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] 
}

def doings2() String{
	b={ar}:
	b2={{ar}:}:

	b[0]++
	b2[0]++
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] 
}

def doings3() String{
	b={ar}:
	b2={{ar}:}:

	++b[0]
	++b2[0]
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] 
}

def doings4() String{
	b={ar}:
	b2={{ar}:}:

	j1=b[0]++
	j2=b2[0]++
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] +"->" + [j1, j2]
}

def doings5() String{
	b={ar}:
	b2={{ar}:}:

	j1=++b[0]
	j2=++b2[0]
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y]  +"->" + [j1, j2]
}


def doings() => "" +[doings1(), "\n", doings1str(), "\n", doings2(), "\n", doings3(), "\n", doings4(), "\n", doings5()]

~~~~~
//##510. oops sort out isolation - all variants with map

ar = {0 -> 1, 1-> 2}

ar2 = {0 -> "_", 1-> "_"}

def doings1() String{
	b={ar}:
	b2={{ar}:}:

	b[0]+=98
	b2[0]+=98
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] 
}

def doings1str() String{
	b={ar2}:
	b2={{ar2}:}:

	b[0]+=98
	b2[0]+=98
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] 
}

def doings2() String{
	b={ar}:
	b2={{ar}:}:

	b[0]++
	b2[0]++
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] 
}

def doings3() String{
	b={ar}:
	b2={{ar}:}:

	++b[0]
	++b2[0]
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] 
}

def doings4() String{
	b={ar}:
	b2={{ar}:}:

	j1=b[0]++
	j2=b2[0]++
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y] +"->" + [j1, j2]
}

def doings5() String{
	b={ar}:
	b2={{ar}:}:

	j1=++b[0]
	j2=++b2[0]
	
	x="" + b + ", " + b: 
	y="" + b + ", " + b:
	"" + [x,y]  +"->" + [j1, j2]
}


def doings() => "" +[doings1(), "\n", doings1str(), "\n", doings2(), "\n", doings3(), "\n", doings4(), "\n", doings5()]

~~~~~
//##511. explicit ref creation behavour

x = 8:
x2 = (8:):

def doings() String{
	ok = 8:
	ok2 = 8:://upgraded to int::
	ok3 = x:
	ok4 = x:: //upgraded to int::
	ok5 = x2: //extracted to int:

	"" + [ok, ok2, ok3, ok4, ok5]
}

~~~~~
//##512. array ref setting tricky

a1 = ["5"::, "5":] 
a2 = [5:, 5:]
a3 = ["5", "5"] 
a4 := ["5":, "5":]
norm  = [1,2]

def doings1() {
	a1[0] += 5
	"" + a1
}

def doings2() {
	a2[0] += 7
	"" + a2
}

def doings3() {
	a3[0] += "hi"
	"" + a3
}

def doings4() String{
	a4[0] = "hi"://overwrite ref
	a4[1] += "hialso"://overwrite ref erm -ref ref:
	"" + a4
}

def doings5() {
	norm[0] = 99
	norm[1] += 99
	"" + norm
}

def doings() String{
	 "" + [doings1(), doings2(), doings3(), doings4(), doings5()]
}


~~~~~
//##513.a check array refs again - simple
testical = [10   10   10   10  10  10  10  10]
testicalstr = ["10"  "10"  "10"  "10"]
testicald = [10.   10   10   10  10  10  10]

nineRef = 99:
TWOREF = 2:
hiStr = "hithere":

def doings(){
	//all array assignment cases
	testical[0] = 99
	testical[1] += 99
	testical[2] -= 99
	testical[3] = new Integer(99)
	testical[4] = nineRef
	testical[5] += nineRef
	testical[6] **= 2
	testical[7] **= TWOREF
	
	testicald[0] = 99
	testicald[1] += 99
	testicald[2] -= 99//casts
	testicald[3] **= 2//casts
	testicald[4] = new Integer(99)
	testicald[5] = nineRef
	testicald[6] += nineRef
	
	testicalstr[0] = "hi"
	testicalstr[1] += "hi"
	testicalstr[2] += hiStr
	testicalstr[3] = hiStr
	
	"" + [ testical, testicalstr, testicald]
}


~~~~~
//##513.b check array refs again - ref versions

thesetter = [10:, 10]
testical = [10,  10,  10,  10, 10, 10:, 10, 10]
testicalstr = ["10", "10", "10", "10":]
testicald = [10.:,  10.:,  10.:,  10.:, 10.:, 10.:, 10.:]

nineRef = 99:
nineRefd = 99.:
tworef = 2.:
hiStr = "hithere":

def doings(){
	//all array assignment cases
	testical[0] = 99
	testical[1] += 99
	testical[2] -= 99
	testical[3] = new Integer(99)
	testical[4] = nineRef
	testical[5] += nineRef
	testical[6] **= 2
	testical[7] **= tworef
	
	testicald[0] = 99
	testicald[1] += 99
	testicald[2] -= 99//casts
	testicald[3] **= 2//casts
	testicald[4] = new Double(99)
	testicald[5] = nineRefd
	testicald[6] += nineRef
	
	testicalstr[0] = "hi"
	testicalstr[1] += "hi"
	testicalstr[2] += hiStr
	testicalstr[3] = hiStr
	
	//ensure we write over the ref correctly
	thesetter[0] = 99:
	thesetter[1] = nineRef:
	
	"" + [ testical, testicalstr, testicald, thesetter]
}

~~~~~
//##513.a.a check array refs again - simple - on a ref array
testical = [10,  10,  10,  10, 10, 10, 10, 10]:

nineRef = 99:
TWOREF = 2:
hiStr = "hithere":

def doings(){
	//all array assignment cases
	testical[0] = 99
	testical[1] += 99
	testical[2] -= 99
	testical[3] = new Integer(99)
	testical[4] = nineRef
	testical[5] += nineRef
	testical[6] **= 2
	testical[7] **= TWOREF
	
	
	"" + testical
}


~~~~~
//##513.b.b check array refs again - ref versions - on a ref array

testical = [10,  10,  10,  10, 10, 10:, 10, 10]:

nineRef = 99:
nineRefd = 99.:
tworef = 2.:
hiStr = "hithere":

def doings(){
	//all array assignment cases
	testical[0] = 99
	testical[1] += 99
	testical[2] -= 99
	testical[3] = new Integer(99)
	testical[4] = nineRef
	testical[5] += nineRef
	testical[6] **= 2
	testical[7] **= tworef
	
	//anymore than this and the method becomes too massive (still need to fix this)
	
	"" + testical
}

~~~~~
//##514. check ref upgrade downgrade correct

nine = 9:
ninel2 = 9::

same int::
same2 int::
same3 int::

upgrade int::
upgrade2 int::
upgrade3 int::

downgrade int:
downgrade2 int:
downgrade3 int:
downgrade4 int:

def doings() String{
	same ::= ninel2:: //same
	same2  = nine::  //same
	same3 ::= nine:: //same
	
	upgrade ::= nine
	upgrade2 ::= nine::
	upgrade3 = nine
	
	downgrade := ninel2
	downgrade2 := ninel2:
	downgrade3 = ninel2
	downgrade4 = ninel2
	
	"" +  [same, same2, same3, upgrade, upgrade2, upgrade3, downgrade, downgrade2, downgrade3, downgrade4] 
}

~~~~~
//##514.b creation via iso check implicit upgrade working ok

a int:= 8
def doings() String{
	c  = {a}:: //creation via seperate iso is failing...
	cs  = {a:} //creation via seperate iso is failing...

	return "" + [[c, c is int::, c: == a:] , [cs, cs is not int::, cs: == a:]]
}

~~~~~
//##515. upcast fail case - modules

ok1 int:::
ok2 int:::
ok3 int:::

class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	def c1 ( xxx int:: )  {
		ok1 := xxx
    }
    
    def c2 ( xxx int:: )  {
		ok2 ::= xxx
    }
    
    def c3 ( xxx int:: )  {
		ok3 :::= xxx
    }
}

child = new Inner()

ff = 55::
def doings() {
	child.c1(ff)
	child.c2(ff)
	child.c3(ff)
	"" + [ok1, ok2, ok3] + "" + [ok1:::, ok2:::, ok3:::]
}

~~~~~
//##516. upcast fail case - classes

class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	public ok1 int::: =6
	public ok2 int::: =6
	public ok3 int::: =6
		
	
	def c1 ( xxx int:: )  {
		ok1 := xxx
    }
    
    def c2 ( xxx int:: )  {
		ok2 ::= xxx
    }
    
    def c3 ( xxx int:: )  {
		ok3 :::= xxx
    }
}

child = new Inner()

ff = 55::
def doings() {
	child.c1(ff)
	child.c2(ff)
	child.c3(ff)
	"" + [child.ok1, child.ok2, child.ok3] + "" + [child.ok1:::, child.ok2:::, child.ok3:::]
}

~~~~~
//##517. assign array ref

sdf = [ 0:::, 0:::, 0:::, 0:::]

def afmt() => "" + [sdf[0], sdf[1], sdf[2], sdf[3]] + "->" + sdf

def doings() String{
	sdf[0]  = 9
	sdf[1]  := 9
	sdf[2]  ::= 9
	sdf[3]  :::= 9
	
	afmt() 
}

~~~~~
//##517.b assign array ref - thing itself is a ref

sdf = [ 0:::, 0:::, 0:::, 0:::]::

def afmt() => "" + [sdf[0], sdf[1], sdf[2], sdf[3]] + "->" + sdf


def doings() String{
	sdf[0]  = 9
	sdf[1]  := 9
	sdf[2]  ::= 9
	sdf[3]  :::= 9
	
	afmt() 
}

~~~~~
//##517.c assign array ref - correct upcasting where needed

sdf = [ 0:::, 0:::, 0:::, 0:::]::

def afmt() => "" + [sdf[0], sdf[1], sdf[2], sdf[3]] + "->" + sdf

nineTwo = 9:: 

def doings() String{
	sdf[0]  = nineTwo
	sdf[1]  := nineTwo
	sdf[2]  ::= nineTwo
	sdf[3]  :::= nineTwo
	
	afmt() 
}

~~~~~
//##517.d assign array ref - array set on inc ops


sdf = [ 0:::, 0:::, 10:::, 0:::]::
bb = ["one":::]::

def afmt() => "" + [sdf[0], sdf[1], sdf[2], sdf[3]] + "->" + sdf + "->" + bb[0]

nineTwo = 9:: 

def doings() String{
	sdf[0]  += 9
	sdf[1]  += nineTwo
	sdf[2]  **= 2
	bb[0] += "hi"//and str concat
	
	afmt() 
}

~~~~~
//##517.e assign array ref - pre postfix

sdf = [ 0:::, 0:::, 0:::, 0:::]::

def afmt() => "" + [sdf[0], sdf[1], sdf[2], sdf[3]] + "->" + sdf

nineTwo = 9:: 

def doings() String{
	sdf[0]++
	sdf[1]--
	++sdf[2]
	--sdf[3]
	
	afmt() 
}

~~~~~
//##517.f assign array ref - pre postfix

sdf = [ 0:::, 0:::, 0:::, 0:::]

def afmt() => "" + [sdf[0], sdf[1], sdf[2], sdf[3]] + "->" + sdf

nineTwo = 9:: 

def doings() String{
	a1=sdf[0]++
	a2=sdf[1]--
	a3=++sdf[2]
	a4=--sdf[3]
	
	afmt() + "~" + [a1, a2, a3, a4]
}

~~~~~
//##518.a list ref - assignment
from java.util import ArrayList
ar = ArrayList<Integer:::>()
ar.add(0:::)
ar.add(0:::)
ar.add(0:::)
ar.add(0:::)
sdf = ar::

def afmt() => "" + [sdf[0], sdf[1], sdf[2], sdf[3]] + "->" + sdf

def doings() String{
	sdf[0]  = 9
	sdf[1]  := 9
	sdf[2]  ::= 9
	sdf[3]  :::= 9
	
	afmt() 
}

~~~~~
//##518.b list ref - in place increment
from java.util import ArrayList
ar = ArrayList<Integer:::>()
ar.add(0:::)
ar.add(0:::)
ar.add(10:::)
ar.add(0:::)
sdf = ar::

def afmt() => "" + [sdf[0], sdf[1], sdf[2], sdf[3]] + "->" + sdf

nineTwo = 9:: 

def doings() String{
	sdf[0]  += 9
	sdf[1]  += nineTwo
	sdf[2]  **= 2
	
	afmt() 
}

~~~~~
//##518.c list ref - str concat multilevel
from java.util import ArrayList

ar = new ArrayList<String:::>()
ar.add("one":::)
sdf = ar::

def afmt() => "" + [sdf[0]] + "->" + sdf

nineTwo = "9":: 

def doings() String{
	sdf[0]  += nineTwo
	
	afmt() 
}


~~~~~
//##519.a map ref - assignemnt

sdf = {0->0:::, 1->0:::, 2->0:::, 3->0:::}::

def afmt() => "" + [sdf[0], sdf[1], sdf[2], sdf[3]] + "->" + sdf

nineTwo = 9:: 

def doings() String{
	sdf[0]  = nineTwo
	sdf[1]  := nineTwo
	sdf[2]  ::= nineTwo
	sdf[3]  :::= nineTwo
	
	afmt() 
}

~~~~~
//##519.b map ref - in place

sdf = {0->0:::, 1->0:::, 2->10:::, 3->0:::}::

def afmt() => "" + [sdf[0], sdf[1], sdf[2], sdf[3]] + "->" + sdf

nineTwo = 9:: 

def doings() String{
	sdf[0]  += 9
	sdf[1]  += nineTwo
	sdf[2]  **= 2
	
	afmt() 
}

~~~~~
//##519.c map ref - str concat

sdf = {0->"0":::, 1->"0":::}::

def afmt() => "" + [sdf[0], sdf[1]] + "->" + sdf

nineTwo = 9:: 

def doings() String{
	sdf[0]  += "9"
	sdf[1]  += nineTwo
	
	afmt() 
}

~~~~~
//##520.1 pre postfix multilevel - var 

sdf1 = 0:::
sdf2 = 0:::
sdf3 = 0:::
sdf4 = 0:::

sdf1b = 0:::
sdf2b = 0:::
sdf3b = 0:::
sdf4b = 0:::

def afmt() => "" + [sdf1, sdf2, sdf3, sdf4]

nineTwo = 9:: 

def doings() String{
	sdf1++
	sdf2--
	++sdf3
	--sdf4
	
	a1 = sdf1b++
	a2 = sdf2b--
	a3 = ++sdf3b
	a4 = --sdf4b
	
	afmt() + [a1, a2, a3, a4] + [sdf1b, sdf2b, sdf3b, sdf4b]
}

~~~~~
//##520.2 pre postfix multilevel - map

sdf1 = {0->0:::}::
sdf2 = {0->0:::}::
sdf3 = {0->0:::}:::
sdf4 = {0->0:::}::

sdf1b = {0->0:::}:
sdf2b = {0->0:::}::
sdf3b = {0->0:::}::
sdf4b = {0->0:::}::

def afmt() => "" + [sdf1, sdf2, sdf3, sdf4]

nineTwo = 9:: 

def doings() String{
	sdf1[0]++
	sdf2[0]--
	++sdf3[0]
	--sdf4[0]
	
	a1 = sdf1b[0]++
	a2 = sdf2b[0]--
	a3 = ++sdf3b[0]
	a4 = --sdf4b[0]
	
	afmt() + [a1, a2, a3, a4] + [sdf1b, sdf2b, sdf3b, sdf4b]
}

~~~~~
//##520.3 pre postfix multilevel - list

from java.util import ArrayList

def makeLi() => {
	ar = new ArrayList<Integer:::>()
	ar.add(0)//cool upcasts it :)
	ar:::
}

sdf1 = makeLi()
sdf2 = makeLi()
sdf3 = makeLi()
sdf4 = makeLi()

sdf1b = makeLi()
sdf2b = makeLi()
sdf3b = makeLi()
sdf4b = makeLi()

def afmt() => "" + [sdf1, sdf2, sdf3, sdf4]

nineTwo = 9:: 

def doings() String{
	sdf1[0]++
	sdf2[0]--
	++sdf3[0]
	--sdf4[0]
	
	a1 = sdf1b[0]++
	a2 = sdf2b[0]--
	a3 = ++sdf3b[0]
	a4 = --sdf4b[0]
	
	afmt() + [a1, a2, a3, a4] + [sdf1b, sdf2b, sdf3b, sdf4b]
}

~~~~~
//##521. fix this syntax problem later
def ttt() => true
def xx() => 8

def doings() => {
	ok3 = (xx():) if ttt() else null: //TODO: should be able to support ok3 = xx(): if true else null:
 	"should be oks" + ok3
 }
 
~~~~~
//##522. special case to handle waiting on refs of refs on creation
a = 8:
def doings1() String{
	c  = {a:}::
	c2 int:: = {a:}:: 
	c3 :: = {a:}::
	//ok this doesnt work can otherwise cause deadlock :( - why would you want to create a ref to a ref anyway? 
	//this was the plan...
	//in the normal case e.g. c int::; c={a:}! the below code would stall
	//for etenity because the ref of c is being overriten by that of a
	//however, special case here on ref creation, we do not create anything
	//more than the first level of the ref, leaving the rhs asynexpression to 
	//create it - better put a note in the book about this
	"" + [c, c2, c3]
}

def doings() String{
	"" + doings1()  
}

 
~~~~~
//##523. ensure local array assignment can be performned

stuff = [1:,2:]

def doings(){
	stuff[0]=10 //invoke virtual on me
	return "" +stuff
}

~~~~~
//##524. check that identity hash map can be iterated correctly without npe

import java.util.IdentityHashMap as IDM

class MyClass(  ) {
~aaa = new IDM<String, String>()

def postOp() => for(a in aaa.keySet() ){ a }

}

def doings(){
	mc = new MyClass()	
	mc.aaa.put("one", "one")
	mc. aaa.put("two", "two")
	
	"" + (mc.postOp().size()==2)
}

~~~~~
//##525. ensure correct type inferance for refs when subtypes are possible

//maybe a problem since I found this in the code: [Float:, Integer:] - have to return Object not Number: 

def doings(){
	//type of arry is Number:
	
	xxx = [99.: 99]
	isnum = xxx is Number:[]
	
	//should be ok - 2nd element converted to Int:
	"" + [xxx, xxx[0]:get(), xxx[1]:get(), isnum]
}


~~~~~
//##526. no inf loop

lam1 = {
		x=def (a int) int {  
				b=20
				5
			}; 
		x(12)
		6
		}!


def doings() {
	"works " + lam1
}


~~~~~
//##527. conversion is ok

from com.concurnas.lang.precompiled import RefHelper

cc  := "me not ref"
//the next functions are expected to return the Object
def uppy1(a com.concurnas.runtime.ref.Local<com.concurnas.runtime.ref.Local<Object>>) => a
//def uppy2(a com.concurnas.runtime.ref.Local<com.concurnas.bootstrap.runtime.ref.Ref<Object>>) => a
def uppy3(a Object::) => a

def doings() => "" +	[uppy1(cc), //ok
				//uppy2(cc), //ok
				uppy3(cc)] //add extra ref level on cast operation

~~~~~
//##527. ensure return as ref not local
cc  := "me not ref"
//next line prevously a was being returned as a local instead of a ref
def uppy2(a com.concurnas.runtime.ref.Local<com.concurnas.bootstrap.runtime.ref.Ref<Object>>) => a::

def doings() => "" +	uppy2(cc)::

~~~~~
//##195 ensure mulitlevel return type chosen correctly	
def ttt()=>true
cc  ::= "me not ref"
//returns Ref Ref in thes cases not Ref Local etc
def uppy(a com.concurnas.runtime.ref.Local<com.concurnas.bootstrap.runtime.ref.Ref<Object>>,		
	b com.concurnas.bootstrap.runtime.ref.Ref<com.concurnas.runtime.ref.Local<Object>>,		
	c boolean) 
	=> (a::) if ttt() else (b::)

def uppy2(a com.concurnas.runtime.ref.Local<com.concurnas.bootstrap.runtime.ref.Ref<Object>>,		
	b com.concurnas.bootstrap.runtime.ref.Ref<com.concurnas.runtime.ref.Local<Object>>,		
	c boolean) 
	=> (a::) if ttt() else (b::)

def doings() {
 	"" + [uppy(cc, cc, true)::, uppy(cc, cc, false)::] + "" +[ uppy2(cc, cc, true)::, uppy2(cc, cc, false)::]
}

~~~~~
//##196 3 refs down should be ok

from com.concurnas.lang.precompiled import RefHelper

cc  :::= "me not ref"
//the next functions are expected to return the Object
def uppy1(a com.concurnas.runtime.ref.Local<com.concurnas.runtime.ref.Local<Object>>) => a
//def uppy2(a com.concurnas.runtime.ref.Local<com.concurnas.bootstrap.runtime.ref.Ref<Object>>) => a
def uppy3(a Object::) => a

def doings() => "" +	[uppy1(cc), //ok
				//uppy2(cc), //ok
				uppy3(cc)] //add extra ref level on cast operation

~~~~~
//##197 check type set to refs

from java.lang import ClassCastException 

cc  := "me not ref"

def uppy3(a Object:) => a = 9//here we set the thing passsed as Object: which is really a String:

def doings() {
	"" + try{
		uppy3(cc)
		"" + cc
	} catch(e ClassCastException ){
		"failed as expected: " + e
	}
}

~~~~~
//##198 was playing up before

def g() => 50
def g2(x int) => 50+x

x = g&():

def doings(){
	x2 = g&()!
	y = g2&(? int)!
	y2 = g2&(2)!

	return "it's done: " + [x() , x2(), y(2), y2()]
}

~~~~~
//##199 def with arrays

ax = [8:] //made locked?
a2 int:[] = [8:] //made locked?


def doings() {

	ax[0] = 9
	a2[0] = 9
	
	"" + [ax[0], a2[0]]
}

~~~~~
//##200 in the past lambda creation was failing
def ttt() => true
cc  ::= "me not ref"

def uppy2(a com.concurnas.runtime.ref.Local<com.concurnas.bootstrap.runtime.ref.Ref<Object>>,		
	b com.concurnas.bootstrap.runtime.ref.Ref<com.concurnas.runtime.ref.Local<Object>>,		
	c boolean) 
	=> (a::) if ttt() else (b::)


def doings() {
	z = uppy2&(cc, cc, ? boolean) //not its ok when refering to refs, cos types were being incorrectly set
 	""  + [z(true)::, z(false)::]
}

~~~~~
//##201 locking of refs ignored for prim operations - plus
def functo() => 454: 

//type is locked, but we permit primative infix operations anyway
def doings1() String{
	xxx1 = 454: 
	x1  = 454: + 1
	x2  = 1 + 454: 
	x3 = 1 * 454: 
	x4 = 454: * 1 
	return "got: " + [xxx1, x1, x2, x3, x4]
}

//type is locked, but we permit primative infix operations anyway
def doings2() String{
	xxx1 = functo() 
	x1  = functo() + 1
	x2  = 1 + functo() 
	x3 = 1 * functo() 
	x4 = functo() * 1 
	return "got: " + [xxx1, x1, x2, x3, x4]
}

def doings() => "" + [doings1(), doings2()] 

~~~~~
//##202 locking of refs ignored for prim operations - gt lt etc

def functo() => 454: 

def doings1() {
	x1 = functo()  >10
	x2 = 10 < functo() 

	"got: " + [x1, x2 ]
}

def doings2() {
	x1 = 11:  >10
	x2 = 10 < 11:

	"got: " + [x1, x2 ]
}

def doings() => "" + [ doings1(),  doings2()] 

~~~~~
//##203 locking of refs ignored for prim operations - eq

a: =234
def functo() => a

def doings1() {
	x1 = functo() == 234
	x2 = 234 == functo() 

	"got: " + [x1, x2 ]
}

def doings2() {
	x1 = a: == 234
	x2 = 234 == a:

	"got: " + [x1, x2 ]
}

def doings() => "" + [ doings1(), doings2() ]

~~~~~
//##204 locking of refs ignored for prim operations - ref eq

from com.concurnas.lang.precompiled import RefHelper

def doings() String{
	ref3 int:= RefHelper.getNullRef2()
	
	//the eq above is based on ref so shouldnt be extracting
	
	"" + [null &== ref3:, ref3: &== null,\
		  null &<> ref3:, ref3: &<> null 
		 ]
}

~~~~~
//##205 locking of refs ignored for prim operations - and or
def doings() String{
	"" + [true: or false, \ //covers not implicitly
		 true: and true,\
		 true or false:,\
		 true and true:]
}

~~~~~
//##206 locking of refs ignored for prim operations - pow
def doings() String{
	"" + [2: ** 2, 2 ** 2:, 2:: ** 2::]//+ other
}

~~~~~
//##207 pre and postfix ops on maps

from java.util import ArrayList
ok = {0-> 23::}
ok2 = new ArrayList<int::>();ok2.add(23::)

def doings() =>{
	ok[0]++
	++ok[0]
	ok2[0]++
	++ok2[0]
	"" + [ok, ok2]
}

~~~~~
//##208 mul ops etc on maps with explicit and non explicit def

from java.util import ArrayList, Map
ok = {0-> 23::}
okb = {0-> 23::}
ok2 ArrayList<int::> = new ArrayList<int::>(); ok2.add(23::)
ok2b  = new ArrayList<int::>(); ok2b.add(23::)

def doings() =>{
	ok[0]*=2
	okb[0]*=2
	ok2[0]*=2
	ok2b[0]*=2
	"" + [ok, okb, ok2, ok2b]
}

~~~~~
//##209 ensure that we can call non ref functions even when we're locked

class AConst(~a int) {} 

def ppa(a int) => "" + a

def doings() =>{
	ac = new AConst(10:)

	"" + [ac.a, ppa(10:)] //now look for the variant without ref insistance
}

~~~~~
//##210 ensure that we can call non ref functions even when we're locked v2

class AConst(~a int) {} 

def ppa(a int) => "" + a

def gotme() => 10:

def doings() =>{
	ac = new AConst(gotme())

	"" + [ac.a, ppa(gotme())] //now look for the variant without ref insistance
}

~~~~~
//##211 ensure that we can call non ref functions even when we're locked v3

class AConst(~a int, ~b int, ~c int) {} 

def ppa(a int, b int, c int) => "" + [a, b, c] //a bit more complex

def gotme() => 10:

def doings() =>{
	ac = new AConst(gotme(), 12, gotme())

	"" + [ [ac.a, ac.b, ac.c], ppa(gotme(), 12, gotme())] //now look for the variant without ref insistance
}

~~~~~
//##212 double check onchange ret of values

def doings() {
	calls := ""
	done :=false
	
	cnt:=0
	
	xx int:
	
	ninset = every(xx) { return xx }//extract xx and ret value not ref
	
	xx = 99
	
	matchla = xx: &== ninset:
	
	xx=100
	
	"" + [matchla, ninset, xx]
}

~~~~~
//##z213 failed before odd

def doings() {
	calls := ""
	done :=false
	
	cnt:=0
	
	xx int:
	
	ninset = every(xx) { return xx }//extract xx and ret value not ref
	
	xx = 99
	
	matchla = xx: &== ninset:
	
	a := 9
	
	xx = async{
		pre{ 
			//99
		}
		onchange(a){ 
			10
		}
		post {
			//100
		} 
	}
	a = 66
	
	await(xx ; xx == 10 ) 
	
	"" + [matchla, ninset, xx, a]
}

~~~~~
//##z214 pre does get ini

def doings() {
	calls := ""
	done :=false
	
	cnt:=0
	
	xx int:
	
	ninset = every(xx) { return xx }
	
	a := 9
	
	xx = async{
		pre{ 
			100
		}
		onchange(a){ 
			10
		}
		post {
			//100
		} 
	}
	a = 66
	
	await(xx ; xx == 10 ) 
	
	"" + [ninset, xx, a]
}

~~~~~
//##z215 async pre can ret

def doings() {
	calls := ""
	done :=false
	
	cnt:=0
	
	xx int:
	
	ninset = every(xx) { return xx }
	
	a := 9
	
	xx = async{
		pre{ 
			100
		}
		onchange(a){ 
			l=9
			99
		}
		post {
			//100
		} 
	}
	a = 66
	await(xx ; xx==99)
	
	"" + [ninset, xx, a]
}

~~~~~
//##z216 onchange no ret

def doings() {
	calls := ""
	done :=false
	
	cnt:=0
	
	xx int:
	
	ninset = every(xx) { return xx }
	
	a := 9
	
	xx = async{
		pre{ 
			slog = 99
			100
		}
		onchange(a){ 
			l=slog
		}
		post {
			//100
		} 
	}
	a = 66
	
	"" + [ninset, xx, a]
}

~~~~~
//##z217 ret in post block

def doings() {
	calls := ""
	done :=false
	
	cnt:=0
	
	xx int:
	
	ninset = every(xx) { return xx }
	
	a := 9
	
	xx = async{
		pre{ 
			slog = 99
			50
		}
		onchange(a){ 
			l=slog
			return
		}
		post {
			101
		} 
	}
	a = 66
	
	await( xx ; xx==101)
	
	"" + [ninset, xx, a]
}

~~~~~
//##z218 things non ret are not forced

def doings() {
	calls := ""
	done :=false
	
	cnt:=0
	
	xx int:
	
	ninset = every(xx) { return xx }
	
	a := 9
	
	xx = async{
		pre{ 
			try{
			x=11}
			finally{p=0}//should not be forced to return anything
		}
		onchange(a){ 
			return
		}
		post {
			101
		} 
	}
	a = 66
	
	await( xx ; xx==101)
	
	"" + [ninset, xx, a]
}

~~~~~
//##z219 ensure that length on local arry can be called when the local array is a class field

def doings() {
	
	xs = [1:, 1:]
	
	output :=""
	cnt :=0
	
	onchange(xs){ 
		output += "" + changed.getChanged().length //implicitly extracts the local array from the classfield
		cnt++
	}
	
	xs[0] = 98
	
	await(cnt ; cnt == 1)
	
	"" + [output]
}

~~~~~
//##z220 ensure local vars for for loops are captured for splicing

valu int: = 0

def dosomework(a int) {
	trans{ valu += a }
}


def doings() {
	sync{
		//prevsouly the local vars declared within for loops were not being captured
		//TODO: any more like this? - check...
		for( b in a[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]){
			dosomework(b)!
		}
		
		for(h =1; h <== 15; h++){
			dosomework(h)!
		}
		
		h2 =1
		for(; h2 <== 15; h2++){
			dosomework(h2)!
		}
	}

	await(valu ; 360 == valu)

	"" + valu// (valu == 360)
}

~~~~~
//##z221 double level ref array extract

from com.concurnas.lang.precompiled import Returner

def doings(){
	ladirect = [[99:], [2:]]
	la = Returner.getMeALocalArrayL2() //here we convert the type to be that of 

	aa = "" + ladirect[0][0]//for(a in ladirect){ a }
	a2 = "" + la[0][0]//for(a in la){ a }
	
	"" + [aa, a2]
}

~~~~~
//##z222 double level ref array itr
from com.concurnas.lang.precompiled import Returner

def doings(){
	ladirect = [[99:], [2:]]
	la = Returner.getMeALocalArrayL2() //here we convert the type to be that of 

	aa = "" + for(a in ladirect){ a }
	a2 = "" + for(a in la){ a }
	
	"" + [aa, a2]
}

~~~~~
//##z223 ensure fields and funcs callable from refs etc

class MyClass{//re ref writes back to ref for array ops 2

	def afunc() => "hi"
	public thingy = "la thing"
	
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
}

ins := new MyClass() 

def doings() => 	"" + [ins.afunc(), ins.thingy, ins:get().thingy]

~~~~~
//##z224 sync blocks

valu int: = 0

def dosomework(a int) {
	trans{ valu += a }
}


def doings() {
		sync{
			for( b in [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]){
				dosomework(b)!
			}
			
			for(h =1; h <== 15; h++){
				dosomework(h)!
			}
			
			h2 =1
			for(; h2 <== 15; h2++){
				dosomework(h2)!
			}
		}

	"" + valu// (valu == 360)
}

~~~~~
//##z225 sync blocks nested

valu int: = 0

def dosomework(a int) {
	trans{ valu += a }
}

def doings() {
	f := 11
	sync{
		sync{
			for( b in [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]){
				dosomework(b)!
			}
			
			for(h =1; h <== 15; h++){
				dosomework(h)!
			}
			
			h2 =1
			for(; h2 <== 15; h2++){
				dosomework(h2)!
			}
		}
		{f=9999}!
	}

	"" + [valu  f]// (valu == 360)
}

~~~~~
//##z226 sync blocks may return stuff just like normal blocks

valu int: = 0

def dosomework(a int) {
	trans{ valu += a }
}

def doings() {
	f = sync{
		for( b in [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]){
			dosomework(b)!
		}
		
		for(h =1; h <== 15; h++){
			dosomework(h)!
		}
		
		h2 =1
		for(; h2 <== 15; h2++){
			dosomework(h2)!
		}
		100
	}
	"" + [valu  f]// (valu == 360)
}

~~~~~
//##z227 sync blocks can ret
def ttt() => 3>2
def pla() String {
	sync{ return "hi" }
}

def retla() String {
	sync{ if(ttt()) { return "cool" } return "hi" }
}

def pladox() String {
	sync{ if(ttt()) { throw new Exception("xxx");} return "hi" }//caught and rethrown
}

def doings() {
	got = try{pladox()}catch(e){"" + e;}

	"" + [retla(), pla(), got]
}


~~~~~
//##z228 to ref ref

cc  ::= "me not ref"
cc2  ::= "me not ref2"

def uppy2(a com.concurnas.runtime.ref.Local<com.concurnas.bootstrap.runtime.ref.Ref<Object>>,		
	b com.concurnas.bootstrap.runtime.ref.Ref<com.concurnas.runtime.ref.Local<Object>>,		
	c boolean) 
	=> (a::) if c else (b::)

def doings() {
 	 "" +[ uppy2(cc, cc2, true)::, uppy2(cc, cc2, false)::]
}

~~~~~
//##z229 ref tidy up

from com.concurnas.lang.precompiled import RefHelper

b := RefHelper.getThingAsRef(12) //tidy up

def doings() {
	""+b:
}

~~~~~
//##z230 nice little thing which works ok now

from com.concurnas.lang.precompiled import RefHelper

b := RefHelper.getThingAsRef(12)
b2 int:com.concurnas.bootstrap.runtime.ref.Ref = 0:
b2 = 5:

def doings() {
	one = "" + [b:]
	two = "" + [b2:]
	""+ [one, two]
}

~~~~~
//##z231 ref bytecode

a Object: = 1:
a2 Object: = "hi":

def doings(){
	
	b = a: as int: //ok
	b2 = try{ f=a2: as String: ; "ok" } catch(e) { "uh oh" }
	b3 = try{ f=a: as String: ; "uh oh" } catch(e) { "err as epected" }
	
	erexpect = try{a2=4; "err" }catch(e) { "nice err: " + e.getMessage() }
	//and of course we cannot set the dude above with that thing, since the local performs the check itself
	"" + [a:, a2:] + [b, b2, b3, erexpect] 
}

~~~~~
//##z233 ref type create local

a int:com.concurnas.bootstrap.runtime.ref.Ref = 0:
a := 9 //a ok

def doings() => "" + (a as int:)

~~~~~
//##z234 fixed bug in ref array where type array not created correctly - check instanceof

def doings(){
	la = [[2:]]
	o = la as Object
	"" + [o is int:[2], o isnot int:[]]
}

~~~~~
//##z235 fixed bug in ref array where type array not created correctly - check cast to a ref

la = [2:]

def doings(){
	o = la: as Object
	"" + o //(o is int:[2])
}

~~~~~
//##z236 fixed bug in ref array where type array not created correctly - was missing cast

from com.concurnas.lang.precompiled import Returner
la int:[2] = [[2:]]

j = la as Object

a2 = j  as int:[2] //was missing cast here

def doings(){
	a3 = j  as int:[2]
	"" + [a2[0], a3[0]]
}

~~~~~
//##z237 type extraction from for and while loops

from java.util import ArrayList

def ran() => false

ar = new ArrayList<Integer>()
ar.add(1)
ar.add(2)
ar.add(3)

def wally() {
	a  = 12:
	one = for(ab in [1,2,3]){//translates to old for
		a
	}
	
	two = for(ab in [1,2,3]){
		if(ab == 1){
			continue a
		}
		break a
	}
	
	three = for(ab in ar){
		a
	}
	
	four = for(ab in ar){
		if(ab == 1){
			continue a
		}
		break a
	}
	
	[one, two, three, four]
}

def wallylocked() {
	a  = 12:
	one = for(ab in [1,2,3]){
		a:
	}
	
	two = for(ab in [1,2,3]){
		if(ab == 1){
			continue a:
		}
		break a:
	}
	
	three = for(ab in ar){
		a:
	}
	
	four = for(ab in ar){
		if(ab == 1){
			continue a:
		}
		break a:
	}
	
	[one, two, three, four]
}


def whila(){
	a :=13
	n1 = 0
	one = while(n1++ < 3){ a  }
	n2 = 0
	two = while(n2++ < 3){ 
		if(n2 == 1){
			continue a
		}
		break a
  	}
	
	"" + [one, two]
}

def whilalocked(){
	a :=13
	n1 = 0
	one = while(n1++ < 3){ a:  }
	n2 = 0
	two = while(n2++ < 3){ 
		if(n2 == 1){
			continue a:
		}
		break a:
  	}
	
	"" + [one, two]
}

def doings() {
	"" + [wally(), "\n", wallylocked(), "\n", whila(), "\n", whilalocked()]
}

~~~~~
//##z238 to add get and set to ref types need support on arbitary classes

from java.util import HashMap

class Parent{
	mine = HashMap<Integer, String>()
	
	def get(a int) => mine[a]
	def put(a int, b String) => mine[a] = b
	
	override toString() => ""+mine
}


def doings() {
	p = Parent()
	p[1] = "one"
	p[2] = "two"

	p[2] += " more"

	ob = p[1]

	"" + [ob, p[1], p[2] ]
}

~~~~~
//##z239 as above but multilevel support

from java.util import HashMap

class Child(name String){
	mine = HashMap<Integer, String>()
	
	def get(a int) => name + mine[a]
	def put(a int, b String) => mine[a] = b
	
	override toString() => name + " -> "+mine
}

class Parent{
	mine = HashMap<Integer, Child>()
	
	def get(a int) => mine[a]
	def put(a int, b Child) => mine[a] = b
	
	override toString() => ""+mine
}


def doings() {
	p = Parent()
	p[1] = Child("fred")
	p[1][2] = "thekid"
	p[1, 3] = "another kid"

	"" + p
}

~~~~~
//##z240. ensure ref writes back to ref for array ops 1

b = [[1,2],[1,2]]:

def doings() String{
	b[0, 0]=23
	"" + b
}

~~~~~
//##z241. ensure ref writes back to ref for array ops 2

b = a[[1 2]: , [1 2]:]:

def doings() String{
	b[0, 0]=23
	"" + b
}

~~~~~
//##z242. ensure ref writes back to ref for array ops 3
sdf = [ 0:, 3:, -1]:

def doings() String{
		
	sdf[0]  = 9:
	sdf[2]  = 9
	//test both methods to set elements in the ref array
	return "" + sdf
}

~~~~~
//##z243. was a bug now its ok

def g() => 50

y2 = g()!
	
def doings(){
	r2 = y2
	
	"it's done: " + r2
}

~~~~~
//##z244. was suffering from conc modi exception

def doings() {
	calls := ""
	done :=false
	
	xx int:
	ninset = every(xx) { return xx }
	
	hicnt = 10
	
	a := 9
	
	xx  = async{
		onchange(a){ 
			hicnt++
			//continue//prevents the ++ from returning anything
			;;
		}
		every(a){ 
			9
		}
		post{123}
	}
	
	a = 66
	a:close()
	
	await(xx ; xx == 123)
	await(ninset ; ninset == 9)//value before closed
	//return called on close
	"" + [ninset, xx, a, xx.isClosed()]
}

~~~~~
//##z245. parfor on void ret
def doings(){
	
	res = parfor(a in [1 2 3 4 5]){
		g=a
		'ok'
	}

	"" + res
}

~~~~~
//##z246. parforsync on void ret

def doings(){
	
	res = parforsync(a in [1 2 3 4 5]){
		g=a
		'ok'
	}

	"" + res
}

~~~~~
//##z247. parforsync on void ret variant 2

def dd() void {}

def doings(){
	res1 = parfor(a in [1 2 3 4 5]){
		dd()
	}
	
	res2 = parforsync(a in [1 2 3 4 5]){
		dd()
	}

	"" + [r is Object for r in res1, r is Object for r in res2]
}

~~~~~
//##z248. user defined ref

class GPURef<X>(type Class<?>[]) < com.concurnas.runtime.ref.Local<X>(type)

def doings(){
	writeComplete boolean:GPURef
	{writeComplete = true}!
	"nice: " + writeComplete //wasnt recognised as being gettable before
}

~~~~~
//##z249. bug concerning ref in closed state
def doings(){
	hasset boolean:
	
	x int:
	setclose boolean:
	
	every(x){
		await(setclose)
		every(x){//should be triggered as x set, even though its now closed
			hasset = true
		}
	}

	x = 88
	x:close()
	setclose=true
	
	await(hasset)//used to never be triggered
	
	"ok"
}

~~~~~
//##z250. bug concerning ref in closed state pt 2
from com.concurnas.lang.pulsar import *
from java.time import Duration

def doings(){
	pp Pulsar = new FrozenPulsar()
	ctime = pp.currentTime
		
	beenCalled1 String:
	
	waite := pp.schedule(ctime - Duration.ofSeconds(10))
	
	await(waite)
	waite.close()
	
	every(waite){
		beenCalled1 = "yup"
	}
	await(beenCalled1)
	
	pp.stop()
	
	"called: " + [beenCalled1, waite:isClosed()]
}

~~~~~
//##z251. bug concerning ref in closed state pt 3
def doings(){
	hasset boolean:
	
	x int:
	setclose boolean:
	
	every(x){
		await(setclose)
		every(x){//should be triggered as x set, even though its now closed
			hasset = true
		}
	}
	
	trans{//great, works in transactions too!
		x = 88
		x:close()
	}
	setclose=true
	
	await(hasset)//used to never be triggered
	
	"ok"
}

~~~~~
//##z252. onchange every options - onlyclose
def doings(){
	mything int:
	done boolean:
	every(mything; onlyclose ){
		done = true
	}
	mything.close()
	await(done)
	
	"done"
}

~~~~~
//##z253. onevery onlyclose pickup change if first is closed - array
def doings(){
	mything1 int:
	mything2 int:
	
	mything1:close()
	mything2:close()
	//mything1 = 9
	
	cnt int: = 0
	xx = [mything1: mything2:]
	every(xx; onlyclose){
		cc = changed.getChanged().length
		cnt += cc
	}
	
	await(cnt; cnt == 2)
	
	"done"
}

~~~~~
//##z254. onevery onlyclose pickup change if first is closed - array - in place
def doings(){
	mything1 int:
	mything2 int:
	
	mything1:close()
	mything2:close()
	//mything1 = 9
	
	cnt int: = 0
	every([mything1: mything2:]; onlyclose){
		cc = changed.getChanged().length
		f=mything1:
		cnt += cc
	}
	
	await(cnt; cnt == 2)
	
	"done"
}

~~~~~
//##z255. onevery onlyclose pickup change if first is closed - ref set
def doings(){
	mything1 int:
	mything2 int:
	
	mything1:close()
	mything2:close()

	from com.concurnas.runtime.cps import ReferenceSet
	liveSet = new ReferenceSet()
	liveSet.add(mything1:)
	liveSet.add(mything2:)
	
	cnt int: = 0
	every(liveSet; onlyclose){
		cc = changed.getChanged().length
		f=mything1:
		cnt += cc
	}
	
	await(cnt; cnt == 2)
	
	"done"
}

~~~~~
//##z256. onevery onlyclose pickup change if first is closed - list set etc
def doings(){
	mything1 int:
	mything2 int:
	
	mything1:close()
	mything2:close()

	
	cnt int: = 0
	xx = set()
	xx.add(mything1:)
	xx.add(mything2:)
	
	every(xx; onlyclose){
		cc = changed.getChanged().length
		f=mything1:
		cnt += cc
	}
	
	await(cnt; cnt == 2)
	
	"done"
}

~~~~~
//##z257. onevery onlyclose pickup change if first is closed - indivuduals
def doings(){
	mything1 int:
	mything2 int:
	
	mything1:close()
	mything2:close()

	
	cnt int: = 0
	
	every(mything1:, mything2:; onlyclose){
		cc = changed.getChanged().length
		f=mything1:
		cnt += cc
	}
	
	await(cnt; cnt == 2)
	
	"done"
}

~~~~~
//##z258. add item to reference set, ensure changes monitored
def doings(){
	mything1 int:
	mything2 int:
	
	from com.concurnas.runtime.cps import ReferenceSet
	liveSet = new ReferenceSet()
	liveSet.add(mything1:)
	
	cnt int: = 0
	every(liveSet; onlyclose){
		cc = changed.getChanged().length
		cnt += cc
	}
	
	liveSet.add(mything2:)
	mything2:close()
	await(cnt; cnt == 1)
	
	"done"
}

~~~~~
//##z259. add item to reference set, ensure changes monitored - close both
def doings(){
	mything1 int:
	mything2 int:
	
	from com.concurnas.runtime.cps import ReferenceSet
	liveSet = new ReferenceSet()
	liveSet.add(mything1:)
	mything1:close()//close both
	
	cnt int: = 0
	every(liveSet; onlyclose){
		cc = changed.getChanged().length
		cnt += cc
	}
	
	liveSet.add(mything2:)
	mything2:close()
	await(cnt; cnt == 2)
	
	"done"
}

~~~~~
//##z260. add item to reference set which is already closed post start

def doings(){
	mything1 int:
	mything2 int:
	mything3 int:
	
	from com.concurnas.runtime.cps import ReferenceSet
	liveSet = new ReferenceSet()
	liveSet.add(mything1)
	mything1:close()
	//mything1 = 9
	
	cnt int: = 0
	every(liveSet; onlyclose){
		cc = changed.getChanged().length
		cnt += cc
	}
	
	liveSet.add(mything2)
	mything2:close()
	
	mything3:close()
	liveSet.add(mything3)
	
	await(cnt; cnt == 3)
	
	"done"
}

~~~~~
//##z261. onlyclose on refsets for onchange variants
def doings(){
	mything1 int:
	mything2 int:
	
	from com.concurnas.runtime.cps import ReferenceSet
	liveSet = new ReferenceSet()
	liveSet.add(mything1)
	//mything1 = 9
	
	cnt int: = 0
	onchange(liveSet; onlyclose){
		cc = changed.getChanged().length
		cnt += cc
	}
	
	mything1:close()//regular
	liveSet.add(mything2)
	mything2:close()//close post add
	
	
	await(cnt; cnt == 2)
	
	"done"
}

~~~~~
//##z262. regular every with bugfixes for ref set as par above
def doings(){
	mything1 int:
	mything2 int:
	mything3 int:
	
	from com.concurnas.runtime.cps import ReferenceSet
	liveSet = new ReferenceSet()
	liveSet.add(mything1)
	mything1 = 11
	//mything1 = 9
	
	cnt int: = 0
	every(liveSet){
		cc = changed.getChanged().length
		cnt += cc
	}
	
	liveSet.add(mything2)
	mything2 = 11
	
	mything3 = 11
	liveSet.add(mything3)
	
	await(cnt; cnt == 3)
	
	"done"
}

~~~~~
//##z263. await listen to close
from com.concurnas.lang.pulsar import RealtimePulsar
from java.time import Duration

def doings(){
	res boolean:
	
	every(new RealtimePulsar().after(Duration.ofSeconds(1))){
		res.close()
	}
	
	await(res)
	"ok"
}

~~~~~
//##z264. array of refs
def doings() {
	xx = new Integer:[2]//needs NEW com/concurnas/bootstrap/runtime/ref/LocalArray
	xx[0] = 1
	xx[1] = 2
	
	"" + xx //+ xx[0]:// + what:
}

~~~~~
//##z265. matrix of refs
def doings() {
	xx = new Integer:[2, 2]
	
	xx[0, 0] = 1
	xx[1, 0] = 2
	xx[0, 1] = 3
	xx[1, 1] = 4
	
	"" + xx
} 

~~~~~
//##z266. ref on its own
def doings() {
	something = new Integer:
	"ok " + something:isSet()
} 

~~~~~
//##z267. ref on its own
def doings() {
	something = new int:
	"ok " + something:isSet()
} 

~~~~~
//##z268. ref array on its own
def doings() {
	xx = [new Integer: new Integer:]
	xx[0] = 1
	xx[1] = 2
	
	"" + xx// + what:
}

~~~~~
//##z269. ref array on its own
def doings() {
	xx = [new int: new int:]
	xx[0] = 1
	xx[1] = 2
	"" + xx
} 

~~~~~
//##z270. ref array on its own mixed
def doings() {
	n=2
	something = new Integer:
	xx = new Integer:[n]
	xp = new Integer[n]:
	"ok " + [something:isSet() xp:isSet()]
}

~~~~~
//##z271. ref array on its own mixed matrix
def doings() {
	n=2
	xx = new Integer:[2, n]
	//xx = [A ; B]
	
	xx[0, 0] = 1
	xx[1, 0] = 2
	xx[0, 1] = 3
	xx[1, 1] = 4
	
	"" + xx
}   

~~~~~
//##z272. ref array on its own 3d matrix init
def doings() {
	n=3

	xx = new Integer:[2,2,n](2)
	
	"" + xx// + what:
}
