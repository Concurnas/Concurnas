//##1. basic single ref case static and class

class TheClass{
	def doings() {
	
		done int:
		x int: = 9
	
		progress = 0
	
		def afunc() => 12
	
		def reg(){
			a = 10
			onchange(x) { if(x==10 ){ done = afunc() + a + x;} }//x getter is called immediatly
		}
	
		reg()
		
		x=8
		progress += 1
		x=10
		progress += 1
		
	 	"hi " + [done, progress] 
	}
}

def doingsown() {

	done int:
	x int: = 9

	progress = 0

	def afunc() => 12

	def reg(){
		a = 10
		onchange(x) { if(x==10 ){ done = afunc() + a + x;} }//x getter is called immediatly
	}

	reg()
	
	x=8
	progress += 1
	x=10
	progress += 1
	
 	"hi " + [done, progress, progress] 
}


def doings() {
	a = ((new TheClass()).doings())!
	b = doingsown()!
	"" + [a, b]
}


~~~~~
//##2. changed variable

def doings() {

	done int:
	x int: =10
	stuff := " "
	
	onchange(x) { 
					stuff += "" + x: +":" + changed.getChanged()[0]: + ", " 
					if(x==10){done=1;} }//x getter is called immediatly

	for(xa in [8,99, 911, -1, 10]){
		x =xa  
	}
	
 	"hi " + [done] + stuff 
}

~~~~~
//##3. calling of local function within initalizer - no extra arguments to bind

def doings() {
	foCall := 1
	done int:
	x int: =10
	stuff := " "
	
	def getFo() => x: //foCall++; x: 
	//z = getFo&()
	
	onchange(getFo()) { stuff += "" + (x as int:) +":" + (changed.getChanged()[0]: as int:) + ", " 
					    if(x==10){done=1;} }//x getter is called immediatly

	for(xa in [8,99, 911, -1, 10]){
		x =xa  
	}
	
 	"hi " + [done] + stuff 
}

~~~~~
//##4. calling of local function within initalizer - extra arguments to bind

def doings() {
	foCall:=0
	done int:
	x int: =10
	stuff := " "
	
	def getFo() => foCall++; x: 
	//z = getFo&()
	
	onchange(getFo()) { stuff += "" + (x as int:) +":" + (changed.getChanged()[0]: as int:) + ", " 
					    if(x==10){done=1;} }//x getter is called immediatly

	for(xa in [8,99, 911, -1, 10]){
		x =xa  
	}
	
 	"hi " + [done, foCall] + stuff 
}


~~~~~
//##5. calling of local function within initalizer - extra arguments to bind - via funcref so more args

def doings() {
	foCall:=0
	done int:
	x int: =10
	stuff := " "
	
	def getFo() => foCall++; x: 
	z = getFo&()
	
	onchange(z()) { stuff += "" + (x as int:) +":" + (changed.getChanged()[0]: as int:) + ", " 
					    if(x==10){done=1;} }//x getter is called immediatly

	for(xa in [8,99, 911, -1, 10]){
		x =xa  
	}
	
 	"hi " + [done, foCall] + stuff 
}

~~~~~
//##6. chain of onchanges - with ref creation

class The{
	def doings() {
		done int:
		x int: =10
		
		a String: = ""
		res = onchange(x) {
		 	x*2
		 }
		
		res2 := onchange(res) {
			if(res==20){done=1;}
		 	v = res * 2
		 	a += v + ", "
		 	v
		}
		
		for(xa in [8,99, 911, -1, 10]){
			x =xa  
		}
		
		await(res2 ; res2==40)//to ensure second one has 'finished'
		
	 	"hi " + [done, res, res2] + a
	}
}

def doings() => (new The()).doings()

~~~~~
//##7. chain of onchanges - with ref pre creation 
class The{
	def doings() {
		done int:
		x int: =10
		
		a String: = ""
		res int:
		res = onchange(x) {
		 	x*2
		 }
		
		res2 int:
		res2 := onchange(res) {
			if(res==20){done=1;}
		 	v = res * 2
		 	a += v + ", "
		 	v
		}
		
		for(xa in [8,99, 911, -1, 10]){
			x =xa  
		}
		await(res2 ; res2==40)//to ensure second one has 'finished'
		
	 	"hi " + [done, res, res2] + a
	}
}

def doings() => (new The()).doings()

~~~~~
//##8. locally bound variables get overwritten 

class The{
	def doings() {
		done int:
		done2 int:
		x int: =10
		
		res = onchange(x) {
			if(x==10){done=1;}
			x int = 99 // we overrite x here so we'd expect to use this value
			x
		 }
		 
		 res2 = onchange(x) {
			if(x==10){done2=1;}
			{
				x int = 99 //change is locally bound only
			}
			x
		 }
		
		for(xa in [8,99, 911, -1, 10]){
			x =xa  
		}
		
		await(res, res2 ; res==99 and res2==10)
	 	"hi " + [done, done2, res, res2]
	}
}

def doings() => (new The()).doings()

~~~~~
//##9. inner function var bindings wihtin the onchange

class The{
	def doings() {
		done int:
		y int:=9
		x int: =111
		a=10
		b := 11
		f=0
		res = onchange(x) {
			if(x==10){done=1;}
			f=0
			//f used to not being bound correctly
			def g() { x + y+f}
			g() + a + b
		 }
		
		for(xa in [8,99, 911, -1, 10]){
			x =xa  
		}
		
		res5 = onchange(res){res+1}
		
		await(res, x, y ;res==40)
		
	 	"hi " + [done, res]
	}
}

def doings() => (new The()).doings()

~~~~~
//##10. onchange multiple refs

class The{
	def doings() {
		x int:=1
		y int:=1
		
		done int:
		done2 int:
		
		series := 0
		
		res = onchange(x, y) {
			v = {x + y}
			series++
			if(x==10){done=1111;}
			if(y==10){done2=69;}
			v
		}
		
		for(xa in [8, 10]){
			x = xa  
		}
		
		check = done
		first = "" + series
		series = 0
		
		for(xa in [8, 10]){
			y = xa  
		}
		
		x:close()
		y:close() //should have no negative side effects
		//also we do not expect x or y to be triggered again
		check2 = done2
		second = "" + series
		await(res ; res == 20)
		
	 	"hi " + [check, check2, res] + [first,second]
	}
}

def doings() => (new The()).doings()

~~~~~
//##11. big random test - many iso

class TheClass{
	def doings() =>	"hi "
}

xs := ""

def afunc(a String){ xs += (a == "first a" or a == "first b") };

spawn = afunc&(? String)

def doings1() {
	a = {spawn("first a"); ((new TheClass()).doings()) + "a"}!
	b = {spawn("first b"); ((new TheClass()).doings()) + "b"}!
	"" + [a, b]
}

def doings() {
	a = doings1()!
	b = doings1()!
	"" + [a,b] + (xs <> "hi")
	//what xs gets set to is nondet
}


~~~~~
//##11.b big random test - many iso - with notificaiton

class TheClass{
	def doings() {
		done int:
		x int: = 9
	
		progress = 0
		def afunc() => 12
		def reg(){
			a = 10
			onchange(x) { if(x==10 ){ done = afunc() + a + x;} }//x getter is called immediatly
		}
	
		reg()
		
		x=8
		progress += 1
		x=10
		progress += 1
		
	 	"hi " + [ progress] 
	}
}

def doings1() {
	a = ((new TheClass()).doings())! + "a"
	b = ((new TheClass()).doings())! + "b"
	"" + [a, b]
}


def doings() {
	a = doings1()!
	b = doings1()!
	"" + [a,b] 
}

~~~~~
//##11.c big random test - simple case to validate non pause of iso
//pause on second iso used to cause init to pause and state in _runExe to mess up
//may still be a problem in the future

class The{
	def doings() {
		done int:
		x int: =10
		a String: = ""
		res:= onchange(x) {
		 	x*2
		 }
		 
		 onchange(res) {
		 	a += "w: " + res
		 
		 	{done = 1}
		 }
		 
		 x=59
		
	 	"hi " + [done, res] + a
	}
}

def doings() => (new The()).doings()

~~~~~
//##12. ensure that binding operates on localvar and not all refnames

class O{
	public x int:=1
}

def doings() {
	myO = new O()
	x :=9
	res = onchange( x){
		myO.x + x
	}
	
	myO.x = 99
	x=101
	
	"" + res
}

~~~~~
//##13.a nested lambda def

def doings() {
	x int:
	y int:
	done boolean:
	
	aaaa=9	
	onchange(x, y) {
		u=10.f
		d2 = def () { h="hi there"; j=aaaa;true }
		if( d2()){//d() and
			done = true
		}
	}
	x=10
	y=10
	x:close()
 	"hi " + done
}

~~~~~
//##13.b nested lambda def with funcref

def doings() {
	x int:
	y int:
	done boolean:
	
	aaaa=9	
	onchange(x, y) {
		u=10.f
		def abb()  { h="hi there"; j=aaaa;true }
		d2 = abb&()
		if( d2()){
			done = true
		}
	}
	x=10
	y=10
	x:close()
 	"hi " + done
}

~~~~~
//##13.c nested lambda def and a funcref complex case...

from java.util import ArrayList

class The{
	def doings() {
		x int:=1
		y int:=1
		
		done int:
		done2 int:
		
		series := 0
		
		res = onchange(x, y) {
			v = {x + y}
			series++
			if(x==10){done=1111;}
			if(y==10){done2=69;}
			def c() { x:isClosed() or y:isClosed() }
			d = def () { x:isClosed() or y:isClosed() }
			if( c() or d() ){
				//System.err.println("uh oh" + [x:isClosed(), y:isClosed()])
			}
			v
		}
		
		for(xa in [8, 10]){
			x = xa  
		}
		
		check = done
		first = "" + series
		series = 0
		
		for(xa in [8, 10]){
			y = xa  
		}
		
		x:close()
		y:close() //should have no negative side effects
		//also we do not expect x or y to be triggered again
		check2 = done2
		second = "" + series
		await(res ; res==20)
	 	"hi " + [check, check2, res] + [first,second]
	}
}

def doings() => (new The()).doings()

~~~~~
//##13.d nested lambda def and a funcref EVEN MORE complex case...

from java.util import ArrayList

class The{
	def doings() {
		x int:=1
		y int:=1
		
		done int:
		done2 int:
		
		series := 0
		
		res = onchange(x, y) {
			v = {x + y}
			series++
			if(x==10){done=1111;}
			if(y==10){done2=69;}
			def c() { x:isClosed() or y:isClosed() }
			d = def () { false }
			if( c()  ){
				//System.err.println("uh oh" + [x:isClosed(), y:isClosed()])
			}
			v
		}
		//d not getting bound?
		
		for(xa in [8, 10]){
			x = xa  
		}
		
		check = done
		first = "" + series
		series = 0
		
		for(xa in [8, 10]){
			y = xa  
		}
		
		x:close()
		y:close() //should have no negative side effects
		//also we do not expect x or y to be triggered again
		check2 = done2
		await(res ; res==20)
		second = "" + series
	 	"hi " + [check, check2, res] + [first,second]
	}
}

def doings() => (new The()).doings()


~~~~~
//##14. close operates as expected - single
//not a great test but ok

def doings() {
	x int:=1
	check boolean:
	from java.util import ArrayList
	got : = 0
	call : =1
	
	
	onchange(x) {
		d = def () { x==3 }
		la = "" + call++ + ": " + [x]
		//System.out.println("oncahnge: " + la);
		got++
		
		if(  d() ){
			check = true
		}
	}
	
	for(a in [2,3]){
		x = a
	}
	hh=0
	x:close()
 	">>>>>>>>>>>>result: " + [check, got]
}

~~~~~
//##14.b close operates as expected - double
def doings() {
	x int:=1
	y int:=1
	check boolean:
	from java.util import ArrayList
	got : = 0
	call : =1
	
	
	onchange(x, y) {
		d = def () { x==3 and y==3 and got == 4}
		got++
		if(  d() ){
			
			check = true
		}
	}
	
	for(a in [2,3]){
		x = a
		y=a
	}
	hh=0
	x:close()
	y:close()
	//this is best one can do cos above code is non-det ::how can this be programatically determined?
	
	//await(got ; got == 4 ) 
	
 	">>>>>>>>>>>>result: " + [check, got==4]
}

~~~~~
//##15. ensure await working

class TheClass{
	def doings() =>	"hi "
}

def afunc(a String, goes String:){ goes =""+( a=="first a" or a=="first b") };

spawn = afunc&(? String, ? String:)

def doings1(r1 String:, r2 String:) {
	a = {spawn("first a", r1); ((new TheClass()).doings()) + "a"}!
	b = {spawn("first b", r2); ((new TheClass()).doings()) + "b"}!
	"" + [a, b]
}


def all(items String:[]){
	for(a in items){
		if(a ==""){ return false }
	}
	return true
}

def doings() {
	r1 := "";
	r2 := "";
	r3 := "";
	r4 := "";

	a = doings1(r1, r2)!
	b = doings1(r3, r4)!
	
	itesm = [r1: r2 r3 r4]
	
	await(itesm ; all(itesm) )
	
	"" + [a,b] + itesm
}


~~~~~
//##16. await - ensure local changes inside await are persisted globally

glob = ""
globM = [1,2]

class MyClass(public k int, public d int){
	this() { this(12, 12) }
}

def doings() {
	xs int:=2
	
	mc = new MyClass()
	
	one = ""
	oneM = [1,2]
	
	fella1 = {globM[1]=100; mc.d=69; "" + [globM, mc.d] }! //makes a copy of globM, changes not persisted
	//copy of mc taken
	
	await(xs ; {mc.k=99; one = "hi"; glob="hi"; globM[0]=10; oneM[0] = 10; true;} )
	//we expect changes to local and module level variabes above to be persisted
	//we also expect mc to be redirected to 99
	
	fella2 = {"" + [globM, mc.d] }!//takes another copy, post above changes we expect to see them
	
	"" + [xs, one, glob, oneM, globM, fella1, fella2, mc.k, mc.d]
}

~~~~~
//##17. ref async block await consistancy

def doings() {
	xs int:=2
	wonger = "orig"
	
	sploint := 88
	cc int: = sploint:
	
	await(xs ; {sploint := 100:; wonger="set in await";  true;} )
	//we expect the ref to be overwritten since its redefined in here
	
	fella2 = {sploint:=999:; wonger="set in asycnblock"; "" + sploint }!
	//redefining the ref above should have no effect on the main one below since its a copy
	
	"" + [xs, wonger, sploint, cc, sploint: &<> cc:]
}

~~~~~
//##18. ensure exceptions passed up the stack on await

def ttt() => 5>4
def doings() {
	xs int:=2
	
	msg="fail"
	ok=false
	try{
		await(xs ; { if(ttt()){ throw new RuntimeException("uh oh") } true })
	}
	catch(e){
		msg = e.getMessage()
		ok = true
	}
	//great, we expected the exception to be thrown up the stack
	
	"" + [ok, msg]
}


~~~~~
//##19. exceptions not caught and passed up stack on onchange
def ttt() => 5>4
def doings() {
	xs int:=2
	
	msg="fail"
	ok=false
	try{
		f=onchange(xs) { if(ttt()){ throw new RuntimeException("uh oh") } true }
		//shouldnt crash lol
	}
	catch(e){
		msg = e.getMessage()
		ok = true
	}
	//not expected to do anything
	
	"" + [ok, msg]
}

~~~~~
//##20. multiawait


def doings() {
	xs int:=2
	
	res = onchange(xs) { xs+100 }
	res2 = onchange(xs) { xs+101 }
	
	for(a in [1,2,1000]){
		xs = a
	}
	
	await(res, res2 ; res > 1000 and res2 > 1000)
	
	"" + [res, res2]
}

~~~~~
//##21. assign ref to locally bound var

def doings() {
	xs int:=2
	res = onchange(a=xs) 	{a+6119	}
	res2 = onchange(a:=xs) 	{a+6119	}
	res3 = onchange(a=xs:) 	{a+6119	}
	res4 = onchange(a:=xs:) 	{a+6119	}
	
	a=9.0 
	
	for(a in [1,2,1000]){
		xs = a
	}
	
	await(res, res2, res3, res4 ; res > 6121 and res2>6121 and res3>6121 and res4>6121 )
	
	"" + [res, res2, res3, res4]
}

~~~~~
//##22. ensure onchange exceptions not boiled up to initiator
def ttt() => 5>4
def doings() {
	xs int:=2
	done :=false
	
	msg="no msg as expected"
	ok=true
	try{
		onchange(xs) { {done=true; if(ttt()){ throw new RuntimeException("uh oh") }  } }
		//ends in throw; note this has no impact on try catch
		//also this has no impact on main program strucuture
		//TODO: add custom handler for above exceptions to boil up when uncaught
	}
	catch(e){
		msg = e.getMessage()
		ok = false
	}
	//great, we expected the exception to be thrown up the stack
	
	xs = 9
	
	await(done ; done)
	
	"" + [ok, msg]
}

~~~~~
//##23. more than one onchange variable subscription

def doings() {
	xs int:=2
	xs2 int:=2
	res = onchange(a=xs, b=xs2) 	{a+b	}
	res2 = onchange(a:=xs) 	{a+6119	}
	res3 = onchange(a=xs:) 	{a+6119	}
	res4 = onchange(a:=xs:) 	{a+6119	}
	
	a=9.0 
	
	for(a in [1,2,1000]){
		xs = a
	}
	
	xs2 = 2000
	
	await(res, res2, res3, f=res4 ; res > 1000 and res2>1000 and res3>1000 and res4>1000 and f>1000 )
	
	"" + [res, res2, res3, res4]
}

~~~~~
//##24. double notification registration

def doings() {
	xs int:=2
	cnt := 0
	res3 = onchange(a=xs, b=a) 	{cnt++; a +b 	}//should be ok
	a=9.0 
	
	for(a in [1,2,500]){
		xs = a
	}
		
	await(r1=res3, f=r1 ; r1+f >== 2000   )//works for await too!
	
	"" + [res3, cnt]
}

~~~~~
//##25. ensure can write to classfield correctly

def doings() {
	xs int:=2
	//stateobject.a=8. is a classfield ref - there was a bug here before
	res3 = onchange(a=xs) 	{a=8; 7000 	}//should complain
	xs=3
	"" + [res3, xs]
}


~~~~~
//##26. nested onchange
def doings() {
	xs int:=2
	done := false
	
	res3 = onchange(a=xs){
		f=onchange(a) { 
			p=a+69; 
			p
			}
		done = a==3
		
		f
	}
	xs=3
	await(done;done)
	xs=30
	await(res3 ; res3 == 99)
	"" + [res3]
}

~~~~~
//##27. nested await

def doings() {
	xs int:=2
	did:=false
	await(a=xs ; {await(a ; a==2); did=true; did} )
	
	"" + [xs, did]
}

~~~~~
//##28. nested onchange - 3 levels

def doings() {
	xs int:=2
	done := false
	done2 := false
	
	res3 = onchange(a=xs){
		f=onchange(xs) { 
			f2=onchange(a) { 
					a+69
				}
			done2 = a==3
			f2
			}
		done = a==3
		f
	}
	xs=3
	await(done ; done)
	xs=3
	await(done, done2 ;  done and done2)
	xs=30
	"" + [res3]
}

~~~~~
//##29. every

def doings() {
	xs :=1
	pp := ""
	//bug below: pp += xs, used to get called on ref version, fixed!
	every(xs){ pp += xs;}
	//System.err.println("wake: " + [xs, pp]);
	
	await(pp;pp.length()==xs)
	xs=2
	await(pp;pp.length()==xs)
	xs=3
	
	await(pp;pp.length()==xs)
	
	"" + [xs, pp]
}

~~~~~
//##30. catch errors on init

def ttt() => 2>1
def doings() {
	xs :=1
	
	def getXS() int: {
		if(ttt()){ throw new Exception("As expected") }
		return xs
	}
	
	catchAwait = "fail"
	catchchange = "fail"
	catchevery = "fail"
	
	try{
		await(a=getXS() ; a + 1>0 )
	}catch(e){
		catchAwait = "ok"
	}
	
	try{
		onchange(a=getXS()){ y=a + 1>0 }
	}catch(e){
		catchchange = "ok"
	}
	
	try{
		every(a=getXS()){ y=a + 1>0 }
	}catch(e){
		catchevery = "ok"
	}
	
	"" +[catchAwait, catchchange, catchevery]//+ [res, ]
}



~~~~~
//##31. this and super

open class Parent{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 11;}
	
	protected xxx = 99
	protected def par() => 80
}

class MyClass extends Parent{


	def aFunc(a int:) => "one" + a

	private thing = 9

	def doings() {
		xs :=1
		
		f = every(xs){ aFunc(xs) + [thing , super.xxx, par()] }
		
		"" + f
	}
}

def doings() => (new MyClass()).doings()

~~~~~
//##32. break onchange

def doings() {
	xs int:
	twice :=0
	res = onchange(xs){
		if(xs==2){
			break { 99}//set res and exit
		}
		twice++ //once from continue one from normal return
		111		
	}
	
	xs = 1
	correctSubs = xs:getListnerCount():get()==1 and xs:get()==1
		
	await(res;res==111)
	xs=2
	await(res;res==99)
	
	"" + [res, twice==1, correctSubs, xs:getListnerCount()]
}

~~~~~
//##33. break continue onchange

def doings() {
	xs int:
	twice :=0
	res = onchange(xs){
		if(xs==3){
			continue 77 //writes to res and carries on
		}
		elif(xs==2){
			break {99}//set res and exit
		}
		twice++ //once from continue one from normal return
		111		
	}
	
	xs = 1
	correctSubs = xs:getListnerCount():get()==1 and xs:get()==1
		
	await(res;res==111)
	xs=2
	await(res;res==99)
	xs=3
	await(res;res==111)
	
	"" + [res, twice==2, correctSubs, xs:getListnerCount()]
}

~~~~~
//##34. break continue return onchange

def doings() {
	xs int:
	twice :=0
	res = onchange(xs){
		if(xs==4){
			return 44
		}
		elif(xs==3){
			continue 77 //writes to res and carries on
		}
		elif(xs==2){
			break {99}//set res and exit
		}
		twice++ //once from continue one from normal return
		111		
	}
	
	xs = 1
	correctSubs = xs:getListnerCount():get()==1 and xs:get()==1
		
	await(res;res==111)
	xs=2
	await(res;res==99)
	xs=3
	await(res;res==111)
	xs=4
	await(res;res==44)
	
	await(li=xs:getListnerCount();li==0)
	
	"" + [res, twice==2, correctSubs, xs:getListnerCount()]
}

~~~~~
//##35. no return on break is required

def doings()  {
	xs int:
	log := ""
	res = onchange(xs){
		log += xs
		if(xs==6){
			log += " go into break"
			break//just escapes with no write to var
		}
		log += " no break ret 9"
		9	
	}
	xs=24
	await(log;log=="24 no break ret 9")
	xs=6
	await(log;log<>"24 no break ret 9" and log=="24 no break ret 96 go into break")
	"" + [res, log]
}

~~~~~
//##36. no return on continue is required

def doings()  {
	xs int:
	log := ""
	res = onchange(xs){
		log += xs
		if(xs==6){
			log += " go into continue"
			continue//just escapes with no write to var
		}
		log += " got ret 9"
		9	
	}
	xs=24
	await(log;log=="24 got ret 9")
	xs=6
	await(log;log<>"24 got ret 9")
	"" + [res, log]
}

~~~~~
//##37. no return on return is required


def doings()  {
	xs int:
	log := ""
	res = onchange(xs){
		log += xs
		if(xs==6){
			log += " go into so ret"
			return//just escapes with no write to var
		}
		log += " got ret 9"
		9	
	}
	xs=24
	await(log;log=="24 got ret 9")
	xs=6
	await(log;log=="24 got ret 96 go into so ret")
	"" + [res, log]
}

~~~~~
//##38. always returns

def doings()  {
	xs int:
	
	def doit(xs int:, v int)   {
		res = onchange(xs){
			if(xs>7){ 
				return 69
			}
			return 99
		}
		xs = v
		res
	}
	r1 = doit(xs, 100)
	r2 = doit(xs, 1) //just check this rets a ref
	
	await(li=xs:getListnerCount();li==0) //no more subs!
	
	"" + [r1, r2]
}

~~~~~
//##39. break and ret

def doings()  {
	xs int:
	
	def doit(xs int:, v int)   {
		res = onchange(xs){
			if(xs>7){ 
				break 69
			}
			return 99
		}
		xs = v
		res
	}
	r1 = doit(xs, 100)
	r2 = doit(xs, 1) //just check this rets a ref
	"" + [r1, r2]
}

~~~~~
//##40.a end cont

def doings()  {
	xs int:
	
	def doit(xs int:, v int)   {
		res = onchange(xs){
			if(xs>7){ 
				return 69
			}
			continue 99
		}
		xs = v
		res
	}
	r1 = doit(xs, 100)
	r2 = doit(xs, 1) //just check this rets a ref
		
	"" + [r1, r2]
}

~~~~~
//##40.b end cont

def doings()  {
	xs int:
	
	def doit(xs int:, v int)   {
		res = onchange(xs){
			if(xs>7){ 
				return 69
			}
			break 99
		}
		xs = v
		res
	}
	r1 = doit(xs, 100)
	r2 = doit(xs, 1) //just check this rets a ref
		
	"" + [r1, r2]
}

~~~~~
//##41. break cont on own

def doings1()  {
	xs int:
	res = onchange(xs){
		continue 8
	}
	xs=24
	"" + res
}

def doings2()  {
	xs int:
	res = onchange(xs){
		break 8
	}
	xs=24
	"" + res
}

def doings() => "" + [doings1(), doings2()]

~~~~~
//##42. not sure why this is hear but broke before probably so include as test

def doings()  {
	xs int:
	log := ""
	res = onchange(xs){
		log += xs
		if(xs==6){
			log += " go into so ret"
			break 10//just escapes with no write to var
		}
		log += " got ret 9"
		return 8
	}
	xs=6
	await(log;log=="6 go into so ret")
	xs=24
	await(log;log<>"6 go into so ret")
	"" + [res, log]
}

~~~~~
//##43. dun expect a npe here

def doings()  {
	xs int:
	log := ""
	res = onchange(xs){
		log += xs
		if(xs==6){
			log += " go into so ret"
			break 10//just escapes with no write to var
		}
		log += " got ret 9"
		break 8 //same with continue
	}
	xs=24
	await(log;log=="24 got ret 9")
	xs=6
	await(log;log=="24 got ret 96 go into so ret")
	"" + [res, log]
}

~~~~~
//##44. break in await etc

def doings()  {
	xs int: = 6
	await(xs;{ if(xs==6) {return true}; true})//ok
	await(xs;{ if(xs==6) {break true}; true})
	await(xs;{ if(xs==6) {continue true}; true})
	
	"" + xs
}

~~~~~
//##44.b break in await etc

def doings()  {
	xs int: = 6
	await(xs;{ 	return true	})//
	//await(xs;{ 	break true	})//ugh ignore nobody will do this
	//await(xs;{ 	continue true	})//ugh ignore nobody will do this
	"" + xs
}

~~~~~
//##45. self writer

def doings() String{
	res := 1
	done boolean:
	res = onchange(res){
		if(res>==10){
			return 100
		}
		res+1
	}
	res=1
	await(res;res==100)
	"" + res
}

~~~~~
//##46. fix bug in default calling of hashcode from tostring on object level

public class Fiely(public ff double:){
//tostring -> calls hashcode, oh but there is no fiber at this stage
}

def sss() => false

public class MyC{
	a = new Fiely(1)
	
	def doings() {
		a.ff = try{ 444. } catch(e){ 4. } //this fella wipes out the stack! - this used to be a problem! - now we have the stack state tracking
		"hh " + a <> "asdasd" //a => hashcode to str - as defualt since no default str
	}
}

def doings() String{
	mmm = new MyC()
	"" + mmm.doings()
}


~~~~~
//##47. this test may not belong here

//a tricky case of stack frame restoration

def sss() => false

def tryme(a int) Object{
	xs:=1
	res int:=onchange(xs){
		r = "START"
		try{
			if(sss()){
				k=1
			}
			//hidden goto to *
		}catch(e){
			p="DO NTHING"
		}
		//<-stack restoration code here, so we push the label early (and try to double visit oh well, thats filtered out later)
		//*
		lo=999
		444
	}
	xs=2
	res
}


def doings() String{
	"" + [tryme(1), tryme(4)]
}

~~~~~
//##49. onchange on arrays of refs

def all(items int:[]){
	for(a in items){
		if(a <> 100){ return false }
	}
	return true
}

a1 := 10
a2 := 20

f = [a1:, a2:]
	
def tryMe(){

	res := onchange(f){a1+a2 +f[0]+f[1] }
	res2 := every(f){a1+a2 +f[0]+f[1] }
	
	res3 := onchange(f = [a1:, a2:]){a1+a2 +f[0]+f[1] }
	res4 := every(f = [a1:, a2:]){a1+a2 +f[0]+f[1] }

	a1 = 30
	fellas = [res: res2 res3 res4]
	await(fellas ; all(fellas))
	
	return "" + fellas
}

def doings() String{
	"" + tryMe()
}

~~~~~
//##50. list of refs

def all(items int:[]){
	for(a in items){
		if(a <> 100){ return false }
	}
	return true
}

from java.util import ArrayList

a1 := 10
a2 := 20

f = new ArrayList<int:>()
f.add(a1:)
f.add(a2:)
	
def getF() => f
	
def tryMe(){

	res := onchange(f){a1+a2 +f[0]+f[1] }
	res2 := every(f){a1+a2 +f[0]+f[1] }
	
	res3 := onchange(f = getF()){a1+a2 +f[0]+f[1] }
	res4 := every(f = getF()){a1+a2 +f[0]+f[1] }

	a1 = 30
	fellas = [res: res2 res3 res4]
	await(fellas ; all(fellas))
	
	return "" + fellas
}

def doings() String{
	"" + tryMe()
}

~~~~~
//##51. set of refs

def all(items int:[]){
	for(a in items){
		if(a <> 100){ return false }
	}
	return true
}

from java.util import HashSet

a1 := 10
a2 := 20

f = new HashSet<int:>()
f.add(a1:)
f.add(a2:)
	
def getF() => f
	
def tryMe(){

	def conv(x HashSet<int:>, n int) => (x.toArray()[n] as Integer: )

	res := onchange(f){a1+a2 +conv(f, 0) + conv(f, 1) }
	res2 := every(f){a1+a2 +conv(f, 0)+conv(f, 1) }
	
	res3 := onchange(f = getF()){a1+a2 +conv(f, 0)+conv(f, 1) }
	res4 := every(f = getF()){a1+a2 +conv(f, 0)+conv(f, 1) }

	a1 = 30
	fellas = [res: res2 res3 res4]
	await(fellas ; all(fellas))
	
	return "" + fellas
}

def doings() String{
	"" + tryMe()
}

~~~~~
//##52. hashset of refs

def all(items int:[]){
	for(a in items){
		if(a <> 100){ return false }
	}
	return true
}

from java.util import HashMap

a1 := 10
a2 := 20

f = new HashMap<int:, int:>()
f.put(a1:, a1:)
f.put(a2:, a2:)
	
def getF() => f
	
def tryMe(){


	res := onchange(f){a1+a2 +f[a1:] + f[a2:] }
	res2 := every(f){a1+a2 +f[a1:]+f[a2:] }
	
	res3 := onchange(f = getF()){a1+a2 +f[a1:]+f[a2:] }
	res4 := every(f = getF()){a1+a2 +f[a1:]+f[a2:] }

	a1 = 30
	fellas = [res: res2 res3 res4]
	await(fellas ; all(fellas))
	
	return "" + fellas
}

def doings() String{
	"" + tryMe()
}

~~~~~
//##53. basic refset

from com.concurnas.runtime.cps import ReferenceSet

k1 := 1
k2 := 10

//the set iteration seems to be failing

def doings(){
	
	rs = new ReferenceSet()
	rs.add(k1)
	rs.add(k2)
	
	tot = onchange(a=rs, x=k1){ x+k1 + k2 }

	k1=8

	return "" +tot
}

~~~~~
//##54. refset await and every

from com.concurnas.runtime.cps import ReferenceSet

k1 := 1
k2 := 10

//the set iteration seems to be failing

def doings(){
	rs = new ReferenceSet()
	rs.add(k1)
	rs.add(k2)
	
	tot = onchange(a=rs, x=k1){  [x+k1 + k2, ""+a.contains(changed.getChanged()[0]:), a.contains(x:), a==rs]; }
	
	k1=8	
	d :=0
	//here we return so we only want one thing, and expect an unregeistration after complete
	tot2 = every(a=rs, x=k1){ d++; return [x+k1 + k2, ""+a.contains(changed.getChanged()[0]:), a.contains(x:), a==rs]; }
	
	await(rs ; k2==10 )
	await(tot2)

	return "" + [tot, tot2, d==1]
}

~~~~~
//##54.b refset await and every - array version

from com.concurnas.runtime.cps import ReferenceSet

k1 := 1
k2 := 10

//the set iteration seems to be failing

def doings(){
	rs = new ReferenceSet()
	rs.add(k1)
	rs.add(k2)
	
	tot = onchange(a=rs, x=k1){  [x+k1 + k2 ""+a.contains(changed.getChanged()[0]:) a.contains(x:) a==rs]; }
	
	k1=8	
	d :=0
	//here we return so we only want one thing, and expect an unregeistration after complete
	tot2 = every(a=rs, x=k1){ d++; return [x+k1 + k2 ""+a.contains(changed.getChanged()[0]:) a.contains(x:) a==rs]; }
	
	await(rs ; k2==10 )
	await(tot2)

	return "" + [tot, tot2, d==1]
}

~~~~~
//##55. refset add and remove post creation

from com.concurnas.runtime.cps import ReferenceSet

k1 := 1
k2 := 10
buddy : =100

//the set iteration seems to be failing

def doings(){
	rs = new ReferenceSet()
	rs.add(k1)
	rs.add(k2)
	
	alcount := 0
	sofar := ""
	tot = onchange(a=rs){alcount++; if(alcount==2){a.add(buddy) } a.remove(changed); sofar+=""+(changed.getChanged()[0] as int:) + "=> "; sofar }
	
	k1=9
	
	await(alcount; alcount==1)
	await(tot ; tot == "9:=> " )

	k1=69
	k2=50
	await(alcount; alcount>==2)
	await(tot; tot=="9:=> 50:=> ")

	//note that now buddy is included in the watch list...
	buddy = 99
	await(alcount; alcount>==3)
	await(tot; tot=="9:=> 50:=> 99:=> ")

	return "" + [alcount, tot]//its nice when stuff just works
}

~~~~~
//##z56 async 1 simple
xs := 1

def doings(){
	
	done := 0
	 async{
		every(xs) {
			done++;
		}
	}
	
	xs = 2
	
	await(done ; done==2)
	return "k done: " + done 
}

~~~~~
//##56.b close bug

xs := 1

def doings(){
	
	done := 0
	 //async{
		every(xs) {
			done++;
		}
	//}
	
	xs = 2
	
	await(done ; done==2)
	xs:close()
	return "k done: " + done //should be triggered just twice
}

~~~~~
//##z57 async 2 simple

xs := 1

def doings(){
	
	done := 0
	 async{
		onchange(xs) {
			done++;
		}
	}
	
	xs = 2
	
	await(done ; done==1)
	return "k done: " + done
}

~~~~~
//##z58 async pre called

xs := 1

def doings(){
	prepended := false
	done := 0
	 async{
	 	pre{
	 		prepended=true;
	 	}
	 
		onchange(xs) {
			done++;
		}
	}
	
	xs = 2
	
	await(done ; done==1)
	return "k done: " + [done, prepended]
}

~~~~~
//##z59 async pre can be used in main block

xs := 1

def doings(){
	prepended := 0
	done := 0
	 async{
	 	pre{
	 		prepended++;
	 	}
	 
		onchange(xs) {
			done++;
			prepended++;
		}
				
	 	post{
	 		System.err.println("end");
	 	}
	}
	
	xs = 2
	
	await(done, prepended ; done==1 and prepended==2)
	return "k done: " + [done, prepended]
}

~~~~~
//##z60 async do every for all just latter for onchange

xs := 1

def doingsa(){
	//System.out.println("start")
	done1 := 0
	done2 := 0
	 async{
	 	every(xs){
	 		done1++;
	 	}
		onchange(xs) {
			done2++;
		}
	}
	//for above every gets all updates, onchange only gets those post initial
	
	xs = 99
	
	await(done1, done2 ; done1==2 and done2==1)
	//System.out.println("end")
	return "k done: " + [done1, done2, xs] //2, 1, 99
}

def range(n int){
	m=0
	while(m++ < n){ m-1 }  
}

def doings(){
	"" + for(a in range(5)) { doingsa() } 
}

~~~~~
//##z61 async ensure registration performed once only

xs := 99

def doings(){
	done1 := 0
	done2 := 0
	 async{
	 	every(xs){
	 		done1++;
	 	}
		every(xs) {
			done2++;
		}
	}
	//ensure that initial registration is performed on a set
	//so the above async invokation gets called once only
	
	await(done1, done2 ; done1==1 and done2==1)
	return "k done: " + [done1, done2, xs]
}

~~~~~
//##z62 ensure that expr args declared for every onchange are visible

xs := 99

def doings(){
	zzz String:
	done1 := 0
	 async{
	 	every(f=xs){
	 		zzz=("enter 1 : " + f)
	 		done1++;
	 	}
	}
	await(done1 ; done1==1 )
	await(zzz)
	return "k done: " + [done1, xs, zzz]
}

~~~~~
//##z63 ensure that expr args declared for every onchange are visible more than one

xs := 1
xs2 := 100

def doings(){
	zzz String: = ""
	zzz2 String: = ""
	done1 := 0
	done2 := 0
	 async{
	 	onchange(f=xs){
	 		zzz +=("enter 1 : " + f)
	 		done1++;
	 	}
		onchange(f2=xs2) {
	 		zzz2 +=("enter 2 : " + f2)
	 		done2++;
		}
	}
	
	
	xs2=101
	xs = 2
	
	await(done1, done2 ; done1==1 and done2==1 )
	await(zzz)
	await(zzz2)
	
	
	"complete: " + [done1, done2, zzz, zzz2]
}

~~~~~
//##z64 stateObj var refernces on subsequent local var defs get remapped

//so here the second flava gets remapped because 'flava' is already taken on the stateobject

xs := 1
xs2 := 100

def doings(){
	zzz String: = ""
	zzz2 String: = ""
	done1 := 0
	done2 := 0
	 async{
	 	onchange(flava=xs){
	 		zzz +=("enter 1 : " + flava)
	 		done1++;
	 	}
		onchange(flava=xs2) {
			//this gets remapped to something else - flava$u0
			//etc
	 		zzz2 +=("enter 2 : " + flava)
	 		done2++;
		}
	}
	
	
	xs2=101
	xs = 2
	
	await(done1, done2 ; done1==1 and done2==1 )
	await(zzz)
	await(zzz2)
	
	
	"complete: " + [done1, done2, zzz, zzz2]
}

~~~~~
//##z65 infer return type

xs := 1

def doings(){
	zzz String: = ""
	done1 := 0
	xxx=async{
	 	onchange(f=xs){
	 		zzz +=("enter 1 : " + f + ", ")
	 		done1++;
	 		"hi"
	 	}
	}
	
	cnt := 0
	onchange(xxx) { cnt++ ; }
	
	xs = 1
	xs = 2
	
	await(cnt ; cnt == 2 )
	
	
	"complete: " + [cnt, xxx, zzz]
}

~~~~~
//##z66 infer return type many invokations and writes to return

xs := 1

def doings(){
	zzz String: = ""
	done1 := 0
	xxx=async{
	 	onchange(f=xs){
	 		zzz +=("enter 1 : " + f + ", ")
	 		done1++;
	 		"hi"
	 	}
	 	onchange(f=xs){
	 		zzz +=("enter 1 : " + f + ", ")
	 		done1++;
	 		"hi"
	 	}
	}
	
	cnt := 0
	onchange(xxx) { cnt++ ; }
	
	xs = 1
	xs = 2
	
	await(cnt ; cnt == 4 )
	
	
	"complete: " + [cnt, xxx, zzz]
}

~~~~~
//##z67 break support within async

xs := 1

def doings(){
	zzz String: = ""
	nevermore String: = "ok"
	done1 := 0
	xxx=async{
	 	onchange(f=xs){
	 		zzz +=("enter 1 : " + f + ", ")
	 		done1++;
	 		break "hi"
	 	}
	 	onchange(f=xs){//should never get called
	 		nevermore = "fail - i got set"
	 		"hi"
	 	}
	}
	
	cnt := 0
	onchange(xxx) { cnt++ ; }
	
	xs = 1
	xs = 2
	
	await(cnt ; cnt == 2 )
		
	"complete: " + [cnt, xxx, zzz, nevermore]
}

~~~~~
//##z68 continue support within async

xs := 1

def doings(){
	zzz String: = ""
	nevermore String: = "fail - i was not set"
	done1 := 0
	xxx=async{
	 	onchange(f=xs){
	 		zzz +=("enter 1 : " + f + ", ")
	 		done1++;
	 		continue "hi"//ret and proceed as normal
	 	}
	 	onchange(f=xs){//this gets executed, nothing too exciting going on here...
	 		nevermore = "ok"
	 		"hi"
	 	}
	}
	
	cnt := 0
	onchange(xxx) { cnt++ ; }
	
	xs = 1
	xs = 2
	
	await(cnt ; cnt == 4 )
		
	"complete: " + [cnt, xxx, zzz, nevermore]
}

~~~~~
//##z69 return support within async

xs := 1

def doings(){
	zzz String: = ""
	nevermore String: = "ok"
	done1 := 0
	fin String:
	
	xxx=async{
	 	onchange(f=xs){
	 		zzz +=("enter 1 : " + f + ", ")
	 		done1++;
	 		return "hi" //return and halt all further execution
	 	}
	 	onchange(f=xs){
	 		nevermore = "fail"
	 		"hi"
	 	}
	 	post{ fin = "leave" }
	}
	
	cnt := 0
	onchange(xxx) { cnt++ ; }
	
	xs = 1
	xs = 2
	
	await(cnt ; cnt == 1 )
	await(xxx ; xxx:isClosed() )//it can take some time...
			
	"complete: " + [done1, cnt, xxx, zzz, nevermore, xxx:isClosed(), fin]
}

~~~~~
//##z70 async edxplicit return type infer type

xs := 1

def doings(){
	zzz String: = ""
	
	xxx=async  {
		pre{ xfs String="" }
	 	onchange(f=xs){
	 		zzz +=("enter 1 : " + f + ", ")
	 		xfs = "hi" //return and halt all further execution
	 		xfs = "hi2"
	 		xfs
	 	}
	 	every(xs){//do nothing
	 		xfs = "hi3"
	 		//""
	 		xfs
	 	}
	}
	
	//xxx - should be written to 3 times
	
	cnt := 0
	every(xxx) { cnt++ ; }
	
	xs = 100
	
	await(cnt ; cnt == 3 )
			
	"complete: " + [xs, cnt, xxx, zzz,]
}

~~~~~
//##z71 async edxplicit return type return type defined
xs := 1

def doings(){
	zzz String: = ""
	
	xxx=async  {//explicit return type for async, should be able to infer type of rhs
		pre { xfs String =""}
	 	onchange(f=xs){
	 		zzz +=("enter 1 : " + f + ", ")
	 		xfs = "hi" //return and halt all further execution
	 		xfs = "hi2"
	 		xfs
	 	}
	 	every(xs){//do nothing
	 		xfs = "hi3"
	 		xfs
	 	}
	}
	
	//xxx - should be written to 3 times
	
	cnt := 0
	every(xxx) { cnt++ ; }
	
	xs = 100
	
	await(cnt ; cnt == 3 )
			
	"complete: " + [xs, cnt, xxx, zzz]
}

~~~~~
//##z72 async edxplicit return type return type defined ref of ref

xs := 1

def doings(){
	zzz String: = ""
	
	xxx=async {//explicit return type for async, should be able to infer type of rhs
		pre{xfs String: = ""}
	 	onchange(f=xs){
	 		zzz +=("enter 1 : " + f + ", ")
	 		xfs = "hi" //return and halt all further execution
	 		xfs = "hi2"
	 		//xfs=69
	 		//"hi3"
	 		xfs
	 	}
	 	every(xs){//do nothing
	 		xfs = "hi3"
	 		//""
	 		xfs
	 	}
	}
	
	//xxx - should be written to 3 times
	
	cnt := 0
	every(xxx) { cnt++ ; }
	
	xs = 100
	
	await(cnt ; cnt == 3 )
			
	"complete: " + [xs, cnt, xxx, zzz]
}

~~~~~
//##z72b async edxplicit return type return type defined ref of ref

xs := 1

def doings(){
	zzz String: = ""
	
	xxx=async {//explicit return type for async, should be able to infer type of rhs
		pre{xfs String: } //b no init thing here
	 	onchange(f=xs){
	 		zzz +=("enter 1 : " + f + ", ")
	 		xfs = "hi" //return and halt all further execution
	 		xfs = "hi2"
	 		//xfs=69
	 		//"hi3"
	 		xfs
	 	}
	 	every(xs){//do nothing
	 		xfs = "hi3"
	 		//""
	 		xfs
	 	}
	}
	
	//xxx - should be written to 3 times
	
	cnt := 0
	every(xxx) { cnt++ ; }
	
	xs = 100
	
	await(cnt ; cnt == 3 )
			
	"complete: " + [xs, cnt, xxx, zzz]
}

~~~~~
//##z73 return is permitted inside onchange async etc

xs := 1

def doings(){
	xfs String:
	xfs2 String:
	async {
	 	onchange(f=xs){
	 		xfs = "hi: " + f
	 		return //return after first
	 	}
	}
	
	onchange(f=xs){
 		xfs2 = "hi: " + f
 		return //return after first
 	}
		
	xs = 100
	xs = 200
	
	"complete: " + [xs, xfs, xfs2] //just process first and then quit
}

~~~~~
//##z74 continue is permitted

xs := 1

def doings(){
	xfs String:
	xfs2 String:
	async {
	 	onchange(f=xs){
	 		xfs = "hi: " + f
	 		continue
	 	}
	}
	
	onchange(f=xs){
 		xfs2 = "hi: " + f
 		continue
 	}
		
	xs = 100
	xs = 200
	
	await(xfs ; xfs == "hi: 200")
	await(xfs2 ; xfs2 == "hi: 200")
	
	"complete: " + [xs, xfs, xfs2] //just process first and then quit
}

~~~~~
//##z75 return var can be used within onchange args

xs := 1

def doings(){
	
	xxx =async   {
		pre{xfs = ""}
	 	onchange(f=xs){
	 		xfs = "hi" 
	 		xfs = "hi2"
	 		return xfs //inf loop otherwise since feedback on xfs as par above
	 	}
	}
		
	cnt := 0
	every(xxx) { cnt++ ; }
	
	xs = 100
	await(cnt ; cnt == 1 )
			
	"complete: " + [xs, xxx]
}

~~~~~
//##z76 break can be used in onchange at end

xs := 1

def doings(){
	
	xxx =async   {
		pre{xfs = ""}
	 	onchange(f=xs){
	 		xfs = "hi "
	 		break xfs
	 	}
	}
		
	cnt := 0
	every(xxx) { cnt++ ; }
	
	xs = 100
	await(cnt ; cnt == 1 )
			
	"complete: " + [xs, xxx]
}

~~~~~
//##z77 avoid splice confusion

xs := 1

class MyClass{
	public f = 22

}

def doings(){
	
	f=22
	mc = new MyClass()
	
	xxx =async  {
	 	onchange(xs){
	 		f=10
	 		mc.f=44
	 		"hi " + [f, mc.f]
	 	}
	}
		
	cnt := 0
	every(xxx) { cnt++ ; }
	
	xs = 100
	await(cnt ; cnt == 1 )
			
	"complete: " + [xs, xxx]
}

~~~~~
//##z78 spawn async instances


def range(n int) => {m=0; while(m++ < n){ m-1 } }

def doingsa(){
	xs := 1
	
 	xxx = async{
 	 	onchange(xs){
	 		"hi "
	 	}
 	} 
			
	cnt := 0
	every(xxx) { cnt++ ; }
	
	xs = 100
	await(cnt ; cnt == 1 )
	"complete: " + [xs, xxx]
}

def doings(){
	li = for(a in range(5)) { doingsa()! } 

	"" + li
}

~~~~~
//##z79 exceptions still count as counts

xs := 1

def doings(){

	def throwme(){
 		throw new Exception("excep") 
	}
	
 	xxx = {
 	 	onchange(xs){
 	 		throwme()
	 		"hi " 
	 	}
 	} 
			
	cnt := 0
	every(xxx) { cnt++ ; }
	
	//exceptions still count as counts :)
	//then the thing closes
	
	xs = 100
	xs = 101
	await(cnt ; cnt == 1 )//await should throw
	
	"complete: " + [cnt, xs]
}

~~~~~
//##z80 ensure exceptions thrown ok in isocore

def ttt() => 2>1
def doings(){

	def moi() int {
		if(ttt()){ throw new Exception("As expected") }
		10
	}
	
	def ano() int{
		try{
			moi()
		
		}
		catch(e){}
		
		7
	
	}

	ok = {
		ret = [1,2]
	
		ano()
		ano()
		
		ret
	}! ///looks ok
	
	return "was ok: " + ok 
}

~~~~~
//##z81 close triggers event to close async

theX := 1

def doings(){
	cnt : = 0
	endCalled String:
	
	async  {
		onchange(theX){ cnt +=1 }
		post{//triggered on cleanup as all subscriptions are closed
			endCalled = "yup"
		}
	}

	theX=100
	theX:close()
	
	await(cnt ; cnt==1)
	await(endCalled)
	
	return "was ok: " + [cnt,endCalled] //endCalled
}

~~~~~
//##z82 exception triggers close triggers event to close async

theX := 1


def doings(){
	cnt : = 0
	endCalled String:
	
	async  {
		onchange(theX){ cnt++ }
		post{//triggered on cleanup as all subscriptions are closed
			endCalled = "yup"
		}
	}
	

	theX=100
	theX:setException(new Exception("uh oh "))
	
	await(endCalled)
	
	return "was ok: " + [endCalled] //endCalled
}

~~~~~
//##z83 exceptions still count as counts in async

xs := 1

def doings(){

	def throwme(){
 		throw new Exception("excep") 
	}
	
 	xxx = {
 	 	onchange(xs){
 	 		throwme()
	 		"hi " 
	 	}
 	} 
	
	wantClose String:
	
	cnt := 0
	async {
		every(xxx) { cnt++ ; }
		post{
	 		wantClose = "closed"
	 	}
	}
	
	//exceptions still count as counts :)
	//then the thing closes
	
	xs = 100
	xs = 101
	await(cnt ; cnt == 1 )//await should throw
	
	expectExcep = "fail"
	try{
		y=xxx
	}
	catch(e){
		expectExcep = "ok " + e.getMessage()
	}//and we expect an exception to be thrown...
	
	"complete: " + [cnt, xs, wantClose, expectExcep]
}

~~~~~
//##z84 check i didnt break copy

from com.concurnas.lang.precompiled import RefHelper

def doings() {
	
	thingy Object = RefHelper.getIntegerRef(12):
	
	"" + [System.identityHashCode(thingy) == System.identityHashCode(thingy@) ]
}

~~~~~
//##z85 check copy on ints etc works ok

from com.concurnas.lang.precompiled import RefHelper

def doings() {
	
	thingy = RefHelper.getIntegerRef(12) // now the thing returned from the rhs gets accepted thus setting the fact that its a system java class
	o Integer= thingy@
	"" + [System.identityHashCode(thingy) == System.identityHashCode(thingy@) ]
}

~~~~~
//##z86 close ref written to on nothing more to do

def doings(){
	xs int:
	xxx = async {
		onchange(xs){ xs }
	}
	
	xs = 10
	xs:close()
	
	await(xs ; xs:isClosed())
		
	await(xxx ; xxx:isClosed())

	"it works"
}

~~~~~
//##z87 onchange can be within an async block

xs := 1

def doings(){
	done boolean:
	{
		onchange(xs){ done = true }
	}!
		
	//+ above but using a fun, and using a lambda so x3
	//+nested asycn with above pattern
	
	xs=22
	
	//await(done)
			
	"Done"
}

~~~~~
//##z88 a complex nested case of await setting things correctly

def doings() {
	xs := 1
	wonger String:
	thingy = "nope2"
	async{
		pre{
			thingy = "nope"
		}
		onchange(xs){
			x = 8 //thingy below should be set for external usage
			await(xs ; { thingy="set in await " + xs; x = xs;  true;} )
			j=9
			//x is local var which should be written to
			thingy += [j, x]
		}	
		post{
			wonger = thingy//check this is readable from pre block
		}
	}
	
	xs = 7//failure to set this wont trigger the await
	xs:close()//now wrap it allul
	
	
	"" + [xs, wonger]
}

~~~~~
//##z89 ensure nested await is ok

xs int:=2

def doings() {
	await(a2=xs ; 
		{await(a2 ;
			 a2==2 and xs ==2); true; 
		}
		  )
	"cool"
}

~~~~~
//##z90 minor tweaking of await to support no ret required

xs int:=2
def doings() {
	onchange(xs){
		await(xs ; xs == 2)//doesnt return anything
	}
	
	def vv(){
		await(xs ; xs == 2)//doesnt return anything
	}
	
	vv()
	
	"cool"
}

~~~~~
//##z91 another minor await tweak

xs int:=2
def doings() {
	//this is probably fair, await iself is an interjection, so it shouldnt really return anything
	await(a2=xs ; { await(a2 ; a2==2); true } )
	"just fine"
}

~~~~~
//##z92 catches exceptions as expected
def ttt() => 2>1
def doings(){

	def moi() int {
		if(ttt()){ throw new Exception("As expected") }
		10
	}

	ok = {
		ret = [1,2]
	
		try{
			moi()
		}
		catch(e){
			ret[0] = 100
		}
		
		try{
			moi()
		}
		catch(e){
			ret[1] = 200
		}
		
		ret
		
	}
	return "was ok: " + ok 
}

~~~~~
//##z93 creations in pre block correctly mapped 

def doings() {
	xs := 1
	wonger String:
	async{
		pre{
			thingy String = "ok" //gets remapped to assingn existing so that bytecode can be correctly gennerated
			thingy2 = "also ok"
			{aaa = 55}//this does not get created in the stateobject
		}
		onchange(xs){
			x = 8 //thingy below should be set for external usage
			await(xs ; { x = xs;  true;} )
			j=9
		}	
		post{
			//wonger += "ok"//check this is readable from pre block
			wonger = ""+[thingy, thingy2]
		}
	}
	
	xs = 7//failure to set this wont trigger the await
	xs:close()//now wrap it allul
	
	"" + [xs, wonger]
}

~~~~~
//##z94 try catch inside async block

def doings(){
	ok = {
		ret = 2
	
		try{
			j=9
		}
		catch(e){
			f = "hi"
		}
		
		ret
	}!


	return "was ok: " + ok 
}

~~~~~
//##z95 check references to other nested functions work ok

def doings() {
	xs =1
	
	def getXS() int {
		return xs
	}
	
	def trymoi() int {
		getXS(); 
	}
	
	z = trymoi()
	
	"" + z
}

~~~~~
//##z96 ref to other nested more complex


def doings() {
	xs :=1
	
	def getXS()  {
		 xs
	}
	
	def trymoi()  {
		getXS(); 
	}
	
	z = trymoi()
	
	"" + z
}

~~~~~
//##z97 ref to other nested more complex2


def doings() {
	xs :=1
	
	def getXS()  {
		 xs
	}
	
	def trymoi(xs int)  {
		xs + getXS(); //ensure correct xs spliced in
	}
	
	z = trymoi(11)
	
	"" + z
}

~~~~~
//##z98 ref to other nested more complex2 in neste

def doings() {
	xs :=1
	
	
	def trymoi(xs int:)  {//n2
		def getXS()  {//n2 gets passed in
			 xs
		}
	
		xs + getXS(); //ensure correct xs spliced in
	}
	
	z = trymoi(10)
	
	"" + z
}


~~~~~
//##z99 big test to ensuer doing nesting correctly

def doingsaa() {
	xs :=1
	
	def getXS()  {
		 xs
	}
	
	
	z = getXS()
	
	"" + z
}


def doingsa() {
	xs :=1
	
	
	def trymoi(xs int:)  {//n2
		def getXS()  {//n2 gets passed in
			 xs
		}
	
		xs + getXS(); //ensure correct xs spliced in
	}
	
	z = trymoi(10)
	
	"" + z
}



def doingsb() {
	xs :=1
	
	def getXS()  {
		 xs
	}
	
	def trymoi(xs int)  {
		xs + getXS(); //ensure correct xs spliced in
	}
	
	z = trymoi(11)
	
	"" + z
}

def doingsc() {

	done int:
	x int: = 9

	progress = 0
		a = 10
		onchange(x) { if(x==10 ){ done = a + x;} }//x getter is called immediatly

	
	x=8
	progress += 1
	x=10
	progress += 1
	
 	"hi " + [done, progress, progress] 
}

def doings() {
	"" + [doingsaa(), doingsa(), doingsb(), doingsc()]
}


~~~~~
//##z100 another nester thing to test


def doings() {

	done int:
	x int: = 9

	progress = 0

	def afunc() => 12

	def reg(){
		a = 10
		onchange(x) { if(x==10 ){ done = afunc() + a + x;} }//x getter is called immediatly
	}

	reg()
	
	x=8
	progress += 1
	x=10
	progress += 1
	
 	"hi " + [done, progress, progress] 
}

~~~~~
//##z101 even more complex


def doings() {

	done int:
	x int: = 9

	progress = 0

	def afuncla() => x
	
	def body() => afuncla() + 100

	def reg(){
		a = 10
		onchange(x) { if(x==10 ){ done = body() + a + x;} }//x getter is called immediatly
	}

	reg()
	
	x=8
	progress += 1
	x=10
	progress += 1
	
 	"hi " + [done, progress, progress] 
}

~~~~~
//##z102 nesting on two levels


def doings1() {
	xs int:=2
	done boolean :
	
	res3 = onchange(a=xs){
		fo=16 
		done=true
		def gg() => fo
		a+69 + gg()
	}
	
	xs=3
	await(done ; done)
	
	"" + [res3]
}

def doings2() {
	xs int:=2
	done boolean :
	
	res3 = onchange(a=xs){
		fo=16 
		done=true
		def gg() => fo
		a+69 + gg()
	}
	
	xs=3
	await(done ; done)
	
	"" + [res3]
}

def doings() => "" + [doings1(), doings2()]


~~~~~
//##z103 ensure correct type passed to state object

def doings() {
	xs int:=2
	a=89.
	
	res = onchange(xs) 	{
		a+6119	//doubles take up two slots, int + everything else just one etc
	}
	
	xs=9
	
	"" + res
}

~~~~~
//##z104 correct preblock types inclusion mapping etc

xs := 1

def doings(){
	prepended := false
	done := 0
	fuu=12
	xys := 0
	 async{
	 	pre{
	 		//we override the type here for use within the main block
	 		xxla = 50 //use within the preblock, but noewhere else
	 		fuu boolean=true; //new and overriden tpye
	 		pow = 50+xxla
	 		prepended=true//overwrite global var to ref 
	 	}
	 
		onchange(xs) {
			if(fuu){
				done++;
				h = 6 if fuu else 99
				xys=h + pow
			}
		}
	}
	
	xs = 2
	
	await(done, xys, prepended ; done==1 and xys <> 0 and prepended)
	return "k done: " + [done, prepended, xys]
}

~~~~~
//##z105 correct preblock types inclusion mapping etc with a ret

xs := 1

def doings(){
	prepended := false
	done := 0
	 async{
	 	pre{
	 		prepended=true;
	 		fuu=true
	 	}
	 
		onchange(xs) {
			done++;
			xs = 6 if fuu else 99
			return //a ret!
		}
	}
	
	xs = 2
	
	await(done ; done==1)
	return "k done: " + [done, prepended, xs]
}

~~~~~
//##z106 vaar decl in pre works ok for every

xs := 99

def doings(){
	zzz String:
	done1 := 0
	 async{
	 	pre{f=xs: }
	 	every(f){
	 		zzz=("enter 1 : " + f)
	 		done1++;
	 	}
	}
	await(done1 ; done1==1 )
	await(zzz)
	return "k done: " + [done1, xs, zzz]
}

~~~~~
//##z107 vars in pre

xs := 99

def doings(){
	zzz String:
	done1 := 0
	 async{
	 	pre{
	 		def lamx() => xs: 
	 		
	 		def doit(xs int) => xs+  lamx()//nicely correctly bound
	 	
	 		//fa =lamx()
	 		dfg:=9 //should not be created on state object
	 		glower:=66 +dfg //cool gets created on state object
	 		flak: = doit(1)//init for this created in so init method
	 	}
	 	every(flak){
	 		zzz=("enter 1 : " + [flak, glower])
	 		done1++;
	 	}
	}
	await(done1 ; done1==1 )
	await(zzz)
	return "k done: " + [done1, xs, zzz]
}

~~~~~
//##z108 nested funcs in pre

xs := 99

def doings(){
	zzz String:
	done1 := 0
	 async{
	 	pre{
	 		def lamx() {return xs: }
	 		glag:=xs:
	 	}
	 	every(lamx()){
	 		zzz=("enter 1 : " + [xs, glag])
	 		done1++;
	 	}
	}
	await(done1 ; done1==1 )
	await(zzz)
	return "k done: " + [done1, xs, zzz]
}

~~~~~
//##z109 nested lambda outside of pre

xs := 99

def doings(){
	zzz String:
	done1 := 0
	lamx = def () {return xs: }
	
	 async{
	 	pre{
	 		//lamx = def () {return xs: }
	 		f=lamx()
	 	}
	 	every(xs){
	 		zzz=("enter 1 : " + [lamx(), f])
	 		done1++;
	 	}
	}
	await(done1 ; done1==1 )
	await(zzz)
	return "k done: " + [done1, xs, zzz]
}

~~~~~
//##z110 nested lambde defined in pre

xs := 99

def doings(){
	zzz String:
	done1 := 0
	 async{
	 	pre{
	 		lamx = def () {return xs: }
	 		f=lamx()
	 	}
	 	every(xs){
	 		zzz=("enter 1 : " + [f, ])
	 		done1++;
	 	}
	}
	await(done1 ; done1==1 )
	await(zzz)
	return "k done: " + [done1, xs, zzz]
}

~~~~~
//##z111 nested lambde defined in pre used in every

xs := 99

def doings(){
	zzz String:
	done1 := 0
	def doit(){
		 a=999
		 async{
		 	pre{
		 		lamx = def () {return xs: }
		 	}
		 	every(xs){
		 		zzz=("enter 1 : " + [lamx(), a])
		 		done1++;
		 	}
		}
	}
	
	doit()
	
	await(done1 ; done1==1 )
	await(zzz)
	return "k done: " + [done1, xs, zzz]
}

~~~~~
//##z112 nested lambde defined in pre used in every trigger

xs := 99

def doings(){
	zzz String:
	done1 := 0
	def doit(){
		 a=999
		 async{
		 	pre{
		 		lamx = def () {return xs: }
		 	}
		 	every(lamx()){
		 		zzz=("enter 1 : " + [lamx(), a])
		 		done1++;
		 	}
		}
	}
	
	doit()
	
	await(done1 ; done1==1 )
	await(zzz)
	return "k done: " + [done1, xs, zzz]
}

~~~~~
//##z113 fix trigger vars

xs := 99

def doings(){
	zzz String:
	done1 := 0
	brown :=9
	 async{
	 	every(f=xs){
	 		zzz=("enter 1 : " + [f, brown])
	 		done1++;
	 	}
	}
	await(done1 ; done1==1 )
	await(zzz)
	return "k done: " + [done1, xs, zzz]
}

~~~~~
//##z114 takes args correctly

xs := 99

def doings(){
	zzz String:
	done1 := 0
	def doit(){
		 a=999
		 async{
		 	pre{
		 		lamx = def (xs  int:) {return xs: }
		 	}
		 	every(xs){
		 		zzz=("enter 1 : " + [lamx(4:), a])
		 		done1++;
		 	}
		}
	}
	
	doit()
	
	await(done1 ; done1==1 )
	await(zzz)
	return "k done: " + [done1, xs, zzz]
}


~~~~~
//##z115 nested asyncs

xs := 99

def doings(){
	zzz String:
	done1 :=0
	 async{
	 	pre{ p =xs:} 
	 	every(xs){
			async{
			 	every(p){
			 		zzz=("enter 1 : " +[xs, p])
			 		done1++;
			 	}
			}


	 	}
	}
	
	await(done1)
	
	return "k done: " + zzz
}

~~~~~
//##z115 can return and use stuff from pre

theX := 1

def doings(){
	cnt=.0
	x= async {
		pre{ cnt2 int = 0; }
		onchange(theX){ 
			j=9
			cnt2 =88
			g=100
			//cnt2
			[cnt2,100] //cnt
		}
	}

	theX+=100
	
	return "was ok: "  + [x, cnt] //not accesible
}

~~~~~
//##z116 seems not impacted by the ret bug

def doings() {
	xs int:=2
	wonger = "orig"
	
	sploint := 88
	
	fella2 = onchange(xs){sploint:=999:; wonger="set in asycnblock"; return "" + sploint }
	
	xs=3
	
	"" + [sploint, wonger, fella2, xs]
}

~~~~~
//##z117 used to not correctly pass in the types and ret type

def afunc(a String, goes String:){ goes =""+( a=="first a" or a=="first b") };

def fail(r1 String:) String: {
	 xx =  {r1="hi"; r1:get()}!
	 xx
}

def doings() {
	r1 := "";
	r2 := "";
	r3 := "";
	r4 := "";

	a = "" + fail(r1)
	
	itesm = [r1:, r2, r3, r4]
	
	
	"" + [itesm, a]
}

~~~~~
//##z118 double two space

xx double[]:
f = [1. 2. 3.] 

def doings(){
	
	xx=f //previously there was a problem in setting this as arrays take up 32 bit but double entires take 64
	//we were not checking for the fact that the double array was an array (so 32 bit) and were assuming it was 64 bit cos
	//type was double

	"" + xx
}

~~~~~
//##z119 as above

//should be able to use cnt - not passed in correctly?
theX := 1

def doings(){
	cnt=.0
	x= async {
		pre{ cnt2 int = 0; }
		onchange(theX){ 
			j=9
			cnt2 =88
			g=100
			//cnt2
			cnt=99
			[cnt2,cnt, 100] //returns a ref array...
		}
	}

	theX+=100
	
	return "was ok: "  + [x, cnt] //not accesible
}

~~~~~
//##z120 check nesting 

def doings() {
	xs int:=2
	done boolean :
	
	res3 = onchange(a=xs){
	
				
		f=every(xs) {
		
			def gg() { 88888  }	//binding fail>
		 
			done=true
			
			gg()
			
			}
		//done = a==3
		f
	}
	
	xs=3
	await(done ; done)
	xs=3
	await(done ;  done )
	xs=30
	"" + [res3]
}