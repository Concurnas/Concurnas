//##1. vars - 1. String
Hello world

~~~~~
//##1. vars - 1. ints
1

~~~~~
//##1. vars - 1. long
4147483647

~~~~~
//##1. vars - 1. float
5.0

~~~~~
//##1. vars - 1. double
5.0

~~~~~
//##1. vars - 1. char
c

~~~~~
//##1. vars - 1. byte, short
6

~~~~~
//##1. vars - 1. boolean
true

~~~~~
//##2. expr - 1. basic string concatination
Hello world

~~~~~
//##2. expr - 2. basic string concatination with non string
Hello 12

~~~~~
//##2. expr - 3. def string concat 1
a69

~~~~~
//##2. expr - 3. def string concat 2
69a

~~~~~
//##2. expr - 3. def string concat 3
a69a

~~~~~
//##2. expr - 3. def string concat 4
90a

~~~~~
//##2. expr - 3. def string concat 5
a6950

~~~~~
//##3. real expr - 4. add double
110.5

~~~~~
//##3. real expr - 4. minus double
-10.099999999999994

~~~~~
//##3. real expr - 4. minus float to double
-10.099999237060544

~~~~~
//##3. real expr - 4. plus long
11

~~~~~
//##3. real expr - 4. plus minus long with casts
60

~~~~~
//##3. real expr - 1. boolean1
true

~~~~~
//##3. real expr - 1. boolean2
false

~~~~~
//##3. real expr - 1. boolean3
false

~~~~~
//##3. real expr - 1. boolean4
true

~~~~~
//##3. real expr - 1. boolean - with cast1
true

~~~~~
//##3. real expr - 1. boolean - with cast2
true

~~~~~
//##3. real expr - 1. boolean4 - 3 levels of iteration
true

~~~~~
//##3. real expr - 1. boolean4 - rhs nesting
true

~~~~~
//##3. real expr - 1. boolean4 - lhs nesting
true

~~~~~
//##3. real expr - 1. boolean4 - both nesting
true

~~~~~
//##3. real expr - 1. boolean5 - false always
false

~~~~~
//##3. real expr - 1. boolean5 - rhs nesting - always false
false

~~~~~
//##3. real expr - 1. boolean5 - lhs nesting - always false
false

~~~~~
//##3. real expr - 1. boolean5 - mega complex
true

~~~~~
//##3. real expr - 1. boolean5 - mega complex2-false
false

~~~~~
//##3. real expr - 2.muler
100: 1000: 1000: 10000: 20000: 2000: 4: 2

~~~~~
//##3. real expr - 2.pow
16 double v: 16.0

~~~~~
//##4. var assignment - 1. simple all creation variants
65: 67

~~~~~
//##4. var assignment - 2. long cast and useage
468.0

~~~~~
//##42. misc - insert dummy return statements in void ret methods
null

~~~~~
//##42. misc - newline via char



~~~~~
//##3. factor - prefix headless
11
9
11.0
9.0
11.0
9.0

~~~~~
//##3. factor - post headless
11
9
11.0
9.0
11.0
9.0

~~~~~
//##3. factor - neg
12
-12
12
12.0
-12.0
12.0

~~~~~
//##3. factor - as return post
4.0

~~~~~
//##3. factor - as return pre
5.0

~~~~~
//##3. factor - assign post
4.0 5.0

~~~~~
//##3. factor - assign pre
5.0 5.0

~~~~~
//##4. functions - module level static invokation
67.0

~~~~~
//##4. functions - module level static invokation -direct
134.0

~~~~~
//##4. functions - pop from stack if not in use
null

~~~~~
//##4. functions - with arguments and approperiate casting as well
79.0:79.0

~~~~~
//##4. functions - with arguments and approperiate casting as well, many args
11

~~~~~
//##4. assignment thingy operators whatever they're called
5: 20: 9: 100: 0.6999999999999997: 12

~~~~~
//##4. assignment thingy operators whatever they're called - string concat
hi there: hi 6

~~~~~
//##4. less than greater than for all types etc
true, true, true, true
false, false, false, false
true, true, true, true
false, false, false, false
false, false, false, false
true, true, true, true
false, false, false, false
true, true, true, true
true

~~~~~
//##4. not
false: false: false: false

~~~~~
//##4. and or 
false: false: true: true

~~~~~
//##4. mix 1
false: true: true: false: true

~~~~~
//##4. if expr
hi: there

~~~~~
//##4. if expr - complex nesting
5: 3: 5

~~~~~
//##4. if expr, fibonaci series!
1:1 2:2 3:3 4:5 5:8 6:13 7:21 8:34 9:55 10:89 11:144 12:233

~~~~~
//##4. if stmt - really simple
ok:ok:ok:ok

~~~~~
//##4. if stmt - simple
10

~~~~~
//##4. if stmt - simple or in stmt
0: 66: true

~~~~~
//##4. if stmt - elif
0 55 66 88:9 1

~~~~~
//##4. if stmt - fibonaci
 3:3

~~~~~
//##4. if stmt - elif nested
-4 55 66 88

~~~~~
//##5. while stmt
hi 1 2 3 4 5 6 7 8 9 10 end

~~~~~
//##5. while stmt - break
hi 1 2 3 4 5 end

~~~~~
//##5. while stmt - continue
hi 1 2 3 4 5 7 8 9 10 end

~~~~~
//##6. for simple
0 1 2 3 4 5 6 7 8 9 10 

~~~~~
//##6. for simple - simple expr
1 2 3 4 5 6 7 8 9 10 

~~~~~
//##6. for simple - simple expr var creation
0 1 2 3 4 5 6 7 8 9 10 

~~~~~
//##6. for simple - simple expr var assignment
1 2 3 4 5 6 7 8 9 10 

~~~~~
//##6. for simple - simple expr var creation with type
1 2 3 4 5 6 7 8 9 10 

~~~~~
//##6. for simple - break and continue
1 2 3 4 5 6! 7! 8! 

~~~~~
//##69. misc - test scopes of new vars
9109

~~~~~
//##69. for - test scopes of new vars - cotninue and break -on own
1 2 3 4 5 6 7 8 9 10 1 

~~~~~
//##69. for- test stuff missing
1 2 3 4 5 6! 7! 8! 1 2 3 4 5 6! 7! 8! 2 3 4 5 6! 7! 8! 

~~~~~
//##7. arrays - declaration
nullnull

~~~~~
//##7. arrays - ref simple
0 false null

~~~~~
//##7. arrays - ref >1d simple
0 0

~~~~~
//##7. arrays - string print 1d
[0 0 0 0 0][0 0 0 0 0]

~~~~~
//##7. arrays - string print 2d
[0 0 0 0 0 ; 0 0 0 0 0 ; 0 0 0 0 0 ; 0 0 0 0 0 ; 0 0 0 0 0]

~~~~~
//##7. arrays - string print 3d
[null null ; null null ; null null ; null null]: [null null ; null null ; null null ; null null]

~~~~~
//##7. arrays - sublist 1d
[0 0 0]

~~~~~
//##7. arrays - sublist 1d postfix
[0 0 0 0 0 0 0 0]

~~~~~
//##7. arrays - sublist 1d prefix
[0 0]

~~~~~
//##7. arrays - sublist 1d nested sublist
[2, 3, 4]

~~~~~
//##7. arrays - correctly plus eq onto existig string
[1, 2, 3]

~~~~~
//##7. arrays - declaration
[1, 2, 3]: [1.0, 2.0, 3.0]: [[11, 12], [13, 14]]: [[1, 2, 3], [3]]

~~~~~
//##7. arrays - misc, array as first arg
[1, 2, 3]

~~~~~
//##7. arrays - assignment - simple
[1, 88, 3]

~~~~~
//##7. arrays - assignment - with fancy inplace operator
[1.0, 99.0, 91.0, -4.0, 10.0, 36.0, 7.0, 8.0, 9.0, 10.0]: [1, 16]

~~~~~
//##7. arrays - assignment - simple 2d
[[1, 88, 3], [3, 4, 5]]

~~~~~
//##7. arrays - assignment - with fancy inplace operator 2d
[[1, 90, 9], [3, 4, 5]]

~~~~~
//##8. new for loop, two variants
12.0

~~~~~
//##8. new for loop with break, continue
0:5.0

~~~~~
//##9. cast and instanceof - cast
[]:str:5.0

~~~~~
//##9. cast and instanceof - instanceof is isnot
[true, false]

~~~~~
//##10. Exceptions-catch many
Exception thrownjava.lang.Exception: ughExcep:Throwable thrownjava.lang.Throwable: ughTrh:

~~~~~
//##10. Exceptions-nothing
nothing

~~~~~
//##10. Exceptions-from functioncall
Exception thrown: java.lang.Exception: ughExcep

~~~~~
//##10. Exceptions-finally
[Exception: java.lang.Exception: myException - finally!, Throwable: java.lang.Throwable: myThrowable - finally!,  - finally!]

~~~~~
//##10. Exceptions-finally no catch
[hi - finally!, hi - finally!, hi - finally!]

~~~~~
//##10. Exceptions-nested exceptions 2
[mainBlock - first exceptionjava.lang.Exception: Dd2d, mainBlock - first exceptionjava.lang.Exception: Dd2d - second exceptionjava.lang.Exception: Dd2d]

~~~~~
//##10. Exceptions-nested exceptions 2 with a finally it works!
[mainBlock - first exceptionjava.lang.Exception: Dd2d + fin, mainBlock - first exceptionjava.lang.Exception: Dd2d + fin - second exceptionjava.lang.Exception: Dd2d]

~~~~~
//##10. Exceptions-nested exceptions 3 with a finally it works! OMG this took so much fucking work!
[mainBlock - first exception + fin, mainBlock - first exception - second exception + fin - third exception]

~~~~~
//##11. Assert keyword
[ok, failed]

~~~~~
//##12. function call on static imported preimport
2[hi, there][wassup]

~~~~~
//##13.1 equals and not equals on objects
[true, true, true, true, true, true, true, true, true][2, 7]

~~~~~
//##13.2 equals and not equals on primatives
[true, true]

~~~~~
//##14 autoboxing
[true, true, true]: 66, 78: 1,88

~~~~~
//##14.1 autoboxing - functions involving sums etc
[141.0, 141.0, 141.0, 141.0][-123.0, -123.0, -123.0, -123.0]

~~~~~
//##14.2 autoboxing - functions involving mmultiplication etc
(0, 0.11111111, 0.1111111111111111, 0.1111111111111111)(39204, 39204.0, 39204.0, 39204.0)

~~~~~
//##14.3 autoboxing - pow and mod
(2147483647, 2.37626797E16, 2.3762680013799936E16, 2.3762680013799936E16)(9, 9.0, 9.0, 9.0)

~~~~~
//##14.4 autoboxing - operations in place
[2, 4, 1, 2, 5]: 16

~~~~~
//##14.4b autoboxing - operations in place -other way
[3, 2, 1, 8, 1]: 16

~~~~~
//##14.4c autoboxing - operations in place -and another one
[2, 4, 1, 2, 5]: 16

~~~~~
//##14.5 - all autoboxing unboxing combinations when calling constructors
6.0: 6.0: 6.0

~~~~~
//##14.6 - prefix, postfix and neg sign
[-8.0, -4.0][8.0, 4.0][4.0, 8.0][6.0, 4.0, 6.0, 8.0]

~~~~~
//##14.7 autoboxing - and or not
[true, true, true, true][true, true, true, true][false, false, false, false][true, true, true, true][false, true, false, true][true, true]

~~~~~
//##15 list gets translated into objlist - TODO: fix moi
[1 2 3.0  5 6]

~~~~~
//##16.1 generic - use existing
[hi][there]

~~~~~
//##16.1 generic - user defined class
[hi there2]

~~~~~
//##16.2 generic - user der with boxing etc
[hi there2mate]100hi89

~~~~~
//##17.1 superclass invoke
yowassup

~~~~~
//##17.2 superclass invoke - with generics! and constructor flavours
[hi, there, whatu, want, 99, 101]

~~~~~
//##17.3a superclass invoke - generic fields
[matehi, hi][matehi, hi]

~~~~~
//##17.3b superclass invoke - generic fields with accessor
[matehi, hi][matehi, hi]

~~~~~
//##17.4 holder generics - ensure correct checcast cast operation when retrun generic
Holder obj, MyClass obj, matehi, matehi

~~~~~
//##17.4b holder generics - ensure correct checcast cast operation when retrun generic ARRAYS
mate2hi, mate3hi

~~~~~
//##17.4b.b holder generics - ensure correct checcast cast operation when retrun generic ARRAYS -other way!
mate2hi, mate3hi

~~~~~
//##18.1 superclass invoke - DIRECT Field ACCESS
yowassup

~~~~~
//##18.3b superclass invoke - generic fields with accessor- DIRECT Field ACCESS
[matehi, hi][matehi, hi]

~~~~~
//##18.4 holder generics - ensure correct checcast cast operation when retrun generic- DIRECT Field ACCESS
Holder obj, MyClass obj, matehi, matehi

~~~~~
//##18.4b holder generics - ensure correct checcast cast operation when retrun generic ARRAYS- DIRECT Field ACCESS
mate2hi, mate3hi

~~~~~
//##18.4b.b holder generics - ensure correct checcast cast operation when retrun generic ARRAYS -other way!- DIRECT Field ACCESS
mate2hi, mate3hi

~~~~~
//##19 For loop - new fancy iterator style
one, two, one, two, 

~~~~~
//##19.z For loop - old style dun belong here - check casts
1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 

~~~~~
//##19.1 For loop - new fancy iterator style - watch out for boxing
1, 2, 77, 80

~~~~~
//##19.2 For loop - new fancy iterator style - watch out for boxing
1, 2, 77, 80

~~~~~
//##19.3 For loop - new fancy iterator style - watch out for boxing
1, 2, 77, 80

~~~~~
//##19.4 For loop - new fancy iterator style - oh it works
hithere: wassup: 

~~~~~
//##19.4b For loop - new fancy iterator style - oh it works
hithere: wassup: 

~~~~~
//##20.1 nested class - simple decl
[Outer, Inner, Inner, SubB]

~~~~~
//##20.2-a nested class - constructors
1212

~~~~~
//##20.2-b nested class - double nested constructors
2424

~~~~~
//##20.3 nested class - vars funcs and classes direct and indirect
[99, 100, 101][67, 67, 67][12, 12, 12][[99 101], [99 101], [99 101]]

~~~~~
//##20.4a nested class - nested var pre post operations
[99, 101, 17, 101, 17]

~~~~~
//##20.4b nested class - nested var pre post operations accessors
[99, 101, 17, 101, 17]

~~~~~
//##20.5a nested class - array operations
[99, 101, 17, 101, 17]

~~~~~
//##20.5b nested class - array operations via accessors
[99, 101, 17, 101, 17]

~~~~~
//##20.6 nested class - call superclass stuff
[1, 2, 4]

~~~~~
//##20.7a nested class - generics 1
[hi there, hi there]

~~~~~
//##20.7b nested class - generics 2
[hi there, hi there, 99]

~~~~~
//##20.7c nested class - generics 3
[hi there, hi there, 99]

~~~~~
//##21. abstract classes
66

~~~~~
//##22. no bridge method needed
there

~~~~~
//##23. ensure that u can have nested classes inherit from their own parent nestor
Hello world7

~~~~~
//##24.use of generics, arrays of prims
[4 5 6]

~~~~~
//##25. catch all the exptions throwable
ok

~~~~~
//##26. test empty array toString
empty:[null null null null]::[null null null null]

~~~~~
//##27. dict def 1
{hi->there, wassup->mate}
{hi2->there2, wassup2->mate2}
{hi2->2, wassup2->1}
{1->wassup2, 2->hi2}
{1->[1, 2, 3], 2->[2, 3, 4]}
{one->{1->2, 3->4}, two->{1->2, 3->4}}

~~~~~
//##28. null eq optimization
[ok ok ok ok ok ok][ok ok ok ok ok ok]

~~~~~
//##28. null eq optimization via ifexpr
[ok ok ok ok ok ok][ok ok ok ok ok ok]

~~~~~
//##29. default dict impl tests a few things
{hi->default, there->default mate}

~~~~~
//##29. default dict impl tests a few things b - more correct impl i think shakes fist at java
{hi->default, there->default mate}

~~~~~
//##30. you cant do this in java
cool5:9

~~~~~
//##30. call functions taking objects which implement interface desired
[[{0->7}], [{}]]

~~~~~
//##31. import a final var
java.awt.Color[r=0,g=0,b=0]

~~~~~
//##32. does gen ppp correctly
yeah, probably

~~~~~
//##33. make sure arrays get cast correctly
true 2:true true

~~~~~
//##34.1 exceptions properly - correct early termination simple case
[Hello world, fail as expected]

~~~~~
//##34.2 exceptions properly - correct no early term
[Hello world, fail as expected]

~~~~~
//##34.3 exceptions properly - branching logic should need an extra try catch but ok hmmm
truetruetruetruetruetrue

~~~~~
//##34.4 exceptions properly - early term via break, again, seems ok...
Hello world[no excep: 11, excep: 11]

~~~~~
//##35 dunno what this does but its in the spec and is somewhat complex
Hello world

~~~~~
//##36 ppp - calling methods whith are ppp - dynamic binding to one which is visible
Hello world

~~~~~
//##37 ppp - accessability of constructors - extend in childclass
Hello world12

~~~~~
//##38 ppp - accessability of constructors - extend in childclass precomp class extend in childclass
Hello world12

~~~~~
//##39 ppp - accessability of constructors - extend in childclass precomp class extend in childclass direct invoke par
Hello world12

~~~~~
//##40 ppp - accessability of constructors - extend in childclass precomp class extend in childclass direct invoke par
Hello world[99, Good Job]

~~~~~
//##41 ppp - vars dont override
Hello world[9, 99]

~~~~~
//##42 ppp - private static variable or function can only be accessed with an accessor inside nested classes - dumb i know
hey3hey

~~~~~
//##43 ppp - private static lambdas - cool worked first time
hey

~~~~~
//##44 ppp - private static lambdas - cool worked first time - needs accessor
heyhey

~~~~~
//##45 misc ensure the other eq type works - ugly test shouldnt be here but meh
true 2:true true

~~~~~
//##46 default equals implementation - basics
[[true, true], [true, false], [false, false]]
[[true, true, true, true, true, true], [false, false, false], [false, false], [true]]
[false]

~~~~~
//##47 simple arrays equality
[true, true, true, true, true]

~~~~~
//##48 default equals for funcrefs
[[true, true, true, true, true], [true, true, true, true]]

~~~~~
//##49 default equals class must match exactly
[true]

~~~~~
//##50 default equals for lambdas
[true, true, true][true, true, true, true, true]

~~~~~
//##51 default equals for inner functions
[true, true]6

~~~~~
//##52 correctly box up and set type of list with null element
[[1 null], true] : [Ljava.lang.Integer;

~~~~~
//##53 correctly box up and set type of list with null element -2
[[1 2], true] : [[Ljava.lang.Integer;

~~~~~
//##54 correctly box up and set type of list with null element -3
[[null null], true] : [Ljava.lang.Object; : null

~~~~~
//##55 various types of list being instantiated
[null null null]

~~~~~
//##56 null list as argument gets cast to approperiate type
nice StringObject[][null null null null ; null null null null]

~~~~~
//##56 null list on multildir array
[null ; null]

~~~~~
//##57 just wanted to double check this functionality
its fine: 9

~~~~~
//##58 check setters when using null lists
[null ; null]:[null ; null]

~~~~~
//##59 null lists on if epxrs
[[null null], [null null], [null null]]

~~~~~
//##60 nested null list
[[null  [null  null]] [null  [null  null]]]

~~~~~
//##61 ifExp choice null list - 2
.
[null, [null, null], [null, null], null]
[false, false, false, false]
[null, [null, null], [null, null], null]
[false, false, false, false]

~~~~~
//##62 qmark rules all
[hi, 12]

~~~~~
//##63.1 null lists in maps - basic
[{false->[null null], true->[null null]}]true

~~~~~
//##63.2 null lists in maps - as obj
[{false->[null null], true->[null null]}]true

~~~~~
//##63.3 null lists in maps - 2d int
[{false->[null ; null], true->[null ; null]}]true: [[I: true

~~~~~
//##63.5 null lists in maps - maps
[{true->{true->[null null]}}]: true : java.util.HashMap

~~~~~
//##63.6 null lists in maps - 2d maps
[{true->{true->[null null]}} {true->{true->[null null]}}]: true:true : java.util.HashMap : [Ljava.util.HashMap;

~~~~~
//##63.7 null lists in maps - maps in functions
[functo1, functo2, functo3]

~~~~~
//##64.1 null lists in stuff used in lambdas - simple
[functo1, functo2, functo3]

~~~~~
//##64.2 null lists in stuff used in lambdas - curry in args
[functo1, functo2, functo3]

~~~~~
//##65.1 prealloc jump labels - 1
[true, true, true, true, true, true, true, true]

~~~~~
//##65.2 prealloc jump labels - void meths consume final label
[111, 112, 19, 19, 111, 113, 19, 19]

~~~~~
//##65.3 prealloc jump labels - top level, and sneak in ifexpr test
[9, 7]

~~~~~
//##65.4 prealloc jump labels - while break continue
[20, 90, 21, 100, 30, 10]

~~~~~
//##65.5 prealloc jump labels - for loop simple and advanced
0 1 2 3 4 5 6 7 8 9 10 0 1 2 3 4 5 6 7 8 9 10 

~~~~~
//##65.6 prealloc jump labels - more complex for loop
[0ok 1ok 2ok 3ok 4end, 1,2,3,4,end]

~~~~~
//##65.7 prealloc jump labels - for loop with implicit iterator support
1,2,3,4,end

~~~~~
//##66 thegetsettest misc
10151

~~~~~
//##67 something with loops and fin thing being break so u dont need another one
5::2

~~~~~
//##68 some extra for loop tests which could blow up
[oksh, kshh, okshh]

~~~~~
//##69 assign private module filed from class inside module
[99, [100, 100], [101, 101], [101, 102]]

~~~~~
//##69.b works as expected with nested classes too
[99, [100, 100], [101, 101], [101, 102]]

~~~~~
//##69.c assign private module filed from class inside module - to Integer
[99, 100, 100, 101, 101, 101, 102]

~~~~~
//##69.d assign private module filed from class inside module - to Integer other way
[99, 100, 100, 101, 101, 101, 102]

~~~~~
//##70. default equals - check circular rrefs
true

~~~~~
//##71. default equals - misc field tests
[true, true, true, true, true, true]

~~~~~
//##72. default equals - ensure superclass called correctly
[true, true]

~~~~~
//##73. default equals - another one
[false, false, false]

~~~~~
//##74. forward references
hi there2

~~~~~
//##75. default equals implementation for lamdabs
[true, true, true, true, true, true, true]
Interesing[[null x75defaultequalsimplementationforlamdabs NIF$0(I)V  (Ljava/lang/Integer;)V], [null x75defaultequalsimplementationforlamdabs NIF$1(I)V  (Ljava/lang/Integer;)V]]

~~~~~
//##76. while loop tests
234592345

~~~~~
//##77. for double loop tests
2345

~~~~~
//##78. double check while
sz,sz,sz,sz,sz,sz,:sz,sz,sz,sz,sz,

~~~~~
//##79. minor arrays fix
true

~~~~~
//##80. check that u can cast from primative tpye to object and boxing operation auto added
5falsefalse

~~~~~
//##81. test hashcode gennerator
[true, true, true, true]
[true, true, true, true]
[true, true]

~~~~~
//##82. test hashcode edge case
113766

~~~~~
//##83. hashcode doesnt blow up when field is null
[0, 0]

~~~~~
//##84. lambda equals operates on object being called on to ensure equal by ref and not var
[true, true]

~~~~~
//##85. lambda hashcode
[true, true]

~~~~~
//##86. ensure that arr plus singles is cast to Object
[-30, [-30, -30]]

~~~~~
//##87. dunno
[1, 2, 3, 4, 7]

~~~~~
//##88. fin
k

~~~~~
//##89. i thought this was interesting
[12, 2000000]

~~~~~
//##90. ok nice
[{1->3, 2->4}, {1->3, 4->2}, [1, 2, 3], [4]]

~~~~~
//##91. add null check on equals
[true, true, true]::[true, true, true]

~~~~~
//##134.a primatives can be generic qualifiers
[13.0, 9.0, 7.0, 7.23]

~~~~~
//##134.b primatives can be generic qualifiers fix bool bug
[false, false]

~~~~~
//##134.c the joy of lambdas
D:\work\Concurnas-prer\tests\com\concurnas\compiler\bytecode\x134cthejoyoflambdas.conc line 10:9 Unable to find method with matching name: constructor and arguments (def () java.lang.Integer)
D:\work\Concurnas-prer\tests\com\concurnas\compiler\bytecode\x134cthejoyoflambdas.conc line 11:9 Unable to find method with matching name: constructor and arguments (def () java.lang.Integer)

~~~~~
//##134.d the joy of lambdas Function
[7, 7, 7, 8, 8, 8]

~~~~~
//##134.e the joy of lambdas2
[7, 7, 7, 8, 8, 8]

~~~~~
//##135. copier functionality
[[true, true], [true, true]]

~~~~~
//##135.b copier functionality - double check copies work ok
[true, true, true, true, true, true, true, true, true]

~~~~~
//##137. check math
44

~~~~~
//##138. another edge case
5

~~~~~
//##139.a private field accessor
[8, 2, 7[5, 7]]

~~~~~
//##139.b private static accessor
[8, 2, 7[5, 7]]

~~~~~
//##139.c private field accessor ref
[8, 2, 7:[5, 7]]

~~~~~
//##139.d private static accessor ref
[8, 2, 7:[5, 7]]

~~~~~
//##139.e private static accessor ref FUNCTION
[hione8]

~~~~~
//##139.f private static accessor ref FUNCTION module
[hione8]

~~~~~
//##139.g private static accessor ref FUNCTION lambda
[hione8]

~~~~~
//##139.h private static accessor ref FUNCTION module lambda
[hione8]

~~~~~
//##140. dont create acessor when not needed
12

~~~~~
//##141. fix continue in new for loop when operating on non array
45

~~~~~
//##142. another loop fix, just cos last thing is break dosnt mean entire stmt 100pct always breaks, so dont skip the postop code please
1

~~~~~
//##143. dunno what this does looks important
hi

~~~~~
//##144. ensure array length is called correctly
true

~~~~~
//##145. ensure for block temp items created locally
true

~~~~~
//##146. no inf loop caused by for
fine

~~~~~
//##147. module level for loop works ok
fine

~~~~~
//##148. skip goto at end of thing when it contains an inf loop
fine

~~~~~
//##149. oops, if boxed type on comparison, this needs to be unboxed
[below, above]:[below, above]

~~~~~
//##150.a overriden methods can return subtypes - java cls
its fine

~~~~~
//##150.b overriden methods can return subtypes - conc cls
its fine

~~~~~
//##151. nested class construction inside parent - pub
[9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]

~~~~~
//##152.a nested class extension - constru
[true, true, true, true]hi

~~~~~
//##153. ensure that private fields are accesable to outer class
[10, 10]

~~~~~
//##153.b ensure that private fields are accesable to outer class
[2, 2, 2, 2]

~~~~~
//##154. ensure no extra dup is created
[hi there, hi there]

~~~~~
//##155. ensure that custom toStrings are called for set, list and map if one is defined
[CustomHashMap impl of toString, CustomHashMap impl of toString] -> [[{hi->there}], [{hi->there}], {{hi->there}->{hi->there}}]
CustomHashMap impl of toString - CustomHashMap impl of toString
CustomList impl of toString : CustomList impl of toString
CustomSet impl of toString : CustomSet impl of toString

~~~~~
//##156. dunno what this test does but looks clever
hi [hi 1 , hi 1 2 , hi 1 2 3 , hi 1 2 3 4 , hi 1 2 3 4 5 , hi 1 2 3 4 5 7 , hi 1 2 3 4 5 7 8 , hi 1 2 3 4 5 7 8 9 , hi 1 2 3 4 5 7 8 9 10 ]end

~~~~~
//##157. this is also strange so add anyway
true

~~~~~
//##158. using java classes which have local generic types
[2, 1, 2, [hi, there], null]

~~~~~
//##158.b using java classes which have local generic types
true

~~~~~
//##159. ensure all refs in lambdas get bound
done cool 14

~~~~~
//##160. bugfix lambda name
[true]

~~~~~
//##162. weird returns bug
[[2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], false, true, true, true, true, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]

~~~~~
//##163. ugly bug concerning stack frame management
hhFiely: 444.0

~~~~~
//##164. prevsoiuly i messed up the getlest common acestor logic which was operating without the generic type qualifciation this fixes that
[true, true]:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

~~~~~
//##165. iterate on map auto maps to keyset
[18, 8]

~~~~~
//##166. ensure local array handled correctly
[true, true, true]

~~~~~
//##167. abstract method correctly created
hi2

~~~~~
//##168. ensure correct type created
[hi1, hi2]

~~~~~
//##169. the double arg was taking up too much space
hi

~~~~~
//##169. getset on strings with pre and postfix operations
[89, 8911]

~~~~~
//##194 multilevel as before - these are all ok
ok

~~~~~
//##195 type check is performed on set
java.lang.Integer cannot be cast to java.lang.String

~~~~~
//##196 ensure non boxing
it's done: [10, 1]

~~~~~
//##197 double check ref from method return function
12-> 12

~~~~~
//##198 ensure generic field types are captured
[[], []]

~~~~~
//##199 ensure generic field types are captured arrays
[[ok], [ok]]

~~~~~
//##200 local array direct and indirect calls
[[1], [99]]

~~~~~
//##201 we can infer the type here
[one, one]

~~~~~
//##202 new keyword optional
one

~~~~~
//##203 no new and gen inf
one

~~~~~
//##204 infer of generics
[[[3, 4], no set], 4]

~~~~~
//##205 infer of generics more than one here but its not a problem
[[[3, 4], no set], 4]

~~~~~
//##206 array type correctly chosen with respect to generic types
[[[3 4], set], 4]

~~~~~
//##207 infer of generics ensure mapped to correct constructor
[[[3 4], second], 4]

~~~~~
//##208 method generics
[hi]

~~~~~
//##209 the gen captured from enclosing class
[[hi], [hi]]

~~~~~
//##210 merge use of types from class and method
[{hi->12}, {hi->12}]

~~~~~
//##211 locally defined generics override those provided at class level
[{hi->12}, {hi->12}]

~~~~~
//##212 as before but imported
[{hi=12}, {hi->12}]

~~~~~
//##212 as before but imported and type inf
[{hi=12}, {hi->12}]

~~~~~
//##212 as before but imported and type boxed
[{hi=12}, {hi->12}]

~~~~~
//##213 tweak of new keyword ensure geners are passed in
[hi]

~~~~~
//##214 tweak of new keyword ensure geners are passed in more complex
[[hi], [hi]]

~~~~~
//##215 funcref to function with local generics
[[hi there], [hi there]]

~~~~~
//##216 type inference complex constuctors
[[hi], [hi]]

~~~~~
//##217 type inference complex generic methods
[[hi], hi]

~~~~~
//##218 type inference complex const step up heirarchy
[[hi], [hi]]

~~~~~
//##219 type inference complex const step up heirarchy more than one
[[hi], [hi]]

~~~~~
//##220 type inference complex method step up heirarchy more than one as well
[[hi there], [hi there], [hi there], [hi there]]

~~~~~
//##221 type inference complex method step up heirarchy more than one as well for reftypes
[[hi there], [hi there], [hi there], [hi there]]

~~~~~
//##222 type inference complex method step up heirarchy more than one as well for reftypes bit more complex
[[hi there], [hi there], [hi there], [hi there]]

~~~~~
//##223 i guess this can work
[[hi there], [hi there]]

~~~~~
//##224 call method of ref
[11, ok]

~~~~~
//##225 call method of ref more complex
[11, yo, yo, ok]

~~~~~
//##226 various methods with Ref arrays
[[2, true, true]]

~~~~~
//##227 class keyword
[[class java.lang.Integer, class [Ljava.lang.Integer;, [Ljava.lang.Integer;], [class x227classkeyword$MyClass, class x227classkeyword$MyClass2, class [Lx227classkeyword$MyClass2;], [boolean, class [I, class [[I]]

~~~~~
//##228 use of nop expression
0

~~~~~
//##229 lovely now we can create references to constructors
myclass: 12

~~~~~
//##230 as above but with types
[myclass: 12 hi, myclass: 12 hi]

~~~~~
//##231. funcref unbounded binding and direct invokation of apply
[36, 24]

~~~~~
//##232. funcref exceptions on bindings
[fail as expected: com.concurnas.lang.LambdaException: Method reference has not been bound to instance object, call bind() before invocation, fail as expected: com.concurnas.lang.LambdaException: Cannot bind top level function references]

~~~~~
//##233. actingOn type for lambda
[12, class x233actingOntypeforlambda$Myclass]

~~~~~
//##234. only valid use of pure type reference in contents of function reference
cool

~~~~~
//##235. make use of generic array
[hi, hi]

~~~~~
//##236. make use of generic array - 2d
[hi, hi]

~~~~~
//##237. make use of generic array - operates on functions now
[hi, hi]

~~~~~
//##238. unbound method ref with generic args
hi

~~~~~
//##239. unbound method ref with generic args complex
[hi, hi]

~~~~~
//##240. quick check
[10, 1, 1]

~~~~~
//##241. funcrefs to things with generic params simple
[[hi, hi], [12, 12], [yo, yo], [999, 999]]

~~~~~
//##242. funcrefs to things with generic params infer
[[hi, hi], [12, 12], [yo, yo], [999, 999]]

~~~~~
//##242. funcrefs to things with generic params simple array
[[hi, hi], [12, 12], [yo, yo], [999, 999]]

~~~~~
//##242. funcrefs to things with generic params simple array infer
[[hi, hi], [12, 12], [yo, yo], [999, 999]]

~~~~~
//##243. funcrefs to things with generic params simple array - bounded
[[hi, hi], [12, 12], [yo, yo], [999, 999]]

~~~~~
//##244. funcrefs to things with generic params simple array - bounded with infered stuff
[[hi, hi], [12, 12], [yo, yo], [999, 999]]

~~~~~
//##245. funcref to constructor
hi

~~~~~
//##246. funcref to constructor with inf
[hi, hi]

~~~~~
//##247. boxing bug on generic type inference
wonderful

~~~~~
//##248. local gen correctly overwrites class gen
12

~~~~~
//##249. this is fine
[999, 999]

~~~~~
//##250. not perfect but good enough
yo

~~~~~
//##251. nested class funcref
hi

~~~~~
//##252. nested class funcref - type inf 1
hi

~~~~~
//##253. nested class funcref - reference inner dude
hi

~~~~~
//##254. nested class funcref - reference inner dude infer types for class
hi

~~~~~
//##255. nested class funcref - reference inner dude infer types for class x2 levels
hi

~~~~~
//##256. super simple
hi

~~~~~
//##257. new is not needed on nested class creation anymore
100

~~~~~
//##258. new is not needed on nested class creation anymore - as above but easier
100

~~~~~
//##259. ensure args get captured correctly
2

~~~~~
//##260. create ref to nested class
[100, 200]

~~~~~
//##261. create ref to nested class - above but simple
100

~~~~~
//##262. create ref to nested class - above but simple but with args
100

~~~~~
//##263. create ref to nested class - with generics
100

~~~~~
//##264. infer generics from types passed in constructor
100

~~~~~
//##265. used to npe no longer does
gool

~~~~~
//##266. used to npe no longer does x2
hi

~~~~~
//##267. statics can be referenced
3.141592653589793

~~~~~
//##268. no need to use new long version
dave21

~~~~~
//##269. funcref to const using new
dave21

~~~~~
//##270. funcref to const using new mk 2
dave21

~~~~~
//##271. use new in funcref and imply arguments
hi

~~~~~
//##272. create funcref use new in nested maner
100

~~~~~
//##273. create funcref use new in nested maner - infer type
hi

~~~~~
//##274. another case
100

~~~~~
//##275. complex and cool
[hi, hi]

~~~~~
//##276. another test
hi

~~~~~
//##277. more exmaples
[hi, hi]

~~~~~
//##278. looks fine
[hi, hi]

~~~~~
//##279. works getting boring
[hi, hi]

~~~~~
//##280. ywarn
[hi, hi]

~~~~~
//##281. ok
[hi, hi]

~~~~~
//##282. can create funcref to nested inner thing
[hi, hi, hi]

~~~~~
//##283. hard but we got there
one

~~~~~
//##284. lovely now we can create parent nested refs which require binding
100

~~~~~
//##285. more complex cases
46

~~~~~
//##286. get function via psa - with arguments
hi

~~~~~
//##287. get function via psa - with arguments from generic
12

~~~~~
//##288. funcref on a psar - works
[12, ok]

~~~~~
//##289. funcref on a psar - works but with a generic
[12, ok]

~~~~~
//##290. correct use of local generics
[12, 99]

~~~~~
//##291. psar created for private thing
12

~~~~~
//##292. local generic params on lambda
[hi, hi]

~~~~~
//##293. little thing
[hi, hi]

~~~~~
//##294. local generic params on lambda with infer types
[[hi, hi], [12, 12]]

~~~~~
//##295. was failing before
[12, 12]

~~~~~
//##296. funcref to lambda with local generics
[12 12]

~~~~~
//##297. funcref to lambda with local generics - infer type
[12 12]

~~~~~
//##298. funcref to lambda with local generics - infer type lovely
[12 12]

~~~~~
//##299. complex via class
[12 12]

~~~~~
//##299.b complex via class - unrelated gens on type and locally
[12 12]

~~~~~
//##300. unbounded ref to lambda function variable
[a [12, 12], b [12, 12]]

~~~~~
//##301. its nice when stuff just works ok
[[hi, 100, cool], [hi, 101, cool2]]

~~~~~
//##302. this was failing before
[12, 12]

~~~~~
//##303. classes dont need to have blocks
[hi, hi, hi, hi, hi, hi]

~~~~~
//##304. was a bug now its not
[1, 1]

~~~~~
//##305. this used to fail
[28, 20]

~~~~~
//##306. was a bug now its not
36

~~~~~
//##307. avoid accidental ref overwrite
12

~~~~~
//##308. rhs async block with ref should not overwrite lhs
12

~~~~~
//##309. rhs async block with ref should overwrite lhs
[12, 12]

~~~~~
//##310. complex but ok
12

~~~~~
//##311. complex but ok expands on idea from above
12

~~~~~
//##312. as above complex
[12, 12, 12, 12, 12]

~~~~~
//##313. ensure correct toString called
didnt crash and correct thing called: [true, true, true, cannot clone as expectedjava.lang.CloneNotSupportedException: x313ensurecorrecttoStringcalled$MyClass]

~~~~~
//##314. tostring calls hashcode by default
[true, true, true, true]

~~~~~
//##315. tostring calls hashcode by default
[123, true, true, true, true]

~~~~~
//##316. carry through the generics
nice when stuff works

~~~~~
//##317. carry through the generics - local gens
nice when stuff works

~~~~~
//##317. more def with generics this used to fail
[hi, mate, mate, mate, 99]

~~~~~
//##318. we used to be unable to bind this
ok boysnull

~~~~~
//##319. as above but with local generics
[nice when stuff works, nice when stuff works]

~~~~~
//##320. works lovely
ok stuff

~~~~~
//##321. only do checks above on locally bound generics
ok [hey, hey]

~~~~~
//##322. this stuff where we are not doing references seems ok i guess testing could be better
ok boysnull

~~~~~
//##323. bugfix, qualification of generic super types
lovely

~~~~~
//##324. was a bug but has an easy fix
[noe]

~~~~~
//##325. forgetting to bind causes npe which used to crash
null

~~~~~
//##326. i forgot this could be done
from outer

~~~~~
//##327. i also forgot this was doable
3

~~~~~
//##328. i also forgot this was doable
[12]

~~~~~
//##329. i also forgot this was doable as well
12

~~~~~
//##330. default constructor added regardless unsupressable
[12, 13]

~~~~~
//##331. immutable stuff is not copied
[true]

~~~~~
//##332. mutable stuff is copied
[true]

~~~~~
//##333. redefinition of types where we infer types
[1, 2, 3]

~~~~~
//##334. some more tricky type inference via supertype
3

~~~~~
//##335. toBoolean - easy ones
[[[no null, no null], [is null, is null]], [[no null, no null], [is null, is null]]]

~~~~~
//##336. toBoolean - faked to be on object
[[[is null, is null], [is null, is null]], [[is null, is null], [is null, is null]], true, true]

~~~~~
//##337. toBoolean - on arrays
[[[ok, ok], [null, null]], [[ok, ok], [null, null]]]

~~~~~
//##338. toBoolean - on list array collections etc
[[[null, null], [ok, ok], [null, null], [ok, ok], [null, null], [ok, ok], [ok, ok], [ok, ok], [ok, ok], [null, null], [null, null]]]

~~~~~
//##339. toBoolean - on string
[[[ok, ok], [null, null], [null, null], [null, null]], [[ok, ok], [null, null], [null, null], [null, null]]]

~~~~~
//##340. toBoolean - on or and not
[true, false, false, false, true, true, true, false, true]

~~~~~
//##341. toBoolean - primatives
[[true, true, true, true, true, true, true], [false, false, false, false, false, false, false]]

~~~~~
//##342. toBoolean - assert
ok

~~~~~
//##343. toBoolean - while
1

~~~~~
//##343.b toBoolean - while
2

~~~~~
//##344. toBoolean - for
1

~~~~~
//##345. toBoolean - if elif
k

~~~~~
//##346. toBoolean - typed actor
[no false, no false, false, ok, ok, true, true, false]

~~~~~
//##347. toBoolean - untyped actor
[no false, no false, false, ok, ok, true, true, false]

~~~~~
//##348. regex
true

~~~~~
//##349. better char
[a, a, ', "]

~~~~~
//##350. better asserts
failed as expected

~~~~~
//##351. even better asserts
assert a > 3 failed

~~~~~
//##352. fix not order
true

~~~~~
//##353. better strings
[l'ov'ely, l"ov"ely, lovely, lovely]

~~~~~
//##354. named arrays
[0 0 0 0 0 0 0 0 0 0]

~~~~~
//##355. multiline strings ugh
hi	
	there

~~~~~
//##356. more on strings
[hi '" , there "' ]

~~~~~
//##357. format strings
hi 100 there 8mate

~~~~~
//##358. format strings advanced
the{one}:1 hi:3

~~~~~
//##359. in and not in
[true, true, true, true, true, true, true, true, hi mum]

~~~~~
//##360. for incrementors on arrays
[[1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 10], 
, [[100, 101], [101, 102], [102, 104], [103, 105], [104, 107], [105, 108], [106, 110], [107, 111], [108, 113], [109, 114], [110, 120]], 
, [[200, 201], [201, 202], [202, 204], [203, 205], [204, 207], [205, 208], [206, 210], [207, 211], [208, 213], [209, 214], [210, 220]], 
, [[1000, 1001], [1001, 1002], [1002, 1004], [1003, 1005], [1004, 1007], [1005, 1008], [1006, 1010], [1007, 1011], [1008, 1013], [1009, 1014], [1010, 1020]], 
, [[0, 1], [1, 2], [2, 4], [3, 5], [4, 7], [5, 8], [6, 10], [7, 11], [8, 13], [9, 14], [10, 20]]]

~~~~~
//##361. for incrementors on objects
[[1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 10], 
, [[100 101], [101 102], [102 104], [103 105], [104 107], [105 108], [106 110], [107 111], [108 113], [109 114], [110 120]], 
, [[200 201], [201 202], [202 204], [203 205], [204 207], [205 208], [206 210], [207 211], [208 213], [209 214], [210 220]], 
, [[1000 1001], [1001 1002], [1002 1004], [1003 1005], [1004 1007], [1005 1008], [1006 1010], [1007 1011], [1008 1013], [1009 1014], [1010 1020]], 
, [[0 1], [1 2], [2 4], [3 5], [4 7], [5 8], [6 10], [7 11], [8 13], [9 14], [10 20]]]

~~~~~
//##362. while incrementors
[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 
, [[100, 101], [101, 103], [102, 105], [103, 107], [104, 109], [105, 111], [106, 113], [107, 115], [108, 117], [109, 119]], 
, [[200, 201], [201, 203], [202, 205], [203, 207], [204, 209], [205, 211], [206, 213], [207, 215], [208, 217], [209, 219]], 
, [[1000, 1001], [1001, 1003], [1002, 1005], [1003, 1007], [1004, 1009], [1005, 1011], [1006, 1013], [1007, 1015], [1008, 1017], [1009, 1019]], 
, [[0, 1], [1, 3], [2, 5], [3, 7], [4, 9], [5, 11], [6, 13], [7, 15], [8, 17], [9, 19]]]

~~~~~
//##363. while incrementors no ret
[12345678910, 
, [100, 101][101, 103][102, 105][103, 107][104, 109][105, 111][106, 113][107, 115][108, 117][109, 119], 
, [200, 201][201, 203][202, 205][203, 207][204, 209][205, 211][206, 213][207, 215][208, 217][209, 219], 
, [1000, 1001][1001, 1003][1002, 1005][1003, 1007][1004, 1009][1005, 1011][1006, 1013][1007, 1015][1008, 1017][1009, 1019], 
, [0, 1][1, 3][2, 5][3, 7][4, 9][5, 11][6, 13][7, 15][8, 17][9, 19]]

~~~~~
//##364. for incrementors on objects no ret
[112233445510, 
, [100 101][101 102][102 104][103 105][104 107][105 108][106 110][107 111][108 113][109 114][110 120], 
, [200 201][201 202][202 204][203 205][204 207][205 208][206 210][207 211][208 213][209 214][210 220], 
, [1000 1001][1001 1002][1002 1004][1003 1005][1004 1007][1005 1008][1006 1010][1007 1011][1008 1013][1009 1014][1010 1020], 
, [0 1][1 2][2 4][3 5][4 7][5 8][6 10][7 11][8 13][9 14][10 20]]

~~~~~
//##365. for incrementors on ar no ret
[112233445510, 
, [100, 101][101, 102][102, 104][103, 105][104, 107][105, 108][106, 110][107, 111][108, 113][109, 114][110, 120], 
, [200, 201][201, 202][202, 204][203, 205][204, 207][205, 208][206, 210][207, 211][208, 213][209, 214][210, 220], 
, [1000, 1001][1001, 1002][1002, 1004][1003, 1005][1004, 1007][1005, 1008][1006, 1010][1007, 1011][1008, 1013][1009, 1014][1010, 1020], 
, [0, 1][1, 2][2, 4][3, 5][4, 7][5, 8][6, 10][7, 11][8, 13][9, 14][10, 20]]

~~~~~
//##366. as above for loop
[12345678910, 
, [100, 101][101, 103][102, 105][103, 107][104, 109][105, 111][106, 113][107, 115][108, 117][109, 119], 
, [200, 201][201, 203][202, 205][203, 207][204, 209][205, 211][206, 213][207, 215][208, 217][209, 219], 
, [1000, 1001][1001, 1003][1002, 1005][1003, 1007][1004, 1009][1005, 1011][1006, 1013][1007, 1015][1008, 1017][1009, 1019], 
, [0, 1][1, 3][2, 5][3, 7][4, 9][5, 11][6, 13][7, 15][8, 17][9, 19]]

~~~~~
//##367. regex matcher
[true, false, true, false]

~~~~~
//##368. for else - nt
[[101, 555, 103, 104, 999], no, no, [101, x, 103, 104, b, ], [no], [no]]

~~~~~
//##369. for else - ar
[no, [101, 555, 103, 104, 999], no], [101, x, 103, 104, b, ]]

~~~~~
//##370. for else - ar new style
[no, [101, 555, 103, 104, 999], no], [101, x, 103, 104, b, ]]

~~~~~
//##371. while else
[no, [101, 555, 103, 104, 999], [no], [101, x, 103, 104, b, ]]

~~~~~
//##372. js style maps getter
[1, null]

~~~~~
//##373. js style maps getter - 2 levels
1

~~~~~
//##374. js style maps setter
[12, 2]

~~~~~
//##375. js style ensuer getter cast correct
1

~~~~~
//##376. js style ref keys
{one->12:, three->12:, two->12:}

~~~~~
//##377. hashmap ref keys and values
{four->12:, one->12:, three->12:, two->12:}

~~~~~
//##378. js style hashmaps with prefix, postfix and special assigments
[{five->6, four->5, one->13, six->7, three->4, two->24}, 5, 7]

~~~~~
//##379. or eq and eq infix ops - simple
[true, false, true, false]

~~~~~
//##380. or eq and eq infix ops - lhs object
[true, false, true, false]

~~~~~
//##381. or eq and eq infix ops - lhs object rhs prim
[true, false, true, false]

~~~~~
//##382. or eq and eq infix ops - lhs object rhs object
[true, false, true, false]

~~~~~
//##383. or eq and eq infix ops - lhs object rhs object ref
[true, false, true, false]

~~~~~
//##384. or eq and eq infix ops - lhs object rhs object ref when it resolves to a number
true

~~~~~
//##385. or eq and eq infix ops - lhs object rhs object ref when it resolves to a number inv
false

~~~~~
//##386. if ref is null then avoid npe when converting to boolean
true

~~~~~
//##387. boolean to float etc conversions
[0.0, 1.0]

~~~~~
//##388. clean up remaining explicit primative type casts
0: oops -> String
1: 0 -> Integer
2: 0 -> Long
3: 0.0 -> Float
4: 0.0 -> Double
5: 0 -> Short
6: 0 -> Byte
7:  -> Character
8: true -> Boolean
9: 1 -> Long
10: 2.0 -> Float
11: 1.0 -> Double
12: 1 -> Short
13: 1 -> Byte
14:  -> Character
15: [true false] -> boolean[]
16: 1 -> Integer
17: 1.0 -> Float
18: 1.0 -> Double
19: 1 -> Short
20: 1 -> Byte
21:  -> Character
22: true -> Boolean
23: 1 -> Integer
24: 1 -> Long
25: 12.0 -> Double
26: 12 -> Short
27: 12 -> Byte
28:  -> Character
29: true -> Boolean
30: 12 -> Integer
31: 12 -> Long
32: 12.0 -> Float
33: 12 -> Short
34: 12 -> Byte
35:  -> Character
36: true -> Boolean
37: 12 -> Integer
38: 99 -> Integer
39: 99.0 -> Float
40: 99.0 -> Double
41: 99 -> Byte
42: c -> Character
43: true -> Boolean
44: 26 -> Integer
45: 3405691582 -> Long
46: 37.0 -> Float
47: 37.0 -> Double
48: 37 -> Short
49: % -> Character
50: true -> Boolean
51: 99 -> Integer
52: 99 -> Long
53: 99.0 -> Float
54: 99.0 -> Double
55: 99 -> Short
56: 99 -> Byte


~~~~~
//##402. init block
[1, [OP NO], 5, 2]

~~~~~
//##403. ensure operates after initial constructor call
[0, 99]

~~~~~
//##404. ensure setter doesnt trigger inf loop
MyClass: a: 99

~~~~~
//##405. thought this was cool
cool ok

~~~~~
//##406. define lambda as function argument
works: ok