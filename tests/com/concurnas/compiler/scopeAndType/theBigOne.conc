//##3. Lexical Structure
// http://docs.oracle.com/javase/specs/jls/se7/html/index.html
//n/a
~~~~~
//##3.1. Unicode
//n/a
~~~~~
//##3.2. Lexical Translations
//n/a
~~~~~
//##3.3. Unicode Escapes

a = "\\u2297=\u2297" //dunno if unicode works properly

~~~~~
//##3.4. Line Terminators
//n/a
~~~~~
//##3.5. Input Elements and Tokens
//n/a
~~~~~
//##3.6. White Space
//n/a
~~~~~
//##3.7. Comments


//1 line comment

/* star commennts */

/* multiline comment
 *
 */
~~~~~
//##3.8. Identifiers
//n/a
~~~~~
//##3.9. Keywords
//n/a
~~~~~
//##3.10. Literals
//n/a
~~~~~
//##3.10.1. Integer Literals
a = 3
b = 4L
//c=0x7fff_ffff //- not supported



~~~~~
//##3.10.2. Floating-Point Literals
a float = 1e1f    
a = 2.f
a = .3f
a = 0f
a = 3.14f
a = 6.022137e+23f

b double = 1e1 
b = 2.
b = .3
b = 0.0
b = 3.14
b = 1e-9d
b = 1e137

~~~~~
//##3.10.3. Boolean Literals
a = true and false;
b = true or false
c = a or b

~~~~~
//##3.10.4. Character Literals
//n/a
~~~~~
//##3.10.5. String Literals
g  = 6.;
a=""                    // empty 
a="\""                  // one "
a="This is a string"    // normal
a="This is a " +        \ 
    "two-line string"    

~~~~~
//##3.10.6. Escape Sequences for Character and String Literals
~~~~~
//##3.10.7. The Null Literal
d = null; //nice, obviously object!
d Object =null //this would be ok but d already exists
//d = new Object()

~~~~~
//##3.11. Separators
~~~~~
//##3.12. Operators

//fyi
//    =   >   <   !   ~   ?   :
//  ==  <==  >==  !=  &&  ||  ++  --
//  +   -   *   /   &   |   ^   mod   <<   >>   >>>
//  +=  -=  *=  /=  &=  |=  ^=  mod=  <<==  >>==  >>>==

~~~~~
//##4. Types, Values, and Variables
b Object = void;

~~~~~
//##4.1. The Kinds of Types and Values
~~~~~
//##4.2. Primitive Types and Values
//a void = ""; //void is not a valid type
a int
a = 2.0; //this throws error
tolong long = 21474836489l
tolong long = 214748364896 //already been declared


~~~~~
//##4.2. Primitive Types and Values - no void 4u
a void = ""; //void is not a valid type


~~~~~
//##4.2.1. Integral Types and Values
a=5
b=-4
tox int;
tox = -2147483649
tox = 21474836489
tox = 214748367 //this one is ok
tolong long = 21474836489l
tolong = 214748364896


~~~~~
//##4.2.1. Integral Types and ValuesTooLong
fartoolong long = 287349827349827348723942389479

~~~~~
//##4.2.2. Integer Operations
bol1 = false;
bol2 boolean  = false;
bol3 = bol1 and bol1;
bol boolean = false;
bol = 4 >5;
bol = 4 < 5;
bol = 4 >== 5;
bol = 4 <== 5;

bol = 4 == 5;
bol = 4 <> 5;
longe long = 4 + 5;

a int =67;
a = a + a;
a = a -a;
a = 100 * 2;
a = 10/4;
a = 1000 mod 5
a++
++a
a--
--a


//The signed and unsigned shift operators <<, >>, and >>> (�15.19) - NONONONO
//The bitwise complement operator ~ (�15.15.5) - NONONONO
//The integer bitwise operators &, ^, and | (�15.22.1) - NONONONO
def z() => 4>3
quest = 5 if z() else 3;

casta long = 5 as long;
castb int = 5 as int;
castc double = castb as double;

str String = "";
str = str + "hi2";
str = str + 2;
str = str + 2.3 
str += "hi";
str -= "hi"; //cannot do this


~~~~~
//##4.2.3. Floating-Point Types, Formats, and Values

bol = 0.0==-0.0 or 0.0>-0.0;
bol = false
posInf = 1.0/0.0;
negInf = 1.0/-0.0
f = new Float(2.5);
simplenana = Float.NaN;
nan = Float.NaN > Float.NaN;
x=4.5
y=6e4
check =  (x<y) ==( not (x>==y))
fl = 4.5f
doub double = fl
ff float = doub //fail
g float = 6
h double =6

~~~~~
//##4.2.4. Floating-Point Operations

bol = 4e5 >5.;
bol = 4. < 5.;
bol = 4. >== 5.;
bol = 4. <== 5.;

bol = 4. == 5.;
bol = 4. <> 5.;
longe double = 4. + 5;

a float =67.f;
a = a + a;
a = a -a;
a = 100.f * 2;
a = 10/4.f;
a = 1000.f mod 5.
a = 1000.f mod 5.f
a++
++a
a--
--a
def dd() => 4>3.
quest = .5 if dd() else 3.;

~~~~~
//##4.2.5. The boolean Type and boolean Values

bol boolean = true == false;
bol = true <> false;
bol = not false
bol = not (5>6)

//The logical operators &, ^, and | (�15.22.2)

bol = 4 > 5 and 4<3;

a = "" + bol

~~~~~
//##4.3. Reference Types and Values
//dunno what this means but lets have some simple def anyway...
import java.util.ArrayList

class Point {  
	metrics int[]?
 }

p = new Point();


~~~~~
//##4.3.1. Objects System.out.println
//need to ensure that System.x.y.z is loaded and tracked properly
//this may need to be rewritten on the bytecode

System.out.println("hello world")

~~~~~
//##4.3.1. Objects
//good luck...
i1aa=""
System.out.println("")
System.out.println("i1==" + i1aa);

System.out.println(false + "" );

//System.out.println("")
//import Something as Sys
//Sys.out.println("")

currenttime = System.currentTimeMillis();

class Test {
    def main(args String[] ) void {
        i1 = 3;
        i2 = i1;
        i2 = 4;
        System.out.println("")
        System.out.println("i1==" + i1);
        System.out.println(" but i2==" + i2);
        System.out.print("v1.val==" + System.currentTimeMillis());
    }
}


~~~~~
//##4.3.2. The Class Object

//The class Object is a superclass (�8.1.4) of all other classes.
class Moi
{
	 a int = 8;
}

zz Object = Moi;

o Object = new Object();

//oo = o.clone(); //dont exist!
//zzz = zz.clone();

g boolean = o.equals(o);
o.finalize()
a Class = o.getClass(); //wrong because the generic parameter lhs type has not been declared oops - u need to fix that
//a Class[_] = o.getClass(); //like this! TODO
code int = o.hashCode();
oops int = o.toString();
correct String = o.toString();
correcta String = (new String()).toString();

~~~~~
//##4.3.2.b The Class Object - prevent forbidden method calls

//prevent forbidden method calls: wait, notify, notifyAll - dont want locking!

o = new Object();

o.wait();
o.wait(6l);
o.wait(6l, 3);
o.notify();
o.notifyAll();

s = new String();

s.wait();
s.wait(6l);
s.wait(6l, 3);
s.notify();
s.notifyAll();



~~~~~
//##4.3.3. The Class String

ss = new String() + "" + 5
sss String = "" + ss



~~~~~
//##4.3.4. When Reference Types Are the Same


~~~~~
//##4.4. Type Variables
//TODO: subclass inherits from parent class, but private methods are not available to child or outside caller

~~~~~
//##4.5. Parameterized Types
//TODO

~~~~~
//##4.5.1. Type Arguments and Wildcards
//TODO

~~~~~
//##4.5.2. Members and Constructors of Parameterized Types
//TODO

~~~~~
//##4.6. Type Erasure
//TODO

~~~~~
//##4.7. Reifiable Types
//TODO

~~~~~
//##4.8. Raw Types

//some basic generics tests
//in concurnas we dont allow raw types (but we do allow e.g. List<?> something = maybesomelegacyfunccall() )

from java.util import ArrayList, List

ss ArrayList<String> = new ArrayList<String>();
ssok ArrayList<String> = ss
ssok = new ArrayList<Object>();

ass ArrayList<Object> = new ArrayList<String>(); //no

no = new ArrayList()//not raw

fun1 List<Object> = new ArrayList<Object>();
fun2 List<Object> = new ArrayList<String>();//FAIL
fun3 List<String> = new ArrayList<String>();
funu ArrayList<Object> = new List<Object>(); //this is not allows as List is an interface
a List = new ArrayList<String>(); //the lhs must specify type

~~~~~
//##4.9. Intersection Types
//dunno what this is
~~~~~
//##4.10. Subtyping
//fluff
~~~~~
//##4.10.1. Subtyping among Primitive Types

a1 double = 4f;
a2 float = 4l;
a3 long = 4;

~~~~~
//##4.10.2. Subtyping among Class and Interface Types

//TODO



~~~~~
//##4.10.3. Subtyping among Array Types

from java.util import List, ArrayList

ss List<String>[] = new ArrayList<String>[3] 

longers long[] = new int[2]; //not ok
longers2 int[] = new long[2]; //not ok

obj Object  = new Object[2];//object is the master of all
obj2 java.lang.Object  = new Object[2];//object is the master of all

cl Cloneable = new Object[2];

s java.io.Serializable = new Object[2];

a Object = new int[2]
b Object = new long[2]

a2 Cloneable = new int[2]
b2 Cloneable = new long[2]

a3 java.io.Serializable = new int[2]
b3 java.io.Serializable = new long[2]

a3=1 //this is also ok

//exhaustive 

e Object  = new Object[2,2]; // - ok
e1 Object[]  = new Object[2,2]; // - ok
e2 Object[2]  = new Object[2,2]; // - ok
e3 java.io.Serializable[]  = new Object[2]; // not allowed
e4 java.io.Serializable[2]  = new Object[2,2]; // not allowed
e5 java.io.Serializable[]  = new Object[2,2]; //ok

~~~~~
//##4.11. Where Types Are Used
//NA
~~~~~
//##4.12. Variables
//NA
~~~~~
//##4.12.1. Variables of Primitive Type
//NA
~~~~~
//##4.12.2. Variables of Reference Type
//NA
~~~~~
//##4.12.3. Kinds of Variables
//NA
~~~~~
//##4.12.4. final Variables
//TODO dont do final in concurnas et...
~~~~~
//##4.12.5. Initial Values of Variables
//NA
~~~~~
//##4.12.6. Types, Classes, and Interfaces
//NA
~~~~~
//##5. Conversions and Promotions
//cool little program to get us started...
class Test {			
    def main(args String[] ) void {
        // Casting conversion (5.4) of a float literal to
        // type int. Without the cast operator, this would
        // be a compile-time error, because this is a
        // narrowing conversion (5.1.3):
        i int  = 12.5f as int;
        // String conversion (5.4) of i's int value:
        System.out.println("(int)12.5f==" + i);
        // Assignment conversion (5.2) of i's value to type
        // float. This is a widening conversion (5.1.2):
        f float  = i;
        // String conversion of f's float value:
        System.out.println("after float widening: " + f);
        // Numeric promotion (5.6) of i's value to type
        // float. This is a binary numeric promotion.
        // After promotion, the operation is float*float:
        System.out.print(f);
        f = f * i;
        f *= i;
        // Two string conversions of i and f:
        System.out.println("*" + i + "==" + f);
        // Method invocation conversion (5.3) of f's value
        // to type double, needed because the method Math.sin
        // accepts only a double argument:
        d double  = Math.sin(f);
        // Two string conversions of f and d:
        System.out.println("Math.sin(" + f + ")==" + d);
    }
}


~~~~~
//##5.1. Kinds of Conversion

~~~~~
//##5.1.1. Identity Conversion
i int = 8 as int;
l long = 6l as long ;
o String? = null;
b String = "" as String;


~~~~~
//##5.1.2. Widening Primitive Conversion

by byte = 127;
srt short = 4;
ch char = '3'
nt int = 5;
ln long = 6l;
fl float = 6e1f;
db double = 6e1f;

a1 short = by;
a2 int = by;
a3 long = by;
a4 float = by;
a5 double = by;

b1 int     = srt;
b2 long    = srt;
b3 float   = srt;
b4 double  = srt;

c1 int    = ch;
c2 long   = ch;
c3 float  = ch;
c4 double = ch;


d2 long   = nt;
d3 float  = nt;
d4 double = nt;

e3 float  = ln;
e4 double = ln;

f5 double = fl




~~~~~
//##5.1.3. Narrowing Primitive Conversion
//TODO: check that these are doable via a cast converstion (but not doable otherwise)

by byte = 127;
srt short = 4;
ch char = '3'
nt int = 5;
ln long = 6l;
fl float = 6e1f;
db double = 6e1f;



q1 byte = srt
q2 char = srt

qq1 byte = ch
qq2 short = ch

qqq1 byte  = nt
qqq2 short = nt
qqq3 char  = nt

qqqq1 byte  = ln
qqqq2 short = ln
qqqq3 char  = ln
qqqq4 int  = ln

qqqqq1 byte  = fl
qqqqq2 short = fl
qqqqq3 char  = fl
qqqqq4 int  = fl
qqqqq5 long  = fl


qqqqqq1 byte  = db
qqqqqq2 short = db
qqqqqq3 char  = db
qqqqqq4 int  = db
qqqqqq5 long  = db
qqqqqq6 float  = db



~~~~~
//##5.1.4. Widening and Narrowing Primitive Conversion
by byte = 127;

cc char  = by;




~~~~~
//##5.1.5. Widening Reference Conversion
o Object = ""; //simgple...

~~~~~
//##5.1.6. Narrowing Reference Conversion
//NA boring

~~~~~
//##5.1.7. Boxing Conversion
a1 Boolean = false;
a2 Byte = 1 as byte;
a3 Short = 5 as short;
a4 Character = 'c'
a5 Integer = 34;
a6 Long = 234l;
a7 Float = 5.0f;
a8 Double = 5.0;

fail1 Integer =   5l; //its ok in concurnas


b1 boolean = a1;
b2 byte = a2;
b3 short = a3
b4 char = a4
b5 int = a5
b6 long = a6
b7 float = a7
b8 double = a8

fail2 int = new Long(5l); //this is also ok
~~~~~
//##5.1.8. Unboxing Conversion

a Integer = new Integer(8) + 6
a2 int = new Integer(8) + 6

b double = new Double(8/6) + 5.

c boolean = new Boolean(false) + new Boolean(false) + false



~~~~~
//##5.1.9. Unchecked Conversion

~~~~~
//##5.1.10. Capture Conversion

~~~~~
//##5.1.11. String Conversion
a String = "";

a += 1
a += false
a += 'c'
a +=   1 as byte
a += 3 as short
a += 1l
a += 1.0
a += 1.0f
a+= null


~~~~~
//##5.1.12. Forbidden Conversions
//U cannot create threads... this helps... (bit of a hack)
t Thread = new Thread();
class Me extends Thread {
a int = 44
};


~~~~~
//##5.1.13. Value Set Conversion





~~~~~
//##5.2. Assignment Conversion
//TODO: when doing interfaces, prevent: Integer, Comparable<Integer>, Comparable, Comparable<String> - in assignment chain

class Test {
    def main(args String[] ) void {//static...
        s short = 12;      // narrow 12 to short
        f float  = s;       // widen short to float
        System.out.println("f=" + f);
        c char = 'c';
        l long = c;        // widen char to long
        System.out.println("l=0x" + Long.toString(l,16));
        f = 1.23f;
        d double = f;      // widen float to double
        System.out.println("d=" + d);
    }
}//ok

def main(args String[] ) void {
    s short  = 123;
    c char = s;    // error: would require cast
    s = c;         // error: would require cast
} //needs casts



~~~~~
//##5.3. Method Invocation Conversion
//basically these tests ensure that the correct method is getting called
//TODO: superclass or subclass method getting called?
class Test {
    def exalready(o String) void { return ; }
	def exalready(o String) void { return ; }//fail

    def m(a byte , b int ) int { return a+b; }
    def m(a short , b short ) int { return a-b; }
    
    def main(args String[] ) void  {
        //System.out.println(m(12, 2));  // compile-time error - because cannot determine most specific function - its ambigious- JPT: i think this is ok, but check ambig rules again
        System.out.println(m(12 as short, 2 as short));  // but this one is ok because you're hitting a specific method call
        System.out.println(m(12 as short, new Short(3 as short)));  // automatically convert from a boxed type to the primative type
    }
}


//return types check... - not really sure if this belongs here or not...

def m(o String) void { return ; } //good
def mo(o String) void { return 5; } //bad
def moo(o String) void { return null; } //bad
def mooo(o String) String { return null; } //ok
def moooo(o String) String { return new Object(); } //obj not subtype
def mooo0o(o String) Object { return new String(); } //ok
def mooo00o(o String) String { return 12; } //not ok
def mooo0d0o(o String) Object { return 12; } //this is ok!

//ensure correct one chosen...

def something(x int ) void { return;  }

s boolean = something(3) //better error message


def cho(a int, o Object) boolean { return false; } 
def cho(aa int, o String) String { return null; } 

def main2(a int) void
{
	res boolean = cho(12, new Object());
	res boolean = cho(12, ""); //this should correctly give an error indicating that the correct method is being selected
}

def nullarg() String {return "";}//this should be ok

from java.util import List, ArrayList
def cahpo( o Object?) String { return ""; } 
def cahpo( o List<String>?) boolean { return false; } 
res boolean = cahpo( null);//this is not ambious, null resolves to List<String>

def cho2( o Object, b String) boolean { return false; } 
def cho2( o String, a Object) String { return null; } 

res2 boolean = cho2( null, null); //this is still ambigous, ok...


def cahpo2( o Long) String { return ""; } 
def cahpo2( o Integer) boolean { return false; } 
res boolean = cahpo2( null);//Long and Integer are not related and represent seperate islands -> null
res2 = cahpo2( 5);//this is ok
res2 = cahpo2( 5.0);//and this is not ok


~~~~~
//##5.4. String Conversion
//covered in 5.1.11

~~~~~
//##5.5. Casting Conversion

// obj  Object = (Object)(new Object[2]);
//check points in 5.1.3 - they are narrowing but are ok to cast via (only them...) - should throw an error really
//TODO: warning gennerated on narrowing cast convertion of primative



//Table 5.1. Casting conversions to primitive types
//prim cast
a1 = false as boolean;
a2 = 44 as boolean; //YES! it's ok
a3 = 'c' as float;
a4 = 2e1f as long; 

//from boxed to prim
b1 = new Boolean(false) as boolean;
b2 = new Float(4.f) as double;
b3 = new Float(4.f) as char; //fail in java, ok here

//from boxed to boxed
c1 = new Boolean(false) as Boolean;
c2 = new Long(45L) as Boolean;; //no

//from boxed to Object
d1 = new Boolean(false) as Object;

//from prim to boxed
e1 = 12l as Long;
e2 = 12 as Long //its ok in concurnas but not in java

//from prim to object(does it get boxed up automatically?)
f1 = 12 as Object; //yah, this is ok

~~~~~
//##5.5.1. Reference Type Casting
//TODO: might be more to do here?
p = new Object() as String
p1 = "" as Object
p2 = new Integer(3) as String;//not ok

~~~~~
//##5.5.2. Checked Casts and Unchecked Casts
//na
~~~~~
//##5.5.3. Checked Casts at Run-time
//NA
~~~~~
//##5.6. Numeric Promotions
//as below

~~~~~
//##5.6.1. Unary Numeric Promotion
//We do not have this in concurnas...
// seems mad to support this: a = [1,2,3]; got int = a[c"c"]; //in java 'c' gets promoted to int..
//but u can't do this: a int = c"c";...


~~~~~
//##5.6.2. Binary Numeric Promotion
//again we don;t subscribe to this particular brand of madness in concurnas
def main(args String[]) void  
{
        i int     = 0;
        f float   = 1.0f;
        d double  = 2.0;
        // First int*float is promoted to float*float, then
        // float==double is promoted to double==double:
        if (i * f == d)
        {	
        	System.out.println("oops");
        }
		
        // A char&byte is promoted to int&int:
        b byte  = 0f;
        c char = 'G';
        control int  = c and b;
        System.out.println(Integer.toHexString(control));
		
        // Here int:float is promoted to float:float:
        f =  i if (b==0) else 4.0f;
        System.out.println(1.0/f);
}





~~~~~
//##6. Names

~~~~~
//##6.1. Declarations

~~~~~
//##6.2. Names and Identifiers

~~~~~
//##6.3. Scope of a Declaration

~~~~~
//##6.4. Shadowing and Obscuring

String String = "";
Object Object = new Object()

from java.util import List, ArrayList
zz = new List<String>(); //btw you cannot instantiate this!
List List<String> = new List<String>();

//already decl
def fff(a int) void
{
	b int = a//ok
	a int = a//not ok cannot force redeclare
	a double = a//not ok cannot force redeclare
}

~~~~~
//##6.4.1. Shadowing
//various stuff
from java.util import List, ArrayList

zz = new ArrayList<String>();

aString String = zz.get(0)

ret String = ""

for(z in zz)
{//z will be avaiable in local context
	z int = 7; //cannot do this
	ret += ""+z.charAt(0)//only string has this (probably)
	localThing int = 8
}

ret += localThing; //fella doesnt exist

a java.lang.String = ""

defonewvari += 5;//this is not permitted for new stuff
defonewvari = 5;//bute this is of course ok

{scopedint int = 7;} ; lovers = 2 + scopedint //should throw an error as not in scope
lovers += 1 //but failure of the above causes it to fail too whcih is wrong - bug fixed!

~~~~~
//##6.4.2. Obscuring

~~~~~
//##6.5. Determining the Meaning of a Name

~~~~~
//##6.5.1. Syntactic Classification of a Name According to Context

~~~~~
//##6.5.2. Reclassification of Contextually Ambiguous Names

~~~~~
//##6.5.3. Meaning of Package Names
~~~~~
//##6.5.3.1. Simple Package Names
~~~~~
//##6.5.3.2. Qualified Package Names
~~~~~
//##6.5.4. Meaning of PackageOrTypeNames

~~~~~
//##6.5.4.1. Simple PackageOrTypeNames

~~~~~
//##6.5.4.2. Qualified PackageOrTypeNames

~~~~~
//##6.5.5. Meaning of Type Names

~~~~~
//##6.5.5.1. Simple Type Names


~~~~~
//##6.5.5.2. Qualified Type Names

class Test {
    def main(args String[] )  void  {
        date java.util.Date  = new java.util.Date(System.currentTimeMillis());
        System.out.println(date.toLocaleString());
    }
}
//this is totally ok



~~~~~
//##6.5.6. Meaning of Expression Names

~~~~~
//##6.5.6.1. Simple Expression Names
//TODO: final module level variables
v int;
f int = 3;

class Test {    
    def main(args String[]) void  {
        i int ;
        i = 1;
        v = 2;
        f = 33;  // in concurnas this is not a compile time error, the call to set f is routed upwards to the static thing
        //if it were declared final then we'd have a problem [const?]
        System.out.println(i + " " + v + " " + f);
    }
}



~~~~~
//##6.5.6.2. Qualified Expression Names
//final test is the jls one, rest are just def (premptive)
class Point(x int, y int) {
    public nPoints int
}

class SimpleClass()
{
	public xxx int = 49
	this(xxa int) 
	{
		this.xxx = xxa;//this is ok
		ad String = xxx; //this complains because xxx (this.xxx) is an INT!
		{y = this.xxx;}//this is ok
	}
	
	def ss() void
	{
		{y = this.xxx;}       //this is ok
		{this.xxx = this.xxx;}//this is ok, also ok
		{++this.xxx;}		  //also fine, though weird, dunno why ud want a new scope but anyway...
	}
	
	{a = 66;} //this is NOT OK
}

class Boyish
{

	{ a  =6; } //cannot have a block nested directly in a class

	public c = 7;//render externally accessible

}

a Object = new Boyish()
a.c= 8 //fails as a is declared as being of type Object
if(c is Boyish)
{
	(a as Boyish).c = 8 //but this is ok, cos we cast it first, fails syntax test, oops
}

if(a is Boyish)
{
	(a as Boyish).c = 8 //but this is ok, cos we cast it first, fails syntax test, oops
}


class Test {
    def main(args String[]) void {
        i int  = 0;
        i.x++;        // compile-time error
        p = new Point(1,2);
        p.nPoints();  // compile-time error
        p.nPoints ++;//ok
        
    }
}

//more def stuff...


class Two()
{
	public xxx int = 49

	this() 
	{
		this.xxx = 6;
	}
	
	def zz() void
	{
	}
}

//lets try to instantiate one of our classes...
one = new Two(2) //fails
two = new Two() //ok
two.beards()//fails
two.zz() //ok
two.xxx++;//ok


//do recursive function...
def fib(n int ) int 
{ 
	return fib(n-1) + fib(n-2); 
}


//avoid ambigious constructor...

class Amibg
{
	this(a Object, b String){}
	this(a String, b Object){}
	
}
uhoh = new Amibg("","") //yeah! this is defo ambigous

~~~~~
//##CONC this constructors
class A
{
	public goo int; //todo finals, will have to get this set
	this()
	{
		this(99) //this is ok, fwd ref
		this(99) //no has to be first call
		super(8) //no has to be first call
	}
	
	this(x String)
	{
		super(8)//search for superconstructor wil fail of course
	}
	
	this(x int)
	{
		this.goo = x
	}
	
	def doing() int
	{
		return this.goo
	}
}

a = new A()
f= a.goo as int
u=a.doing() as int


~~~~~
//##6.5.7. Meaning of Method Names

~~~~~
//##6.5.7.1. Simple Method Names

~~~~~
//##6.5.7.2. Qualified Method Names

~~~~~
//##6.6. Access Control
//TODO: public private etc, is covered heres





~~~~~
//##6.6.1. Determining Accessibility
class Point {
     x int 
     y int ;
    def move(dx int , dy int ) void { x += dx; y += dy; }
    def moveAlso(dx int , dy int) void  { move(dx, dy); }
}

~~~~~
//##6.6.2. Details on protected Access


~~~~~
//##6.6.2.1. Access to a protected Member


~~~~~
//##6.6.2.2. Qualified Access to a protected Constructor
//doesnt belong here but test anyway
nofwd = new C()//not allowed at this level

//check fwd reference works ok
class C
{
	public class A(b B) {  }
	
	public class B	{ 	a =55; c Ca = new Ca("");	} //we can have fwd refernces here

	public class Ca(a String){}
	
	public class Inner(a Object){}

}

class D{}
ss = new C()
inner = ss.new Inner( new D() )
cool = ss.new Ca("cool"); //this works ok
ss4 = new C(). new B() //and this is ok
cool = ss4; //NO obsvly this cant work
ss3 = new C.Ca("cool")//NO you cannot do this as Ca is not static



~~~~~
//##Classes cannot ext self

class C{ class A{ class C {} } } //cannot nest type an hide name

~~~~~
//##6.7. Fully Qualified Names and Canonical Names

open class O1 { class I {} }
class O2 extends O1 {}



~~~~~
//##8. Classes


/*
class Value { 
 val int=99
 val2 int; 
}

v1 = new Value();
v1.val = 5;
*/

import java.util.ArrayList;

open class B
{
	g ArrayList<String>? ;
}
	
class C extends B
{
	ar ArrayList<String>?  = super.g;
}



~~~~~
//##8.1.a1 Simple class stuff

bob = "";
bob.ddd(""); //ddd doesnt exist
bob.charAt("");//wrong type
bob.charAt(0);//fine

class A<T>(~car T) {} //optional {}'s????

a A<String> = new A<String>("hi");

got String = a.getCar();//ok
a.setCar("niceguy");//ok
a.setCar(44);//fail as there isnt one for a str

a.car = "hi";//autoconvert to the setter... func.. later


~~~~~
//##8.1.a2 getters settters

class A<T>(~car T) {}
class B<T>(+car T) {}
class C<T>(-car T) {}
class D<T>(car T) {}

a A<String> = new A<String>("hi");
b B<String> = new B<String>("hi");
c C<String> = new C<String>("hi");
d D<String> = new D<String>("hi");

got String;

a.setCar("");
got = a.getCar();

b.setCar("");
got = b.getCar();//just setter

c.setCar("");//just getter
got = c.getCar();

d.setCar("");//no getter
got = d.getCar();//no setter

~~~~~
//##8.1.a3 getters settters fields

class AA<T>(~car T) { }
aa AA<String> = new AA<String>("");

class BB<T> { ~car T?;}
bb BB<String> = new BB<String>();

aa.setCar("");
aa.getCar();

bb.setCar("");
bb.getCar();



~~~~~
//##8.1.a4 getters settters fields - specifically arrays


import java.util.ArrayList;
import java.util.List;

System.out.println( new String[2] ); //println has Object arg, and arrray is an obj...

class B<T> { public ~something T[]?; ~another Object[]?; public ~prim double[]?; }

aa B<String> = new B<String>();
aa.setSomething(new String[2] );
System.out.println(aa.getSomething());
aa.something = new String[2];//cools tpye matches
aa\.something = new Object[2];//cannot upcast
aa.something = new Object[2];//cannot upcast - not atuo field op fails too
aa.another = new Object[2];//fine
aa.another = new String[2];//non primative so subtype ok
aa.prim = new double[2];//fine
aa\.prim = new float[2];//cant upcast this
aa.prim = new float[2];//cant upcast this - not atuo field op fails too
aa.prim = new float[2] as double[];//cant upcast this either
aa.setPrim([2.0 4.f])//fine as double array
aa.setPrim(new int[2])//not fine, as int array to double



~~~~~
//##8.1.a5 generic cast

class A<T>
{
	def get() T
	{
		return ( new Object() ) as T //actually u dont need the returns
	}
}


~~~~~
//##8.1.a6 dont allow duplicate vars
class B(x String, x String, x int)
{
	 x boolean;
}

class C()
{
	 x boolean = false;
	 x = false; //error as already declared
	 x = 7
	 x = 7
	 x boolean = false
	 x int = 9
}

class Oops
{
	var2 = 8;
	var2=8;//not allow as var already defined at this level with infered type
	car int = 5;
	car = 6;
}

~~~~~
//##CONC dup cls name

class A{}
class A{}

~~~~~
//##CONC class name variants

class Cont
{
	public class SubA {}
	public class SubB {}
}

class SubA{} //this is ok
//relative and abs type referencing
str = new java.lang.String(); //abs path reference

cont = new Cont();               
cont = new xCONCclassnamevariants.Cont();        // search abs user path ok
cont2 xCONCclassnamevariants.Cont = cont;
cont3 Cont = cont
cont4 xCONCclassnamevariants.Cont.SubA = cont.new SubA()  //abs type reference
cont5 Cont.SubA = cont.new SubA();        //type reference via non abs
cont6 Cont.SubA = cont.new SubA(); //ok as well, SubA decl avaialbel to all

//cast gives full path
tryCast  = cont.new SubA(); h = tryCast as int //throws cast error with full package name, no relative rubbish

~~~~~
//##CONC outer class overrides nested

//outer, overrides nested classdef, so have to refer by abs path or relative abs
class Cont
{
	public class SubA {}
	public class SubB {}
}
class SubA{}
cont = new Cont();
wrongtype1 SubA = cont.new SubA(); //no this is overriden
wrongtype2 Cont.SubA = new SubA(); //no this is overriden
wrongtype3 xCONCouterclassoverridesnested.Cont.SubA = new SubA(); //no this is overriden

ok1 Cont.SubA = cont.new SubA(); //ok as well, SubA decl avaialbel to all
ok2 xCONCouterclassoverridesnested.Cont.SubA = cont.new SubA(); //ok as well, SubA decl avaialbel to all

~~~~~
//##CONC nested classes via parent only
class Cont
{
	public class SubA {}
	public class SubB {}
}

//nested vs. static classes
cont = new Cont();
ok = cont.new SubA();
notallow1 = new Cont.SubA(); //this is not allowed as nested type, need cont instance...
notallow2 = new xCONCnestedclassesviaparentonly.Cont.SubA(); //this is not allowed as nested type

//but there is an exception in the case of nested classes at the same level...

class Outer { 
  	alsook =  new Inner2();
  	public class Inner2 { car Inner1 = new Inner1(); }//fwd ref
  	public class Inner1 {  }
  	alsook =  new Inner2();
  	alsook =  new Outer.Inner2();//ref via almost full path name as well
  }//this is permitted (fwd ref and non outer class object ref)


class Outer2 {
	public class InnerL1{ class InnterLevel2 {}; }
	public class InnerL2{ car = new InnerL1(); }
	public class InnerL3{ car = new InnterLevel2(); }//no
}

~~~~~
//##CONC class lines restricted
class Cls
{
	a = 9 //ok
	func() //no
	def () void { } //no lmabdas
	this() { a = 8;} //ok
}


~~~~~
//##CONC generic class must link to something
from java.util import ArrayList
arr = new ArrayList<Inteddger>();

~~~~~
//##CONC good news a new hope autocasts on params
//amazingly this all works!
ag=4 

class Hope
{
	~a Boolean = false
}

a = new Hope()

a.a = true;
a.a = new Boolean(false);
a.setA(false)
a.setA(new Boolean(true))

oh Boolean = a.a
oh2 Boolean = a.isA()

oh3 boolean = a.a
oh4 boolean = a.isA()



~~~~~
//##CONC duplicate vars

def bb(b int, b int, 
b int) int
{ return b+ b ; }

class GOG(a int, a int){
	this(b int, b int, b int)
	{
		this(b)
	}
	
	this(f int){}
}


~~~~~
//##CONC abstract classes - 1

//abstract functions:

from java.util import List, HashMap

class Abstr //class is implicitly abstract
{
	def bb(x int) int { return x+1;} //not abstract
	def ab(x int) int //abstract as no method body
	def ac2(int)  //missing rettype
	def ac(int) int //abstract
	def overme() { ss = 9 ; }
	
	def oops(int) int {return 69;} //missing var name

}

def abast(x int) int //abstract, not allowed outside class def


abstract class EmptyAbst //can also be explicit
{
	
}

class Okdude extends EmptyAbst{}

//cannot create an instance of an abstract class

l = new List<Integer>() //not instantiable
a = new Abstr()
b = new EmptyAbst() //likewise
ok EmptyAbst = new Okdude() //fine

class naughtyChild extends Abstr { } //bad! needs to implement the abstract methods

class goodChild extends Abstr
{
	def overme() {sss = 77 ; } //error, should have been overriden  
	override def bb(x int) int { return x+1;} //must use override
	def ab(x int) int { return bb(x+2); } //good, implemented as approerpiate
}


~~~~~
//##CONC abstract classes - 2

class Sup<X, Y>
{
	def ss(X) X
}

class ChildBadGenericStr<X, Y> extends Sup<String, Boolean> {} //error should refer to String, bound

class ChildBadGeneric<Z, B> extends Sup<B, String> {}  //error should refer to B, unbound

class ChildokGeneric<X, Y> extends Sup<Y, Boolean> {
def ss(abb Y) Y { return abb; } //ok, unbound but fine
}
abb String = (new ChildokGeneric<Integer, String>()).ss("");

class ChildGoodGenericFixed extends Sup<String, String>
{
	def ss(a String) String { return a; } //types got fully bound, 
}

from java.util import ArrayList
//try this:
class MyList extends ArrayList<String>{}
mm = new MyList();
mm.add("")// fine when go over java

//a few levels deep
class Master<A,B>
{ 
	def master(A) B
}

class MiniMaster<C,D> extends Master<String, D>
{
	def master(java.lang.String) D
}

class Kid<C> extends MiniMaster<String, Integer>
{
	def master(oh java.lang.String) Integer {return 69;}
}

//affects variables as well?
//class Fuddy<T>(~myVar T) {} fd = new Fuddy<String>(); check String = fd.myVar; 

open class SupVar<X,Y>
{
	~g Y?
}

class KidVar<B> extends SupVar<Integer, B>
{}

kid = new KidVar<String>()
comeon String? = kid.getG()
comeon2 String? = kid.g


~~~~~
//##CONC abstract classes - 3
//generic and other stuff gets passed down to childrens

a = 88


class SupAbstr
{
	def foo() 
	def goo()
}

class ChildAbst extends SupAbstr
{
	def foo() 
	//def goo() //dont define just yet
} 

class Child extends ChildAbst
{
	//needs both!
}

//now we may also define the generic types as well


class SupAbstrGeneric<T>
{
	def foo() T
	def goo(T)
}

class ChildAbstGeneric<B,C> extends SupAbstrGeneric<C>
{
	def foo() C
	//def goo() //dont define just yet
} 

class ChildGeneric extends ChildAbstGeneric<Boolean, String>
{
	//needs both!
}


class ChildGenericUndef<Z,V> extends ChildAbstGeneric<V, Z>
{
	//needs both!
}


~~~~~
//##CONC override function (inc abstr)
ilike = 69


override def doings() void {}

class NaugtySup
{
	override def doings() { } //FAIL as no superclass
	override def equals(a Object) boolean { return  this == a; } //fine
}

class BadExtendObjectAbstr
{
	def equals(a Object) boolean //FAIL cos u need to override it
}

class BadExtendObjectDefined
{
	def equals(a Object) boolean { return  this == a; } //FAIL cos u need to override it
}

class OkExtendObjectAbstr
{
	override def equals(a Object) boolean //OK
}

open class OKObjectExtendObjectDefined
{
	override def equals(a Object) boolean { return  this == a; } //ok
}

class OkExtendObjectAbstrChildBad extends OkExtendObjectAbstr  //FAIL
{}

class OkExtendObjectAbstrChildOK extends OkExtendObjectAbstr
{
	def equals(a Object) boolean { return  this == a; } //ok
}

class OkExtendObjectAbstrChildOKNeedKW extends OKObjectExtendObjectDefined
{
	def equals(a Object) boolean { return  this == a; } //need override keyword
}


class SupAbst
{
	def foo() 
	def goo()
}

open class Sup extends SupAbst
{
	def foo() { x = 7; } //implimentation
	
}

class Child extends Sup
{
	override def foo() { x = 7; }//missing goo is carried down into the child as well, inherits debt
}


~~~~~
//##CONC function ret type overrides
//function in subtype MUST 
//primative type must match exactly (including void), no boxing unboxing
//object type must be subtype

open class Sup
{
	def fooi() int { return 69;}
	def foo2i() int
	def food() double
	def fooObj() Object
	def fooObjLessGen() String
	def voidray()
}

class Child extends Sup
{//all these fail
	override def fooi() float { return 69.f;}
	def foo2i() float 
	def food() float
	override fooObj() Float //OK
	def fooObjLessGen() Object //FAILL as going more genneral
	def voidray() int
}

open class SupLowest
{
  def fooObj() Object { return "";}
}

class ChildLowest extends SupLowest
{
  override fooObj() String { return "";}
}

str String = (new ChildLowest()).fooObj()//not object, i.e. take the lowest defintion of the more specified return type
oops Object = (new Child()).fooObjLessGen()

~~~~~
//##CONC cannot det sup abs type so make err

open class Sup
{
	def voidray()
}

class Child extends Sup
{//all these fail
	def voidray() int //ok, though parent type is busted
}

~~~~~
//##CONC check supclass pass through generics ok
open class Sup<XXX, Z>
{
	def get() XXX { return null;} 
}

open class Uh<G, KKK> extends Sup<G, Boolean>
{}

class Child extends Uh<String, Float>
{
	override def get() String { return null;} //this is ok because it gets passed up through refs 
}


~~~~~
//##CONC generic types can be primatives

class Sup<X, Y>
{
	def go(s X) X { return s; } 
}


class Child<X, Za> extends Sup<X, int>
{}


ok  Child<float, int> = new Child<float, int>()//gets autocast

arrNo = new Child<int, int>[2,4]();

thisisOk  Child<float[], int[]> = new Child<float[], int[]>()
alsoOK    Child<Float[], Integer[]> = new Child<Float[], Integer[]>()

~~~~~
//##CONC even more def with generics etc
from java.util import ArrayList

class Bpp<X>{ def foo() ArrayList<X> { return null; } }
got ArrayList<String> = (new Bpp<String>()).foo()
//generic child qualificaiton - ok


//no more non gen
open class A<X>
{
	x X?
	def getX() X { return null;}
}

class Z<X>
{}

class B<AAA> extends A<Z<AAA>> //JPT: if Z is not immediatly resolveable this may be a problem...
{}

b = new B<String>()
comeon Z<String> = b.getX()
comeon  = b.x

class B2<Y> extends A<ArrayList<Y>> {}

b2 = new B2<String>()
comeon2 ArrayList<String> = b2.getX()
comeon2  = b2.x

//need explicit override
class Bo<AAA> extends A<Z<AAA>>
{
	override def getX() Z<AAA> { return null;} //omg it works!
}


class NotAllowed<FF> extends A<FF<String>>{} //FAIL!!! u cannot do this, who knows if FF is generic even if it extends a generic type!


class Oops extends Oops {}//FAIL NO

class Oops2<X> extends Oops2<X> {} //FAIL cannot imp subtype of course because not yet decalred in scope


class OopsMore<X> extends ArrayList<OopsMore<X>>{} //this is fine
j OopsMore<java.lang.String> = (new OopsMore<String>()).get(0)


class SupLA
{
	def g() int
}

abstract class SupSupLA extends SupLA
{
	def g() Integer //FAIL, conflicting type
}

open class Top<X,Y,Q> { ~x X?; ~y Y?; ~q Q? }

open class Middle<Acc, AA, AAA> extends Top<AAA, AA, Acc> {}

class Lower<X> extends Middle<Integer, X, ArrayList<Float>> {} //this should fail as there is no superconstructor, TODO: takes place in later compilation stage

low Lower<String> = new Lower<String>();
jtt  ArrayList<Float>? = low.x
j2 String? = low.y
j3 Integer? = low.q

~~~~~
//##CONC generics use the question mark and force coloring
from java.util import ArrayList, List

class GenAB<A, B>
{
	def aa() {
		a ArrayList<B> = (new Object() ) as ArrayList<A>;//FAIL
		aa ArrayList<B> = (new Object() ) as ArrayList<B>;//this is fine
		aaa ArrayList<List<B>> = (new Object() ) as ArrayList<ArrayList<A>>;//FAIL, JPT: should this be allowed?
		g B<ArrayList<A>> = null;///FAIL cannot be gen itsefl
	}
}


obj = new Object();
fails = obj isnot List<String>;//FAIL
itsok = obj isnot List<?>; //OK
cannotdoraw = obj is List;

kl = new ArrayList<?>();//OK, but a bit stupid

~~~~~
//##CONC generics must match 1:1
from java.util import ArrayList, List

open class Supsup{} class Childchild extends Supsup{}
ok Supsup = new Childchild();
ohnoes List<Supsup>  = new ArrayList<Childchild>();
ohnoes2 List<Supsup>  = new ArrayList<Object>();
ohnoes3 List<Object>  = new ArrayList<Supsup>();

~~~~~
//##CONC generics qualified cannot exist in heirachy
class Parent<X> {
	class Nestee<X> { } //error because X hides previously defined generic, and ur new def in boy obscures this fact
}


~~~~~
//##CONC generic nested classes def and games
from java.util import ArrayList

//nested child types ensure inherited generic parameters get colored in
open class Sup<SSS, AAA>
{
	~held SSS?;
	def foo(s SSS) SSS { return s; }
	
	~held2 AAA?;
	def foo2(s AAA) AAA { return s; }
}

class Child<X> {
	
	public class Boy<T> extends Sup<X, T>
	{
		public class LittleBoy<K> {
			def littlFun(t T) T { return t; }
			}
	}
	def makeABoy() Child<String>.Boy<Float> { return new Child<String>.Boy<Float>(); }
	def makeABoyFromMe() Child<X>.Boy<Float> { return new Child<X>.Boy<Float>(); }
	//def makeABoyFromMe() Boy<Float> { return new Boy<Float>(); }  
	//the above should be permitted  
}


xxx int  = (new Child<String>() ).new Boy<Float>(); //force and double check that full qualified type is referenceded
xxxx int = (new Child<String>() ).new Boy<Float>().new LittleBoy<Sup<String, Integer>>();//here is a manialical case!
boy Child<String>.Boy<Float> = (new Child<String>() ).new Boy<Float>();
s  String = boy.foo("");//OK u qualified it above

boyFail Child<String, Float>.Boy<Float> = (new Child<String>() ).new Boy<Float>(); //FAIL Noes, params dont match
noes Child.Boy<Float> = (new Child<String>() ).new Boy<Float>(); //FAIL u forgot to qualify it


{
	implicit = (new Child<String>() ).new Boy<Float>();
	s  String = implicit.foo("");
}

{
	//ensure correct type decl
	wrong Child<Float>.Boy<Float> = (new Child<String>() ).new Boy<Float>();//FAIL: rhs is not a subtype of lhs
}

{//the mad case 
	almost = (new Child<Float>() ).new Boy<String>()
	implicit = almost.new LittleBoy<Sup<String, Integer>>();
	s  String = implicit.littlFun("");//cool
}


{//check for arrays
	asArr Child<String>[]  = new Child<String>[2];
	//assume it got init somehwere here...
	implicit = asArr[1].new Boy<Float>()
	s  String = implicit.foo("");
}



//TODO: tests just like these on already existing compiled types in java (added to classpath)


~~~~~
//##CONC parent nestor generics must match

open class Sup<SSS, AAA>
{
	~held SSS?;	def foo(s SSS) SSS { return s; }
	~held2 AAA?; 	def foo2(s AAA) AAA { return s; }
}

class Child<X> { public class Boy<T> extends Sup<X, T> { public class LittleBoy<K> { def littlFun(t T) T { return t; } }	} }

{ fail Child<String>.Boy<String> = (new Child<Integer>()).new Boy<Integer>(); //FAIL 
}

{ fail Child<Integer>.Boy<String> = (new Child<Integer>()).new Boy<Integer>(); //FAIL
}

{ fail Child<String>.Boy<Integer> = (new Child<Integer>()).new Boy<Integer>(); //FAIL
}


~~~~~
//##CONC more parent nestor generics partly defined constructors...

class SimpleParent {
	public class SimpleChild(~xxx String, ~yyy String) { }
	
	def maker(arg int) SimpleChild {
		return new SimpleChild("arg", "arg2")
	}
}
pars = new SimpleParent(); childs1 SimpleParent.SimpleChild = pars.maker(69)

//generics...
class Parent<XP>
{
	public class Child<ZC>(~xxx ZC, ~yyy XP) {	}
	
	def maker(arg XP) Child<String>
	{
		return new Child<String>("arg", arg)
	}
	
	def maker2(arg XP) Parent<XP>.Child<String>
	{
		return new Child<String>("arg", arg)
	}
	
	def maker3(arg XP) Parent<XP>.Child<String>
	{
		return this.new Child<String>("arg", arg)
	}

}

par = new Parent<Integer>()
child Parent<Integer>.Child<String> = par.maker(69) //as if this were not sadistic enough
child2 Parent<Integer>.Child<String> = par.maker2(69) 
child3 Parent<Integer>.Child<String> = par.maker3(69) 
child4 Parent<String>.Child<String> = par.maker3(69) //FAILS - of course

//3 levels
class Level1<X>
{
	public class Leve2<Y>
	{
		public class Level3<Z>
		{
			def gg(x X, y Y, z Z) Z { return z;}
		}
		
		def maker(x X, y Y) Level3<String> { return new Level3<String>(); }
	}
}

l1 = new Level1<Float>();
l3 Level1<Float>.Leve2<Double>.Level3<String> = (l1.new Leve2<Double>()).maker(2.3f, 2.3)
cool String = l3.gg(4.5f, 3.4, "") //totally insane


~~~~~
//##CONC generic constructors 
class GenClass<X, Y>(~x X)
{
	~y Y?;
	this(x X, y Y)
	{
		this(x)
		this.y = y
	}
}
gen GenClass<String, Float> = new GenClass<String, Float>("", 69.f ) //JPT:should this be auto upcast? if 2nd arg is int

~~~~~
//##CONC generic nested extends supertype...
open class Sup<A, B, C>{
	def do1(a A) A { return a; }
	def do2(b B) B { return b; }
	def do3(c C) C { return c; }
}

class Parent<X>
{
	public class Child<Y> extends Sup<X,Y, String>
	{
		
	}
}

child = (new Parent<Integer>()).new Child<Float>()
a1 Integer = child.do1(5);
a2 Float = child.do2(5.f);
a3 String = child.do3("");
 


~~~~~
//##CONC construcors exist at own level only...
open class Parent{
	this(s String)
	{}
}

class Child extends Parent{ }

class NoConst {}

c = new Child("");//FAIL!!!
no = new NoConst("");//FAIL!!!


~~~~~
//##CONC generic const and method erasure 1
class Gen<X>{}

class Par<X, Y>
{
	def gg(a Gen<X>) {}
	def gg(a Gen<Y>) {}//FAIL as already defined
}

class ParUnqual
{
	def gg(a Gen<String>) {}
	def gg(a Gen<Float>) {}//FAIL as already defined
}

~~~~~
//##CONC generic const and method erasure 2
//even on nestedtypes...

class NestorGen<T>
{
	class Neste<TT>{}
}

class Par2Fail1<X, Y>{
	def gg(a NestorGen<String>.Neste<String> ) {}
	def gg(a NestorGen<String>.Neste<Integer> ) {}//FAIL as already defined
}

class Par2Fail2<X, Y>{
	def gg(a NestorGen<String>.Neste<String> ) {}
	def gg(a NestorGen<String>.Neste<X> ) {}//FAIL as already defined
}

class Par3Fail2<X, Y>{
	def gg(a NestorGen<String>.Neste<String> ) {}
	def gg(a NestorGen<Integer>.Neste<Integer> ) {}//FAIL as already defined
}

~~~~~
//##CONC generic const and method erasure 3 -simple genclash
class GenClass<X, Y>
{
	~y Y?;
	~x X?;
	this(x X)
	{
		this.x = null;
		this.y = null
	}
	
	this(x Y) //FAIL as same erasure
	{
		this.x = null;
		this.y = null
	}
	
	def xxx(x X) {}
	
	def xxx(x Y) {} //FAIL as same erasure
		
	def xxx(d int, x X) {}
	
	def xxx(d int, x Y) {} //FAIL as same erasure
}

~~~~~
//##CONC generic must be totally formalized

open class Sup<X>
{
	def doing(x X ) X { return x; }
}

class Childa<X> extends Sup<String>
{
	def doing(x String ) X { return null; }
}

~~~~~
//##CONC generic override in child, prevents accidental - very cool
open class OKPArent<X>{
	def gg(x X) X { return null; }
}

class ChildOK extends OKPArent<String>{
	override def gg(x String) String { return null; } //cool, must be override, that's a nice quality
}

~~~~~
//##CONC generic const and method erasure 4 - complex with supertypes erasure

open class GenClass<Q1, Q2>
{
	def xxx(x Q1) Q1 { return null; }
}

class ConstAreFines<X,Y> extends GenClass<X,Y>
{
	this(x Y) {}//this is fine
}

class ChildCls<X,Y> extends GenClass<X,Y>
{
	override def xxx(x X) X { return null; } //ok as same erasure, exists already, but overrides
}

class ChildClsFail<ZZ,Y> extends GenClass<String,String>
{
	def xxx(x ZZ) ZZ { return null; } //FAIL as same erasure, exists already
}

class ChildClsFailAlso<X,Y> extends GenClass<Y, X>
{
	def xxx(x X) Y { return null; } //FAIL as same erasure, exists already
}

~~~~~
//##CONC generic const and method erasure 4 - complex with supertypes erasure part 2 with 3 levels
open class L1<X, Y> {
	def go(x X) X {return x }
}

open class L2<K,V> extends L1<String,V>{
}


class L3<F,M> extends L2<Integer, Float>
{
	def go(x M) M {return x }
}


~~~~~
//##CONC generic const and method erasure 4 - complex with supertypes erasure part 3 - qualifcation of generics
from java.util import ArrayList

open class GenClass
{
	def xxx(x ArrayList<String>) String { return null; }
}

class ConstAreFines extends GenClass
{
	def xxx(x ArrayList<Integer>) String { return null; }
}


~~~~~
//##CONC just check some more override and abstract
open class SupAbst
{
	override def toString() String
}

class ChildFails extends SupAbst{} //Fail as missing def

class ChildAlsoFails extends SupAbst
{
	override def toString() String { return ""; } //Fail as overriding an abstract thing
}

class ChildFine extends SupAbst
{
	def toString() String { return ""; } //Fine because finanly defining an abstract thing
}

class ChildFineCleve extends SupAbst
{
	def toString() String //ok as it was never deinfed in the above class was it? (nooo!)
}


open class SupAbst2{}
class ChildFialThrough3rdLevel extends SupAbst2
{
	def toString() String //Fail as from 3rd level
}




~~~~~
//##CONC this-super classes functions and variables - 1 - pickup super type

open class Sup() { 	x = 8; }

class Child extends Sup
{
	def gg() int { return x + this.x + super.x; }
}


~~~~~
//##CONC this-super classes functions and variables - 2 - choose from this and superdef

open class Sup{
	x String = ""
}

class Child extends Sup{
	x float = 6.7f;
	
	def doings()
	{
		g float = this.x
		g2 float = x //defaults to this.x
		g3 String = super.x
		
	}
}


~~~~~
//##CONC this-super classes functions and variables - 3 - choose from this and superdef functions
open class Sup{
	def xxx() String {return null; }
}

class Child extends Sup{
	def xxx2() float { return 67.7f; } 
	
	def doings()
	{
		g float = this.xxx2()
		g2 float = xxx2() //defaults to this.x
		g3 String = super.xxx()
		
	}
}

~~~~~
//##CONC this-super classes functions and variables - 4 - choose from this and superdef functions generics

open class Sup<PPP>{
	def xxx() PPP {return null; }
}

class Child extends Sup<String>{
	def xxx2() float { return 67.7f; } 
	
	def doings()
	{
		g float = this.xxx2()
		g2 float = xxx2() //defaults to this.x
		g3 String = super.xxx()
		
	}
}


~~~~~
//##CONC this-super classes functions and variables - 5 - choose from this and superdef functions generics unqualified

open class Sup<PPP>{
	def xxx() PPP {return null; }
}

class Child<XPPP> extends Sup<XPPP>{
	def xxx2() float { return 67.7f; } 
	
	def doings()
	{
		g float = this.xxx2()
		g2 float = xxx2() //defaults to this.x
		g3 XPPP = super.xxx()
		g4 Object = super.xxx()//yeah, ok...
		
	}
}

~~~~~
//##CONC super constructor invokation, 1 - explicit
open class Pa(a int){}
class ChildFail extends Pa {
	this(x float){ 	super(x);	}
	this(x int) { super(x); }
}

~~~~~
//##CONC super constructor invokation, 2 - helper autogen
open class Parent1(~a int, ~b double){}

class Child1(x int, y int) extends Parent1(x,y) {}
class Child2(x int, y int) extends Parent1(x*2,y) {}

c = new Child1(1,2)
fail1 int = c.x //as passed upwards and not assigned as a local variable
ok int    = c.a
ok = c.getA() ;c.setA(ok)

CONSOTO  = 29
class Child3(x int, y int) extends Parent1(x*2,CONSOTO**y) {}

~~~~~
//##CONC super constructor invokation, 3 - gen default
g = 8

class Som(~x String) {}
s = new Som()//FAIL as no default constructor

class Two(){}
s = new Two();

~~~~~
//##CONC super constructor invokation, 4 - ensure correct stuff callable...
open class Sup(x int){}

class ChildNoThisOrSuper(x int) extends Sup(x) {
	this() { 	super(super.x,    //FAIL no super or this references allowed
					this.y); 	} //FAIL cannot make references to either of these
}


def globFun() int {return 5;}
globVar = 88

arr = [1,2,3]

class ChildFail(x int) extends Sup(x) {
	this() { super(xxx()); } //FAIL
	this(a int, b int)  { super(x); } //FAIL 
	this(x int, a int, b int) { super(arr[xxx()]) ; }//FAIL
		
	def xxx() int { return 4; }
}

class ChildOk() extends Sup {
	this(x int) { super(x) ; }//OK
	this(x int, a int) { super(globFun()) ; }//OK
	this(x int, a int, b int) { super(globVar) ; }//OK
	this(x int, a int, b int, c int) { super(arr[2]) ; }//OK
	this(x int, a int, b int, c int, de int) { super(arr[globFun()]) ; }//OK
		
	def xxx() int { return 4; }
}

~~~~~
//##CONC import name cannot mask existing type
from java.util import Map as String//FAIL

~~~~~
//##CONC imports can go anywhere and have scope
from java.util import ArrayList

a List<String> = new ArrayList<String>();//FAIL

{
	from java.util import List
	a List<String> = new ArrayList<String>();//OK
}

a List<String> = new ArrayList<String>();//FAIL

mmap HashMap<String, String> = null;//FAIL
def ff() 
{
	from java.util import HashMap
	mmap HashMap<String, String>? = null;//OK
}
mmap HashMap<String, String> = null;//FAIL



~~~~~
//##8. Class simple abstract
s=2

abstract class Point {
    x = 1; y = 1;
    def move(dx int , dy int ) {
        x += dx;
        y += dy;
        alert();//not defined here but it will in a non abstract instance
    }
    
    def alert() void
    
    class Neste
    {
    	def gg()
    	{
    		alert() //this is ok as well even though its not been defined yet
    	}
    }
}

abstract class ColoredPoint extends Point {
    color int ;
}
class SimplePoint extends Point {
    def alert() { }
}

paaa Point = new Point(); //FAIL
po Point = new SimplePoint();


~~~~~
//##8. Class bit more interesting - why we need qualified gen types...

class ConvertibleTo<T> {
    def convert() T
}
class ReprChange<T , S> { 
    -t T?; 
    def set(s S) { t = s.convert();    }//FAIL - would work if u were using a dynamic typ or these were partially qualifiable
    def get() S      { return t??.convert(); } 
}

{
	import java.util.Vector
	
	x = new Vector<String>();
 	y = new Vector<Integer>();
	b boolean= x.getClass() == y.getClass();
}


~~~~~
//##8. some more random stuff

a=6

class Gen<T>
{
	-t T?;
	this(t T, two Gen<T>?) {
		this.t = t
	}
}

gg Gen<String> = new Gen<String>("", null);

f String = gg.t??
aa = 9

class Pair<T, S> {
    fst T ; snd S;
    this(f T, s S) { fst = f; snd = s; }
}

class Seq<T> { 
	head T ;
	tail Seq<T>;

    this() { this(null, null); } 
    
    this(head T? ,  tail Seq<T>?) {
        this.head = head??;
        this.tail = tail??;
    }
    
    def isEmpty() boolean { return tail == null; }

    public class Zipper<S> { 
        def zip(that Seq<S>) Seq<Pair<T,S>>
        { 
            if (isEmpty() or that.isEmpty()) {
                return new Seq<Pair<T,S>>(); 
            } else {
                tailZipper Seq<T>.Zipper<S> = tail.new Zipper<S>();
                //return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail));
                return null;
            }        }    }
}


def main(args String[]) {
	strs Seq<String> = new Seq<String>( "a", new Seq<String>("b", new Seq<String>()));
    nums  Seq<Number> = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>()));

    zipper Seq<String>.Zipper<Number> = strs.new Zipper<Number>();

    combined  Seq<Pair<String,Number>> = zipper.zip(nums);
}



~~~~~
//##8. no local classes

 def classMethod() {
    class LocalInStaticContext { }//no local classes
}


~~~~~
//##8. def with nested
class WithDeepNesting {
    toBe boolean ; 
    this(b boolean) { toBe = b; }

    class Nested {
        theQuestion boolean;
        class DeeplyNested {
            this(){
                theQuestion = toBe or( not toBe); //results in??
            }
        }
    }
}

~~~~~
//##8. final classes cannot be extended
open class Point {  x int ; y int ; }
closed class ColoredPoint extends Point { color int; }
class Colored3DPoint extends ColoredPoint { z int; }  //err
class ColoredPoint2 extends Point { color int; }
class Colored3DPoint2 extends ColoredPoint { z int; }  // err

~~~~~
//##8. what is the

class Point {
    x int ;
    y int;
    def  move( dx int ,  dy int ) { x += dx; y += dy; }
}

class Point2 {
     public x = 1; public y = 5;
}

def main(args String[]) {
    p = new Point2();
    System.out.println(p.x + ", " + p.y);
}

~~~~~
//##8. class - no fwd reference

class Test1 {
     private i int = j;  // compile-time error:
                // incorrect forward reference
     private j  int = 1;
}

class Test2 {
    this() { k = 2; }
    j int = 1;
    i int = j;
    k int;
}

~~~~~
//##8. class - some exceptions
class BufferEmpty extends Exception {
    this() { super(); }
    this(s String) { super(s); }
}
class BufferError extends Exception {
    this() { super(); }
    this(s String) { super(s); }
}
abstract class InfiniteBuffer {
    def get() char { return 'd' };
}


~~~~~
//##8. class - cannot directly invoke abst

abstract class Point {
    override def toString() String 
}

class ColoredPoint extends Point {
    def toString() String  {
        return super.toString()  // error, as not defined
    }
}

~~~~~
//##8. class - cannot directly invoke abst - the right way

abstract class Point {
    x int; y int;
    override def toString() String
    def objString() String { return super.toString(); }
}
class ColoredPoint extends Point {
    color int;
    def toString() String {
        return objString() + ": color " + color;  // correct
    }
}



~~~~~
//##8. class - nested classes cannot be superclass
class Nestor
{
	class Neste{}
}

class AnotherM extends Nestor.Neste
{}


~~~~~
//##8. Class dunno waht this does but looks cool

class Point(x int, y int) {
    this(){ this(0,0); }
    def move(dx int, dy int) { x += dx; y += dy; }
}

def main(args String[] ) {
    p Point[] = new Point[100];
    for (i int = 0; i < p.length; i++) {
        p[i] = new Point();
        p[i].move(i, p.length-1-i);
    }
}

~~~~~
//##8. Class dunno waht this does but looks cool2
def sdf() => 4>5; 
class DizzyDean {
    def pitch() int { if(sdf()) { throw new RuntimeException("90 mph?!"); } return 56 }
}



~~~~~
//##8. Class dunno waht this does but looks cool3
def limit(d int, limit int ) int {
	return d
    //return d > limit ? limit : d < -limit ? -limit : d; - TODO: fix bug in this area when converted to if else
}

open class Point {
    x int = 0; y int = 0;
    def move(dx int, dy int ) { x += dx; y += dy; }
}
class SlowPoint extends Point {
    xLimit int; yLimit int;
    override def move(dx int, dy int) {
        super.move(limit(dx, xLimit), limit(dy, yLimit));
    }
}

~~~~~
//##8. Class dunno waht this does but looks cool4

class CheckedPoint(x int, y int) {
    def move(dx int, dy int) {
        if ((x + dx) < 0 or (y + dy) < 0)
        {
        	throw new Exception("");
        }
        x += dx; y += dy;
    }
}

~~~~~
//##8. Class dunno waht this does but looks cool 5 - cool caught this

open class Outer {
     public class Inner {}
}

class SonOfOuter extends Outer {
    def foo() {
        new Inner();  // this is ok but not across modules TODO: test across modules
    }
}

~~~~~
//##8. Class dunno waht this does but looks cool 6 - the final generics menace
open class C<T> {
    def id(x T ) T  { return x; }
}
class D extends C<String> {
    def id(x Object) Object { return new Object() } //this should be flagged as a bug because this has the same erasure as supertype - Object does this
}//later extend case to deal with generics that have an upper bound specified







~~~~~
//##8. Class template



~~~~~
//##10. Arrays
from java.util import ArrayList
 a int[]     ;        // array of int
asa short[2] ;        // array of array of short
s short       ;       // scalar short
aa short[2];   // array of array of short
ao Object[]         // array of Object
otherAo Object[];   // array of Object
ca Collection<String>[] ;  // array of Collection of unknown type - no
ca ArrayList<String>[] ;  // array of Collection of unknown type - ok

aao Object[2]  = new Exception[2,3];
factorial int[] = [ 1 1 2 6 24 120 720 5040 ];
aas String[]    = [ "array" "of" "String" ];
ac char[]       = [ 'n' 'o' 't' ' ' 'a' 's' 't' 'r' 'i' 'n' 'g'];

uhoh int[] = [ 1 2 3 ; 1 2 3 ] //wrong!
uhohok int[2] = [ 1 2 3 ; 1 2 3 ]  


~~~~~
//##10.1. Array Types





~~~~~
//##10.2. Array Variables





~~~~~
//##10.3. Array Creation
objok int[]? = null;//fine as array is an object
manyobjnullok  Integer[]?[] = [[1 2] ; null];//should be fine

manyobjnullfail  int[] = [null null];//not ok

manyobjnullalright2  Integer[] = [null as Integer null];//ok

manyobjnullalright3  int[3] = [null null];//ok

cannotdothisinjava Object[]= [1 null];//1 gets boxed up as object

oops = ["", null]

noempty int[2] = [[] []]; //empty arrays are not instantiable
noemp = []; //not ok, cannot empty
fine int[2] = [1 2 3 ; 1 2 ] //

notfine2v1 int[2] = [1 2 3]
hi int[] 
hi = [3]
ho int[] = hi

a=null
failok int[3] = [a a] //fail as cannot be null
thisIsFine int[3] = [null null] //this is fine and bc is ok as well


~~~~~
//##10.4. Array Access


class Gauss {
    def main(args String[] ) void {
        ia int[] = new int[101];
        ia[2] = 6;
        sum int = 0;
        for (e int in ia)
        {
        	sum += e;
        }
        System.out.println(sum);
    }
}


~~~~~
//##10.5. Array Store Exception
//wtf

~~~~~
//##10.6. Array Initializers
//access

arr = [1 2 3 4 5  6  7 8 9 10];

got1 int[] = arr[ ... 3]
got2 int[] = arr[3 ... ]
got3 int[] = arr[1 ... 3]
ll = got1.length //magic field

hu float[] = got1 //error as we cannot cast this
hu2 float[] = got1 as float[] //error as we cannot cast this



~~~~~
//##10.6.a Array Initializers - generics and more
a String[] = new String[3]; //this is fine
ab Object[] = new String[3]; //this is fine as well
aab Object[] = [new Integer(6) ""  null]; //fine
aaba = [new Integer(6) ""  null]; //fine
anum Number[] = [new Integer(6)  new Double(6.0)];
aaba2 Integer[] = anum; //not allowed

class Gen<T>
{
	g T[] = new T[2]; //this is not allowed
	go T[] = [new T()]; //nor is this!
}

~~~~~
//##10.7. Array Members

class Test1 {
    def main(args String[]) void  {
        ia1 int[] = [ 1  2 ];
        ia2 int[] = ia1.clone();
        System.out.print((ia1 == ia2) + " ");
        ia1[1]++;
        System.out.println(ia2[1]);
    }
}

class Test2 {
	def main(args String[] ) void  {
	
        ia Integer[2] = [ [Integer(1) 2];  null  ]
        ja Integer[2] = ia.clone()
        System.out.print((ia == ja) + " ")
        System.out.println(ia[0] == ja[0] and ia[1] == ja[1])
    }
}



~~~~~
//##10.8. Class Objects for Arrays

class Test2 {
	def main(args String[] ) void  {
	
        ia Integer[2] = [ [Integer(1) 2] ; null  ]
        ja Integer[2] = ia.clone()
        System.out.print((ia == ja) + " ")
        System.out.println(ia[0] == ja[0] and ia[1] == ja[1])
    }
}

~~~~~
//##10.9. An Array of Characters is Not a String
@SuppressWarnings("all")

class A<T> with Cloneable, java.io.Serializable {
    //length int = X ;
    override clone() T[]  {
        try {
            return super.clone() as T[]; // unchecked warning
        } catch (e CloneNotSupportedException) {
            throw new InternalError(e.getMessage());
        }
    }
}


~~~~~
//##11. Exceptions

def ff(x int) void
{
	if(x ==1) { throw new Exception(""); }
	elif(x ==2) { throw new Throwable(""); }
	elif(x ==3) { throw new Error(""); }
	elif(x ==4) { throw new RuntimeException (""); }
} //TODO: deadcode analysis

try { ff(6); }
catch(e Throwable) { a = e.getMessage() as String; }
finally { }

~~~~~
//##11.a Exceptions thrown ext throwable etc

class Excep(msg String) extends Throwable(msg) {}

class Excep2 {}

def x() { throw new Excep(" ok ") }   //ok 
def y() { throw new Excep2() } //fail
def z() { throw 3; } //fail - no throwing primatives
def u() { throw def (x int) void {} }//no throwing functypes

class GenOne<T> {
	car T?;
	def doing() void {
		throw car??; //now allowed as upper bound is object
	}
}


~~~~~
//##11.b generic classes cannot subclass throwable
open class ExcepSup extends Error {} //ok
class Excep<T> extends Error {} //no
class Oops<T,C> extends ExcepSup {} //no


~~~~~
//##11.c Unreachable catch block

try {  }
catch(e Throwable) { a = e.getMessage() as String; }
catch(e Exception) { a = e.getMessage() as String; } //err
finally { }


~~~~~
//##14. CONC continue and break in right place
//continue must be within for, or while
from java.util import ArrayList
def sdf() => true
while(sdf())
{
	break;
}

while(sdf())
{
	continue;
}

for( a in [1,2,3])
{

}

arr = new ArrayList<Integer>();
arr.add(12);
arr.add(2);

for( a Integer in arr)
{
	if(sdf())
	{
		break;
	}
	if(sdf())
	{
		continue;
	}
	elif(sdf())
	{
		break;
	}
	else
	{
		continue
	}
}

continue; //fail

class A
{
	break;//fail
}

def f() void
{
	while(sdf())
	{
		def g() void
		{
			break;//fail
		}
		g()
	}
	
}



~~~~~
//##14. CONC assert 
def g() boolean
{
	return true
}

def ga() String
{
	return "";
}

assert true
assert ""//fine as has toBoolean by default
assert g()
assert ga()


~~~~~
//##14. CONC withable 
//TODO: classes to implement withable interface
//TODO: concurnas build path as part of binary (like rt.jar, gets auto imported)
//TODO: custom classes on the compile path (custom jars, e.g concurnas standard library)
withable = "";

try(withable)
{
	
}

~~~~~
//##14. CONC old for loop 
def foo() boolean { return false; } 
len = 10

for(n = 0; n < len; n++)
{
	System.out.println("" + n)
}
for(n int = 0; n < len; n++)
{
	System.out.println("" + n)
}

for(n int = 0; n < len; n++)
{
	System.out.println("" + n)
}

for(foo(); foo(); foo())
{
	System.out.println("inf" )
}

for(; ; )
{
	System.out.println("inf" )
}

for(; ; n++ )
{
	System.out.println("inf" )
}
m = n+1; //wrong, n is not at this scope level



~~~~~
//##14. CONC return stmt in special place
return 5 //not ok
def ttt() => true
class A
{
 	return //not ok
 	
	def a() void
	{
		if(ttt())
		{
			{
				return; //not ok
			}!
			return //ok
		}
		return //ok
		while(1<2)
		{
			return //ok
		}
		sync{
			return //not ok
		}
		
		for(a in [1,2,3])
		{
			return //ok
		}
		
		for(a in [1,2,3])
		{
			{return} //ok
		}
	}
	
}
//ninja
isTrue Boolean = not ("" == "") as boolean

{return 69;} //not ok

~~~~~
//##15.1. CONC - simple exp
def ttt() => true
class Test {
    def main(args String[] ) void {
        divisor = 0;
        try {
            i int = 1 / (divisor * loseBig());
        } catch (e Exception) {
            System.out.println(e);
        }
    }
    def loseBig() int {
    	if(ttt()) { throw new Exception("Shuffle off to Buffalo!"); }
        return 67
    }
}



class Test2 {
    def main(args String[]) void {
        d = 8e+307;
        System.out.println(4.0 * d * 0.5);
        System.out.println(2.0 * d);
    }
}

class IntVector 
{
    v int[]?
    
    def equals(other IntVector) boolean {
        if (this == other){
            return true;
        }
        if (v??.length <> other.v??.length){
            return false;
        }
        
        for (i = 0; i < v??.length; i++){
            if (v??[i] <> other.v??[i]) { 
            	return false; //another bug here inf loop
            }
        }
        return true;
    }
}


~~~~~
//##15.16. Misc one

class Test {
    def main(args String[] ) void 
    {
        id = 0
        oldid = 0;
        try {
            for (;;) {
                ++id;
                new int[id];
            }
        } catch (e Error) {
            
            System.out.println(e.getClass() + ", " + (oldid==id));
        }
    }
}


~~~~~
//##15.16. Misc arrays

gg int= 2

obj  = new double[3,gg,4] //fine
obj  = new double[3,3,]// fine 


class A
{
	x int; y int } //syntax bugfix
	
class A2 extends A
{
	x int; y int; } //syntax bugfix

~~~~~
//##15.16. Misc arrays tests 2

def main(args String[] ) void 
{
    i = 4;
    ia = new int[i,3];
    i=3
    System.out.println(
        "[" + ia.length + "," + ia[0].length + "]");
}

def cal() int  {
   return 56
}

def main2(args String[] ) void  {
    ax = [ 00  01 ; 10  11 ];
    i = 99;
    try {
    	i = 1
        ax[cal()][i]++;
    } catch (e Exception ) {
        System.out.println(e + ", i=" + i);
    }
}

matrix = new float[3,3];
matrix2 = new float[3,2];

for (d = 0; d < matrix.length; d++)
{
    matrix[d] = new float[3];
}

class Age(s String) {}

Aquarius = new Age[6,10,8,12,2];



for (d1 = 0; d1 < Aquarius.length; d1++) 
{
    Aquarius[d1] = new Age[10,2,1,1];
    for ( d2 = 0; d2 < Aquarius[d1].length; d2++)
	{
        Aquarius[d1][d2] = new Age[8,2,3];
        for ( d3 = 0; d3 < Aquarius[d1,d2].length; d3++)
        {
            Aquarius[d1,d2,d3] = new Age[12,1];
        }
    }
}



Hair = [ new Age("quartz") new Age("topaz") ]
Aquarius[1,9,6,9] = Hair

triang = new float[100,2];
for (i = 0; i < triang.length; i++)
{
    triang[i] = new float[i+1];
}



~~~~~
//##15.16. Misc arrays tests 3

array int[2] = new int[5,5]
array[1, 1] = 4
array[2,2] = 4

assert array[1, 1] == array[1,1]
//also check:

arr = new int[10,10]
ok int[2] //= arr[1 ... 3]
ok2 int[2] //= arr[1 ... 3, 1 ... 3]
okugh int[] //= arr[1 ... 2, 1]
oknice int = arr[1,2]


array2d int[2] = new int[5,5]

from java.util import ArrayList


len = 10
oldlen = 0;
a = new Object[10];
b Integer[2] = new Integer[10, len] ;
lev int[] = new int[10] //can optionally not have the levels, default to 1
lev2 int[1] = lev
daft ArrayList<String>[] = new ArrayList<String>[1];//cant even have generic arrays in pure java...




//g = new int[len]
g2 = new ArrayList<String>[len];  

try {
    for (;;) {
        ++len;
        temp = new Object[0]
        temp[0] = a;
        a = temp;
    }
} catch (e Error) {
    System.out.println(e + ", " + (oldlen==len));
}


~~~~~
//##15.16. Var resolution 1

//var resolution from supers

open class S      { public x = 0; }
class T extends S { public x = 1; }
class Test1 {
    def main( args String[]) void 
    {
        t  = new T();
        System.out.println("t.x=" + t.x + when("t", t));
        s S= new S();
        System.out.println("s.x=" + s.x + when("s", s));
        s = t;
        System.out.println("s.x=" + s.x + when("s", s));
    }
    
    def when(name String, t Object) String {
         return " when " + name + " holds a "  + \ 
         t.getClass() + " at run-time.";
    }
}

~~~~~
//##15.16. Var resolution 2 - methods


open class S      { x = 0; def z() int { return x; } }
class T extends S { x = 1; override def z() int { return x; } }
class Test2 {
    def main(args String[]) void {
        t = new T();
        System.out.println("t.z()=" + t.z() + when("t", t));
        s = new S();
        System.out.println("s.z()=" + s.z() + when("s", s));
        s = t;
        System.out.println("s.z()=" + s.z() + when("s", s));
    }
    def when(name String ,  t Object) String {
        return " when " + name + " holds a " \ 
                        + t.getClass() + " at run-time.";
    }
}

~~~~~
//##15.16. Var resolution 3 - supes

open class T1 { public x = 1; }
open class T2 extends T1   { public x = 2; }
class T3 extends T2 {
    x = 3;
    def test() void {
        System.out.println("x=\t\t"          + x);
        System.out.println("super.x=\t\t"    + super.x);
        System.out.println("((T2)this).x=\t" + (this as T2).x);
        System.out.println("((T1)this).x=\t" + (this as T1).x);
    }
}

def main(args String[]) //no return type => void
{
    (new T3()).test() //implicit returns void
}

/*
This program produces the output:

x=              3
super.x=        2
((T2)this).x=   2
((T1)this).x=   1
((I)this).x=    0
Within class T3, the expression super.x is treated as if it were:

((T2)this).x
JPT: test when doing bytcode
*/

~~~~~
//##15.16. werid not supported

mountain String = "Chocorua";
def favorite() void {
    System.out.print("Mount ");
    return null;
}
def main(args String[]) {
    System.out.println(favorite().mountain);
}


~~~~~
//##15.16.  not supported - u cant have static class methods
def two(i int) int  
{ return 2*i;    }

def two()  int      
{ return two(1); }


two()
two(9)

~~~~~
//##15.16.  some random stuff with btyes
open class ColoredPoint {
    color byte;
    def setColor(color byte) { this.color = color; }
}

class ColoredPoint2 extends ColoredPoint
{
	def setColor(color int) { this.color = color as byte; }
	
}

def main(args String[] ) {
    cp  = new ColoredPoint();
    color byte = 37;
    cp.setColor(color);
    cp.setColor(37);  // compile-time error
    
    cp2  = new ColoredPoint2();
    cp.setColor(37); //this is ok...
}


~~~~~
//##15.16.  ambigious function stuff long winded
open class Point {}
open class ColoredPoint extends Point { color int =99; }

class ColoredPoint2 extends ColoredPoint {}


def test(p ColoredPoint, q Point ) {
    System.out.println("(ColoredPoint, Point)");
}
def test(p Point, q ColoredPoint ) {
    System.out.println("(Point, ColoredPoint)"); 
}

cp ColoredPoint = new ColoredPoint();
test(cp, cp);  // compile-time error


def test(p ColoredPoint , q ColoredPoint ) {
    System.out.println("(ColoredPoint, ColoredPoint)");
}

test(cp, cp);  // fine

~~~~~
//##15.16. return type not considered when resolving fun
open class Point { x int ; y int; }
class ColoredPoint extends Point {  public color int; }

def test( p ColoredPoint) int {
    return p.color;
}
def test(p Point ) String {
    return "Point";
}

cp ColoredPoint = new ColoredPoint();
s String= test(cp);  // compile-time error as
s2 String = test(cp as Point);  // ok


~~~~~
//##15.16. cool random stuff

open class Point(
public x int,	
public y int)
{
    def toString() String { return toString(""); } //fwd ref
    
    def toString(s String ) String   {
        return "(" + x + "," + y + s + ")";
    }
}

RED = 0;
GREEN = 1;
BLUE = 2;
COLORS String[] = [ "red"  "green"  "blue" ];

class ColoredPoint extends Point {

    color byte ;
    this(x int , y int , color int ) {
        super(x, y);
        this.color = color as byte;
    }

 	// Copy all relevant fields of the argument into this ColoredPoint object.
    def  adopt(p Point ) { x = p.x; y = p.y; }

	def adopt2(p Point ) {
	    if (p is ColoredPoint)
	    {
	    	color = (p as ColoredPoint).color;
	    }
	        
	    x = p.x; y = p.y;
	}

    override def toString() String  {
        s = "," + COLORS[color as int];
        return super.toString(s);
    }
    
    
	def adopt3(p ColoredPoint) {
	    adopt( p as Point);
	    color = p.color;
	}
    
}


class Test {
    def main( args String[] ) {
        cp ColoredPoint= new ColoredPoint(6, 6, RED);
        cp2 = new ColoredPoint(3, 3, GREEN);
        cp.adopt(cp2);
        System.out.println("cp: " + cp);
    }
}


~~~~~
//##15.16. random stuff 2 


class Test2 {
    def main(args String[] ) {
        s = "one";
        if (s.startsWith("two"))
        {System.out.println("oops");
        }
            
    }
}

~~~~~
//##15.16. thissuper method resolution

EDGE = 20

open class Point {
    x int;
    y int;
    def move(dx int , dy int ) {
        x += dx; y += dy;
        if (Math.abs(x) >== EDGE or Math.abs(y) >== EDGE)
        {
            clear();
        }
    }
    def clear() {
        System.out.println("\tPoint clear");
        x = 0; y = 0;
    }
}

class ColoredPoint extends Point {
    color int ;
    override def clear() {
        System.out.println("\tColoredPoint clear");
        super.clear();
        color = 0;
    }
}

class Test1 {
    def main(args String[] ) {
        p = new Point();
        System.out.println("p.move(20,20):");
        p.move(20, 20);

        cp = new ColoredPoint();
        System.out.println("cp.move(20,20):");
        cp.move(20, 20);

        p = new ColoredPoint();
        System.out.println("p.move(20,20), p colored:");
        p.move(20, 20);
    }
}


open class T1 {
    def s()  String { return "1"; }
}

open class T2 extends T1 {
     override def s()  String { return "2"; }
}

class T3 extends T2 {
    override def s()  String { return "3"; }
    def test() {
        System.out.println("s()=\t\t"          + s());
        System.out.println("super.s()=\t"      + super.s());
        System.out.println("((T2)this).s()=\t" + (this as T2).s());
        System.out.println("((T1)this).s()=\t" + (this as T1).s());
    }
}
class Test2 {
    def main(args String[] ) {
        t3 = new T3();
        t3.test();
    }
}

class AbstT2 extends T1 {
	override def s()  String
}

class T3OO extends AbstT2 {
    def s()  String { return "3"; }//no override keyword needed because it was never defined above haha!
 }

/* 
s()=            3
super.s()=      2
((T2)this).s()= 3
((T1)this).s()= 3
*/

~~~~~
//##15.16. some more virtual stuff and subtypeing of generic thingy
abstract class C<T> { //JPT: abstract
    def  id( x T) T {return x;}
}
class D extends C<String> {
    override def id(x String) String { return x; }
    def id2( x Object)  Object { return id( x as String); }
}

//D === C<String>

c C<String> = new D(); //this is ok, note that we cannot set to C staight as that would be unqualified that's not allowed
c.id(new Object() as String);  // fails with a ClassCastException
c.id("");  // ok
(c as D).id2(new Object());  // dunno what this proves, virtual blah blah




//check more sophiscated case of sub

class E<XXX> extends C<XXX>
{
	override def  id( x XXX) XXX {return x;} //this works!
}

c2 C<String> = new E<String>();
clever String = c2.id("");


~~~~~
//##15.16. more random stuff

class Test1 {
    def main() {
        ax int[] = [ 11 12 13 14 ];
        b = [ 0 1 2 3 ];
        System.out.println(b[(ax)[3]]);
    }
}

class Test2 {
    def main() void {
        index = 1;
        try {
            skedaddle()[index]++;
        } catch (e Exception ) {
            System.out.println(e + ", index=" + index);
        }
    }
    def  skedaddle() int[] {
        return [12 3]
    }
}


class Test3 {
   def main() void {
        index int  = 1;
        try {
            nada()[2]++;
        } catch (e Exception ) {
            System.out.println(e + ", index=" + index);
        }
    }
    def nada() int[] { return null; }
}


class Test4 {
    def main() {
        ax int[]? = null;
        try {
            i = ax??[vamoose()];
            System.out.println(i as int);
        } catch (e Exception ) {
            System.out.println(e);
        }
    }
    def vamoose() int {
        return 7
    }
}




~~~~~
//##15.16. vartypes

class Test1 {
    def sth() {
        a int= 5 mod 3;  // 2
        b int= 5/3;  // 1
        System.out.println("5 mod 3 produces " + a + \ 
                           " (note that 5/3 produces " + b + ")");

        c int= 5 mod (-3);  // 2
        d int= 5/(-3);  // -1
        System.out.println("5 mod %(-3) produces " + c + \ 
                           " (note that 5/(-3) produces " + d + ")");

        e int= (-5) mod 3;  // -2
        f int= (-5)/3;  // -1
        System.out.println("(-5) % 3 produces " + e + \ 
                           " (note that (-5)/3 produces " + f + ")");

        g int= (-5) mod (-3) + new Integer(2) as int;  // -2
        h int= (-5)/(-3);  // 1
        System.out.println("(-5) % (-3) produces " + g + \ 
                           " (note that (-5)/(-3) produces " + h + ")");
    }
}


class Test2 {
    def sth() {
        a double= 5.0 mod 3.0;  // 2.0
        System.out.println("5.0 % 3.0 produces " + a);

        b double = 5.0 mod (-3.0);  // 2.0
        System.out.println("5.0 % (-3.0) produces " + b);

        c double= (-5.0) mod 3.0;  // -2.0
        System.out.println("(-5.0) % 3.0 produces " + c);

        d double= (-5.0) mod (-3.0);  // -2.0
        System.out.println("(-5.0) % (-3.0) produces " + d);
    }
}



~~~~~
//##15.16. random stuff

a = 77

class Bottles {
    def printSong(stuff Object, n int)
    {
        plural String = "" if (n == 1) else "s";
  		 while (true) {
            System.out.println(n + " bottle" + plural \ 
                    + " of " + stuff + " on the wall,");
            System.out.println(n + " bottle" + plural \ 
                    + " of " + stuff + ";");
            System.out.println("You take one down " \ 
                    + "and pass it around:");
            --n; plural = "" if (n == 1) else "s";
            if (n == 0)
            {
                break ;
              }
            System.out.println(n + " bottle" + plural \ 
                    + " of " + stuff + " on the wall!");
            System.out.println();
        }
        System.out.println("No bottles of " + \ 
                    stuff + " on the wall!");
    }

    def main() {
        this.printSong("slime", 3);
    }
}



~~~~~
//##15.16. random stuff 2 

class Test {
    def main() {
        k  int= 1;
        ax int[] = [ 1 ];
        k += (k + 4) * (k + 2);
        ax[0] += (ax[0] + 4) * (ax[0] + 2);
        System.out.println("k==" + k + " and ax[0]==" + ax[0]);
    }
}

a = true
b = (1*2*3*4*5*6) as short
c= Integer.MAX_VALUE / 2
d =2.0 * Math.PI
e = "The integer " + Long.MAX_VALUE + " is mighty big."


~~~~~
//##15.16. no threads for you
def rightThrow() Thread {
    return null;
}

t Thread = rightThrow()



~~~~~
//##15.16. lets do some assignment 1
//Simple Assignment Operator =

//x String = null;
//sx String = "null" if x == null else  "s";


class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow          extends RuntimeException { }
class RightHandSideThrow  extends RuntimeException { }

 objects Object[] = [ new Object() "" ];
threads Integer[] = [ new Integer(2) 6 ];

def arrayThrow() Object[]  {
    return null; //throw new ArrayReferenceThrow();
}
def indexThrow() int {
     return 6 //throw new IndexThrow();
}
def rightThrow() Integer {
    return 7;//throw new RightHandSideThrow();
}
def name(q Object) String {
     sq String= q.getClass().getName();
     k int = sq.lastIndexOf('.');
    return sq if (k < 0) else sq.substring(k+1);
}

def testFour( x Object[]?, j int, y Object ) {
     sx String = "null" if x == null else name(x??[0]) + "s";
     sy String= name(y);
    System.out.println();
    try {
        System.out.print(sx + "[throw]=throw => ");
        x??[indexThrow()] = rightThrow();
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print(sx + "[throw]=" + sy + " => ");
        x??[indexThrow()] = y;
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print(sx + "[" + j + "]=throw => ");
        x??[j] = rightThrow();
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print(sx + "[" + j + "]=" + sy + " => ");
        x??[j] = y;
        System.out.println("Okay!");
    } catch ( e Throwable) { System.out.println(name(e)); }
}

def main(args String[] ) {
    try {
        System.out.print("throw[throw]=throw => ");
        arrayThrow()[indexThrow()] = rightThrow();
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print("throw[throw]=Integer => ");
        arrayThrow()[indexThrow()] = new Integer(1);
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print("throw[1]=throw => ");
        arrayThrow()[1] = rightThrow();
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print("throw[1]=Integer => ");
        arrayThrow()[1] = new Integer(1);
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }

    testFour(null, 1, new StringBuffer());
    testFour(null, 1, new StringBuffer());
    testFour(null, 9, new Integer(1));
    testFour(null, 9, new Integer(1));
    testFour(objects, 1, new StringBuffer());
    testFour(objects, 1, new Integer(1));
    testFour(objects, 9, new StringBuffer());
    testFour(objects, 9, new Integer(1));
    testFour(threads, 1, new StringBuffer());
    testFour(threads, 1, new Integer(1));
    testFour(threads, 9, new StringBuffer());
    testFour(threads, 9, new Integer(1));
}

/*
This program produces the output:

throw[throw]=throw => ArrayReferenceThrow
throw[throw]=Thread => ArrayReferenceThrow
throw[1]=throw => ArrayReferenceThrow
throw[1]=Thread => ArrayReferenceThrow

null[throw]=throw => IndexThrow
null[throw]=StringBuffer => IndexThrow
null[1]=throw => RightHandSideThrow
null[1]=StringBuffer => NullPointerException

null[throw]=throw => IndexThrow
null[throw]=StringBuffer => IndexThrow
null[1]=throw => RightHandSideThrow
null[1]=StringBuffer => NullPointerException

null[throw]=throw => IndexThrow
null[throw]=Thread => IndexThrow
null[9]=throw => RightHandSideThrow
null[9]=Thread => NullPointerException

null[throw]=throw => IndexThrow
null[throw]=Thread => IndexThrow
null[9]=throw => RightHandSideThrow
null[9]=Thread => NullPointerException

Objects[throw]=throw => IndexThrow
Objects[throw]=StringBuffer => IndexThrow
Objects[1]=throw => RightHandSideThrow
Objects[1]=StringBuffer => Okay!

Objects[throw]=throw => IndexThrow
Objects[throw]=Thread => IndexThrow
Objects[1]=throw => RightHandSideThrow
Objects[1]=Thread => Okay!

Objects[throw]=throw => IndexThrow
Objects[throw]=StringBuffer => IndexThrow
Objects[9]=throw => RightHandSideThrow
Objects[9]=StringBuffer => ArrayIndexOutOfBoundsException

Objects[throw]=throw => IndexThrow
Objects[throw]=Thread => IndexThrow
Objects[9]=throw => RightHandSideThrow
Objects[9]=Thread => ArrayIndexOutOfBoundsException

Threads[throw]=throw => IndexThrow
Threads[throw]=StringBuffer => IndexThrow
Threads[1]=throw => RightHandSideThrow
Threads[1]=StringBuffer => ArrayStoreException

Threads[throw]=throw => IndexThrow
Threads[throw]=Thread => IndexThrow
Threads[1]=throw => RightHandSideThrow
Threads[1]=Thread => Okay!

Threads[throw]=throw => IndexThrow
Threads[throw]=StringBuffer => IndexThrow
Threads[9]=throw => RightHandSideThrow
Threads[9]=StringBuffer => ArrayIndexOutOfBoundsException

Threads[throw]=throw => IndexThrow
Threads[throw]=Thread => IndexThrow
Threads[9]=throw => RightHandSideThrow
Threads[9]=Thread => ArrayIndexOutOfBoundsException
*/


~~~~~
//##15.16. lets do some assignment 2
//Example 15.26.2-1. Compound Assignment To An Array Component

class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow          extends RuntimeException { }
class RightHandSideThrow  extends RuntimeException { }

strings String[] = [ "Simon" "Garfunkel" ];
doubles double[] = [ Math.E Math.PI ];

def stringsThrow() String[] {
    return null; //throw new ArrayReferenceThrow();
}
def doublesThrow() double[] {
    return null; //throw new ArrayReferenceThrow();
}
def indexThrow() int {
    return 5; //throw new IndexThrow();
}
def stringThrow() String {
    return null; //throw new RightHandSideThrow();
}
def doubleThrow() double {
    return 5.; //throw new RightHandSideThrow();
}
def name(q Object ) String {
     sq String = q.getClass().getName();
     k int = sq.lastIndexOf('.');
    return sq if (k < 0) else sq.substring(k+1);
}

def testEight(x String[]?, z double[]?, j int ) {
    sx String= "null" if (x == null) else "Strings";
    sz String = "null" if (z == null) else "doubles";
    System.out.println();
    try {
        System.out.print(sx + "[throw]+=throw => ");
        x??[indexThrow()] += stringThrow();
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print(sz + "[throw]+=throw => ");
        z??[indexThrow()] += doubleThrow();
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print(sx + "[throw]+=\"heh\" => ");
        x??[indexThrow()] += "heh";
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print(sz + "[throw]+=12345 => ");
        z??[indexThrow()] += 12345;
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print(sx + "[" + j + "]+=throw => ");
        x??[j] += stringThrow();
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print(sz + "[" + j + "]+=throw => ");
        z??[j] += doubleThrow();
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print(sx + "[" + j + "]+=\"heh\" => ");
        x??[j] += "heh";
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print(sz + "[" + j + "]+=12345 => ");
        z??[j] += 12345;
        System.out.println("Okay!");
    } catch ( e Throwable) { System.out.println(name(e)); }
}

def main(args String[] ) {
    try {
        System.out.print("throw[throw]+=throw => ");
        stringsThrow()[indexThrow()] += stringThrow();
        System.out.println("Okay!");
    } catch ( e Throwable) { System.out.println(name(e)); }
    try {
        System.out.print("throw[throw]+=throw => ");
        doublesThrow()[indexThrow()] += doubleThrow();
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print("throw[throw]+=\"heh\" => ");
        stringsThrow()[indexThrow()] += "heh";
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print("throw[throw]+=12345 => ");
        doublesThrow()[indexThrow()] += 12345;
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print("throw[1]+=throw => ");
        stringsThrow()[1] += stringThrow();
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print("throw[1]+=throw => ");
        doublesThrow()[1] += doubleThrow();
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    try {
        System.out.print("throw[1]+=\"heh\" => ");
        stringsThrow()[1] += "heh";
        System.out.println("Okay!");
    } catch ( e Throwable) { System.out.println(name(e)); }
    try {
        System.out.print("throw[1]+=12345 => ");
        doublesThrow()[1] += 12345;
        System.out.println("Okay!");
    } catch (e Throwable ) { System.out.println(name(e)); }
    testEight(null, null, 1);
    testEight(null, null, 9);
    testEight(strings, doubles, 1);
    testEight(strings, doubles, 9);
}

/*
This program produces the output:

throw[throw]+=throw => ArrayReferenceThrow
throw[throw]+=throw => ArrayReferenceThrow
throw[throw]+="heh" => ArrayReferenceThrow
throw[throw]+=12345 => ArrayReferenceThrow
throw[1]+=throw => ArrayReferenceThrow
throw[1]+=throw => ArrayReferenceThrow
throw[1]+="heh" => ArrayReferenceThrow
throw[1]+=12345 => ArrayReferenceThrow

null[throw]+=throw => IndexThrow
null[throw]+=throw => IndexThrow
null[throw]+="heh" => IndexThrow
null[throw]+=12345 => IndexThrow
null[1]+=throw => NullPointerException
null[1]+=throw => NullPointerException
null[1]+="heh" => NullPointerException
null[1]+=12345 => NullPointerException

null[throw]+=throw => IndexThrow
null[throw]+=throw => IndexThrow
null[throw]+="heh" => IndexThrow
null[throw]+=12345 => IndexThrow
null[9]+=throw => NullPointerException
null[9]+=throw => NullPointerException
null[9]+="heh" => NullPointerException
null[9]+=12345 => NullPointerException

Strings[throw]+=throw => IndexThrow
doubles[throw]+=throw => IndexThrow
Strings[throw]+="heh" => IndexThrow
doubles[throw]+=12345 => IndexThrow
Strings[1]+=throw => RightHandSideThrow
doubles[1]+=throw => RightHandSideThrow
Strings[1]+="heh" => Okay!
doubles[1]+=12345 => Okay!

Strings[throw]+=throw => IndexThrow
doubles[throw]+=throw => IndexThrow
Strings[throw]+="heh" => IndexThrow
doubles[throw]+=12345 => IndexThrow
Strings[9]+=throw => ArrayIndexOutOfBoundsException
doubles[9]+=throw => ArrayIndexOutOfBoundsException
Strings[9]+="heh" => ArrayIndexOutOfBoundsException
doubles[9]+=12345 => ArrayIndexOutOfBoundsException

*/


~~~~~
//##15.16. inc dec post prefix only on special stuff

def functo() int
{
	return 66;
}

a = new Integer(1);
a++
++a

b = 8.0
++b

for(aa int = new Integer(2); aa<a; a++)
{
 --a
}

z = functo()

functo()++

z = null++

ar = [1,2,3]


fine1 = -((8))
fine2 = -((8))
fine3 = -(new Integer(8))

ar[2]++


~~~~~
//##15.16. Cast Expressions

//not that this is not permitted =  a double[] = [1,2,3] as double[];
ass double[] = [1 2 3] as double[];

a = 9
class Point(x int , y int)   {  }
class Element { atomicNumber int; }

class Test {
    def main(args String[] ) {
        p Point    = new Point(1,2);
        e Element  = new Element();
        if (e isnot Point) {  // compile-time error - it is totally not possible
            System.out.println("I get your point!");
            p = e as Point;  // compile-time error
        }
    }
}



~~~~~
//##15.16. equality

/*
//test flavours of equality: 


'=='  : .equals                -> unless primative type (also consider boxing -> valueof), if prim revert to reference equality
'&==' : reference equality ==  -> 

//below are inversion

'<>'  : !.equals()
'&<>' : reference equality !=

//EqualityExpression

*/

//a = new ArrayList<String>()

//from java.util import ArrayList

//b = new ArrayList<String>()

gg Object= 8;

def z(x int) int[] { return [x+2]; }

b = false
b=[1 2 3] ==[1 2 3]
b=[1 2 3] &== [1 2 3]
b= (def (x int) int[] {return [x+2];})(3) &== [1 2 3]
b= z(3) &== [1 2 3]
//b= (z&(int))(4) == [5] - later
eq = (def (x int) int[] {return [x+2];}) == (def (x int) int[] {return [x+2];})
b = new Object() == (def (x int) int[] {return [x+2];})
b = (def (x int) int[] {return [x+2];}) == new Object()
bo1 = [1 2 3] == new Object()
///v  (x int, y int) int = def (x int, y int) int { x+y; } - busted - synax seems broken uh oh!, funcrefs too?

//give me something more
from java.util import ArrayList
bo2 = [1 2 3] == new Object()//OK
c = [1 2 3] == [1 2 ; 3 4]  //FAIL
b = [1 2 3] == new int[2] //OK
b = [1 2 3] == new int[2,6] //FAIL
bo3 = new Object() == new ArrayList<String>()//OK


~~~~~
//##15.16. conditional ? : 
def sdfa() => 1==1
b long = 10l if sdfa() else 2
c boolean = false if sdfa() else true

h = 6 if sdfa() else 6;
ho = 6 if 4 else 6; //Expected boolean type not: INT - its ok it can be cast
h2 String?= null if sdfa() else null
bi1 int = 6 if sdfa() else new Integer(6)
bi2 Integer? = new Integer(5) if sdfa() else null //works in java too, what does it mean?
bi3 Object? = "" if sdfa() else null



~~~~~
//##15.16. array type inference
//ensuer array types done correctly
from java.util import ArrayList

//this lot will be fines
bo boolean[] = [true  false];
ac char[]       = [ 'n' 'o' 't' ' ' 'a' 's' 't' 'r' 'i' 'n' 'g' ];
sts String[]    = ["one"  "two"]
onebadApple Object[]    = ["one"  "two"  55]
boxes_fail int[] = [new Integer(6) 3  4 5] //get upcast - so this is not allowed
boxes Integer[] = [new Integer(6) 3  4 5] //get upcast

open class A{} class B extends A{} class C extends A{}

aloadofa_fail C[1] = [ new B()  new C() ] //play.A is not a subtype of play.C
aloadofa  A[1] = [ new B()  new C() ] //play.A is not a subtype of play.C

//JPT: check this i dont think its 100% right
ok String[] = ["" ""]
ugh ArrayList<Object>[] = [new ArrayList<Object>()  new ArrayList<Object>()]
ugh ArrayList<Object>[] = [new ArrayList<Object>()  new ArrayList<String>()] //not allowed - yet!
ugh2 ArrayList<Object>[] = [new ArrayList<String>()  new ArrayList<String>()]

oh ArrayList<java.lang.Object>[] = new  ArrayList<java.lang.Object>[3]
ok2 Object[] = [""  new Object()]

fails A = [new A()] //cannot convert from an array to non array





~~~~~
//##16. Definite Assignment





~~~~~
//##16.1. Definite Assignment and Expressions





~~~~~
//##16.1.1. Boolean Constant Expressions





~~~~~
//##16.1.2. Conditional-And Operator &&





~~~~~
//##16.1.3. Conditional-Or Operator ||





~~~~~
//##16.1.4. Logical Complement Operator !





~~~~~
//##16.1.5. Conditional Operator ? :





~~~~~
//##16.1.6. Conditional Operator ? :





~~~~~
//##16.1.7. Other Expressions of Type boolean





~~~~~
//##16.1.8. Assignment Expressions





~~~~~
//##16.1.9. Operators ++ and --





~~~~~
//##16.1.10. Other Expressions





~~~~~
//##16.2. Definite Assignment and Statements





~~~~~
//##16.2.1. Empty Statements





~~~~~
//##16.2.2. Blocks





~~~~~
//##16.2.3. Local Class Declaration Statements





~~~~~
//##16.2.4. Local Variable Declaration Statements





~~~~~
//##16.2.5. Labeled Statements





~~~~~
//##16.2.6. Expression Statements





~~~~~
//##16.2.7. if Statements





~~~~~
//##16.2.8. assert Statements





~~~~~
//##16.2.9. switch Statements





~~~~~
//##16.2.10. while Statements





~~~~~
//##16.2.11. do Statements





~~~~~
//##16.2.12. for Statements





~~~~~
//##16.2.12.1. Initialization Part of for Statement





~~~~~
//##16.2.12.2. Incrementation Part of for Statement





~~~~~
//##16.2.13. break, continue, return, and throw Statements





~~~~~
//##16.2.14. synchronized Statements





~~~~~
//##16.2.15. try Statements





~~~~~
//##16.3. Definite Assignment and Parameters





~~~~~
//##16.4. Definite Assignment and Array Initializers





~~~~~
//##16.5. Definite Assignment and Enum Constants





~~~~~
//##16.6. Definite Assignment and Anonymous Classes





~~~~~
//##16.7. Definite Assignment and Member Types





~~~~~
//##16.8. Definite Assignment and Static Initializers





~~~~~
//##16.9. Definite Assignment, Constructors, and Instance Initializers


//concurrency in genneral


~~~~~
//##69 - Misc - ensure superconstructor is correctly generic colored

open class A<T, T2>(~t T){}//supercon not getting parameterized
class B(a int[]) extends A<int[], String>(a) {}
class D(a String) extends A<String, String>(a) {}
class C(a String[]) extends A<String[], String[]>(a) {}

b B = new B([1 2 3])
ggg int[] = b.getT()


~~~~~
//##69 - Misc - generics arrays
//you can have a generic qualifier which is an array
from java.util import ArrayList
aa ArrayList<int[]> = new ArrayList<int[]>();

poo int[] = new Integer(5); //FAIL cannot do this
poo2 int[] = 5; //FAIL cannot do this either

g1 int[] = aa.get(1)//ok
g2 int[14] = aa.get(1)//FAIL

aa2 ArrayList<int[]> = new ArrayList<int[3]>();//FAIL
aa3 ArrayList<int[6]> = new ArrayList<int[5]>();//FAIL also


~~~~~
//##70 - Withable -1
try(89) { System.out.println("hi") } //FAIL

class WW with com.concurnas.lang.Withable //old way, we dont do this anymore
{
}

try(89) { System.out.println("hi") } //OK //TODO: when you support interfaces!

~~~~~
//##70 - misc -1trycatch
def sdf() => 6>7
def ok1() int
{
	try
	{
		if(sdf()){throw new Exception("")}
		else {throw new Exception("") }
	}
	return 8;
}

~~~~~
//##71 - explicit constructor invokation
open class Sup
{
	this(i int)
	{}
}

class CFail1 extends Sup
{
//fail, as no superconst
}

class CFail2 extends Sup{
	this(){
	//fail, as no superconst
	}
}

class CFail3 extends Sup{
	this(){
		super(5);
	}

	this(){
	//fail, as no superconst, note just 1 error thrown
	}
}

class OK1 extends Sup{
	this(){
		super(2)
	}
}

~~~~~
//##69. lhs must be a variable
class JJ{
	def aa() int {return 7; }
	~x int;
	def self() JJ { return this; }
}

j = new JJ()

j.aa() = 6 //FAIL not allowed

new JJ().aa() = 9 //FAIL

ll = [1,2,3]
ll[2] = 3 //ok

mm = [new JJ()]
mm[0].x = 9 //OK
mm[0].self().x = 8// OK

~~~~~
//##81.1 ref eq only on objecst not prim
a = 5 &== 6;

~~~~~
//##81.2 pow shortcut to math.pow returns double
a int = 3**4;//ok as well, because we cast back into int once the double raise to power operation has been completed
b int = (3**5) as int//OK
c int = 3**5 as int//OK - note the prescidence rule
//TODO: consider implemening raise to power operation for other primatives, cheaper than converting to double all the time
~~~~~
//##81.3 a doesnt exist! check type dammit!
def doings() String
{
	return "\n" + a
}

~~~~~
//##81.4 no, you cannot go from a boolean to a int in a for loop assignment
def doings() String {
	dd = ""; n=true;
	for(n =5 ; n<== 10; n++){
		dd += n + " "
	}
	return "" + dd
}

~~~~~
//##81.4 plus eq is ok in for loops
def doings2() String {
	dd = ""; n=1;
	for(n += 5 ; n<== 10; n++){ //but += assingment style is ok
		dd += n + " "
	}
	return "" + dd
}

~~~~~
//##81.5 only eq can be used on new var in for loop
def doings2() String {
	dd = ""; 
	for(n += 5 ; n<== 10; n++){ //but += assingment style is ok
		dd += n + " "
	}
	return "" + dd
}

~~~~~
//##81.6 you cannot have matixes of int and double (ie differing types)
def doings() String {
	a = [1,2,3]
	b = [1,2,3.]
	c = [a,b] //no actually this is ok, gets cast to Object
	return  c + ""
}

~~~~~
//##81.6b initialization rhs transformation
v = 5; v2 = [1 2 3]
ok1 Object = 2;//this is ok because rhs is a simple declaration
fail1 Object = v;//cannot convert because cannot rewrite - as rhs is not a declaration

ok2 Object[] = [1 2 3]; //fail! rhs gets rewritten
fail2 Object[] = v2; //fail! as rhs is no a decl so cannot be rewritten


\also Object[] = [1 2 3]
\also[1] = 88;//fail rhs gets rewrittent to object form
\also[1] = v//sort of ok - not reported as error as type of also is set to int[] so the thing works
ok2[2 ... 3] = [55 66] // rewrite this too, convert the elements to Integer

~~~~~
//##81.7 cannot do plus etc on arrays
//TODO: need to fix this in the future to make numerical computing easier, like matlab
//5 fails
ax = [1 2 3]

fail1 = [1 2] + [3 4]
fail1b= [1 2] \ 
			+ [3 4]
fail2 = ax + 1
fail3 = ax + [1 2 3]

ax += 1 //fail
ax += [1 2 3] //fail also
ax[2 ... 4]++ // fail
//actually you can via the majic of auto vectorization!

~~~~~
//##81.8 cannot assign to array length
class XXX{
	public val length =9;
}

def doings() String {
	a = [1 2 3]
	x = new XXX()
	x.length = 9 //no!
	a.length=9 //no its final (val) cant do this either
	return ""
}

~~~~~
//##81.9 no ciruclar refernces in consttuors
class Cls{
	this() {
		this() //not allowed
	}
}

~~~~~
//##81.9b no ciruclar refernces in consttuors via indirection
class Cls{
	this(a int) {
		this()
	}
	this() {
		this(3)
	}
}

~~~~~
//##81.9c no ciruclar refernces in consttuors via indirection
class Cls{
	this(a double) {
		this(1)
	}

	this(a int) {
		this()
	}
	this() {
		this(3.0)
	}
}


~~~~~
//##11. supernonexist blah


class Minor{
	g = 0
}

class Holder{
	d = [new Minor(), new Minor(), new Minor(), new Minor(), new Minor()]

	this(){
		super.d[1].g = 7;//err, super has no d
	}
}

~~~~~
//##82. cannot find function
def range(String) int
{
	return 66;
}

def range2(x) int
{
	return x();
}

def goings()
{
	x= range(22)
}

~~~~~
//##82. cannot be resolved to variable... 

def pp(a int){}

def doings() String {
	pp(a1)
	b=a1
	return "" + [a1]
}

~~~~~
//##83. lhs must be var

class Cls(){ ~x int; y=8;y.u =8 }

~~~~~
//##84. this is ok, autogen we ignore all the override rules etc

open class Sup{ ~x int }

class Cls extends Sup{ 
	~x int
}

~~~~~
//##85. is is only for objects

xx  = "" is String 
xxfail1 = 4 is String
xxfail2 = "" is int
xxfail3 = 4 is int

~~~~~
//##86. object array init weirdness
//TODO: fix the below
ints Integer[] = [new Integer(1) 2];
ints2 Integer[] = [1 2]; //this sHOUDL be ok, fix this bug


~~~~~
//##87. misc - mis aligned generic type inf shouldn't blow up the whole world
class MyClass<Xxx, Y>(~x Xxx[], ~y Y, ~z Z){ }

def doings() String {
	a = new MyClass<String, Integer, String>(["hi"  "there"], 99, "hi") //const
	a.x = ["hi"  "there2"] //setter
	a.y +=1
	a.z += 89
	return "" + a.x + a.y + a.z  //and it don;t!
}

~~~~~
//##88. fiddly nesting not permitted
class Outer{
	class Inner{
		class GG{}
	}
	
	class Inner2{
		def gotoa() GG{
			return new GG();//no, u need a reference to Inner in order to do this
		} 
	}
}

~~~~~
//##89. funcref from boxed to unboxed type not permitted

from java.util import HashMap

def doings()  {
	hm = new HashMap<Double, Double>()
	ref  (double, double) double = hm.put&(? double, ? double)//cannot have return from objec to prim as may be null - no actually this is ok as well
	ref2 (double, double) Double = hm.put&(? double, ? double)//ok
}

~~~~~
//##90. cannot assign to null

y = 9
def funto(x int ) {  y += x }

def doings() String {
	a = funto&(? int)(6) //- syntax err
	b = funto(5)
	return "" + y
}

~~~~~
//##91. lambda cannot be directly invoked
inca = 9
xxx lambda = def () { inca++; }

def doings() String{
	xxx()
	return ""
}

~~~~~
//##92. lambda moans about this generical assingment

class Gen<X>(~x X) {}

def doings() String{
	cls = new Gen<String>(def () String { return "wowow";})
	return "Hello world"
}

~~~~~
//##92. lambda moans about this generical assingment -part 2 other way around

class Gen<X>(~x X) {}

def doings() String{
	cls = new Gen< () String >("ok")//its ok, the string is convereted to: def () => "ok"
	cls.x()
	return "Hello world"
}

~~~~~
//##93. ensure sublist in array sublist op returns list and not arraylist
from java.util import ArrayList, List

myList = new ArrayList<Integer>()
for(x in [1,2,3,4,5]){
	myList.add(x)
}

def doings() String{//nice little ninja test of modulo operator there...
	//a = [myList[4], myList[5 mod myList.size() ] ]
	prefix ArrayList<Integer> = myList[ ... 3]
	return " " //+ [prefix, postfix]
}

~~~~~
//##94. err on ret type cause moan

def doings() Stirng{
	ar = [1l, 2l, 3l]
	//asList = new ArrayList[Long]();
	//asList.add(new Long(0))
	//asList.add(new Long(0))
	
	return ""
}


~~~~~
//##95. assignment fails i forgot about before
asLongArr = new ArrayList<Long>()
prepostOpsAsLong = 2 //error, cannot do this

~~~~~
//##96. nested scope overwrite

from java.util import ArrayList, List
{//this is ok
	from java.util import ArrayList, List
}

~~~~~
//##97. cannot call method on array directly
from java.util import ArrayList

h1 = new ArrayList<int[]>[4]  
shoulderr =  h1.get(0) 

~~~~~
//##98. def with null lists

def doings() String{
	ok String[] = [null as String  null   ]
	ok2 Object[] = [null  null   ]
	notOk = [null  null]  //abscence of type information means that we should consider this as Object[]
	notOk2 String[] = [null  null] 
	
	return ""
}

~~~~~
//##99. misc stuff with keysets and generic types etc


from java.util import ArrayList, Set

def doings() String{
	a1 = {1-> 3, 2-> new Long(4)}

	okaa = a1.keySet()
	fail1 = okaa[0]//fail its not a map etc
	fail2 = a1.keySet()[0]//fail 
	
	sset Set<Integer> = a1.keySet()
	ok2 = new ArrayList<Integer>(sset)
	ok2 = new ArrayList<Integer>(a1.keySet())//direct
	
	return "" +ok2 
}

~~~~~
//##100. array moan

list=[1 2 3]
f  = list[0,2,3,4,5] //int, erm ok maybe err can be imporved here

~~~~~
//##101. no escaping from the erasure rules you sneeky git

from java.util import ArrayList
from java.util import ArrayList as ArrayListo

def x(a ArrayList<String> ){}
def x(a ArrayListo<String> ){}

~~~~~
//##102. sealed classes by default

//fail
closed class ClosedOne{}
class ClosedOne2{}

class F1 extends ClosedOne{}  //fail
class F2 extends ClosedOne2{} //fail

closed class Fail3{ //fail abstract class cannot be closed
	def abstr() String;
}


//ok
open class OpenOne{}
abstract class OpenOne2{}
class OpenOne3{//open
	def abstr() String;
}

open class Ok1 extends OpenOne{}
open class Ok1b extends OpenOne{}
class Ok2 extends OpenOne2{}
class Ok3 extends OpenOne3{
	def abstr() String;
}

class JJ extends String {}

~~~~~
//##103. final methods

def doings() String {
	return  "Hello world";
}

class JJ extends String{} //fail


open class MyCls{
	def finfun.() String {return "";}
}


class Chi extends MyCls{
	override def finfun.() String { return "";} //Fail1
}

class Chi2 extends MyCls{
	def finfun.() String { return "";} //Fail3
}

class Fail2{
	def finfun.() String; //fail cannot be abstract
} 

~~~~~
//##104. final var tests - 1 - gen
def wwww() => true

val a int = 9 //ok
val b int = 9 //ok
a = 11 //fail
b = 11 //fail

val finVar     = 9 
val finVar     = 9//fail -already def
finVar         = 9//fail -its fin
var finVar int = 9//fail -already def
var finVar     = 9//fail -already def

{ val finVar     = 9 } 
{     finVar     = 9 }//fail, already fin
{ var finVar int = 9 }
{ var finVar     = 9 }


x = 10
val x = 10//fail already exists
var x = 10//fail already exists
x = 10;//ok


var xfg  int    //ok - no rhs so no clinit entry

//cannot input these:
//val x  += 9  //fail not new
//x            //fail no type
//val z        //fail no type
//var z2       //fail no type

def xxx(){
	//can be later assigned, unlike module level
	val golo2 int
	if(wwww()){
		golo2   =   9//ok
	}
	else{
		golo2   =   9//ok
	}
}

def xxx2(){//can be later assigned
	val golo int
	golo   =   9//ok - first assignment
	golo   =   9//fail - already assigned
	{
		golo = 9 //fail - already assigned
		var golo = 9//ok new variable
	}  
}

def xxx3(){
	val golo3 int
	golo3 = 34//assigned
	if(wwww()){
		golo3   =   9//fail already assigned
	}
	else{
		golo3   =   9//fail
	}
}

val xfga int    //fail - since module level [static] you must define rhs

def ggg(){
	//final var in function is not permitted with no assignment
	var x int 
	//var x2 //cannot write thie
	x3 int 
	
	val y int //ok
	//val y2   //cannot write this
}

yasas=10
{
	val yasas = 9; //ok, its new
}

def functo(val x int){
	x = 99; //fail as fin already
}

def doings() String {
	return  "Hello world"
}

~~~~~
//##104. final var tests - 2 - classes a

class Cls(public val -x int){
	public val y int = 88
	public -z int //ok
	
	def ss.(){
		x = 99 //fail
		y = 99 //fail
		val x = 99 //ok
		val y = 99 //ok
	}
}

class Cls2(public x int, public val z int){
	public val y int = 10
	public val z int = 9;//fail already created
	val a int
	def ss.(){
		val x = 99    //ok, we're explicitly creating a new thing here
		y = 89      //fail
		z=99          //fail
		a=8			  //fail cannot be set in method
	}
}

def doings() String {
	my = new Cls2(1, 22)
	my.ss()
	my\.x = 10     //ok
	my\.y = 33;      //fail
	my\.z = 33;      //fail     ------ this is not getting picked up!
	return  "Hello world" + [my.x , my.y, my.z];
}

~~~~~
//##104. final var tests - 3 - classes b

class Cls2(val ~x int, //fail as setter
			val +y int, //fail as setter
			val -z int, 
			val a int){ 
	val ~x2 int = 10 //fail as setter
	val +y2 int = 10 //fail as setter 
	val -z2 int = 10 //getter only is alright
	val a2  int = 10
}//PRT: should it be possible to manually define a setter on a val field?

def doings() String {
	return  "Hello world"
}

~~~~~
//##104. final var tests - 4 - cls a

class Cls1(val z int){
	val x int
	val y int = 21
	
	this(){//all ok, defer to later check to write
		x = 8;
		x = 8; //fail obivously wrong
		y = 9; //fail as also obivously wrong
		z = 9; //this is ok
	}
}

def doings() String {
	return  "Hello world"
}

~~~~~
//##105. final var tests - 5 constructors set only - 1

class Er1(val x int){//fail - tag cls with err
	val y int
}

abstract class Er2(val x int){//fail - tag cls with err
	val yp int
}

class Er3(){//fail - tag cls with err
	val y int
	val x int
}

~~~~~
//##105. final var tests - 5 constructors set only - 2

class OK(){
	val y int = 10
	val x int = 9
	
	this(){}
}

~~~~~
//##105. final var tests - 5 constructors set only - 3

class Cls1(){
	val y int
	val x int
	
	this(g Integer){
		x=2; y=2 //ok all vars set
	}
	
	this(g String){
		x=2; 
		this.y=2 //ok all vars set
	}
	
	this(a int, b int){// ok - all set
		this(a)
	}
	
	this(g String, f String){ //fail, as final vars are not set at all
	}
	
	this(){//fail, already set
		this(12)
		y=9; x=3 
	}
	
	this(dd Double){//fail, already set
		this(12)
		y=9;//inclusive
	}
}

~~~~~
//##105. final var tests - 5 constructors set only - 4

class Cls2(val z int){
	val x int
	val y int = 21
	
	this(){//all ok, defer to later check to write
		x = 8; //ok
		x = 8; //fail obivously wrong
		y = 9; //fail as also obivously wrong
		z = 9; //ok
	}
}

~~~~~
//##105. final var tests - 6 this is fine

class SDF{
	private val -g = sdf()
	
	def sdf() int{
		return 4
	}	
}

def doings() String{
	ok =new SDF().g
	fail =  new SDF()\.g
	return ""+ [ok , fail]
}

~~~~~
//##106. imported final var cannot be fiddled with

from java.awt import Color

bet = Color.black
Color.black = null //fail

def doings() String{
	return "" + bet
}

~~~~~
//##107. Dunno where this belongs - abst if not impl all

class Molly{
	public def meth(a Object) void
}

abstract class Dave extends Molly{}

public class Fiddle extends Dave{
	public def meth(a Object){}
}
 
def doings() String{
	new Fiddle()
	new Molly() //abstract
	new Dave() // also abstract
	
	return "Hello world"
}

~~~~~
//##107. nested final class logic
class Mega{
	class Cls1(){
		val y int
		val x int
		
		this(g Integer){
			x=2; y=2 //ok all vars set
		}
		
		this(g String){
			x=2; 
			this.y=2 //ok all vars set
		}
		
		this(a int, b int){// ok - all set
			this(a)
		}
		
		this(g String, f String){ //fail, as final vars are not set at all
		}
		
		this(){//fail, already set
			this(12)
			y=9; x=3 
		}
		
		this(dd Double){//fail, already set
			this(12)
			y=9;//inclusive
		}
		
		
		class Cls2(val z int){
			val x int
			val y int = 21
			
			this(){//all ok, defer to later check to write
				x = 8; //ok
				x = 8; //fail obivously wrong
				y = 9; //fail as also obivously wrong
				z = 9; //ok
			}
		}
	}

	class OK(){
		val y int = 10
		val x int = 9
		
		this(){}
	}

}



~~~~~
//##110. ppp - abstract no privates

public class ABA{
	private def johnny() String;
}


~~~~~
//##111. ppp - cannot narrow scope

a = (3) + 5

open class Sup{
	def somethng() String{ return "aaa";}
}

class OK extends Sup{//no scope change
	override def somethng() String{ return "";}
}

class FAIL extends Sup{//fail - narrow scope
	private override def somethng() String{ return "fff";}
}

class FAIL2 extends Sup{//fail - no scope change
	protected  override def somethng() String{ return "";}
}


abstract class Sup2{
	protected def somethng() String
}

class OK2 extends Sup2{//increase scope
	 def somethng() String{ return "";}
}

class FAIL3 extends Sup2{//fail - narrow scope so fail
	private  def somethng() String{ return "fff";}
}

open class Sup3{
	private def somethng() String{return "sdf" }
}

class OK3 extends Sup3{//increase scope, public
	 override def somethng() String{ return "";}
}

class OK4 extends Sup3{//increase scope, protected
	 protected override def somethng() String{ return "";}
}

~~~~~
//##112. ppp - cannot narrow scope - already compiled class
from com.concurnas.lang.precompiled.TestHelperClasses import Sup, Sup2, Sup3

class OK extends Sup{//no scope change
	override def somethng() String{ return "";}
}

class FAIL extends Sup{//fail - narrow scope
	private override def somethng() String{ return "fff";}
}

class FAIL2 extends Sup{//fail - no scope change
	protected  override def somethng() String{ return "";}
}


class OK2 extends Sup2{//increase scope
	 def somethng() String{ return "";}
}

class FAIL3 extends Sup2{//fail - narrow scope so fail
	private  def somethng() String{ return "fff";}
}

class OK3 extends Sup3{//increase scope, public
	 override def somethng() String{ return "";}
}

class OK4 extends Sup3{//increase scope, protected
	 protected override def somethng() String{ return "";}
}

def doings() String{
	return "Hello world"
}

~~~~~
//##113. ppp - calling methods whith are ppp
//moan 4 times, lol
open class Cls{
	public def methpub() {}
	protected def methprotect() {}
	private def methprivat() {}
	
	
	def sdfsdf() {
		methpub()//ok
		methprotect()//ok
		methprivat()//ok
		this.methpub()//ok
		this.methprotect()//ok
		this.methprivat()//ok
	}
	
	def takesOwn(inst Cls){
		inst.methpub()//ok
		inst.methprotect()//ok
		inst.methprivat()//ok
	}
}

open class ClsSup{
	public def methpub() {}
	protected def methprotect() {}
	private def methprivat() {}
	
	open class ClsChiNestee{
		def takesOwn(inst ClsSup){
			inst.methpub()//ok
			inst.methprotect()//ok
			inst.methprivat()//ok
		}
	}
}


def funco(){
	c = new Cls()
	c.methpub() //ok
	c.methprotect() //fail
	c.methprivat()//fail
}


class Chi extends Cls{
	def sdfsdfxcx() {
		super.methpub()//ok
		super.methprotect()//ok
		super.methprivat()//fail
		
		methpub()//ok
		methprotect()//ok
		methprivat()//fail
	}
}


~~~~~
//##113.b ppp - calling methods whith are ppp - calling precompiled class

from com.concurnas.lang.precompiled.PrivatePublicProtected import Cls

open class ClsSup{
	public def methpub() {}
	protected def methprotect() {}
	private def methprivat() {}
	
	open class ClsChiNestee{
		def takesOwn(inst ClsSup){
			inst.methpub()//ok
			inst.methprotect()//ok
			inst.methprivat()//ok
		}
	}
}


def funco(){
	c = new Cls()
	c.methpub() //ok
	c.methprotect() //fail
	c.methprivat()//fail
	c.methdefault()//fail - as we treat this as private
}


class Chi extends Cls{
	def sdfsdfxcx() {
		super.methpub()//ok
		super.methprotect()//ok
		super.methprivat()//fail
		
		methpub()//ok
		methprotect()//ok
		methprivat()//fail
		methdefault()//fail - as we treat this as private
	}
}

~~~~~
//##113.c ppp - calling methods whith are ppp - dynamic binding to one which is visible

class Molly{
	private def meth(a String){}
	public def meth(a Object){}
}

def doings() String{
	(new Molly()).meth("");
	return "Hello world"
}

~~~~~
//##114.a ppp - accessability of constructors
class Molly{
	val -x int
	private this(x int){
		this.x = x
	}
	
	protected this(x int, y int){
		this.x = x
	}		
	
	this(){
		this(12)
	}
}
 
def doings() String{
	m = new Molly()
	new Molly(12)//fail - not accesible
	new Molly(12, 13)//fail - not accesible
	return "Hello world" + m.x
}

~~~~~
//##114.b ppp - accessability of constructors - precomp class

from com.concurnas.lang.precompiled.PrivatePublicProtected import MollyPreDef

def doings() String{
	m = new MollyPreDef()
	new MollyPreDef(12)//fail - not accesible
	new MollyPreDef(12, 13)//fail - not accesible
	return "Hello world" + m.x
}

~~~~~
//##114.c ppp - accessability of constructors - extend in childclass
open class Molly{
	val -x int
	private this(x int){
		this.x = x
	}
	
	protected this(x int, y int){
		this.x = x
	}		
	
	this(){
		this(12)
	}
}

class Dolly extends Molly{
	this(g int){
		super() // ok
	}

	this(g int, f int){
		super(g,f) // ok protected
	}
	
	this(){
		super(1) // fail as private
	}
}

 
def doings() String{
	d = new Dolly()
	new Dolly(12)
	new Dolly(12, 13)
	return "Hello world" + d.x
}

~~~~~
//##114.d ppp - accessability of constructors - precomp class extend in childclass
from com.concurnas.lang.precompiled.PrivatePublicProtected import MollyPreDef

class Dolly extends MollyPreDef{
	this(g int){
		super() // ok
	}

	this(g int, f int){
		super(g,f) // ok
	}
	
	this(){
		super(1) // fail as private
	}
}

 
def doings() String{
	d = new Dolly()
	new Dolly(12)
	new Dolly(12, 13)
	return "Hello world" + d.x
}

~~~~~
//##115.a ppp - local vars
open class Cls{
	public x int =8
	protected y int = 10
	private z int = 12
	
	
	def sdfsdf() {
		s = x+y+z//ok
	}
	
	def takesOwn(inst Cls){
		s = x+y+z//ok
	}
}

open class ClsSup{
	public x int =8
	protected y int = 10
	private z int = 12
	
	open class ClsChiNestee{
		def takesOwn(inst ClsSup){
			s = x+y+z//ok
		}
	}
}

def funco(){
	c = new Cls()
	f=c.x //ok
	f=c.y //fail
	f=c.z //fail
}

class Chi extends Cls{
	def sdfsdfxcx() {
		f=super.x //ok
		f=super.y //ok
		f=super.z //fail
		
		u = x//ok
		u = y//ok
		u = z//fail
	}
}

private  modLevel1 =9 //not exten accesible...
protected  modLevel2 =9 //FAIL - invalid
public  modLevel3 =9
//default module level is private

open class MyClsVars(public val x int, val y int, private z int){}

class Chi2 extends MyClsVars(1,2,3){
	def zzz(){
		ac1 = x//ok
		ac1 = y//ok
		ac1 = z//fail
	}
}

def doings() String{
	private hg = 9 //FAIL
	mm = new MyClsVars(12, 14, 15)
	ac1 = mm.x//ok
	ac2 = mm.y//fail prot
	ac3 = mm.z//fail priv
	
	return "Hello world" + [modLevel1, modLevel3]
}

~~~~~
//##115.b ppp - local vars imported from precompiled

from com.concurnas.lang.precompiled.PrivatePublicProtected import publicModLevel

from com.concurnas.lang.precompiled.PrivatePublicProtected import privModLevel //cannot be resolved as private, later on...

fiddles = 99;

def doings() String{
	ac1 = fiddles //ok
	ac2 = publicModLevel //ok
	ac3 = privModLevel //no
	return "Hello world"
}

~~~~~
//##115.c ppp - local vars imported from precompiled fails a few times

from com.concurnas.lang.precompiled.PrivatePublicProtected import Vars, publicModLevel

open class Vars{
	public x int =8
	protected y int = 10
	private z int = 12
	
	
	def sdfsdf() {
		s = x+y+z//ok
	}
	
	def takesOwn(inst Vars){
		s = x+y+z//ok
	}
}

def funco(){
	c = new Vars()
	f=c.x //ok
	f=c.y //fail
	f=c.z //fail
}

class Chi extends Vars{
	def sdfsdfxcx() {
		f=super.x //ok
		f=super.y //ok
		f=super.z //fail
		
		u = x//ok
		u = y//ok
		u = z//fail
	}
}

def doings() String{
	
	return "Hello world" + publicModLevel
}

~~~~~
//##115.d ppp - static functions imported access modifiers get respected

from com.concurnas.lang.precompiled.PrivatePublicProtected import aFunction
from com.concurnas.lang.precompiled.PrivatePublicProtected import aFunctionPrivate
from com.concurnas.lang.precompiled.PrivatePublicProtected import aFunctionProtected


//import predef function as well

def doings() String{
	xxx = aFunction("")
	fail = aFunctionPrivate("")//fail as not visible
	fail = aFunctionProtected("")//fail as not visible
	return "Hello world" + xxx
}

~~~~~
//##116.a ppp - vars can increase scope 

open class One{	private g = 99; }
class Chi1 extends One{ public g = 9; }

def doings() String{
	xxx = new Chi1()
	return "Hello world" + xxx.g//ok
}

~~~~~
//##116.b ppp - and also overide scope

open class One{	public g = 99; }
class Chi1 extends One{ private g = 9; }

def doings() String{
	xxx = new Chi1()
	ac1 = xxx.g //fail
	ac2 = (xxx as One).g //ok
	return "Hello world" 
}

~~~~~
//##117. something i overlooked re parent types being genericalsz
@SuppressWarnings("all")

open class Sup<X, Y>{
	override def equals(o Object) boolean{return false;}
}

open class Middle<X> extends Sup<X, String>{
	override def equals(o Object) boolean{return false;}
}

class Child extends Middle<String>{
	override def equals(o Object) boolean{return false;}
}

//the next line is ok:
xxx Sup<String, String> = new Child() 

~~~~~
//##117.b something i overlooked re parent types being genericalsz - reson i found prev one
@SuppressWarnings("all")
class Sup<X, Y>
{
	def ss(X) X
}

@SuppressWarnings("all")
class ChildBadGeneric<Z, B> extends Sup<B, String> {

	override def equals(o Object) boolean{
		theOther = o as ChildBadGeneric<Z,B>
		z = this as  Sup<B, String>//it is subtype - used to break
		b = theOther as Sup<B, String> //it is subtype
		
		return true
	}
	//bytecodeSandbox.ChildBadGeneric<Z,B>
	//bytecodeSandbox.ChildBadGeneric

	def ss(s B) B { return s }

}  //error should refer to B, unbound


def doings() String { return "hi"; } 


~~~~~
//##118. ambigousness checks

def tripleY(a Object?){}
def tripleY(a String?){}

def tripleX(a Object?){}
def tripleX(a Object[]?){}

//not ambigous:
tripleX(new Object()) 
tripleX([new Object(),]) 
tripleX(null)

tripleY("") 
tripleY(null)

~~~~~
//##119. more ambigousness checks

def checkInvoke(x Object?) String{
	return "Object"
}

def checkInvoke(x String? ) String{
	return "String"
}

def checkInvoke2(x Object?, y Object?) String{
	return "Object"
}

def checkInvoke2(x Object?, y String?) String{
	return "String"
}

def doings() String {
	return "" +  [checkInvoke(null), checkInvoke2(null, null)]
}

~~~~~
//##120. cannot dup local fields

class MyClass{
	ss = 12
	ss = 12 //assign Existing
}

class MyClass2{
	public ss = 12
	public ss = 12 //assign New
}

~~~~~
//##121. search no further than parent when doing assignment checking

lam1 = 12

class MyCls{
	 private lam1 = 12
}

def doings() String{//all true
	mc = new MyCls()
	return "" + [ mc.lam1 == mc.lam1]
}

~~~~~
//##122. search no further than parent when doing assignment checking - lambda version

lam = def (a int, b int) int { return a+b; } 

class MyCls{
	public lam = def (a int, b int) int { return a+b; } 
}

def doings() String{//all true
	return "" + new MyCls().lam(1,2)
}

~~~~~
//##123. null lists on setters

class MyClass{
	~x int[]?
	~x2 int[2]?
	
	override def equals(a Object) boolean{
		return true
	}
}

def doings() String{
	mc = new MyClass()
	mc.x = [null null] //invalid 
	mc.x2 = [null null]//this is ok
	return "" + mc.x2
}

~~~~~
//##124. null lists on setters of obj type

class MyClass{
	~x Integer[]?
	~x2 Integer[2]?
	
	override def equals(a Object) boolean{
		return true
	}
}

def doings() String{
	mc = new MyClass()
	mc.x = [null null] //invalid
	mc.x2 = [null null]//this is ok
	return "" + mc.x2
}

~~~~~
//##125. null lists on on if expr stmts
def sdfsdf() => true
myPiggie1 = [null  null] if sdfsdf() else [null  null]
myPiggie2 Object[] = [null  null] if sdfsdf() else [null  null]
myPiggie3 Integer[] = [null  null] if sdfsdf() else [null  null]
myPiggie4 int[] = [null  null] if sdfsdf() else [null  null] //fail
myPiggie46 int[] = [null  null] //fail

def doings() String{
	return ""// + myPiggie
}

~~~~~
//##126. generic qmark owns all

@SuppressWarnings("all")

def doings1() String{
	dude = new java.util.ArrayList<String>()
	dude.add("hi")
	dude.add(12) //FAILS because not string
	return "" + dude 
}

@SuppressWarnings("all")
def doings() String{
	ar = new java.util.ArrayList<String>()
	asfd = ar is java.util.ArrayList<?>
	dude java.util.ArrayList<?> = ar as java.util.ArrayList<?>
	dude.add("hi")
	dude.add(12) //fine, because it is an object, which we treat the qmark as
	return "" + dude //ok
}


~~~~~
//##127.1 null lists in maps - basic

from java.util import Map
myPiggie1 Map<Boolean, Integer[]> = {true ->[null  null], false->[null  null]}
myPiggie1  = {true ->[null  null], false->[null  null]}


def doings() String{
	a = myPiggie1[true] 
	istrue = (a is Integer[])
	return ""+ [myPiggie1] + "" + istrue
}

~~~~~
//##127.2 null lists in maps - as obj


from java.util import Map

myPiggie1 Map<Boolean, Object[]> = {true ->[null  null], false->[null  null]}
myPiggie1 = {true ->[null  null], false->[null  null]}


def doings() String{
	a = myPiggie1[true] 
	istrue = (a is Object[])
	return ""+ [myPiggie1] + "" + istrue
}

~~~~~
//##127.3 null lists in maps - 2d int

from java.util import Map

myPiggie1 Map<Boolean, int[2]> = {true ->[null  null], false->[null  null]}
myPiggie1  = {true ->[null  null], false->[null  null]}

def lam(x int) int{ return x+1;}

def doings() String{
	a = myPiggie1[true] 
	istrue = (a is int[2])
	lamCool = lam&(? int) is lambda
	return ""+ [myPiggie1] + "" + istrue + ": " + a.getClass().getName() + ": " + lamCool
}

~~~~~
//##127.4 null lists in maps - moan not doable to simple array

from java.util import Map
//moans
myPiggie1 Map<Boolean, int[]> = {true ->[null  null], false->[null  null]}

def doings() String{
	return ""
}

~~~~~
//##127.5 null lists in maps - maps
@SuppressWarnings("all")

from java.util import Map

myPiggie1 Map<Boolean, Map<Boolean, Integer[]>> = {true ->{true ->[null  null]}}
myPiggie1 = {true ->{true ->[null  null]}}

def doings() String{
	a = myPiggie1[true] 
	istrue = (a is Map<?,?>)
	return "" + [myPiggie1]  + ": " + istrue + " : " + a.getClass().getName()
}

~~~~~
//##127.6 null lists in maps - 2d maps
@SuppressWarnings("all")

from java.util import Map

myPiggie1 Map<Boolean, Map<Boolean, Integer[]>>[] = [{true ->{true -> [null  null]}} {true ->{true -> [null  null]}}]

def doings() String{
	a = myPiggie1[0][true] 
	istrue = (a is Map<?,?>)
	istrue2 = (myPiggie1 is Map<?,?>[])
	return "" + [myPiggie1]  + ": " + istrue + ":" + istrue2 + " : " + a.getClass().getName() + " : " + myPiggie1.getClass().getName()
}

~~~~~
//##127.7 null lists in maps - maps in functions

from java.util import Map

def functo1(a Map<Boolean, Integer[]>) String {
	return "functo1"
}

def functo2(a Map<Boolean, Map<Boolean, Integer[]>>) String {
	return "functo2"
}

def functo3(a Map<Boolean, Map<Boolean, Integer[]>>[]) String {
	return "functo3"
}

def doings() String{
	a1 = "" + functo1({true -> new Integer[2]} )
	a2 = "" + functo2({true-> {true -> [null  null]}} )
	a3 = "" + functo3([{true-> {true ->[null  null]}} ])
	return "" +[a1 a2 a3]
}

~~~~~
//##128. finally blocks cant have return, break or continue

def noRetInFin() int {
	try{ return 7 }
	finally{ v=9
		return 7  //no!
	}
}

def noExcepInFin() int {
	try{ return 7 }
	finally{ v=9
		throw new RuntimeException("")//ok
	}
}

def noBreakInFin() int {
	while(true){
		try{ return 7 }
		finally{ v=9
			break//no!
		}
	}
	return 8;//will never get here
}

def noContInFin() int {
	while(7>6){
		try{ return 7 }
		finally{ v=9
			continue//no!
		}
	}
	return 8;
}


def noContInFinOwnOk() int {
	while(7>6){
		try{ return 7 }
		finally{ v=9
			for( a in [1,3]){
				break //ok
			}
		}
	}
	return 8;
}

def noRetFinOwnOk() int {
	while(7>6){
		try{ return 7 }
		finally{ v=9
			def xxx() int{ return 3;} //ok
			f = xxx()
		}
	}
	
	return 8;//will never get here
}

~~~~~
//##129 avoid the more pathalogical try catch excep cases
def noRetInFin()  {
	try{ 
		return //void ret
	}
	catch(e){ dfgdfg = 9 }
	finally{
		v=9
	}
}

def noRetInFin2()  {
	try{ 
		{return} //void ret
	}
	catch(e){ dfgdfg = 9 }
	finally{
		v=9
	}
}

def noRetInFin3()  {
	try{ //nothing!
		
	}
	catch(e){ dfgdfg = 9 }
	finally{
		v=9
	}
}

~~~~~
//##130 fwd references

def doings() String {	
	return ""  + (new A()).f.z + x() + d
}


class B{
	~z = "hi there"
}


class A{
	~f =new B()
	override equals(o Object) boolean { return false; }
}


def x() int{
	return y()
}

def y() int{ return 2;}


d = 9 // dont permit fwd references to variables

~~~~~
//##131 check private constructor cant be called

def doings() String{
	mc = new MyCls(5)
	mc2 = new MyCls()
	return ""
}

class MyCls(~a int){
	private this(){}
}


~~~~~
//##132 no u cant instantiate this private guy

class Priv{
	private this(){}
}

def doings() String {
	x = new Priv()
	return ""
}

~~~~~
//##133 java system lib classes cannot be extended
class myBigInteger extends java.math.BigInteger("8"){
}//because we cant gennerate a copier for this mutable object
//i guess if it were immutable then the above would be ok...


def doings() String {
	return "Hello world"
}

~~~~~
//##134.a primatives can be generic qualifiers

class MyGen<X>{
	public ~x X?
 }

open class MyGenCon<X>(~x X){ }

class MyGenCon2<X>(y X) extends MyGenCon<X>(y) { }


def doings() String{
	a = new MyGen<int>()
	b = new MyGen<double>()
	a\.x = 9
	a.x += 4
	b.x=9
	
	
	c = new MyGenCon<float>(7)
	d = new MyGenCon2<double>(7.23)
	
	return "" + [a.x , b.x, c.x, d.x] 
}

~~~~~
//##134.b primatives can be generic qualifiers fix bool bug

open class MyGenCon<X>(private ~x X){ }

def doings() String{
	a = new MyGenCon<Boolean>(false)
	b = new MyGenCon<Boolean>(false)
	
	return "" + [a.x , b.x]
}


~~~~~
//##134.c the joy of lambdas

open class MyGenCon<X>(private ~x X){ }

def doings() String{
	zz lambda = def () int { return 7}
	zz2 com.concurnas.bootstrap.lang.Lambda = def () int { return 7}
	zz3 Lambda = def () int { return 7}//auto import
	
	a = new MyGenCon<lambda>( def () int { return 7} )
	b = new MyGenCon<lambda>( def () int { return 7} )
	
	//a = new MyGen<lambda>()
	//a = new MyGen<int>()
	//a = new MyGenCon<Integer>(5)
	//b = new MyGenCon<Boolean>(false)
	
	f=(zz as () int )()
	f2=(zz2 as () int )()
	f3=(zz3 as () int )()
	f4 = (a.x as () int )()
	f5 = (b.x as () int )()
	
	return "" + [f, f2, f3, f4, f5]    //+ [a.x]// , b.x]
}


~~~~~
//##135. copy function only on object types

def doings() String{
	l = "hi"
	l2 = l@
	oo = 5@
	oo2 = [5 2]@
	ok = [null 4]@
	fails = [null null]@
	x = def (a int) int{ return a+3; }
	xx = x@
	return ""
}

~~~~~
//##136. int to Integer

class Mycls<X>{}

a  = new Mycls<int>()
b Mycls<Integer> = a

a2  = new Mycls<Integer>()
b2 Mycls<int> = a2

~~~~~
//##137. check this works

from java.util import ArrayList

def check(){
	func = def () int { return 5}
	ar = new ArrayList<() int>();
	ar.add(func)
}

~~~~~
//##138. misc err

class MyClas{
	var ~x : = "orig"
	override equals(o Object) boolean {return true;}
	override hashCode() int {return 6;}
	
	def setG(g String ){
		this\.x java.lang.String : = g ;
	}
}

~~~~~
//##139. compiler used to blow up when postfix augmenter visitor was in wrong place
def doings() String{
	a7 int:= 5
	
	x7 Integer[][] = [[a7++]]
	
	return "" + x7
}

~~~~~
//##140. double cehck boolean operations

def doings() String{
	a31 = 5
	a32 = 5
	a33 = 5
	a34 = 5
	
	x31 = a31++ == 5 == 6
	x32 = 5 == a32++ == 6
	x33 = a33++ == a34++ == 6
	
	return "" + [x31, x32, x33] + [a31, a32, a33, a34]
}

~~~~~
//##141. Cannot refer to an instance field y while explicitly invoking a constructor

open class Moi(public x int){
	public y int: = 5
	this(){
		this(y++) //this cannot be done! instance field cannot be referenced, nested is ok though
	}
}

class Moi2 extends Moi {
	public y2 int: = 5
	this(){
		super(y2++) //this cannot be done either! instance field cannot be referenced, nested is ok though
	}
}


class Nestor(){
	public ok int: = 5
	public class Nestee(xxx int) {
		this(){
			this(ok++) //this is fine because it's not a field of the class the consturcotr of which is being called
		}
	}
}

def doings() String{
	m = new Moi()
	m2 = (new Nestor()).new Nestee()
	return ""
}

~~~~~
//##142. if throws an exception then doesnt return anything

def doings() void{
	try{ c="12" } catch(e){ c="7"} finally{ throw new Exception("23") } 
}

~~~~~
//##142.b if throws an exception then doesnt return anything - in plus minus

def doings() void{
	try{ c="12" } catch(e){ c="7"} finally{ throw new Exception("23") } 
}

~~~~~
//##143. in for loop last thing must be defined (and cannot be void)

def sd(){}

def doings() String{
	ar0 = for( n=0; n < 10; n++){   }
	ar1 = for(n in [1,2,3]){  }
	ar2 = for( n=0; n < 10; n++){  sd() }
	ar3 = for(n in [1,2,3]){ sd()  }
	return "" //+ ar
}

~~~~~
//##144. break and continue can return stuff

def doings() String { 
	a=0;
	while(a++ < 10){ continue a;	} //invalid
	ar = while(a++ < 10){ continue a;	} //ok
	ar = while(a++ < 10){ continue	} //invalid
	while(a++ < 10){ break a;	} //invalid
	ar = while(a++ < 10){ break a;	} //ok
	ar = while(a++ < 10){ break	} //invalid
	return ""
}

def doings2() String { 
	for(a=0;a<10;a++){ continue a;	} //invalid
	ar = for(a=0;a<10;a++){ continue a;	} //ok
	ar = for(a=0;a<10;a++){ continue	} //invalid
	for(a=0;a<10;a++){ break a;	} //invalid
	ar = for(a=0;a<10;a++){ break a;	} //ok
	ar = for(a=0;a<10;a++){ break	} //invalid
	return ""
}

def doings3() String { 
	for(a in [1,2,3]){ continue a;	} //invalid
	ar = for(a in [1,2,3]){ continue a;	} //ok
	ar = for(a in [1,2,3]){ continue	} //invalid
	for(a in [1,2,3]){ break a;	} //invalid
	ar = for(a in [1,2,3]){ break a;	} //ok
	ar = for(a in [1,2,3]){ break	} //invalid
	return ""
}


~~~~~
//##145. tweak imports

from java.lang import Comparable //its ok to import this and override the defualt import

from java.util import ArrayList
from java.util import ArrayList //not ok

def doings() String{
	from java.util import ArrayList //ok to redefine as not in same level
	a Comparable<String> = "hi"
	return "" + a
}

~~~~~
//##146. rubbish line imp used to think this was ok

class AsConstruAutoCls () {
	private ref int:
	this( ref Integer : )  {
      this.ref jh GSGSGSGS: = ref ;
      k=9
    }
}

~~~~~
//##147. ensure blow up only on f missing

def doings() String{
	var x = if(f mod 2==0)
				{ 2 } 
			elif(f mod 3==0)
				{ 3 }
			else{ "_" }
	return "" + x
}

~~~~~
//##148. no iterate on obj

orig int:: = 90
x int:: = orig

from java.util import ArrayList

checks = new ArrayList<Boolean>();

raw = 8
ref1l = 8!
ref2l = (8!)!


rawAOnes = [def () boolean { x ::= raw; return true }, 
		  def () boolean { x := raw; return true },
		  def () boolean { x = raw; return true } ]

l1ones =  [def () boolean { x ::= ref1l; return true },
			def () boolean { x := ref1l; return true },
			def () boolean { x = ref1l; return true } ]

l2ones =  [[def () boolean { x ::= ref2l; return true },
		def () boolean { x := ref2l; return true },
		def () boolean { x = ref2l; return true } ]]

proc = def ( funcl () boolean ) boolean { x ::= orig; return funcl(); }//reset then do


def doings() String{
	return "" + for (group in [rawAOnes, l1ones, l2ones ] ) {	
			 for( test in group) { proc(test) }		
			 	}
}

~~~~~
//##149. variables dont return anything yet

za = [1 2 3 4 5 6 7 8 9]

def doings() String{
	d = for(n = 0; n < za.length; n++){
		a = za[n]
		//r=0
		try{
			r=try{
				if(a mod 2 == 0){ 22} else {  throw new Exception("") }
			}catch(e){
				if(a mod 3 == 0){ 33} else { throw e }
			}
			r
		}catch(e){
			93
		}
		
		//r
	} 
			
	return "" + d
}

~~~~~
//##150. wrong type ret

import java.util.List as MySpecialList
//should really just moan once, but it does it twice, oh well...

def doings() String{
	a=0
	d MySpecialList<MySpecialList<String>> = while(a++ < 10)
	{
		b=0
		while(b++ < 10){
			z=a*b
			z
		}
	}
			
	return "" + d
}

~~~~~
//##151. ensure all paths return properly

import java.util.List as MySpecialList

def doings() String{
	d MySpecialList<Integer> = for(a in [1,2,3,4,5,6,7,8,9]){
		try{
			if(a mod 2 == 0){ throw new Exception("1") }
			elif (a mod 2 == 0){ 
				//null!
				null
			 }
			else { throw new Exception("2") }
		}catch(e){
			99
		}
	} 
			
	return "" + d //+ "" + ab
}

~~~~~
//##152. ensure no hide from dero analysis, even for block inner blocks are caught
def sdf() => true
def doings() {
	for (nohoh=9;{nohoh++; nohoh<10}; 
			{nohoh++; nohoh++; 
				{a int; if(sdf){a=5}; b=a} //no ret needed
					} ) {//a not init!
	    a=5
	}
 	"fine"
}

~~~~~
//##153. inifinite loop deadcode - fors


def doings1() String{
	for (n=0;;n++) {
	    a=5
	}
 "fine" //deadcode
 }


def doings2() String{
	{
		for (n=0;;n++) {
		    a=5
		}
	}//anon block
 "fine" //deadcode
 }

def doings3() String{
	for (n=0;;n++) {
	    a=5
	    if(a>2){
	    	break//or return
	    }
	}
 "fine" //this is ok
 }
 
def doings4() String{
	{for (n=0;;n++) {
	    a=5
	    if(a>2){
	    	break//or return
	    }
	}}
 "fine" //this is ok
 }
 
def doings5() String{
	for (n=0;;n++) {
	    a=5
	    if(a>2){
	    	return ""
	    }
	}
 "fine" //this is going to fail too, cos if u do break out you return, thus deadcode still
 }


def doings6() String{
	{for (n=0;;n++) {
	    a=5
	}}!
 "fine" //not deadcode as async occurs in own isolate.. 
 }


~~~~~
//##154. cleanup func overrides

open class Parent{
	def fail()  => 12
	def ok() Object => ""
	def fail2() Object => ""
	def fail3() Object => ""
}

class Child extends Parent{
	override fail()  => 12.//noes incompatible type
	override ok() String => ""
	def fail2() String => ""//must use override keyword
	def fail3() int => 2//must use override keyword
	
}

def doings()  {
	c = new Child()
	"" + c.ok()
}

~~~~~
//##155. prim type and Obj type non compatible in ret type matching

open class Sup{ 
	public def noes() int => 2
 }

class ClsOther extends Sup{
	public override noes() Integer => 2
}

def doings() => ""


~~~~~
//##156. nested child privates are visible - fields

class X{
	class Y{
		public a =9 
		private b =9 
	}

	yy = new Y();
	
	def showme() => "" + [yy.a, yy.b] //both a and b are visible
}

def doings() String {
	return "" + new X().showme()
}

~~~~~
//##156.b nested child privates are visible - methods

class X{
	class Y{
		public def a() => "a"
		private def b() => "a"
	}

	yy = new Y();
	
	def showme() => "" + [yy.a(), yy.b()] //both a and b are visible
}

def doings() String {
	return "" + new X().showme()
}

~~~~~
//##157.a nested class extension - declaration

open class Parent{
	private open class Inner{}
	public open class InnerPubDef{}
}

class Child extends Parent{
	class ChiIn1 extends Inner{}       //not ok, private
	class ChiIn3 extends InnerPubDef{}
}

class Fail extends Parent.InnerPubDef{} //not ok must be nested

class Fail2 {
	class ChiIn3 extends Parent.InnerPubDef{}//not valid
}

def doings() String {
	return "" 
}

~~~~~
//##157.b nested class extension - reference

open class Parent1{
	private open class Priv{}
	protected open class Pro{}
	public open class Pub{}
	
	ok1 Priv? = null //fine
	ok2 Pro? = null  //fine
	ok3 Pub? = null  //fine
}

open class Child2 {
	
	private open class Priv{}
	protected open class Pro{}
	public open class Pub{}
	
	open class X{
		ok1 Priv? = null //fine
		ok2 Pro? = null  //fine
		ok3 Pub? = null  //fine
	}
}

open class Child extends Parent1{
	
	ok1 Priv = new Priv() //no 
	ok2 Pro = new Pro()  //fine
	ok3 Pub = new Pub()  //fine
}


ok1 Priv = new Priv() //no
ok2 Pro = new Pro()  //no
ok3 Pub = new Pub()  //fine


~~~~~
//##157.c nested class extension - constru

private open class Sup{
	override toString() => "hi"
}

private class X{
	public class Y extends Sup{}
	public class Y2{}
	override toString() => "hi"
	public this() {}
}

s = new Sup();//fine

myY Sup = new X().new Y();
myY2 = new X().new Y();
myY3 Object = new X().new Y2();
myY4  = new X().new Y2();


def doings() String {
	return "" + [myY is Sup, myY2 is Sup, myY3 is Object, myY4 is Object] + s
}

~~~~~
//##157.d nested class extension - private nested constructor invokation

private open class Parent{
	override equals(o Object) => true
	override hashCode() => 2
	public a = 2
		override toString() => ""+a
	
	private class Priv{
		override equals(o Object) => true
		override hashCode() => 2
		public a = 2
		override toString() => ""+a
	}
	
	protected class Pro{
		override equals(o Object) => true
		override hashCode() => 2
		public a = 2
		override toString() => ""+a
	}
	
	public class Pub{
		override equals(o Object) => true
		override hashCode() => 2
		public a = 2
		override toString() => ""+a
	}
}

private open class Parent2 extends Parent{
	//nested are always visible
	~c1 = this.new Priv()//not visible
	~c2 = this.new Pro()//ok
	~c3 = this.new Pub()//ok
	~c4 = new Priv()//not visible
	~c5 = new Pro()//ok
	~c6 = new Pub()//ok
}

def doings() {
	p2 = new Parent2()
	"" + [p2.c1, p2.c2, p2.c3, p2.c4, p2.c5, p2.c6]
}

~~~~~
//##158. no void in plus minus permitted

def doingsd() { //void!
}

def fail1() => "" + doingsd() 

def fail2() =>  doingsd()  + "" 

~~~~~
//##159. nested class superclass must be marked open

from java.util import HashMap

class SupClass{
	public class MyClass{
		val -x int
		this(x int){
			this.x=x
		}
		
		this() { this(5) }//note that this invokation must pass up the outer class instance
	}
	
	public class MyClass2 extends MyClass{ //oh no, MyClass is not open 
		this() { super(5) }//uh oh
	}
	
	this(a int, b int){}
}

def doings() String {
	mc = new SupClass(1,2).new MyClass()
	mc2 = new SupClass(1,2).new MyClass2()
	"" + mc.x + " : " + mc2.x
}

~~~~~
//##160. invoke superconstructor of an abstract class

abstract class SSS(a String){
	override toString() => "my: " + a
}

class Child1 extends SSS("one"){}
class Child2 extends SSS("two"){}
def sdf() => true
def xxx(x boolean) => "" + (new Child1() if sdf() else new Child2())

def doings()  String {
	m1 = xxx(sdf())
	m2 = xxx(sdf())
	"ok" + m1 + " : " + m2
}

~~~~~
//##161. invalid array type

bo int:

def g() void { bo = 9 }

def doings(){
	x={g()!}! 

	x:waitUntilSet()

	return "it's done: " + [x:waitUntilSet(), bo:get(false) ] //void
}

~~~~~
//##162. CAN convert from int: to int:: if one is locked etc

ok int::
class Inner{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	
	public a1 int::: = 6;
	
	def c1 ( xxx int: )  {
		//y =	xxx:: as Object
		//System.err.println("" + y)
		
		ok = xxx::
		
    	//this.a1 ::= xxx ;
    }
}

child = new Inner()

ff = 55::

def doings() {
	child.c1(ff::)//na its ok m8!
	"" + ok::// child.a1:::
}


~~~~~
//##163. call setter dependant on ref levels

class MyClass{
	override equals(o Object) boolean { return true;}
	override hashCode() int { return 1;}
	~z2 int:: =1 //has custom setter, but only one getter
}

def doings() String{
	m=new MyClass()
	
	a = 2: 
	m.z2 = a //ok 
	m.z2 ::= a//ok 
	m.z2 := a //not ok 
	
	return "" 
}

~~~~~
//##164. ensure ref levels are correct on deref

g=(8:):
g2 = 8:
def doings() String{
	a = ""+ g::get() //this should complain
	b = ""+ g2::get() //this should complain
	c = ""+ g:get():get() //this should complain
	d = ""+ g2:get():get() //this should complain
	"" + [a,b, c,d]//very weird
}

~~~~~
//##165. mist err used to npe
def sdf() => x==10

def xx() => 8
def sss()=>false
def doings() => {
	ok3 = xx()[0] if sss() else null:
 	"hi" 
 }

~~~~~
//##165. basic onchange
def sdf(x int) => x==10
def doings() {
	x int: = 9
	a=9
	
	onchange(x) {if(sdf(x)){ done = 1;} }//ok
	onchange(a) {if(sdf(a)){ done = 1;} }//not ok
 	""
}
 
~~~~~
//##166. basic onchange - must ret sth
 
 class The{
def doings() {
	done int:
	x int: =10
	
	def fa() {}
	
	res := onchange(x) {
	 	if(x==10){done=1;}
	 	res = x*2
	 	f=89
	 }

	for(xa in [8,99, 911, -1, 10]){
		x =xa  
	}
	
 	"hi " + [done, res]
}
}

~~~~~
//##167. await - basic syntax

from java.util import ArrayList

class TheClass{
	def doings() =>	"hi "
}

xs := ""

def afunc(a String){ xs += (a == "first a" or a == "first b") };

spawn = afunc&(? String)

def doings1() {
	a = {spawn("first a"); ((new TheClass()).doings()) + "a"}!
	b = {spawn("first b"); ((new TheClass()).doings()) + "b"}!
	"" + [a, b]
}

def doings() {
	a = doings1()!
	b = doings1()!
		
	await(xs ; true )
	await(xs ; {true;} )
	await(xs )
	await(xs ; 55 ) //should return boolean!
		
	"" + [a,b] + xs
}

~~~~~
//##168. onchange vars

def doings() {
	xs int:=2
	res0 = onchange(a int::=xs) 	{a	}//should complain
	res  = onchange(a int=xs) 	{a	}//should complain
	res2 = onchange(a float=xs) 	{a	}//should complain
	res3 = onchange(a=xs, b=a) 	{a +b 	}//should be ok
	a=9.0 
	
	for(a in [1,2,1000]){
		xs = a
	}
		
	await(res ; res >== 1000   )
	
	"" + [res]
}

~~~~~
//##169. onchange vars

def doings() {
	xs int:=2
	
	res3 = onchange(a=xs) 	{a=""; 7000 	}//should complain about the type
	xs=3
	"" + [res3, xs]
}

~~~~~
//##170. await missing var

def doings() {
	xs int:=2
	done := false
	
	res3 = onchange(a=xs){
		f=onchange(xs) { 
			f2=onchange(a) { 
					a+69
				}
			done2 = a==3
			f2
			}
		done = a==3
		f
	}
	xs=3
	await(done, done2 ;done and done2)
	xs=30
	"" + [res3]
}

~~~~~
//##171. correct working on type errror

def doings() {
	xs int=1
	pp = ""
	every(xs){ pp += xs;}
	
	xs=2
	xs=3
	
	await(pp;pp=="123")
	
	"" + [xs, pp]
}

~~~~~
//##172. onchange return type tagged and expected

def doings() {
	xs int:
	twice :=0
	res = onchange(xs){
		if(xs==4){
			return 
		}
		elif(xs==3){
			continue 77 //writes to res and carries on
		}
		elif(xs==2){
			break {99}//set res and exit
		}
		twice++ //once from continue one from normal return
		111		
	}
	
	xs = 1
	correctSubs = xs:getListnerCount():get()==1 and xs:get()==1
		
	await(res;res==111)
	xs=2
	await(res;res==99)
	xs=3
	await(res;res==111)
	xs=4
	await(res;res==44)
	
	//await(li=xs:getListnerCount();li==0)
	
	"" + [res, twice==2, correctSubs, xs:getListnerCount()]
}

~~~~~
//##173. auto iterate on keyset for map

from java.util import HashMap

f = new HashMap<int, int>()
f.put(8,9)
f.put(18,19)

def doings() String{
	"" + for(a in f){ a } //no complaints!
}

~~~~~
//##174. async scope basics
xs := 1

def doings(){

	 async{
		pre{ a=1}
		pre{
		  a2=1
	      a3=33
		}
				
		onchange(xs) {  
			d = a + a2 //this is defined in pre block so should exist
			
			a3 boolean =true//not allowed since already defined
		}
		
		post{ done = a == a2  }
	}
	
	return "" //+ res
}

~~~~~
//##175. ensure only onchange every at top level

xs := 1

def doings(){

	 async{
		pre{ a=1}
		pre{
		  a2=1
	      a3=33
		}
		j=9
		
		onchange(xs) {  
			d = a + a2 //this is defined in pre block so should exist
			
			a3 boolean =true//not allowed since already defined
		}
		await(xs ; true)
		
		post{ done = a == a2  }
	}
	
	return "" //+ res
}


~~~~~
//##176. no npe on await being wrong no ret

xs := 1

def doings(){
	xs=1
	
	x={
	await(xs )
	}	
	
	return "" //+ res
}

~~~~~
//##177. at least one required

xs := 1

def doings(){

	 async{
		pre{ a=1}
		pre{
		  a2=1
	      a3=33
		}
		
		post{ done = a == a2  }
	}
	
	return "" //+ res
}

~~~~~
//##178 vars cannot be redefined more than once inside onchange every block

xs := 1
xs2 := 100

def doings(){
	zzz String: = ""
	zzz2 String: = ""
	done1 := 0
	done2 := 0
	 async{
	 	every(f=xs, f=x2){//also a nono
	 		zzz +=("enter 1 : " + f)
	 		done1++;
	 	}
		onchange(f=xs2, f=xs) {//this is not permitted
	 		zzz2 +=("enter 2 : " + f)
	 		done2++;
		}
	}
	
	
	xs2=101
	xs = 2
	
	await(done1, done2 ; done1==1 and done2==1 )
	await(zzz)
	await(zzz2)
	
	
	"complete: " + [done1, done2, zzz, zzz2]
}

~~~~~
//##179 correct err thrown on missing ret type within async

xs := 1

def doings(){
	zzz String: = ""
	done1 := 0
	System.err.println("createa async")
	xxx = async{
		pre{
			System.err.println("enter pre")
		}
	 	every(f=xs){
	 		System.err.println("enter me")
	 		zzz +=("enter 1 : " + f) //misisng ret
	 	}
	 	onchange(f=xs){
	 		System.err.println("enter me")
	 		zzz +=("enter 1 : " + f) //misisng ret
	 	}
	}
	
	System.err.println("go here")
	xs = 2
	
	await(done1 ; done1==1 )
	
	
	"complete: " //+ xxx
}



~~~~~
//##185 check valid return 1 for onchange

xs := 1

def doings(){
	
	async {
	 	onchange(f=xs){
	 		xfs = "hi" 
	 		xfs = "hi2"
	 		return "" //not permitted, but ret itself is ok
	 	}
	}
		
	xs = 100
	
	"complete: " + [xs]
}



~~~~~
//##188 pre post cannot have return and break continue
def fff()=>false
xs := 1

def doings(){
	
	xxx =async  {
		pre{
			if(fff()){ break}
			else{ continue }
			return ""
		}
	 	onchange(f=xs){
	 		 "hi "
	 	}
		post{
			if(fff()){ break}
			else{ continue }
			return ""
		}
	}
		
	cnt := 0
	every(xxx) { cnt++ ; }
	
	xs = 100
	await(cnt ; cnt == 1 )
			
	"complete: " + [xs, xxx]
}

~~~~~
//##189 ref of array strict type check

xx double[]:
f = [1 2 3] 

def doings(){
	
	xx=f //not permitted

	""// + xx
}


~~~~~
//##190 trans break continue

def doings() {
		
	trans{	
		while(1>2){ return ""}//we dont want this in here, no ret from trans
		return ""	//no
	}
	
	trans{	
		while(1>2){ continue}//ok
		continue	
	}
	
	trans{	
		while(1>2){ break}//ok
		break
	}
	
	"" //+ [a, b]
}

~~~~~
//##191 no void left of ref

def doings() {
	a := 1
	onchange(a){
		//next is void, this is not permitted
		System.err.println("err balance: " + a):
		
	}
	
	"" + a
}

~~~~~
//##192 ensure that we cannot cast to Ref interface type, but to ref it ok

from com.concurnas.lang.precompiled import RefHelper

cc  = "me not ref" 

def xxx(a Object:) => a
def xxx2(a com.concurnas.bootstrap.runtime.ref.Ref<Object>) => a //expect error here - because not gettable
def xxx3(a Object:com.concurnas.runtime.ref.Local) => "ok" //expect error here

def doings() => "" +	[RefHelper.actonref(cc),
					xxx(cc),
					xxx2(cc),//its ok, creates to local which is a subtype of ref
					xxx3(cc),
					]
					
~~~~~
//##193 ensure that we cannot cast to Ref interface type, but to ref it ok - multilevel
					
from com.concurnas.lang.precompiled import RefHelper

cc  = "me not ref" 

def xxx(a Object::) => a //ok, others fail
def xxx2(a com.concurnas.bootstrap.runtime.ref.Ref<com.concurnas.bootstrap.runtime.ref.Ref<Object>>) => a
def xxx3(a com.concurnas.runtime.ref.Local<com.concurnas.bootstrap.runtime.ref.Ref<Object>>) => a
def xxx4(a com.concurnas.bootstrap.runtime.ref.Ref<com.concurnas.runtime.ref.Local<Object>>) => a

def doings() => "" +	[RefHelper.actonref(cc),
					xxx(cc), //ok, others fail
					xxx2(cc),
					xxx3(cc),
					xxx4(cc)
					]
					
~~~~~
//##194 multilevel as before - these are all ok
					
from com.concurnas.lang.precompiled import RefHelper

cc  ::= "me not ref"

def xxx(a Object::) => a //ok, others fail
def xxx2(a com.concurnas.bootstrap.runtime.ref.Ref<com.concurnas.bootstrap.runtime.ref.Ref<Object>>) => a
def xxx3(a com.concurnas.runtime.ref.Local<com.concurnas.bootstrap.runtime.ref.Ref<Object>>) => a
def xxx4(a com.concurnas.bootstrap.runtime.ref.Ref<com.concurnas.runtime.ref.Local<Object>>) => a

def doings() => "" +	[xxx(cc),//all ok
					RefHelper.actonref2(cc),	
					xxx2(cc),
					xxx3(cc),
					xxx4(cc)
					]
					
~~~~~
//##194 multilevel as before - some ok some not
			
from com.concurnas.lang.precompiled import RefHelper

cc  := "me not ref"

def xxx(a Object::) => a //ok, others fail
def xxx2(a com.concurnas.bootstrap.runtime.ref.Ref<com.concurnas.bootstrap.runtime.ref.Ref<Object>>) => a
def xxx3(a com.concurnas.runtime.ref.Local<com.concurnas.bootstrap.runtime.ref.Ref<Object>>) => a
def xxx4(a com.concurnas.bootstrap.runtime.ref.Ref<com.concurnas.runtime.ref.Local<Object>>) => a

def doings() => "" +	[xxx(cc),//all ok
					RefHelper.actonref2(cc),	
					xxx2(cc),
					xxx3(cc),//this one is ok since goinf from ref to make local
					xxx4(cc)
					]
				
~~~~~
//##195 no break continue in pre post blocks
def zzx() => true
def doings() {
	calls := ""
	done :=false
	
	xx int:
	
	ninset = every(xx) { return xx }
	
	a := 9
	
	xx  = async{
		pre{ 
			//leave out break and continue
			if(zzx()){continue 66}
			if(zzx()){ 		break 8 }//just one error we dont permit this here
			return 123 //permitted though a bit pointless
		}
		onchange(a){ 
			return 22
		}
		post {
			//leave out break and continue
			if(zzx()){continue 66}
			if(zzx()){ 		break 8 }//just one error we dont permit this here
			 return 101
		} 
	}
	a = 66
	
	await( xx ; xx==101)
	
	"" + [ninset, xx, a]
}


~~~~~
//##196 no return in sync blocks
def zzx() => 3>1
valu int: = 0

def dosomework(a int) {
	trans{ valu += a }
}


def doings() {
	f = sync{
		for( b in [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]){
			dosomework(b)!
		}
		
		for(h =1; h <== 15; h++){
			dosomework(h)!
		}
		
		h2 =1
		for(; h2 <== 15; h2++){
			dosomework(h2)!
		}
		
		if(zzx()){
			return "early"//yeah, you probably dont want a return in the middle of a sync block, doesnt make logical sense
		}
		
		100
	}
	"" + [valu, f]// (valu == 360)
}

~~~~~
//##197 more than one default no allow map

mmap = {1 -> 2, 3 -> 4, default -> 88, default -> 100}

def doings() => "hi " + mmap[1]

~~~~~
//##198 return a funcref incorrectly

mmap = {1 -> def () { 12}, default ->  def () {12} }

def doings() => "" + [mmap[1]()] //, mmap[10]()]


~~~~~
//##199 funcref one void but not all

//b not found, previouly this was blowing up
mmap = {1 -> def (a int) int { 12}, default -> def () { def (a int)  {a+b} } }

def doings() => "" + [mmap[1](3), mmap[10](3)]
//should explode in a few errors

~~~~~
//##200 we can infer the type here

class MyClass<X>{
	private var x X;

	this(x X){
		this.x = x
	}

	override toString() => "" + x
}

def doings() {
	mc = new MyClass<String>("one")
	mc2 = new MyClass("one") //gets infered as String
 	"" + [mc, mc2]
} 

~~~~~
//##201 optional new keyword

class MyClass{
	private val x String
	this(x String){
		this.x = x
	}
	
	override toString() => "" + x
}

def doings() {
	mc2 = MyClass("one") //new keyboard is optional required!
 	"" + mc2
}

~~~~~
//##202 no new and gen inf

class MyClass<X>{
	private var x X;

	this(x X){
		this.x = x
	}

	override toString() => "" + x
}

def doings() {
	mc2 = MyClass("one") //new keyboard is optional required!
 	"" + mc2
}

~~~~~
//##203 gen inf - missing some generics

class MyClass<X, Y>{
	public var x X?;
	public var y = "no set"

	this(x X){
		this.x = x
	}
	
	this(a String){
		this.x = null
		this.y="set"
	}

	override toString() => "" + [""+x,y]
}

def doings() {
	mc2 = new MyClass([1,2]) //new keyboard is optional required!
	mc2.x=[3,4]//type gets bound correctly
 	"" + [mc2, mc2.x?[1]]
}

~~~~~
//##204 erasure check performed on generic types of classes for consturctor and methods
@SuppressWarnings("all")
class MyClass<X>{
	private var x X?;

	this(x X){
		this.x = x
	}
	

	this(x Object){
		this.x = x as X
	}

	def do(x X){
			this.x = x
		}
		
	def do(a Object){//ereasure detectable here
		this.x = null
	}

	override toString() => "" + x
}

def doings() {
	mc2 = new MyClass<String>("one") //new keyboard is optional required!
	//mc2.do("")
 	"" + mc2
}

~~~~~
//##205 some complex constructor invokations are too complex

from java.util import ArrayList
class MyAR extends ArrayList<String>{}
class MyARInt extends ArrayList<Integer>{}

//MyAR and MyARInt dont map to same type so this is not possible
class MyClass<T>(t ArrayList<T>, t2 ArrayList<T>){
	def addToT(a T){
		t.add(a)
		t2.add(a)
	}
	override toString() => "" + [t, t2]
}

def doings(){
	xxx = new MyClass(	MyAR(), MyARInt()	)
	
	xxx.addToT("hi")
	
	return ""+ xxx
}

~~~~~
//##206 what if not all the generics got qualified...

from java.util import ArrayList
class MyAR extends ArrayList<String>{}
@SuppressWarnings("all")
def myGen<T, H>(t T, taker ArrayList<T>) H {
	taker.add(t)
	""+ taker as H
}

def doings(){
 	kid = MyAR()
	thing = myGen("hi there", kid);//this doesnt qualify H so error in local bindings
	thing2 = myGen&("hi there", kid);//likewise
	
	"" + [thing, thing2(), kid]
}

~~~~~
//##207 what if not all the generics got qualified when explicit

from java.util import ArrayList
class MyAR extends ArrayList<String>{}
@SuppressWarnings("all")
def myGen<T, H>(t T, taker ArrayList<T>) H {
	taker.add(t)
	""+ taker as H
}

def doings(){
 	kid = MyAR()
	thing  = myGen<String>("hi there", kid);//this doesnt qualify H so error in local bindings
	
	"" + [thing, kid]
}

~~~~~
//##207.b avoid accidental binding
//was accidentally being bound to H because its declared in the containing method previously, this is not correct
from java.util import ArrayList
class MyAR extends ArrayList<String>{}
@SuppressWarnings("all")
def myGen<T, H>(t T, taker ArrayList<T>) H {
	taker.add(t)
	""+ taker as H
}

def getstuff<H>(){
 	kid = MyAR()
	thing2 = myGen&("hi there", kid);//this should not be accepted because H is not bound
}

def doings(){
	getstuff<String>()
	kid = MyAR()
	thing2 = myGen&("hi there", kid);//this should not be accepted because H is not bound
	
	"" //+ [thing, thing2(), kid]
}

~~~~~
//##208 method locals do get ereased at runtime

from java.util import ArrayList
class MyAR extends ArrayList<String>{}

def myGen<T>(t T, taker ArrayList<T>) {
	taker.add(t)
	""+ taker
}

def myGen<F >(t F, taker ArrayList<F>) {
	taker.add(t)
	""+ taker
}

def doings(){
 	kid = MyAR()
	thing  = myGen<String>("hi there", kid);//this doesnt qualify H so error in local bindings
	
	"" + [thing, kid]
}

~~~~~
//##209 no new ints

f =  new int()

~~~~~
//##210. class ref oh no 1

ll = 99

def doings(){
	got2 = ll.class //not permitted either

	"" + got2
}

~~~~~
//##211. class ref oh no 2

def doings(){
	got = class//its fine on its own, its just class < Object which is valid - no, silly

	"" + got
}

~~~~~
//##212. couple of errors now gracefuly handlered

import com.concurnas.runtime.ref.RefArray

def doings() {
	xx = new int:RefArray(2)
	
	secondSet := false
	entryCnt:=0
	//got String:
	got Sting
	got=9
	
	onchange(xx){
		if(50 == xx:getNoWait(1)){//ignore the first one
			await(secondSet )
			got = "" + xx.get()//should be 10, 50 NOT 90, 50
		}
		trans{entryCnt++;}
	}
	
	
	trans{
		xx[0] = 10
	}
	
	trans{
		xx[1] = 50
	}
	
	trans{
		xx[0] = 90
	}
	
	secondSet = true
	
	await(got)
	await(entryCnt ; entryCnt==3)
	
	"" + [ got, "ok?: " + (got == "[10, 50]")]
}

~~~~~
//##213. super constructor must be public or protected

open class Sup{
	private this(){}
}

class Child < Sup{
	//super constructor must be protected or public
}


def doings()=>"hi" + Child()

~~~~~
//##214. no parfor transation if block not meant to return but does

import com.concurnas.runtime.ref.RefArray

ar = [1 2 3 4]

xx2 int:RefArray = new int:RefArray(ar.length)

def doings(){

	parforsync(na in ar){
		xx2[na-1] = na
		"f"//we do not attempt to translate this into a true parfor expression
	}

	"" + [xx2:get()]
}

~~~~~
//##215. no parfor transation if block not meant to return but does 2

def ff() => 12

import com.concurnas.runtime.ref.RefArray

ar = [1 2 3 4]

xx2 int:RefArray = new int:RefArray(ar.length)

def doings(){

	parforsync(na in ar){
		xx2[na-1] = na
		ff()//as par above but this is acceptable, because it gets poped off
	}

	"" + [xx2:get()]
}

~~~~~
//##216. generic param missing on this constructor invokation

class MyClass{
	def  getLa<XXX>(a XXX) => [a,a]
	override toString() => "hi"
}

def taker( dower () MyClass<String>  ){
	dower()
}

def doings(){
	ma ()MyClass<String> = MyClass<String>&()
	ma2  = MyClass<String>&()
	x = taker(ma)!
	x2 = taker(ma2)!
	"" + [x, x2]
}

~~~~~
//##217. function takes constructor func ref but missing generic params

class MyClass<T>{
	def  getLa<XXX>(a XXX) => [a,a]
	override toString() => "hi"
}

def taker( dower ()MyClass  ){
	dower()
}

def doings(){
	ma ()MyClass<String> = MyClass<String>&()
	ma2  = MyClass<String>&()
	x = taker(ma)!
	x2 = taker(ma2)!
	"" + [x, x2]
}

~~~~~
//##218. ensure that when locally qualified but wrong args passed then this fails

//error message could be better, since problem here was incorrect binding of generic args

from java.util import HashMap
from com.concurnas.lang.precompiled import GiveMeAGenericMethod

def doings(){
	lc = new GiveMeAGenericMethod<String>()
	kid = new HashMap<String, Integer>();

	"" + [lc.proc<String>("hi", 12, kid), kid]
}

~~~~~
//##219. type can only be used as funcref in this way

class MyClass(public ~a String){
	override equals(a Object)=>true
	override hashCode()=>69
}

def doings(){
	mc = MyClass("cool")
	
	"" + MyClass.getA()
}

~~~~~
//##220. ensure that functype is being invoked without array levels on funcrefinvoke

class MyClass<T>{
	def  getLa(a T) => [a,a]
	def  getLaTyped<T>(a T) => [a,a]
	override equals(a Object)=>true
	override hashCode()=>69
}
def doings(){
	low = def () String { "yo"}

	myRef = MyClass<() String>.getLa&(low)//<- fully defined
	
	mc = MyClass< () String>();
	myRef.bind(mc)
	
	"" +myRef()() //error, we we are trying to invoke on a thing with array levels - not nice
}

~~~~~
//##221. named type useage check - cant go on its own

class MyClass<T>{
	def  getLa(a T) => a
	def  getLaTyped<T>(a T) => a
	override equals(a Object)=>true
	override hashCode()=>69
	public x=100
}


def doings(){
	xx =  MyClass<String> //cannot be on its own
	myRef2 =xx.getLaTyped("hi")//fine
	
	myRef1 =MyClass<String>.getLaTyped&("hi")//ok
	myRef1.bind(MyClass<String>())
	
	myRef2=MyClass<String>.getLaTyped("hi")//- not permitted, must be a funcref when like this
	varac=MyClass<String>.x//not permitted also
	
	"" 
}

~~~~~
//##222. incorrect generics passed in unbound func ref

public class Parent<V>{
	public class MyClass<T>{
		def  getLa(a T, b V) T => a
		override equals(a Object)=>true
		override hashCode()=>69
	}
}

def doings(){
	xx () String = Parent<Float>.MyClass<Float>.getLa&("hi", 12)//fail
	
	par = new Parent<Integer>()
	ins =  par.new MyClass<String>()
	xx.bind(ins)
	
	"" +xx()
}

~~~~~
//##223. used to fail

class Parent<To>{
	public class MyClass(-g int){
		def  getLa(a String) => a
		def  getLaTyped(a String) => a
		override equals(a Object)=>true
		override hashCode()=>69
		public x=100
	}
}

def doings(){
	par = Parent<int>(12)//used to compile fail on missing, now its ok and throws correct error messages
	pp = par.MyClass&()
	
	ins = pp()
	
	"" +ins.x
}

~~~~~
//##224. constructor ref generic type inference wrong type passed

class Parent<To>{
	public class MyClass<T>(a T){
		def  getLa(a T) => a
		def  getLaTyped<T>(a T) => a
		override equals(a Object)=>true
		override hashCode()=>69
		~x=100
	}
}

def doings(){
	par = Parent<int>()
	refla () Parent<int>.MyClass<float> = par.MyClass&("hi")
	ins = refla()
	
	"" + ins.x
}

~~~~~
//##225. should fail

class MyClass<T>{
	def  getLa(a T) => [a,a]
	override equals(a Object)=>true
	override hashCode()=>69
}


dd=def () { "hi" }

def doings(){
	mc = MyClass<() String>();
	la = MyClass.getLa(dd )//should fail as we have no variable called MyClass 
		
	"" 
}

~~~~~
//##226. used to blow up...
//now just spits out errors as expcted
class Theclass<T>{
	def takeT(a T) => getter(a)
	private def getter(a F) => [a,a]
}

def doings(){
	tc = new Theclass<String>()
	"" + tc.takeT("hi")
}

~~~~~
//##227. funcref visibility

class Theclass<T>{
	private def getter(a T) => [a,a]
}

def doings(){
	tc = new Theclass<String>()
	go = tc.getter&("HI")//this is not allowed
	"" + go()
}

~~~~~
//##228. ensure generic bindings

from java.util import ArrayList
class MyAR extends ArrayList<String>{}

def myGen<T, H>(t T, taker ArrayList<T>) H {
	taker.add(t)
	""+ taker
}


def doings(){
 	kid = MyAR()
	thing = myGen("hi there", kid);//this doesnt qualify H so error in local bindings
	thing2 = myGen&("hi there", kid);//likewise <- MISSING HERE
	
	"" + [thing, thing2(), kid]
}

~~~~~
//##229. missing local bindings

class MyClass<Ta>(a Ta) {

	def something() => a
	def something2<P>() => a
	
	def getThingy() => something&() //fine, no missing bindings
	def getThingy2() => something2&() //fail as p is unbounded
}


def doings(){
	mc = MyClass(12)
	
	"" + [mc.getThingy()(), mc.getThingy2()() ]	
}

~~~~~
//##230. missing generic type qualification in funcType definition T

thefunc <Ta>(T) T[] = def<T>(a T) { [a,a] } //what is T?

def doings() {	
	ff = thefunc<int>&(? int)
	
	
	"" + ff(12)
}

~~~~~
//##231. complains on lambda funcref with local gens

thefunc <T>(T) T[] = def<T>(a T) { [a a] }

def doings() {	
	ff = thefunc<int>&(? String)//moan as mismatch
	
	"" + ff("12")
}

~~~~~
//##232. something we may not extend

private class WrongActor < com.concurnas.lang.Actor{
//not permitted to extend Actor
}

private class MyClass(x int) {
	def plus(b int)  =>  x += b; x 
}

//plus is not a method here...
def doings(){//but the below is ok
	my com.concurnas.lang.Actor =  actor MyClass(12)
	"" + my.plus(222)
}

~~~~~
//##232.b TypedActor we may not extend

private class WrongActor < com.concurnas.lang.TypedActor<MyClass>{
//not permitted to extend Actor
}

private class MyClass(x int) {
	def plus(b int)  =>  x += b; x 
}

//plus is not a method here...
def doings(){//but the below is ok
	my com.concurnas.lang.TypedActor<MyClass> =  actor MyClass(12)
	"" + my.plus(222)
}


~~~~~
//##233. non existant actor method

private class MyClass(x int) {
	def plus(b int)  =>  x += b; x 
	def hi() => x
	def stop() => "ok"//defines its own stop method
}

def doings(){
	my actor MyClass  =  actor MyClass(12)
	"" + my:hi();//does not exist
}

~~~~~
//##234. some actor errors

private class MyClass(~x int) {

	private def notAllowed() {}
	
}

private class MyClass2() {

	private def notAllowed() => {}
	protected def notAllowed2() => {}

	def doStuff(mc  MyClass){
		mc.notAllowed()
	}
	
	def doStuffToMe(mc MyClass2){
		mc.notAllowed()//could be another instance
		mc.notAllowed2()//could be another instance
		
		this.notAllowed()//this is ok - as self
		this.notAllowed2()//this is ok - as self
	}

}
	
def doings(){
	my  = actor MyClass(99)
	my2 = actor MyClass2()
	bug = actor MyClass2()
	my2.doStuff(my)
	my2.doStuffToMe(my2)
	
	"" 
}

~~~~~
//##235. actor fields are private

class MyClass(public a String){

}

def doings(){
	a =  actor MyClass("there") //func invoke...
	"hi " + a.a //moans
}

~~~~~
//##236. actors cant call private or protected methods on other instances of themselves

//unlike normal objects...
private class MyClass(~x int) {

	private def notAllowed() {}
	
}

private class MyClass2() {

	private def notAllowed() => {}
	protected def notAllowed2() => {}

	def doStuff(mc actor MyClass){
		mc.notAllowed()//could be another instance so no
	}
	
	def doStuffToMe(mc actor MyClass2){
		mc.notAllowed()//could be another instance so no
		mc.notAllowed2()//could be another instance so no
		
		this.notAllowed()//this is ok - as self
		this.notAllowed2()//this is ok - as self
	}

}
	
def doings(){
	my  = actor MyClass(99)
	my2 = actor MyClass2()
	bug = actor MyClass2()
	
	my2.doStuff(my)
	my2.doStuffToMe(my2)
	
	"" 
}

~~~~~
//##236. private and public actor fields are not visible

private class MyClass(public x int, private y int) {
}

def doings() String {
	my  =  actor MyClass(12, 13)
	norm = MyClass(12, 13)
	no1 = my.x
	no2 = my.y
	yes1= norm.x
	no3 = norm.y
	"" 
}

~~~~~
//##237. bugfix on unknown type

class MyClass(~x X){}//no idea what X is - this used to blow up

def doings(){
	mc = new actor MyClass("stuff")
	mc2 = new actor MyClass("ooh stuff")
	
	"" + [mc.x, mc2.x]
}

~~~~~
//##238. check local method binding count for both func invoke and references

//error cos no local binding
class MyClass<X>(~x X){
}

def shouldFail1<YYY, F>(a YYY){
	mc = MyClass(a)
	inst = mc.getX<YYY, F>()//error cos no local generics defined here
	inst
}

def shouldFail2<YYY, F>(a YYY){
	mc = MyClass(a)
	
	inst = mc.getX<YYY, F>&()//error cos no local generics defined here
	inst.bind(mc)
	
	inst()
}

def doings(){
	"ok " + [shouldFail1<String, int>("hey"), shouldFail2<String, int>("hey")]
}

~~~~~
//##239. lhs generic rhs must match or be null

class MyClass<X>(~x X){
	def stuff<H>() H{
		return ""
	}
	
	def thisIsOK<H>() H{
		return null//this is ok
	}
}


def doings(){
	"ok boys"
}

~~~~~
//##240. more generic errors as par above

class MyClass<X>(~x X){}

def asd<XX>(){
	mc = MyClass<XX>("stuff")//actually this should fail, since passed in type != generic binding
	mc.getX<XX>()//another error because this doesnt take generics
	mc.getX<XX>&()//another error because this doesnt take generics
}

def doings(){
	f = asd<String>()
	"" + f()
}

~~~~~
//##241. more local binding errors

//error cos no local binding
class MyClass<X>(~x X){

	def getMe<JJ>() => x

}

def shouldFail1<YYY, F>(a YYY){
	mc = MyClass(a)
	inst = mc.getMe<YYY, F>()//error cos no local generics defined here
	inst
}

def shouldFail2<YYY, F>(a YYY){
	mc = MyClass(a)
	
	inst = mc.getMe<YYY, F>&()//error cos no local generics defined here
	inst.bind(mc)
	
	inst()
}

def doings(){
	"ok " + [shouldFail1<String, int>("hey"), shouldFail2<String, int>("hey")]
}

~~~~~
//##242. use generics in - as

class MyClass<X>{}

def getStuff<Y>(a Object) => a as Y:

def doings(){
	"" + getStuff<int>(66:)
}

~~~~~
//##243. use generics in - is

class MyClass<X>{}

def getStuff<Y>(a Object) => a is Y:

def doings(){
	"" + getStuff<boolean>(66:) + " hi"
}

~~~~~
//##244. creation of actors with missing generics

class MyClass<X>( a X?){
	this(){ this(null) }
}

def getStuff<Y>() Object => new actor MyClass<Y>()//create with upper bound and issue warning

def getStuff2<Y>(a Y) Object => new actor MyClass<Y>(a)//this is ok, we can infer the type at runtime

def getStuff3<Y>() Object => return actor MyClass<Y>()//create with upper bound and issue warning

def getStuff4<Y>(a Y) Object => return actor MyClass<Y>(a)//this is ok, we can infer the type at runtime


def doings(){
	""
}

~~~~~
//##245. aside

class MyClass<X, Y>( a X, b Y, c ZZ){
	this(){ this(null, null, null) }
}

def getStuff2<Y, Z>(a Y, g Z) Object => new actor MyClass<Y, double, Z>(a, 69, g)//this is ok, we can infer the type at runtime
//the above constructor used to blow up as only 2 gen params defined on class yet 3 passed in here

def doings(){
	""
}
	
~~~~~
//##246. warning on creation of generic ref tpye

def getStuff2<Y>(a Y) Object => a://no!

def doings(){
	thing = getStuff2("hi")
	test = "" + (thing is String:)
	asRef = thing as String:
	
	"" + [asRef:getType(), test]
}

~~~~~
//##247. more than on qualifying thing for gens assocaited with actor

class MyClass<X>( a X, b X)

def getStuff2<Y>(a Y, b Y) => new actor MyClass(a, b)//ambigious

def doings(){
	thing = getStuff2("12", 13)
	
	"" + thing:getType()
}

~~~~~
//##248. more warning on crappy defitions

from java.util import ArrayList

class MyClass<X>{}

def getStuff<Y>() Object => new ArrayList<Y>()://this also needs to warn

def doings(){
	mc = getStuff<int>()
	
	"" + [mc is ArrayList<int>:]
}

~~~~~
//##249. bug with superclasses having args themselves being nested classes with generic params

class Outer<X>{
	override equals(a Object) => false
	override hashCode() => 1
	class Inner<Y>{
		def stuff() => "hi"
		override equals(a Object) => false
		override hashCode() => 1
	}
}

open class Holder<X>{}

class Comb<A, B> < Holder<Outer<AF>.Inner<B>> {//not ok doesnt resolve
	
}

class Comb2<A, B> < Holder<Outer<A>.Inner<B>> {//ok, resolves
	
}


def doings(){
	c= Comb<int, double>()
	c2= Comb2<int, double>()

	"" + c
}

~~~~~
//##250. bug used to npe on constructor ref not existing

class MyClass<X>(~a X)

def maker() => return actor MyClass<int>(12)

def doings(){
	thing = maker()
	
	ff2 = actor MyClass<int>.getA&()//thinks that its a constructor ref
	ff2.bind(thing)
	
	"" + ff2()
}

~~~~~
//##251. a does not exist

class MyClass(){
	~xa=9
}

actor MyActor(public a int) of MyClass{ //fail as requires no arg constructor

	def stuff(){
		b=a//actor can access its own feilds, but not that of others
		b=this.a//this is ok too
	}

	def stuff(ma MyActor){
		b=ma.a//cannot do this
	}

}

def doings(){
	xxx = new MyActor(12)
	"" + [xxx.xa, xxx.a]
}

~~~~~
//##252. actor field access no confuse with actee

class MyClass(){
	~xa=9
	~b=99
}

actor MyActor(~a int, ~b int) of MyClass{ //fail as requires no arg constructor
}

def doings(){
	xxx = new MyActor(12, 12)
	xxx:a+=1
	"" + [xxx.xa, xxx:xa, xxx.a, xxx:a, xxx.b, xxx:b]//complains about :xa
}

~~~~~
//##253. actor constructor args

class MyClass(~xa int){
	
}

actor MyActor(a int) of MyClass{ //fail as requires no arg constructor
}

def doings(){
	xxx = new MyActor(12)
	"" + xxx.xa
}

~~~~~
//##254. another actor ttest

class MyClass(~xa int){
	this() => {this(99)}//this being = {block} was a bug
}

actor MyActor(a int) of MyClass{ //requires no arg constructor
}

def doings(){
	xxx = new MyActor(12)//fine
	fail = new MyActor()//ERROR not existant, just have one
	"" + xxx.xa
}

~~~~~
//##255. untyped actor gen

abstract actor AbstractActor<Y,Y> of XXX {
	this(xxx () XXX ){
		super(xxx)
	}
	def something() => "hi there"
}

def doings()=>""

~~~~~
//##256. abstract typed actee gen already defined

abstract actor AbstractActor<XXX> of XXX {
	this(xxx () XXX ){
		super(xxx)
	}
	def something() => "hi there"
}

def doings()=>""


~~~~~
//##257. error could be better here

abstract actor AbstractActor of YYY<String> {//YYY<String> cannot be made into a generic
	this(xxx () YYY ){
		super(xxx)
	}
	def something() => "hi there"
}

def doings()=>""

~~~~~
//##258. this was a bug before

class MyClass(){
	~xa int = 100
}

abstract actor AbstractActor of XXX{
	this(xxx () XXX ){
		super(xxx)
	}
	something() = "hi there " //used to have a problem with this
	
}

actor MyActor of MyClass < AbstractActor {}

def doings(){
	xxx = new MyActor()//fine
	"" + [xxx.xa, xxx.something()]
}

~~~~~
//##259. abstract typed actors cannot have actee arguments

class MyClass(){
	~xa int = 100
}

actor AbstractActor of XXX(12){//no
	this(xxx () XXX ){
		super(xxx)
	}
	def something() => "hi there "
	
}

actor MyActor of MyClass < AbstractActor(12) {}

def doings(){
	xxx = new MyActor()//fine
	"" + [xxx.xa, xxx.something()]
}

~~~~~
//##260 no actors of actors

class MyClass(){
	~xa int = 100
}

actor MyActor of MyClass  {}

actor MyActor2 of MyActor  {}//nope, of is already an actor

def doings(){
	xxx = actor MyActor2()
	"" + [xxx.xa]
}

~~~~~
//##261. missing actee show correct line

class MyClass(){
	~xa int = 100
}

abstract actor MyActor of MyClass 

//actor MyActor2 < Object {}

def doings(){
	xxx = actor MyActor2()//ensure correct line
	""
}

~~~~~
//##262. actors can only extend actors

class MyClass(){
	~xa int = 100
}

abstract actor MyActor of MyClass 

actor MyActor2 < Object {}
actor MyActor2b of MyClass < Object {}

def doings(){
	xxx = actor MyActor2()//ensure correct line
	""
}

~~~~~
//##263. classes cannot extend actors

class MyClass(){
	~xa int = 100
}

abstract actor MyActor(~a int) of MyClass 

class MyActor2(a int) < MyActor(a+1) {}//classes cannot extend actors (actors cannot extend classes)

def doings(){
	xxx = actor MyActor2(12)//ensure correct line
	"" + [xxx.xa, xxx.a]
}

~~~~~
//##264. of syntax can be used on abstract typed actors only

from java.util import Set

class MyClass<X>{
	~xa = 99
}

actor MyInterceptor<Y> of SSS

actor MyActor<Yxx, Axx > of MyClass<Axx> < MyInterceptor<Yxx>

def doings(){
	xxx = actor MyActor<String, String>()//ensure correct line
	o Object = xxx
	x = o is String of MyClass<String>
	y = o is Set<String> of MyClass<String>
	//no two both the above
	""
}

~~~~~
//##265. of syntax can be used on abstract typed actors only missing stuff

class MyClass<X>{
	~xa = 99
}

actor MyInterceptor<Y> of SSS{
	def hi() => "hi"
}

actor MyActor<Yxx, Axx > of MyClass<Axx> < MyInterceptor<Yxx>

def doings(){
	xxx = actor MyActor<String, String>()//ensure correct line
	o Object = xxx
	"" + o is MyInterceptor<String>
}

~~~~~
//##266. four errors with actors

closed actor SupActorFail of XXX {}//cannot be closed
class LeNonActor of MyClass{}//normal classes cant do this
class LeNonActor2 of XXX {}//normal classes cant do this


class MyClass(xa int){
	private this(){ 	this(99)	}	
}

actor MyActor of MyClass{
	def nope() void { of = null;} //no, you can do this! no reassignment of of
}

~~~~~
//##267. nested classes cannot be actors

class DatCls(a int)

class MyHolder{
	there = "there"
	public actor AnAcotr of DatCls(12){//no!
		override toString() => "hi" + there
	}
}

def doings(){
	mc = MyHolder()
	x = mc.actor AnAcotr()
	"" + x
}

~~~~~
//##268. used to blow up now it doesnt, great

class DatCls(a int)

class MyHolder{
	there = "there"

	actor AnAcotr of DatCls(12){
		override toString() => "hi" + there
	}
}

def doings(){
	mc = MyHolder()
	x = mc.actor AnAcotr&()
	
	"" + x
}

~~~~~
//##269. actors and classes cannot extend stuff willy nilly

class AClass(~sth String)

open actor AnUntyped

open actor ATyped of AClass("hi"){
	def doSomething() => "with that:" + of.sth //legit
}

actor Fail1 < Object //untyped cannot extend class

actor Fail2 of AClass("") < Object //typed cannot extend class

actor Fail3 of String < AnUntyped //typed cannot extend untyped

actor Fail4 < ATyped //untyped can extend typed - because that would make it typed...

class Fail5 < AnUntyped //no extend untyped actor

class Fail6 < ATyped   //no extend typed actor

def doings(){
	""
}

~~~~~
//##270. used to blow up

class ClassWithAnId{

	def myID() => System.identityHashcode(this)
}

def doings(){
	x = ClassWithAnId()
	"" + x.myID()
}

~~~~~
//##271. toBoolean void check
def sdf() => true
def mevoid(){}

def doings(){
	x = if(	mevoid()) { "hi" } else { "fail" }
	x = if(sdf()) { "hi" }//TODO: should trigger warning re deadcode
		 elif(mevoid()){"k"}
		 else { "fail" }
	x = "ho" if mevoid() else ""
	x = mevoid() and mevoid()
	x = mevoid() or mevoid()
	assert mevoid()
	while(mevoid()){ v=2 }
	for(n=0; mevoid(); n++){ }

	""
}

~~~~~
//##272. invalid regex picked up at runtime

def doings(){
	rr = r"a***b"//invalid
	"" + rr.matcher("aaaaab").matches();
}

~~~~~
//##273. invalid format strings

def doings(){
	x1 = "hi {v+1} there {m}mate"
	x2 = "{sdfsdf"
	x3 = "{}"
	r=12
	x4 = "ass {12} what {asddsa+/}f"
	""//you get the idea
}

~~~~~
//##274. in and not in errors

from java.util import HashSet

class MyClass{
	def contains(a String) => true 
}

def vvoid() {}

def doings(){
	mc = MyClass()
	"" + [ 1 in mc,
			vvoid() in mc,
			12 in [1,2,3]
		 ]
}

~~~~~
//##275. restrictions on parallel for use
from java.util import Arrays, ArrayList, List

def forerunner(xxx List<int>){

	""+	parfor(a in xxx){
		if(a==2){continue 555;}
		if(a==5){break 999;}
		a + 100	
	}
	else{ "no" }
}

def forerunner(xxx int[]){

	""+	parfor(n=0; n < xxx.length; n++){
		a = xxx[n]
		if(a==2){continue 555;}
		if(a==5){break 999;}
		a + 100	
	}
	else{ "no" }
}

~~~~~
//##276. for else must return something

from java.util import Arrays, ArrayList, List

def vv() {}

def forerunner(xxx List<int>){
	""+	for(a in xxx){
		if(a==2){continue 555;}
		if(a==5){break 999;}
		a + 100	
	}
	else{  vv()  }
}

def forerunne2r(xxx List<int>){
	""+	for(n=0; n < xxx.size(); n++){
		a=xxx[n]
		if(a==2){continue 555;}
		if(a==5){break 999;}
		a + 100	
	}
	else{  vv()  }
}

def forerunner(){
	a=10
	""+	while(a<00){
		if(a==2){continue 555;}
		if(a==5){break 999;}
		a + 100	
	}
	else{  vv()  }
}


def doings() => ""

~~~~~
//##277. for, while etc incrementors

def doings(){
	n=0
	m = "hi"
	for(a in [1,2]; m) { }
	for(a in [1,2]; g String = "hi") { }
	for(a in [1,2]; f = "hi") { }
	for(a in [1,2]; n = "hi") { }
	//while etc use same code, show errors as approeriate when incorrect type used in incrementor
	""
}

~~~~~
//##278. werid bug

hh = {"one" -> 1:, "two" -> 2:, "three" -> 3:, "four" -> 4:}

def doings(){
	//one : 2
	hh.two : 12//used to crash compiler now ok


	"" + [hh.one, hh.two]
}

~~~~~
//##279. js style maps bugs

one=1
hh = { 1 -> 1, 2 -> 2}
hh2 = { "1" -> 1, "2" -> 2}

def doings(){
	g = hh.one//fails as lhs type is not string

	////ensure rhs is correct type
	hh2.one  = "12" //err wrong rhs type in map
	hh2.one := 12 //err not ref

	""
}

~~~~~
//##280. boolean infix operations

a1 = "hi"

def doings() {
	a1 or= true //lhs must be booean
	a1 and= true //lhs must be booean

	""
}

~~~~~
//##281. operator overloader error messages

class Complex(real double, imag double){
}


c1 = Complex(12,2)
c2 = Complex(2,2)
c3 = Complex(0,0)
flipper = Complex(6,6)
minusflipe = Complex(-6,-6)

toInc1 = Complex(99,0)
toDec1 = Complex(99,0)
toInc2 = Complex(99,0)
toDec2 = Complex(99,0)

toInc1r = Complex(99,0)
toDec1r = Complex(99,0)
toInc2r = Complex(99,0)
toDec2r = Complex(99,0)

def commerize(stuff Object[]){
	ret = ""
	for(s in stuff; n){ ret+="" + s +('\n' if n<stuff.length-1 else'')}
	ret
}

def doings(){
	p1 = c1+c2+c2
	m1 = c1-c2-c2
	
	mul1 = c1*c2*c2
	mul2 = c1/c2/c2
	mul3 = c1 mod c2 mod c2
	
	pow = c1**c2**c2
	
	ands = c1 and c2 and c3
	ors = c1 or c2 or c3
	
	
	gt = c1 > c2
	gteq = c1 >== c2
	lt = c2 < c1
	lteq = c2 <== c1
	
	gti = c2 > c1
	gteqi = c2 >== c1
	lti = c1 < c2
	lteqi = c1 <== c2
	
	
	got = c1['cool']
	got2 = c1[69]
	
	sublist = c1[1 ... 3]
	subpost = c1[1 ... ]
	subpree = c1[ ... 3]
	
	//map style assignment
	c1.myMap['check'] = 3
	c1["x"] = 4
	c1[69] = 2 //ensure no pop
	
	jsstylegetter = c1.one
	c2.one = 99//js style setter
	
	cont1 = 12 in c1
	cont2 = 13 not in c1
	
	toInc1++
	toDec1--
	++toInc2
	--toDec2
	
	a1=toInc1r++
	a2=toDec1r--
	a3=++toInc2r
	a4=--toDec2r
	
	gotf = -flipper
	gotmf = +minusflipe
	
	notc3 = not c3
	
	invk1 = c1()
	invk2 = c1("hi")
	invk3 = c1("hi", 69)
	
	c1 += c2
	
	""
}

~~~~~
//##282. used to be an error

ar = [1 2 3 4 5 6 7]

def doings(){

	ar[1:3] = [7 8 9]//this would blow up

	"" + ar
}

~~~~~
//##283. operator overloaded get and put types must amtch

from java.util import ArrayList

class Complex(real double, imag double){
	override toString() { 
		ip = '+' if imag >== 0 else '' 
		return "{real}{ip}{imag}i"
	}
	def get(a String) => 69
	def put(a String, b String) { got.add("{a}->{b}")}
	
	~got = new ArrayList<String>()
	
}


def doings(){
	c1 = Complex(12, -2)

	c1.f1 += "cool"//get type must match putable type
	
	"" + [c1.got, c1]
}

~~~~~
//##284. operator overloading of inc and dec

open class ComplexParent(real double, imag double){
	def inc() => ComplexParent(real+1, imag+1)
	def dec() => ComplexParent(real-1, imag-1)
}


class Complex(real double, imag double) < ComplexParent(real, imag)

toInc1 = Complex(99,0)

def doings(){
	toInc1++ //cannot do this, must return = or subtype
	toInc1-- //cannot do this, must return = or subtype
	"" 
}

~~~~~
//##285. enums can have protected stuff

enum MyEnum{ONE, TWO
	protected def afunc() => "ok"
	def pubone() => "ok" + afunc()
}

def doings(){
	one = MyEnum.ONE
	"" + one.pubone()
}

~~~~~
//##286. enum cannot define own values and valueOf methods

enum MyEnum{ONE, TWO

	def values() => 12//no, implicit defined already
	def values() => "12"//no as well, this was prevoiusly not being picked up....
	def valueOf(a String) => null//no, implicly defined already

}

class MyClass(~a int){}

def doings(){
	one = MyEnum.ONE
	
	"" + one
}

~~~~~
//##287. enum fields private only for elemnts

enum MyEnum{
	ONE{
		public f = 9 //not permitted
	},
	TWO{}//no stuff so no subclass just ingore
	public f=9;//fine
}

def doings(){
	one = MyEnum.ONE
	
	"" + one
}

~~~~~
//##288. inner item enum methods

enum MyEnum{
	ONE{
		public f = 9 //not permitted
		def something() => f++ //private by default
		public def something2() => f++ //must override in par
		protected def myprotected() => f++ //protected not allowed here 
		def motok() => 9//needs override
		override ok() => 9
		protected def sdsdasd() => f++ //protected not allowed
		private def mypriv() => f++ //ok
		
	},
	TWO{}//no stuff so no subclass just ingore
	def ok()=>9
	def motok()=>9
	protected def somethings() => 100//protected here is alright
}

def doings(){
	one = MyEnum.ONE
	two = MyEnum.TWO
		
	"" + one
}

~~~~~
//##289. enum super cannot invoke

enum MyEnum{
	ONE(),
	TWO()
	
	val a int=1;
	val b double=2.;
	
	this(){
		super("one", 1)//no! cant interact with this
	}
		
	override toString() => "{name()}({a}, {b})"
}

def doings(){
	one = MyEnum.ONE
	two = MyEnum.TWO
		
	"" + [one, two]
}

~~~~~
//##290. enum constructors can be private only

enum MyEnum{
	ONE(),
	TWO()
	
	val a int=1;
	val b double=2.;
	
	public this(){//no only private is permitted
	}
		
	override toString() => "{name()}({a}, {b})"
}

def doings(){
	one = MyEnum.ONE
	two = MyEnum.TWO
		
	"" + [one, two]
}

~~~~~
//##291. no access of private stuff from the non nested class ok

enum MyEnum{
	ONE("hi"){
		my String = ""
		//subtype has its own constructor!
		this(g String){
			super(100, 90.)
			my = g
		}
		
		private def som(){
			super.a=99
			f=afunc()//not accisible
		}
		
		override toString() => som(); "{name()}({a}, {b}) : {my}"//a and b are not visible
		
	},
	TWO(22, 8.){
		h=99//and all the ones from the parent
	}
	
	private a int
	private b double
	
	public this(a int, b double ){//no only private is permitted
		this.a=a; this.b=b;
	}
	
	private def afunc() => 99
	
	override toString() => "{name()}({a}, {b})"
}

def doings(){
	one = MyEnum.ONE
	two = MyEnum.TWO
		
	"" + [one, two]
}

~~~~~
//##292. enum at top level only if unnested else must go via thingy

class Outer{
	public enum MyEnum(~a int, ~b int){
		ONE(12, 13),
		TWO(22, 33)
		override toString() => "{name()}({a}, {b})"
	}
}

def doings(){
	one = MyEnum.ONE //check doesnt exist
	two = Outer.MyEnum.TWO //does exist
	
	"" + [one, two]
}

~~~~~
//##293. nested enum cannot access nestor class variables

class Outer{
	private xxx = 9
	public xxx2=9
	public enum MyEnum(~a int, ~b int){
		ONE(12, 13),
		TWO(22, 33)
		
		private def stuff(){
			w  = xxx //not visible from nested enum
			w2 = xxx2 //not visible from nested enum
		}
		
		
		override toString() => "{name()}({a}, {b})"
	}
}

def doings(){
	one = Outer.MyEnum.ONE //fine
	two = Outer.MyEnum.TWO //does exist
	
	"" + [one, two]
}

~~~~~
//##294. nested enum cannot access nestor class functions

class Outer{
	private def xxx() => 9
	public def xxx2()=>9
	public enum MyEnum(~a int, ~b int){
		ONE(12, 13),
		TWO(22, 33)
		
		private def stuff(){
			w  = xxx() //not visible from nested enum
			w2 = xxx2() //not visible from nested enum
		}
		
		override toString() => "{name()}({a}, {b})"
	}
}

def doings(){
	one = Outer.MyEnum.ONE //fine
	two = Outer.MyEnum.TWO //does exist
	
	"" + [one, two]
}

~~~~~
//##295. nested enum enum cannot access  stuff

enum MyEnum(~a int, ~b int){
	ONE(12, 13),
	TWO(22, 33)
	
	public h=9;
	def sdf(){
		"go"
	}
	
	public enum InnerEnum{
		GREEN, BLUE
		
		def asd(){
			gg=h
			np=sdf()
		}	
	}
}

def doings(){
	v = MyEnum.InnerEnum.GREEN
	
	"" + v
}

~~~~~
//##296. inner thing protected by default no create for you

class Outer{
	class Inner{}
}

def doings(){
	xxx  = Outer. new Inner()
	o = Outer()
	xxx2 = o.new Inner()
	
	xxx3 = Outer.Inner()
	xxx4 = o.Inner()
	
	""
}

~~~~~
//##297. inner thing no instiation like this

class Outer{
	public class Inner{}
}

def doings(){
	xxx  = Outer. new Inner()
	xxx  = Outer.Inner()
	
	""
}

~~~~~
//##298. nested class in enum no

enum MyEnum(~a int, ~b int){
	ONE(12, 13),
	TWO(22, 33)
	
	public class MyClass(~ass int){
		//can access stuff in the outer enum actually
	}
	
}


def doings(){
	v = MyEnum.new MyClass(9) //not accessiable
	
	"" + v
}

~~~~~
//##299. nested enum private by default
//#err111
enum MyEnum(~a int, ~b int){
	ONE(12, 13),
	TWO(22, 33)
	
	enum InnerEnum{
		GREEN, BLUE
	}
}

def doings(){
	v = MyEnum.InnerEnum.GREEN //inner enum is private by default
	
	"" + v
}

~~~~~
//##300. no weird stuff in enum subelements

enum MyEnum(~a int, ~b int){
	ONE(12, 13){
		class SillyClass(what int){
			//no you just cant do this...
		}
		actor G of String {}//no actors either
		enum FFS{ ONE, TWO }//nor this - who would want this?
	},
	TWO(22, 33)
	
	override toString() => "{a} {b}"
}

def doings(){
	"" + MyEnum.values()
}

~~~~~
//##301. no nesting of actors

enum MyEnum(~a int, ~b int){
	ONE(12, 13),
	TWO(22, 33)
	
	actor G of String{}
	
	override toString() => "{a} {b}"
}

def doings(){
	"" + MyEnum.values()
}

~~~~~
//##302. no actors of enums

enum MyEnum(~a int, ~b int){
	ONE(12, 13),
	TWO(22, 33)
	
	override toString() => "{a} {b}"
}

class Obay < MyEnum{}

actor Obayxxx of MyEnum{}

def doings(){
	m = Obay()
	m3 = actor MyEnum()
	"" 
}

~~~~~
//##303. enums items have got to explicity call this or super on entry

enum MyEnum(~a int, ~b int){
	ONE(9){
		this(a int){//must be this or super
		}
	},
	TWO(22, 33)
	
	override toString() => "{a} {b}"
}


def doings(){
	"" + MyEnum.values()
}

~~~~~
//##304. some dupe enum bugs

enum MYDullEnumAcc{ONE, TWO, ONE}//two items the same, not permitted

enum MYDullEnum{ONE, TWO}
enum MYDullEnum{ONE, TWO}//we have this guy defined already!

def doings(){
	"" + [MYDullEnumAcc.ONE, MYDullEnum.TWO]
}

~~~~~
//##305. placement of inits

inited = 0

init{
	inited++//not valid at this level
}

class One(){
	init{
		inited++//not valid as no classdef args
	}
}

enum MYE(){
	OP(), NO()

	init{
		inited++//not valid as no classdef args
	}
}

init{
	inited++//not valid at this level
}

def doings() {
	one = One()
	
	"" + [inited, MYE.values(), inited]
}

~~~~~
//##306. placement of inits re enums

inited = 0

enum MYE(a int){
	ONE(2){
		hh = "one"
		init{
			inited=99//not valid here in enum sub element (by accident it seems)
		}
	}
}

def doings() {
	"" + inited
}

~~~~~
//##307. annotation basic errors

@Stringx
def doings1(){//dunno type
}

@Thread
def doings2(){//can never intatitiate this

}

class MYClass

@MYClass
def doings(){//class not an annotation

}

~~~~~
//##308. annotation no duplicates for you

from com.concurnas.lang.precompiled import AnnotationHelper as AH

class MyClass{
	@AH.SimpleAnnotation()
	@AH.SimpleAnnotation()//no permitted as duplicate
	@AH.SimpleAnnotation2()
	@AH.SimpleAnnotation2()//no permitted as duplicate x2
	@AH.SimpleAnnotation2()//no permitted as duplicate x2 x2
	def simpleAnnot(){
	
	}
}

def doings() {
	m = AH.getMethodFromClass(MyClass.class, 'simpleAnnot')
	"" + AH.showAnnotations(m)
}

~~~~~
//##309. annotation missing args

from com.concurnas.lang.precompiled import AnnotationHelper as AH

class MyClass{
	@AH.AnnotOneArg()
	def simpleAnnot(){
	
	}
}

def doings() {
	m = AH.getMethodFromClass(MyClass.class, 'simpleAnnot')
	"" + AH.showAnnotations(m)
}

~~~~~
//##310. annotation single arg case

from com.concurnas.lang.precompiled import AnnotationHelper as AH

class MyClass{
	@AH.AnnotTwoArg("name") //not ok - which one?
	def simpleAnnot(){
	
	}
}

def doings() {
	m = AH.getMethodFromClass(MyClass.class, 'simpleAnnot')
	"" + AH.showAnnotations(m)
}

~~~~~
//##311. annotation single arg incorrect arg

from com.concurnas.lang.precompiled import AnnotationHelper as AH

class MyClass{
	@AH.AnnotOneArg(12) //not ok - which one?
	def simpleAnnot(){
	
	}
}

def doings() {
	m = AH.getMethodFromClass(MyClass.class, 'simpleAnnot')
	"" + AH.showAnnotations(m)
}

~~~~~
//##312. annotation single must resolve to constant

from com.concurnas.lang.precompiled import AnnotationHelper as AH

dave = "nope"

class MyClass{
	@AH.AnnotOneArg(dave) //correct type but non constant
	def simpleAnnot(){
	
	}
	@AH.AnnotTwoArgOneDefault("const" + dave) //not ok - which one?
	def simpleAnnot2(){
	
	}
}

def doings() {
	m = AH.getMethodFromClass(MyClass.class, 'simpleAnnot')
	m2 = AH.getMethodFromClass(MyClass.class, 'simpleAnnot2')
	"" + [AH.showAnnotations(m), AH.showAnnotations(m2)]
}

~~~~~
//##313. annotation multi key args

from com.concurnas.lang.precompiled import AnnotationHelper as AH
from java.util import Collections

class MyClass{
	@AH.AnnotTwoArg(name="hi") //missing name2
	def m1(){}
	
	@AH.AnnotTwoArg(name="hi", name="hi") //dupe
	def m2(){}
	
	@AH.AnnotTwoArg(namex="hi", name2="hi") //unknown
	def m3(){}
	
	@AH.AnnotTwoArg(name="hi", name2=4) //wrong type
	def m4(){}
}

def doings() {
	methods = MyClass.class.getDeclaredMethods()
	things = for(m in methods) {m.getName() + ":" + AH.showAnnotations(m)}
	Collections.sort(things)
	"" + things
}

~~~~~
//##314. annotation multi kv args must resolve to constants

from com.concurnas.lang.precompiled import AnnotationHelper as AH
from java.util import Collections

val xxx = "hi"

class MyClass{
	@AH.AnnotOneArg(name=xxx + "9") //xxx is not a constant sorry!
	def m1(){}
}

def doings() {
	methods = MyClass.class.getDeclaredMethods()
	things = for(m in methods) {m.getName() + ":" + AH.showAnnotations(m)}
	Collections.sort(things)
	"" + things
}

~~~~~
//##315. err takes annot as arg

from com.concurnas.lang.precompiled import AnnotationHelper as AH
from java.util import Collections

class MyClass{
	//@AH.TakesAnnotation(theArg = @AH.TakesEnum(theArg = AH.TheEnum.ONE))
	//def m0(){}//via kv form
	
	@AH.TakesAnnotation( "")
	def m1(){}//via single arg form
}

def doings() {
	methods = MyClass.class.getDeclaredMethods()
	things = for(m in methods) {m.getName() + ":" + AH.showAnnotations(m)}
	Collections.sort(things)
	"" + things
}

~~~~~
//##316. annotations only to new stuff

from com.concurnas.lang.precompiled import AnnotationHelper as AH
from java.util import Collections

class SpecialClass{
	@AH.AnnotOneArg("ok") //default applies to field
	public ~a int=99;
	
	@AH.AnnotOneArg("ok2") //default applies to field
	public b=99
	
	def something(){
		@AH.AnnotOneArg("ok2") //default applies to field
		ba=99//ok
		
		@AH.AnnotOneArg("ok2") //default applies to field
		a=99//not ok as not new
	}
	
}

def doings() {
	fields = SpecialClass.class.getFields()
	"" + for(f in fields) {f.getName() + ": " + f.getAnnotations(); } 
}

~~~~~
//##317. invalid annotation location

from com.concurnas.lang.precompiled import AnnotationHelper as AH
from java.util import Collections

class SpecialClass{
	@[field, setter]AH.AnnotOneArg("ok") //default applies to field
	public ~a int=99;
	
	@[dog, cat]AH.AnnotOneArg("ok") //default applies to field
	public ~ax int=99;
	
	override equals(a Object) => false
	override hashCode() => 1
}

def doings() {
	fields = SpecialClass.class.getFields()
	"" + for(f in fields) {f.getName() + ": " + f.getAnnotations(); } 
}

~~~~~
//##318. invalid annotation location x2

from com.concurnas.lang.precompiled import AnnotationHelper as AH
from java.util import Collections

@[dog, cat]AH.AnnotOneArg("ok")
class SpecialClass{
	@[field, setter]AH.AnnotOneArg("ok") //default applies to field
	public ~a int=99;
	
	override equals(a Object) => false
	override hashCode() => 1
}

def doings() {
	fields = SpecialClass.class.getFields()
	"" + for(f in fields) {f.getName() + ": " + f.getAnnotations(); } 
}

~~~~~
//##319. invalid annotation location x3

from com.concurnas.lang.precompiled import AnnotationHelper as AH
from java.util import Collections

class SpecialClass{
	@[setter,param]AH.AnnotOneArg("ok") //cannot use params on field annotaion locations
	public ~a int=99;
	
	override equals(a Object) => false
	override hashCode() => 1
}

def doings() {
	fields = SpecialClass.class.getFields()
	"" + for(f in fields) {f.getName() + ": " + f.getAnnotations(); } 
}

~~~~~
//##320. can only use setter getter locations for annotations where they are defined

from com.concurnas.lang.precompiled import AnnotationHelper as AH
from java.util import Collections

class SpecialClass{
	@[setter]AH.AnnotOneArg("ok") //only apply to setter
	@[getter]AH.AnnotOneArg("ok") //only apply to setter
	public a int=99;
	
	override equals(a Object) => false
	override hashCode() => 1
}

def doings() {
	fields = SpecialClass.class.getFields()
	"" + for(f in fields) {f.getName() + ": " + f.getAnnotations(); } 
}

~~~~~
//##321. annotations all defaults

from com.concurnas.lang.precompiled import AnnotationHelper as AH
from java.util import Collections

class SpecialClass{
	
	@AH.AnnotTwoArgAllDefault("ok-set")//but which one could it be?
	public ~e int=99;
	
	override equals(a Object) => false
	override hashCode() => 1
}

def doings() {
	""
}

~~~~~
//##322. annotations on classdef args

from com.concurnas.lang.precompiled import AnnotationHelper as AH
from java.util import Collections

class SpecialClass(@AH.AnnotOneArg("ok") public ~a int,
@[param]AH.AnnotOneArg("ok") public ~b int,
@[dsddd]AH.AnnotOneArg("ok") public ~c int, //not permitted
@[getter]AH.AnnotOneArg("ok") public d int,//there is no getter
@[field]AH.AnnotOneArg("ok") public ~e int,
){
	override equals(a Object) => false
	override hashCode() => 1
}

def doings() {
	fields = "" + for(f in SpecialClass.class.getFields()) {f.getName() + ": " + f.getAnnotations(); }
	
	methods = for(m in SpecialClass.class.getMethods()){m.getName() + ": " +  m.getAnnotations() }
	Collections.sort(methods)
	
	cons = for(m in SpecialClass.class.getConstructors()){  m.getParameterAnnotations() }
		
	"fields: {fields}\nmethods:{methods}\ncons:{cons}"
}

~~~~~
//##323. annotations on class level applying to constructor

from com.concurnas.lang.precompiled import AnnotationHelper as AH
from java.util import Collections

@[thss]AH.AnnotOneArg("ok")
class SpecialClass(public ~a int){
	override equals(a Object) => false
	override hashCode() => 1
}

def doings() {
	fields = "" + for(f in SpecialClass.class.getFields()) {f.getName() + ": " + f.getAnnotations(); }
	
	methods = for(m in SpecialClass.class.getMethods()){m.getName() + ": " +  m.getAnnotations() }
	Collections.sort(methods)
	
	cons = for(m in SpecialClass.class.getConstructors()){  m.getAnnotations() }
		
	"fields: {fields}\nmethods:{methods}\ncons:{cons}"
}

~~~~~
//##324. annotations on class level need defaultarg to use this

from com.concurnas.lang.precompiled import AnnotationHelper as AH
from java.util import Collections

@[this]AH.AnnotOneArg("ok")//compainss
class SpecialClass(){
	override equals(a Object) => false
	override hashCode() => 1
}

def doings() {
	fields = "" + for(f in SpecialClass.class.getFields()) {f.getName() + ": " + f.getAnnotations(); }
	
	methods = for(m in SpecialClass.class.getMethods()){m.getName() + ": " +  m.getAnnotations() }
	Collections.sort(methods)
	
	cons = for(m in SpecialClass.class.getConstructors()){  m.getAnnotations() }
		
	"fields: {fields}\nmethods:{methods}\ncons:{cons}"
}

~~~~~
//##325. target applies restrictions on to where annotations can be used

from com.concurnas.lang.precompiled import AnnotationHelper as AH
from java.util import Collections

class SpecialClass{
	@AH.FieldAnnot
	def amethod(){
		200
	}
}

def doings() => ""

~~~~~
//##326.nested enum double check

class MyClass(a int){
	
	public enum MYEnum{
		ONE, TWO
		def sdf(){
			a//but a is not visible
		}
	}
}

def doings() {
	"" + MyClass.MYEnum.ONE
}

~~~~~
//##327. annotation default values must resolve to constants

f=1

//@Retention(RetentionPolicy.RUNTIME)//defaults to this
annotation MYAnnotation(a = "hi", c String = "ok"){
	b = 99+f
	e int = 199+f
}

@MYAnnotation //to default values
class SpecialClass {
	override equals(a Object) => false
	override hashCode() => 1
}

def doings() {
""
}

~~~~~
//##328. annotation fields must resolve to approperiate types

from java.util import HashMap

//@Retention(RetentionPolicy.RUNTIME)//defaults to this
annotation MYAnnotation{
	b = new HashMap<String, String>()
	bc HashMap<String, String>?
}

def doings()  => ""

~~~~~
//##329. annotation fields validation checks of formattings

//@Retention(RetentionPolicy.RUNTIME)//defaults to this
annotation MYAnnotation{
	b = ""
	public ba = ""
	val noval = ""//no
	~noprfix String = ""//no
}

def doings()  => ""

~~~~~
//##330. annotations cannot have methods or init

//@Retention(RetentionPolicy.RUNTIME)//defaults to this
annotation MYAnnotation{
	def notallowedhere() => "no"
	init{}//nope
}

def doings()  => ""

~~~~~
//##331. validate attributes

from com.concurnas.lang.precompiled import AnnotationHelper as AH

//@Retention(RetentionPolicy.RUNTIME)//defaults to this
annotation MYAnnotation(a = "hi", c String = "ok"){
	b = 99
}

@MYAnnotation(b=8, f=9) //to default values
class SpecialClass {
	override equals(a Object) => false
	override hashCode() => 1
}

def doings() {
	from java.util import Collections
	fields = "" + for(f in SpecialClass.class.getFields()) {f.getName() + ": " + f.getAnnotations(); }
	
	methods = for(m in SpecialClass.class.getMethods()){m.getName() + ": " +  m.getAnnotations() }
	Collections.sort(methods)
	
	cons = for(m in SpecialClass.class.getDeclaredConstructors()){  m.getParameterAnnotations() }
	consitself = for(m in SpecialClass.class.getDeclaredConstructors()){  m.getAnnotations() }
	
	"fields: {fields}\nmethods:{methods}\ncons: {cons}\ncon itself: {consitself}\nclass: " + SpecialClass.class.getAnnotations()
}

~~~~~
//##332. custom annotations no boxed types for you

enum TheEnum{ONE, TWO}

annotation MYAnnotation{
	check  = [new Integer(1) new Integer(2)]
	check2 Integer[]?
}

@MYAnnotation(check2=[new Integer(33)  new Integer(44)])
class SpecialClass {
	override equals(a Object) => false
	override hashCode() => 1
}

def doings() {
	"" + SpecialClass.class.getAnnotations()
}

~~~~~
//##333. annotation cannot be instantiated

annotation MyAnnotation//note that you dont need to use the {}

class MyClass{
	no = new MyAnnotation() //cannot refer to these in this way
	noz = MyAnnotation() //cannot refer to these in this way
	no2 = @MyAnnotation() //can only be done inside an annotation
	def something(){
		cant = 	@MyAnnotation() + ""//canot be used here
	}
}

def doings() =>  "" 

~~~~~
//##334. annotation fields checks

annotation MYAnnotation1(b=1){
	b=2
}

annotation MYAnnotation2(ab=1, ab=2){
}

annotation MYAnnotation3(xx){
}


def doings() {
	"" 
}

~~~~~
//##335. custom annotation field useage restriction

from java.lang.\annotation import Target, ElementType

@Target([ElementType.FIELD])
annotation MYAnnotation1(b=1){
}


@MYAnnotation1 //not ok here
class SpecualClass{
	@MYAnnotation1 //ok here
	a =2
}

def doings() {
	"" + SpecualClass.class.getAnnotations()
}

~~~~~
//##336. custom annotation field useage restriction converted to array

from java.lang.\annotation import Target, ElementType

@Target(ElementType.FIELD)//converted to array
annotation MYAnnotation1(b=1, c=[1 2 3]){
}


@MYAnnotation1(c=1) //not ok here
class SpecualClass{
	@MYAnnotation1(c=1) //converted to array
	a =2
}

def doings() {
	"" + SpecualClass.class.getAnnotations()
}

~~~~~
//##337. annotation can have inner enum but this must be public

from java.lang.\annotation import Target, ElementType
from com.concurnas.lang.precompiled import AnnotationHelper as AH

//public enum Thing{ONE, TWO}
annotation MYAnnotation1{
	c=Thing.ONE
	d=Thing2.ONE
	public enum Thing{ONE, TWO}
	private  enum Thing2{ONE, TWO}//no!
}
//its only really enums that one can do the above...

@MYAnnotation1
class MyClass

def doings() {
	"" + MyClass.class.getAnnotations()
}

~~~~~
//##338. no nested classes thanks

from java.lang.\annotation import Target, ElementType
from com.concurnas.lang.precompiled import AnnotationHelper as AH

//public enum Thing{ONE, TWO}
annotation MYAnnotation1{
	class Nope

}
//its only really enums that one can do the above...

@MYAnnotation1
class MyClass

def doings() {
	"" + MyClass.class.getAnnotations()
}

~~~~~
//##339. suppress warnings params that can be used

from java.lang.\annotation import Target, ElementType
from com.concurnas.lang.precompiled import AnnotationHelper as AH

class MyClass<T>{//TODO: need to apply warning suppressors to local variable definitions and others
	@SuppressWarnings("allx")
	def something(a Object){
		a as T[]
	}
	
	@SuppressWarnings("allc")
	this(a Object){
		v=a as T[]
	}
	
	@SuppressWarnings("generic-castc")
	def something2(a Object){
		a as T[]
	}
	
	@SuppressWarnings(["generic-castx"  "pants"])
	this(a Object, b int){
		v=a as T[]
	}
}

@SuppressWarnings(["generic-cast"  "all"])//cannot specify all and generic-cast together
def something2<T>(a Object){
	a as T[]
}


@SuppressWarnings("alla")
class MyClass2<T>{
	def something(a Object){
		a as T[]
	}
}

@SuppressWarnings("generic-castd")
class MyClass3<T>{
	def something(a Object){
		a as T[]
	}
}

def doings() {
	"coll"
}

~~~~~
//##340. try w resrouces

public closeCount = 0
closed class Closer(throwExcp boolean){
	
	def close(){
		if(throwExcp){
			throw new Exception("uh oh")
		}
		closeCount++//returns but we throw that away
	}
	
	override equals(a Object) => false;
	override hashCode()=>1
}

def excepThrower(throwExcp boolean){
	if(throwExcp){
		throw new Exception("excepThrower exception")
	}
}

def subject(){
	try(
		 a = new Closer(false);	
		 b="" //no no close method
	 ){
		excepThrower(false)
	}
	
	"ok"
}

~~~~~
//##341. try w resrouces var decl
def subject() => ""
def excepThrower(a boolean){throw Exception("uh oh in excepThrower")}
public closeCount = 0
closed class Closer(throwExcp boolean, a int){
	
	def close(){
		if(throwExcp){
			throw new Exception("uh oh")
		}
		closeCount++//returns but we throw that away
	}
	
	override equals(a Object) => false;
	override hashCode()=>1
}

def doings(){
	""+[subject(), closeCount]
}


def subject(excepEx boolean, closerEx1 boolean, closerEx2 bool){
    b Closer//null is created for this because its not been instatiated
	try(
		 a Closer = new Closer(closerEx1, 1);
		 b = new Closer(closerEx2, 2)
	 ){
		excepThrower(excepEx)
		
	}
	
	"ok"+b//maybe not instatiated
}

~~~~~
//##342. try w resrouces var decl respected
def excepThrower(a boolean){throw Exception("uh oh in excepThrower")}
public closeCount = 0
closed class Closer(throwExcp boolean, a int){
	
	def close(){
		if(throwExcp){
			throw new Exception("uh oh")
		}
		closeCount++//returns but we throw that away
	}
	
	override equals(a Object) => false;
	override hashCode()=>1
}

def subject(excepEx boolean, closerEx1 boolean, closerEx2 bool){
    b Closer?=null
    c Closer?=null
	try(
		 a Closer = new Closer(closerEx1, 1);
		 var b Closer?= new Closer(closerEx2, 2);
		 val c Closer?= new Closer(closerEx2, 3)
	 ){
		excepThrower(excepEx)
		c=null//not permitted as c decl val
		b=null
		//"{a},{b}"
	}
	""+[b, c]
}

~~~~~
//##343. try w resrouces must impl close
def excepThrower(a boolean){throw Exception("uh oh in excepThrower")}
class MyClass
def subject(excepEx boolean, closerEx boolean){
	try(
		 assert true;
		  MyClass()
	 ){
		excepThrower(excepEx)
	}
	
	"ok"
}

~~~~~
//##344. try w assign existing must resolve to refname

public closeCount = 0
closed class Closer(throwExcp boolean){
	
	def close(){
		if(throwExcp){
			throw new Exception("uh oh")
		}
		closeCount++//returns but we throw that away
	}
	
	override equals(a Object) => false;
	override hashCode()=>1
}
def excepThrower(a boolean){throw Exception("uh oh in excepThrower")}
def subject(excepEx boolean, closerEx boolean){
	try(
		 uhoh[0] = Closer(false, 2)
	 ){
		excepThrower(excepEx)
	}
	
	"ok"
}

~~~~~
//##345. exception caught must be of exception type

class MyExcep //extends Throwable

def doings(){
	try{
		d=99
	}catch(e MyExcep){
	
	}

	""

}

~~~~~
//##346. exception caught does not exist

def excepThrower(throwExcp boolean){
	if(throwExcp){
		throw new Exception("excepThrower")
	}
}

public closeCount = 0
public closeCountx2 = 0
closed class Closer(throwExcp boolean, a int){
	
	def close(){
		if(throwExcp){
			throw new Exception("uh oh")
		}
		closeCount++//returns but we throw that away
	}
	
	override equals(a Object) => false;
	override hashCode()=>1
}

def subject(excepEx boolean, closerEx boolean){
	try(
		  Closer(closerEx, 1)
	 ){
		excepThrower(excepEx)
	}
	catch(a MyExcep){
		closeCountx2 += 1
	}
	"ok"
}

~~~~~
//##347. multi catch one each please

open class MasterException(g String) < RuntimeException(g){
	def getG() {super.getMessage()}
}

class Excep1(a String) < MasterException(a)

class Excep2(a String) < MasterException(a)

enum ThrowsWhat(public excep MasterException){
	ONE( Excep1("e1") ), TWO( Excep2("e2")), THREE( MasterException("xxx"))
}

def thrower(thing ThrowsWhat){
	throw thing.excep
}

def multicatch(thing ThrowsWhat){
	try{
		thrower(thing)
		"ok"
	}
	catch(a Excep1 or Excep1){
		"got expceted: " + a.getG()
	}
	catch(a){
		"mystery exception: " +  a.getMessage()
	}
}

~~~~~
//##348. potential reassignment of val in loop not permitted

class MyClass{
	val a int
	this(a int){
		for(n=0; n < 10; n++){
			this.a = a
		}
	}
}

def doings() => "fail"

~~~~~
//##349. is cannot reuse same type name

a Object = "12"

def doings() {
	isit1 = a is Integer or String
	isit2 = a is String or Integer
	isit3 = a is String
	isit4 = a is not Integer
	isit5 = a is not String
	isit6 = a is Integer
	isit7 = a is not String or Integer
	isit8 = a is not Integer or Integer
	
	"" + [isit1, isit2, isit3, isit4, not isit5, not isit6, not isit7, not isit8]
}

~~~~~
//##350. double dot usage

myarray = [1,2,3]

def doings() {
	x= myarray..length
	""
}

~~~~~
//##351. double dot usage restrict assignment

rscalled = 0
doublea = 0

class Myclass{
	public var ax =[1,2,3]
	public b=0
	public ~ba=0
	public ~c=0
}

def doings() {
	mc = Myclass()
	mc..b=12//nope
	mc..ba=12//this is ok as setter is called
	mc..ax[0]=12//no!!!
	mc..getB()=12//no wtf
	mc..getC().c=99//its ok
	
	"" + mc.c
}

~~~~~
//##351. param name cannot be directly declared

from com.concurnas.lang import ParamName

class Myclass(){
	override equals(a Object) => false 
	override hashCode() => 11 
	
	def stuff(@ParamName("a") a int){
		"" + a
	}
	
}

def doings() {
	mc = Myclass()
	s = mc.stuff(2)
	
	mm = Myclass.class.getMethod("stuff", [int.class])
		
	"" + [s, mm.getParameterAnnotations()]
}

~~~~~
//##352. param name cannot be dupe

class Myclass(a int){
	def thefunction(a int, b int) => a+b
	override equals(a Object) => false 
	override hashCode() => 11 
	
}

def doings() {
	mc = Myclass(12)
	res = mc.thefunction(a=12, b=23, a=13)
	""// + [res, res2]
}

~~~~~
//##353. named param checks

from com.concurnas.lang.precompiled import MethodPlusHelper

def doings() {
	mph = MethodPlusHelper()
	n="" + mph.afunc(2, a=5, c=9, d=9)//no match
	n="" + mph.afunc(2, a=5)//no match
	n="" + mph.afuncLackInfo(2, a=5, c=9)//no mapping
	"" + mph.afunc(2, a=5, c=9, )//this is ok
}

~~~~~
//##354. named type too many gens

from java.util import ArrayList

class Myclass(a int, b int){
	override equals(a Object) => false 
	override hashCode() => 11 
	override toString() => "{a}-{b}"
}

def doings() {
	mc = new Myclass<String, Integer>(12, 22,)//takes no generic params
	"" + mc
}

~~~~~
//##355. constructor with named param doesnt exist

from java.util import ArrayList

class Myclass<X>(a int, b int, public f X){
	override equals(a Object) => false 
	override hashCode() => 11 
	override toString() => "{a}-{b}"
}

def doings() {
	mc = new Myclass(12, f="hi", 22, h=0)//takes no generic params
	mc2 = Myclass(12, f="hi", 22)//takes no generic params
	"" + [mc, mc2, mc.f, mc2.f]
}

~~~~~
//##356. amibous named parameter mapping

from java.util import ArrayList

open class Myclass(){
	override equals(a Object) => false 
	override hashCode() => 11 
	
	def afunc(a int, b int, c String){
		"{a}{b}{c}"
	}
	def afunc(c String, a int, b int){
		"{a}{b}{c}"
	}
}


def doings() {
	mc = Myclass()
	ambi = mc.afunc(1,2, c="hi")
	"" 
}

~~~~~
//##357. lambda param information presemt

def doings() {
	a = def (a int, b int)  {a+b}
	"" + a(a=2, 5)//lambdas do have parameter information
}

~~~~~
//##358. was a bug on thing creation const not existing

class Acorn{
	def thefunc(a int, b int, c int) => "" + ((a**b)+c)
}

def doings() {
	actles = actor Acorn(2, a=5, 9, )//was a bug previously
	actles2 = actor Acorn(2, 5, 9, )//was a bug previously
	
	//a = actles.thefunc(2, a=5, c=9, )
	c = actles.thefunc(5,2,9 )
	
	//avr = actles.thefunc&(2, a=5, c=9, )
	//cvr = actles.thefunc&(5,2,9 )
	
	
	"" + c//[a, c, avr(), cvr()]
}

~~~~~
//##359. incorrect number of arguments w no defaults

def hasDefaults(a int, b int ) => a+b

def doings() {
	a7=hasDefaults(b=8)
	"" + a7
}

~~~~~
//##360. lhs must be supertype of rhs

def hasDefaults2(a String = 69, b = 2,) => a+b

~~~~~
//##361. defaults arg mach

def hasDefaults(a = 69, b int, c = 22, d int) => [a,b,c,d]
	
def doings() {
	a1=hasDefaults(12, 8)
	a2=hasDefaults(12, b=8)
	a3=hasDefaults(12, b=8)
	a4=hasDefaults(a=12, b=8)//complain
	a5=hasDefaults(b=8, a=12)//complain
	a6=hasDefaults(b=8, 12)//ok
	a7=hasDefaults(b=8)//complain
	a8=hasDefaults(a=8)//complain
	a9=hasDefaults(8)//complain
	a10=hasDefaults()//complain
	
	"" + [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10]
}

~~~~~
//##362. default param or type must be provided for classdef args

public class MyClass(a, b int, c int = 200, d int){//a offender!
	
	this( g String){
		this(99, 88)
	}

	override toString() => "" + [a,b,c,d]
	override hashCode() => 1
	override equals(a Object) => false
}	

	
def doings() {
	a1 = MyClass(12, 13)
	a2 = MyClass(12, 13, 99, 88)
	a3 = MyClass("spooky")
	
	"" + [a1, a2, a3]
}

~~~~~
//##363. minor bug

class MyClass{
	def lefunc(a = 100, b int, c = 200, d int) => [a,b,c,d]
	override hashCode() => 1
	override equals(a Object) => false

}
	
def doings() {
	ma = actor MyClass&() //no

	a1=ma.lefunc&(12, 8)//cannot be called on this boy! - used to blow up
	""
}

~~~~~
//##364. ambigious with default params

def myFunc(a int, b int, c int = 100) => a+b+c
def myFunc(a int, b int) => a+b //we can detect the ambigious declaration at this point as well

def myFunc(a int, c int, b int) => a+b//already exists

	
def doings() {
	ok= myFunc(1,2, c=7)//fine
	ambig = myFunc(1,2)//yes, it is ambigious
	""
}

~~~~~
//##365. ambigious with default params constr

class MyFunc{
	this(a int, b int, c int = 100){}
	this(a int, b int){}
	this(a int, c int, b int){}
}

	
def doings() {
	ok= MyFunc(1,2, c=7)//fine
	ambig = MyFunc(1,2)//yes, it is ambigious
	""
}

~~~~~
//##365. default value besides null cannot be used for generic type assignment

def myFunc<T>(a T = 79){ 5 }//not ok
	
def doings() {
	ok= myFunc<String>()
	""
}

~~~~~
//##366. default value besides null cannot be used for generic type assignment classdef

class Myclass<T>(a  T =9 , b =9 ){//not ok
	override toString() => "Myclass: " + a
}
	
def doings() {
	mc = Myclass("ok")
	"lovely: {mc}"
}

~~~~~
//##367. error when rhs does not match lhs 

def hasDefaults2(a String = 69, b = 2,) => a+b
	
def doings() {
	mc = hasDefaults2()
	"lovely: {mc}"
}

~~~~~
//##368. error when rhs does not match lhs classdefargs meh good enough

class hasDefaults2(a String = 69, b = 2,){
	//error gets output twice, meh
}
	
def doings() {
	mc = hasDefaults2()
	"lovely: {mc}"
}

~~~~~
//##369. error when no type or dv specified for classdefarg

class hasDefaults2(a , b = 2,){
	//error gets output twice, meh
}
	
def doings() {
	mc = hasDefaults2("")//cos there is one object parameter
	"lovely: {mc}"
}

~~~~~
//##370. only one vararg for you

def myMethod(a int, bs int..., bc int...){//can only have one
	for(bss in bs) { bss + a }
}

~~~~~
//##371. default param may not follow vararg immediatly

def myMethod(a int, bs int..., s = 9){//can only have one
	for(bss in bs) { bss + a }
}

~~~~~
//##372. vararg type checking must be subtypes

def myMethod(a int, bs int..., x int){
	for(bss in bs) { bss + a + x }
}

def doings() {
	well = myMethod(100, [1 2. 3], 10)//when presented literally
	well2 = myMethod(100, 1,2.,3, 10)//when a seperate elements
	"" + [well, well2]
}

~~~~~
//##373. vararg default value may not preceed vararg

def myMethod(a = 100., bs int...){
	for(bss in bs) { bss + a  }
}

~~~~~
//##374. this is not a match

def myMethod(bs int..., a = "xxx"){
	for(bss in bs) { bss + a  }
}

def doings() {
	well = myMethod(1,2,3, 4, 5.)
	"" + well
}

~~~~~
//##375. this is not a match either

from java.util import ArrayList, List

def asList(ts int...)  {
    result List<int> = ArrayList<int>()
    for (t in ts) { result.add(t) } 
    result
}

def doings() {
	asList(8, [1 2 3 4 5])
	"" + asList( [1 2 3 4 5], 8)
}

~~~~~
//##376. vararg ambiguity

def mymeth(a int...){}
def mymeth(){}

def doings() {
	mymeth()//its not ambigious
	""
}

~~~~~
//##377. must have diff type seperator between vararg and default param

def mymeth(b int..., g =100) => 	for(bn in b){g+bn}
def mymeth2(g =100, b int...) => 	for(bn in b){g+bn}

def doings() {
	"" + [mymeth(b=[1 2 3 4 5]), mymeth2(b=[1 2 3 4 5])]
}

~~~~~
//##378. as above

def mymeth(a int = 10, b int..., z = 100) => 	for(bn in b){bn+a + z}

def doings() {
	"" + mymeth(1,2,3,4,5)
}

~~~~~
//##379. ambigous wihtout seperating parameter on these varargs

class MyclassNo1(b int..., g =200){
	override toString(){
		"" + for(bn in b){g+bn}
	}
} 
class MyclassNo2(g =200, b int...){
	override toString(){
		"" + for(bn in b){g+bn}
	}
} 

def doings() {
	x = MyclassNo1(b=[1 2 3 4 5])
	x2 = MyclassNo2(1,2,3,4,5)
	
	"" + [x, x2]
}

~~~~~
//##380. typedef misc bugs

from java.util import ArrayList, HashMap

typedef myhm<x, y> = HashMap<y,x>//warning, x unused

def doings(){
	inst = myhm< int, String>//moan
	inst[12] = "ok"//wrong way around
	inst["ok"] = 13//right way around
	""  + inst
}

~~~~~
//##381. typedef takes the provided arg and applies if possible, also throwns warning when unused

from java.util import ArrayList, HashMap

typedef mylistQ<x> = ArrayList<int>//warning, x unused
typedef mylistQ<x, y> = ArrayList<int>//warning, x, y unused

def doings(){
	inst = mylistQ<String>()
	inst.add(12)
	inst.add("12")
	""  + inst
}

~~~~~
//##382. typedef can only be used in blocks

class Outer{
	typedef nestical = String
	class Inner{}
}

~~~~~
//##383. typedef ppp

private typedef nestical = String
public typedef nestical2 = String
protected typedef nope = String//not allowed
typedef nothing = String

def doings(){
	"" 
}

~~~~~
//##384. typedef ppp at module level only

def doings(){
	public typedef mm = int
	""
}

~~~~~
//##385. typedef cehcks

from java.util import ArrayList

public typedef   myok<x> = ArrayList<x>
public typedef   myok<x> = ArrayList<x>//dupe
public typedef   mylistQ<x, x> = ArrayList<x>//too many
public typedef  mylistQ<String> = ArrayList<String>//overrite string
public typedef  mylistQ<mylistQ> = ArrayList<mylistQ>//self ref in ary
public typedef  String = ArrayList<String>//overrite string

typedef  amyc = amyb//nope
typedef  amyb = amyc//nope
typedef  nope = nope//nope

class myClass<X>{
	def xxx(){
		typedef  mylistQ<X> = ArrayList<X>//should be ok
		typedef  mylistQ = ArrayList<X>//also fine
		typedef  aprim = int//also fine
		
		sth Object = ""
		
		sth is aprim 
	}
}

def doings(){
	typedef   myok<x> = ArrayList<x>
	""
}

~~~~~
//##386. match at least one case

def matcher(a Object){
	match(a){
		
	}
	""
}

def doings(){
	"" + [matcher(2), matcher(3), matcher("hello"), matcher(2.)] 
}


~~~~~
//##387. match else block redundant

def matcher(a Object){
	match(a){
		case(x int){
			"an int: " + [x, a] 
		}
		case(x ){
			"catch all: " + [x, a] 
		}
		case(x Object; true){//also renders redundant
			"catch all: " + [x, a] 
		}
		else{
			"sth else: "+a
		}
	}
}

def doings(){
	"" + [matcher(2), matcher(3), matcher("hello"), matcher(2.)] 
}

~~~~~
//##388. match else block because catch all always

def matcher(a Object){
	match(a){
		case(x Object; true){//true=> so will always resolve to true
			"catch all: " + [x, a] 
		}
		case(x int){
			"an int: " + [x, a] 
		}
		else{
			"sth else: "+a
		}
	}
}

def doings(){
	"" + [matcher(2), matcher(3), matcher("hello"), matcher(2.)] 
}

~~~~~
//##389. match catch all stuff after never triggered

def matcher(a Object){
	match(a){
		case(x ){
			//"catch all: " + [x, a] 
		}
		case(x Object; true){
			//"catch all: " + [x, a] 
		}
		case(x int){
			//"an int: " + [x, a] 
		}
	}
	
	""
}

~~~~~
//##390. looks about right 

a Object = 9
def doings(){
	b int=0
	b2 int=0
	
	x boolean = a is Integer//can be compared
	if(x){
		b = a as int//this is how we do the conversion
		b2 = a //implicit conversion from number
	}
		
	"" + [b, b2]
}

~~~~~
//##391. two double matches

def matcher(a Number){
	match(a){
		case(x int){//this does indeed match all as we can convert from any Number to int...
			"an int: " + [x, a] 
		}
		case(Object){//matches as > Number all so goes to else
			"catch all: " +  a 
		}
	}
}

def doings(){
	"" + [matcher(2), matcher(3), matcher(2.)] 
}

~~~~~
//##392. cannot match on unrelated class

class MyClass{}

def matcher(a Number){
	match(a){
		case(x int){//no match
			d="an int: " + [x, a] 
		}
		case(MyClass){//cannot match
			d="catch weird: " +  a 
		}
	}
	""
}

def doings(){
	"" + [matcher(2), matcher(3), matcher(2.)] 
}

~~~~~
//##393. case epr always false

def matcher(a Number){
	match(a){
		case(x Integer; false){//can never match
			"an int: " + [x, a] 
		}
		else{//matches all as > Number all so goes to else
			"catch all: " +  a 
		}
	}
}

def doings(){
	"" + [matcher(2), matcher(3), matcher(2.)] 
}

~~~~~
//##394. else would be better

def matcher(a Number){
	match(a){
		case(x Integer){//this does indeed match all as we can convert from any Number to int...
			"an int: " + [x, a] 
		}
		case(Object){//matches as > Number all so goes to else
			"catch all: " +  a 
		}
	}
}

def doings(){
	"" + [matcher(2), matcher(3), matcher(2.)] 
}

~~~~~
//##395. defo returns needs an else

def matcher(a Number) {
	f=match(a){
		case(x Integer){//this does indeed match all as we can convert from any Number to int...
			"an int: " + [x, a] 
		}
		//else{""}
	}
}

def doings(){
	"" 
}

~~~~~
//##396. flag longers on match no ret

def matcher(a Number) {
	match(a){
		case(x Integer){//this does indeed match all as we can convert from any Number to int...
			"an int: " + [x, a] 
		}
		else{""}
	}
	""
}

def doings(){
	"" + [matcher(2), matcher(3), matcher(2.)] 
}

~~~~~
//##397. exhcaustive enum match no else needed

enum MyEnum{ CASE1, CASE2, CASE3 }

def matcher(a MyEnum) {
	match(a){
		case(MyEnum.CASE1){//one does not need to reference the class
			"case1"
		}
		case(CASE2 or MyEnum.CASE3){
			"case2 or 3"
		}
		else{"fail"}//it can match if null!
	}
}

def doings(){
	"" + [matcher(MyEnum.CASE1), matcher(MyEnum.CASE2), matcher(MyEnum.CASE3)]
}

~~~~~
//##398. exhcaustive enum match no else needed

enum MyEnum{ CASE1, CASE2, CASE3 }

def matcher(a MyEnum) {
	match(a){
		case(MyEnum.CASE1){//one does not need to reference the class
			"case1"
		}
		case(CASE2 or MyEnum.CASE3){
			"case2 or 3"
		}
		case(x){"fail"}//could still be passed as null
	}
}

def doings(){
	"" + [matcher(MyEnum.CASE1), matcher(MyEnum.CASE2), matcher(MyEnum.CASE3)]
}

~~~~~
//##399. else block missing when non exhaustive enum raise WARNING only

enum MyEnum{ CASE1, CASE2, CASE3 }

//@SuppressWarnings("enum-match-non-exhaustive")
def matcher(a MyEnum) {
	d="dunno"
	match(a){
		case(MyEnum.CASE1){//one does not need to reference the class
			d="case1"
		}
		case(CASE2){
			d="case2"
		}
	}
	d
}

def doings(){
	"" + [matcher(MyEnum.CASE1), matcher(MyEnum.CASE2), matcher(MyEnum.CASE3)]
}

~~~~~
//##400. one case and it matches everything

def matcher(a Object){
	match(a){
		case(x ){
			"catch all: " + [x, a] 
		}
		else{'fail'}
	}
}

def doings(){
	"" + [matcher(2), matcher(3), matcher("hello"), matcher(2.)] 
}

~~~~~
//##401. bugfix nasty blowup

//enum MyEnum{ CASE1, CASE2, CASE3 }

def matcher(a MyEnum) {
}

def doings(){
	"" + [matcher(MyEnum.CASE1), matcher(MyEnum.CASE2), matcher(MyEnum.CASE3)]
}

~~~~~
//##402. match assign final cannot be reassigned

def matcher(ab int) {
	match(val a int = ab){
		case(10){
			a=10 //a declared final cannot be reassigned
			"little int"
		}
		case(n){
			"another int" + n
		}
	}
}

def doings(){
	"" + [matcher(1), matcher(9), matcher(10),]
}

~~~~~
//##403. cannot use increment decrement on vals
class AnotherA(a int=0)
val a = 10

def doings(){
	a++
	aa = AnotherA()
	aa.a++
	--a
	--aa.a
	"" + a
}

~~~~~
//##404. ref thing captures all

def matcher(a Object) {
	match(a){
		case(a int: ; a == 10: )=>	"an int ten"
		case(a int:)=>	"an int"
		case(int or Object:) =>	"another thing" 		
	}
}

def doings(){
	"" + [matcher(1:), matcher("9":), matcher(10:),matcher(10)]
}

~~~~~
//##405. sizeof

def nothing() {} 

def doings(){
	f = sizeof 12
	f2 = sizeof nothing()
	f3 = sizeof [12]//ok
	
	""
}

~~~~~
//##406. transient

def doings(){
	a = 99
	transient a=9//nope
	""
}

~~~~~
//##407. enum field restrictions

enum MyEnum{ONE, TWO
	public d=4
}

def doings(){
	www = "" + MyEnum.ONE.d //ok
	www = "" + MyEnum.ONE.ONE //not ok
	www = "" + MyEnum.d //this is not accessable not ok
	""
}

~~~~~
//##408. controls on delete

from java.util import ArrayList

def nothing() {}

modlevel = 44

mmap = {"hi" -> 1, "there" -> 2}
lili = new ArrayList<String>()
lili.add("one")
lili.add("two")
lili.add("three")

def doings(){
	del nothing()//void no type
	del 2+3 //invalid expr
	del modlevel //no mod level
	
	d=100
	del d 
	e=d//cannot do stuff with d it doesnt exist
	d="99" //this is a new d so its ok
	del mmap["hi"]
	del lili[0]

	""
}

~~~~~
//##409. controls on delete double check

from com.concurnas.lang.offheap.storage import OffHeapRAM

wasfincalled = false;

class MyClass{
	~thing =12
	override finalize(){
		wasfincalled=true
	}
}

11_meg = 11*1024*1024


def doings(){
	mc = MyClass()
	del mc
	mc.thing=99//mc cannot be used here
	
	"" + wasfincalled
}

~~~~~
//##410. delete needs override  

class MyClass{
	~thing =12
	def delete(){
		delcalled=true
	}
}

~~~~~
//##411. branch operation del invalidates rest

def what() => true

def doings(){
	thing = 99
	
	if(what()){
		del thing
	}

	"" + thing
}

~~~~~
//##412. no range delete


from java.util import ArrayList

ar = new ArrayList<String>()
ar.add("hi")
ar.add("there")
ar.add("wassup")



def doings(){
	del ar[0 ... 1]//cannot do this yet

	""
}

~~~~~
//##413. custom dma enc and dec

from com.concurnas.bootstrap.lang.offheap import Encoder, Decoder

class ErrorCls1{
	override toBinary(enc Encoder){
	}
}

class ErrorCls2{
	override fromBinary(dec Decoder){}
}


class ErrorCls3{
	def toBinary(enc Encoder){}//to be override
	def fromBinary(dec Decoder){}//to be override
}

from com.concurnas.lang.offheap.storage import OffHeapMapRAM

def doings(){
	""
}

~~~~~
//##414. ref name bugfix

enum MyEnum{ONE, TWO}

def doings(){
	"" + System.identityHashCode(MyEnum);//used to blows up bc gen
}

~~~~~
//##415. was a bug on null arg funcref

//def alovelyone() = "athena"
def whoislovely(its String) => "lovely: " + its

def doings(){
	myRef1 = alovelyone&
	myRef2 = whoislovely&
	"" + [myRef1(), myRef2("hi")]
}

~~~~~
//##416. ambigious no arg match

def whoislovely( ) => "lovely: "
def whoislovely(its String) => "lovely: " + its

def doings(){
	myRef2 = whoislovely&
	""// + myRef2("uh oh")
}

~~~~~
//##417. ambigious no arg match on cons

class MyClass(a int){
	this(a int, b int) {this(a+b); } 
	
	override equals(a Object) => false;
	override hashCode() => 1
	override toString() => "gots: " + a
}

def doings(){
	myClsInst = new MyClass&
	"" //+ myClsInst(12)
}

~~~~~
//##418. we need generic binding on this funcref

from java.util import ArrayList

def alovelyone<X>(an ArrayList<X>, x X) => an.add(x)

def doings(){
	ma = new ArrayList<String>()
	ma.add("hi")
	adder = alovelyone&//nope, it's fine conc will figure out the generic binding itself!
	
	"" + ma
}

~~~~~
//##419. we need generic binding on this construref

from java.util import ArrayList

class MyClass<X>(x X){
	override toString() => "got: " + x
}

def doings(){
	ma = MyClass&
	
	"" + ma("hi")
}


~~~~~
//##420. in out params - out param useage

//cannot set field if out param
//cannot pass in arg if out param

from java.util import ArrayList

class MyGen<X>{
	public x X?
}

def doings(){
	
	strli = new ArrayList<String>();
	strli.add("Hi")
	
	masterox ArrayList<Object> = strli //no
	mastero ArrayList<out Object> = strli//this is ok
	
	mastero.add(12)//not permitted
	ok = mastero.get(0)//this is ok
	xx=mastero.add&(12)//not permitted - also not ok for refs
	
	mygen MyGen<out Integer> = new MyGen<Integer>()
	what = mygen.x //new param gets upper bound without out/in
	what = 12 // ok as lhs is not tagged as an out parameter
	mygen.x = 2//no, cannot be set as qualified as an out parameter

 
	"" + [mastero, mastero[1] is String]
}

~~~~~
//##421. in out params - in param useage

//cannot get field if in param |-> ret upper bound
//cannot return arg if in param |-> ret upper bound


from java.util import ArrayList

class MyGen<X>{
	public x X?
	public def get(ank X) X{
		return null;
	}
}

def doings(){
	
	strli = new ArrayList<Number>();
	
	masterox ArrayList<Object> = strli //no
	masterog ArrayList<in Object> = strli//no
	mastero ArrayList<in Integer> = strli//ok
	
	mastero.add(12)//ok
	ok Object = mastero.get(0)//to the upper bound
	notok Integer = mastero.get(0);//nope
	
	ok2 = mastero.get(0)//to the upper bound, not tagged as in type
	ok2 = "fine"
	
	mygen MyGen<in Integer> = new MyGen<Integer>()
	mygen.x = 12//ok
	what Object = mygen.x //ok
	what2 Integer = mygen.x //not ok bound to upper bound
	what3 = mygen.x //ok
	whats3=""//should be ok as object and not in Integer
  
	"all ok" 
}

~~~~~
//##422. in out params - imported from existing class

from com.concurnas.lang.precompiled import InOutParams


def doings(){
	
	outInstnce = InOutParams.getOutInstance()// its ,out Number.
	
	outInstnce.setX(new Integer(12))//cannot do this as out parameter
	outInstnce\.x = new Integer(12)//cannot do this either
		
	inInstnce = InOutParams.getInInstance()// its, in Integer.
	gotas Object = inInstnce.getX()//ok as > Integer - hack for now as we're not capturing type upper bounds correctly - that comes later
	gotasx Integer = inInstnce.getX()//not ok
	
 
	"all ok"
}

~~~~~
//##423. in out params convert from in out etc

from java.util import ArrayList

def doings() {
	thing ArrayList<out Number>  = ArrayList<int>()//ok
	thing2 ArrayList<Number> 	 = thing//no
	thing3 ArrayList<out int> 	 = thing//no
	thing4 ArrayList<out Object> = thing//ok
	
	inthing ArrayList<in Number>  = ArrayList<Number>()//ok
	inthing2 ArrayList<Number> 	 = thing//no
	inthing4 ArrayList<in Object> = thing//no
	inthing3 ArrayList<in Integer> = thing//ok
	
	""
}

~~~~~
//##424. in out params convert from in out etc imported

from com.concurnas.lang.precompiled import InOutParams

def doings() {
	ee1 InOutParams.ExpClass<Number, String> = InOutParams.getExp<String>() //no: Number is not supertype of out Number
	ee2 InOutParams.ExpClass<out Number, String> = InOutParams.getExp<String>() //correct
	"" + ee2.expiri(new Integer(12), "there")//no - fails as first one is tagged as out param
}

~~~~~
//##425. no inout on constructors

from java.util import ArrayList

def doings(){
	nope = new ArrayList<out String>()//cannot qualify construcotrs
	alsono ArrayList<out int>? = null//this is ok, gets converted anyway
	""
}

~~~~~
//##426. all generics must be qualified inc nested

from java.util import ArrayList


def doings(){
	
	xx = new ArrayList<ArrayList>()//wrong
	//check nested generics for correct usage...
	
	"ok " + xx
}

~~~~~
//##427. generics must have subgenerics in typedef quantified

from java.util import ArrayList

@SuppressWarnings("typedef-arg-use")
typedef mything<x, y, z> = x<y>

def doings(){
	h  = new mything<ArrayList, ArrayList, String>() 
	//complain as we forgot to quanity the ArrayList (y arg) generics
	xx = new ArrayList<String>()
	
	h.add(xx)
	
	"ok " + h
}

~~~~~
//##427. typedef no inout and validate valid structures 

from java.util import ArrayList

typedef  alist<x> = ArrayList<out x>//nope
typedef  something<x> = (x<out x>) x//nope
typedef  impossible1<x, y> = x<y<x>>
typedef  impossible2<x> = x<x>
typedef  impossible3<x, y, z> = z<x, x<y>>

def doings(){
	x alist<out Object> = alist<String>()
	
	"" + x
}

~~~~~
//##428. use of class refs on actors etc

from java.util import ArrayList

class MyClass<X>(x String){
	this(a int) => this("" + a)
	override toString() => "got: " + x
	override hashCode() => 1
	override equals(a Object) => false
	def hi() => "hi"
}

def doings(){
	w="weird"
	no1  ( * ) MyClass<String> = actor  MyClass<String>&
	no2 (  ) MyClass<String> =   MyClass<String>&
	no2b (  ) MyClass<String> =   MyClass<String>&
	no3 (  ) actor MyClass<String> =  actor MyClass<String>&
	no4 (* ) actor MyClass<String> =  actor MyClass<String>&("hi")
	fine (* ) actor MyClass<String> =  actor MyClass<String>&
			
	"" 
}

~~~~~
//##429. lambdas from java code cannot contain wildcard generic qualifications

from com.concurnas.lang.precompiled import ClassRefPasser

def doings(){
	yy = String&
	x = ClassRefPasser.illegalclassref(yy)
	x2 = ClassRefPasser.illegalclassref2(yy)

	"" //+ x2('one')
}

~~~~~
//##430. classsref only can use public constrictors 

from com.concurnas.lang.precompiled.ClassRefPasser import MyClass as MyClassJava

class MyClass(g String){
	private this(a int){
		this("" + a)
	}
	override toString() => "got: " + g
	override hashCode() => 1
	override equals(an Object) => (an is MyClass) and (an as MyClass).g==g
}

def doings(){
	mc = MyClass&
	
	inst = mc(33)//constructor is private
	inst2 = mc&(33)//constructor is private
	
	mc2 = MyClassJava&
	
	inst3 = mc(33)//constructor is private
	ok = mc&('33')
	
	"" 
}

~~~~~
//##431. local classes are not nested

class Thing{
	
	public def b() => 99 
	
	override equals(a Object) => false
	override hashCode() => 1

	def doingsXXX(){
		
		class MiniClass(a String){
			this(a int){
				this("" + a)
			}
		
			override toString() => "got: " + a + " also: " + b()
			def toString2() {
				b&()()
			}
			override equals(a Object) => false
			override hashCode() => 1
		}
		
		mm1 = MiniClass(9)
		//b=100
		//mm2 = new MiniClass("hi 9")
		"" + mm1//[mm1, mm2]
	}
}

def doings(){
	new Thing().doingsXXX()
}

~~~~~
//##432. local classes can only be private

def doings(){

	public class MiniClass(a String){
	}
	"" 
}

~~~~~
//##433. local classes cannot access fields as not nested

ppo  = 99
class MyClass{
	pp  = 99//not visible
	def stuff(){
		xxc=100; 
		class MMM(a String){
			override toString() => "MiniClass: " + [1, 
			xxc, 
			pp, 
			ppo]
			override equals(a Object) => false
			override hashCode() => 1
		}		
		MMM&
	}

	override equals(a Object) => false
	override hashCode() => 1
		
		
	def theops(){
		"" + stuff()('hi')
	}
}

def doings(){
	MyClass().theops()
}

~~~~~
//##434. local classes cannot access funcs of class

class MyClass{

	def lafunc(f String){
		def afunc() => 22//cannot be called in cls
	
		cls = class (a String){
			override toString() => "MiniClass: " + [a, afunc()]
			override equals(a Object) => false
			override hashCode() => 1
		}
		
		cls("ok" + f)
	}


	override equals(a Object) => false
	override hashCode() => 1
		
	def doings(){
		"" + lafunc('hi')
	}
}

def doings(){
	MyClass().doings()
}

~~~~~
//##435. inf copy bug

def lafunc(f String){

	class LocalTwo(public a String){
		override toString() => "LocalTwo: " + a
		override equals(a Object) => false
		override hashCode() => 1
	}
	
	
	actor LocActor of LocalTwo{
		def toStringx() => "LocActor: " + a
		override equals(a Object) => false
		override hashCode() => 1
	}
	
	
	LocActor('').toStringx() 
}


def doings(){
	""+lafunc('there')
}

~~~~~
//##436. no npe

class MyClass(a int, b int){
	override equals(a Object) => false
	override hashCode() => 1
	override toString() => getClass().getSimpleName() + " " + [a,b]
}

class MyProvider{
	override equals(a Object) => false
	override hashCode() => 1
	def \new(className String, args Object...){
		if(className == 'MyClass' and args.length == 2){ new MyClass(args[0] as Integer, args[1] as Integer) }
		else{ null }
	}
}


def doings(){
	mp = MyProvider()
	"" + mp.new MyClasks(1,2)
}

~~~~~
//##437. new oo - type returned must be compatible

class MyClass(a int, b int){
	this() => this(1,2)
	override equals(a Object) => false
	override hashCode() => 1
	override toString() => getClass().getSimpleName() + " " + [a,b]
	def metCall() => toString()
}

class MyProvider{
	override equals(a Object) => false
	override hashCode() => 1
	def \new(className String, args Object...)  {
		if(className == 'bytecodeSandbox.MyClass' and args.length == 2){ new MyClass(args[0] as Integer, args[1] as Integer) }
		elif(className == 'bytecodeSandbox.MyClass'){ new MyClass() }
		else{ null }
	}
}

class MyOtherClass{}

def doings(){
	mp = MyProvider()
	"" + mp.new MyOtherClass()//complains as this is not produced
}

//type returned must be >== expected type

~~~~~
//##438. new oo - type returned must be namedType

class MyProvider{
	override equals(a Object) => false
	override hashCode() => 1
	def \new(className String, ars int...)  {
		
	}
}

def doings(){
	mp = MyProvider()
	"" + mp.new D.MyOtherClass(1,2,3)//complains as this is not produced
}

~~~~~
//##439. new oo - no class refs allowed

class MyGenClass(x String, y String){
	override toString() => "MyGenClass " + [x,y]
}

class MyProvider{
	override equals(a Object) => false
	override hashCode() => 1
	def \new(className String, x String, y String)  {
		MyGenClass(x, y)
	}
	def \new(className String)  {
		MyGenClass('','')
	}
}

def doings(){
	mp = MyProvider()
	what = mp.new MyGenClass&
	
	"" 
}

~~~~~
//##440. new oo - no actors

class MyGenClass(x String, y String){
	override toString() => "MyGenClass " + [x,y]
}

class MyProvider{
	override equals(a Object) => false
	override hashCode() => 1
	def \new(className String, x String, y String)  {
		MyGenClass(x, y)
	}
	def \new(className String)  {
		MyGenClass('','')
	}
}

def doings(){
	mp = MyProvider()
	what = mp.new actor MyGenClass('hi', 'there')
	//future enhancement to support this
	"" + what
}

~~~~~
//##441. used to npe now it doesnt

class MyGenClass<X>(x X){
	override toString() => "MyGenClass " + x
}


class MyProvider{
	override equals(a Object) => false
	override hashCode() => 1
	def \new(className String, thing Object)  {
		MyGenClass(ars[0])
	}
}

def doings(){
	mp = MyProvider()
	"" + mp.new MyGenClass(77)//complains as this is not produced
}

~~~~~
//##442. bug on accessablility of protected items

from com.concurnas.lang.precompiled import ClassWithProtectedMethod

class Another < ClassWithProtectedMethod{
	a = new ClassWithProtectedMethod()

	def lala(){
		a.something()//not accessable, was before - bug
	}
}

def doings(){
	"" + Another().lala()
}

~~~~~
//##443. fix bugs on calling methods with boxed unboxed arguments

def call1(thing Integer[], b int){'well done'} 
def call2(thing int[], b int){'well done'} 
def call3(thing int[]){'well done'} 
def call4(thing Integer[]){'well done'} 


def doings(){
	got1 = call1([1 2 3], 99)
	got2 = call2([Integer(1) 2 3], 99)
	got3 = call3([Integer(1) 2 3])
	got4 = call4([1 2 3])
	
	"lovely"
}

~~~~~
//##444. final block throws exception so no return for main try

class IntExcep(~valu int) extends Exception{ override equals(o Object) boolean{return true;} }
cnt = 0; fincnt = 0; catchCall = 0;
def callCatch1() { catchCall++ }
def mycall(fail boolean) int {
	if(fail){ throw new Exception("") }
	return ++cnt; }


def callOnFinal1(){	fincnt+=1 }
@com.concurnas.lang.Uninterruptible
def da2(fail boolean, f2 boolean) int{
	try{ 
		99//oh no u dont
	}
	finally{
		callOnFinal1()//return 8
		throw new IntExcep(80) 
	}
}

def runner(a boolean, b boolean) int{
	try{ return da2(a,b) }
	catch(e IntExcep){ return e.valu } }

def doings() String{
	return "" + [ runner(true, true), runner(false, true),
				runner(true, false), runner(false, false),
				  cnt, fincnt, catchCall];
}

~~~~~
//##445. final block throws exception so no return for catches of try

class IntExcep(~valu int) extends Exception{ override equals(o Object) boolean{return true;} }
cnt = 0; fincnt = 0; catchCall = 0;
def callCatch1() { catchCall++ }
def mycall(fail boolean) int {
	if(fail){ throw new Exception("") }
	return ++cnt; }

def callOnFinal1(){	fincnt+=1 }
@com.concurnas.lang.Uninterruptible
def da2(fail boolean, f2 boolean) int{
	try{ 
		mycall(fail)//popped
	}
	catch(e Throwable){
		99//no
	}
	finally{
		callOnFinal1()//return 8
		throw new IntExcep(80) 
	}
}

def runner(a boolean, b boolean) int{
	try{ return da2(a,b) }
	catch(e IntExcep){ return e.valu } }

def doings() String{
	return "" + [ runner(true, true), runner(false, true),
				runner(true, false), runner(false, false),
				  cnt, fincnt, catchCall];
}

~~~~~
//##446. bugfix

xs := 1

def doings(){
	zzz String: = ""
	done1 := 0
	System.err.println("createa async")
	xxx = async{
		pre{
			System.err.println("enter pre")
		}
	}
	
	System.err.println("go here")
	xs = 2
	
	await(done1 ; done1==1 )
	
	
	"complete: " //+ xxx
}

~~~~~
//##447. redefine class

from java.util import Arrays, List, HashSet

class HashSet<X>(a X){//warn about overwrite of imported class
	def overrid() => a
}
class HashSet<X>(a X){//complain about local redefinition
	def overrid() => a
}

def doings(){
	xx List<int> = Arrays.asList(1,2,3)
	hs  = HashSet(xx)
	
	"" + hs.overrid()
}

~~~~~
//##448. bugfix on misnamed generics

class MyClass<Taf>(a Ta) {

	def something() => a
	def something2<P>() => a
	
	def getThingy() => something&() //fine, no missing bindings
	def getThingy2() => something2&() //fail as p is unbounded
}


def doings(){
	mc = MyClass(12)
	
	"" + [mc.getThingy()(), mc.getThingy2()() ]	
}

~~~~~
//##449. bugfix on parent nestor name incorrect

class Parent<To>{
		override equals(a Object)=>true
		override hashCode()=>69
	public class MyClass<T>(~a T){
		def  getLa(a T) => a
		def  getLaTyped<T>(a T) => a
		override equals(a Object)=>true
		override hashCode()=>69
		public x=100
	}
	
	def getKidmaker2() () ParentM<To>.MyClass<String> => MyClass&("hi") //no new

}

def doings(){
	par = Parent<int>()
	
	"" + par.getKidmaker2()().a
}

~~~~~
//##450. show error on missing import

def doings(){
	""+(Fiber.getCurrentFiber()<>null)//err on Fiber was being suppressed before
}

~~~~~
//##451. in our param test

from java.util import ArrayList

class MyGen<X>(public x X) {
}

def doings(){
	
	mygen MyGen<in Integer> = new MyGen<Integer>(12)
	hh = mygen.x
	what Object = mygen.x //ok
	what2 Integer = mygen.x //not ok bound to upper bound
	mygen.x = 9//fine
	
	mygen2 MyGen<out Integer> = new MyGen<Integer>(12)
	
	okwhat Object = mygen2.x //ok
	okwhat2 Integer = mygen2.x //ok
	mygen2.x = new Integer(8)//not ok
	
	"nope"
}

~~~~~
//##452. was a bug before concerning args for Holder

class Holder(~a MyClass){ override def toString() String { return "Holder obj" + a.toString()  } }
class MyClass(x String){ override def toString() String { return "MyClass obj"  }  }

def doings() String {
	a = new Holder('bug')
	"" + a
}

~~~~~
//##453. in param cant be used to qualify generic input to method or constructor

class MyClass<X>(x X)

class MyHolder<X>(public ~x X)

def MyLocalDef<X>(a X) => a

def doings(){
	prim = new MyHolder<String>("what")
	prim.x = "hi" 
	
	nope MyHolder<in String> = prim
	n String = nope\.x
	
	mc MyClass<String> = MyClass( n )
	mc2 MyClass<String> = MyClass(nope\.x )//used to blow up as in out cannot qualify generic type
	thing = MyLocalDef(nope\.x )//used to blow up as in out cannot qualify generic type... eh
	
	"" + n
}

~~~~~
//##454. ref array is directly settable

from com.concurnas.runtime.ref import RefArray

def body(){
	x3b int:RefArray = int:RefArray(12)//this is fine, we can directly set it
	x3b:
}

def doings(){
	x3b = body()
	b = x3b//extract to existing var ok
	"" + b
}

~~~~~
//##455. Cannot create ref of type: ref as it is uninstantiable

from com.concurnas.lang.precompiled import RefHelper

b := RefHelper.getThingAsRef(12)
b2 int:com.concurnas.bootstrap.runtime.ref.Ref
b2 = 5:

def doings() {
	one = "" + [b:]
	two = "" + [b2:]
	""+ [one, two]
}

~~~~~
//##456. used to blow up

def g2(x int) => 50+x

//on missing g
x = g&():
def doings(){
	y2 = g2&(2)!
	"it's done: " + [x(), y2()]
}

~~~~~
//##457. cannot cast from x array to x ref array 

def suum(items Integer:[]){
	12
}

def doings(){
	thing = [Integer(12) Integer(3)]
	suum(thing)
	""
}

~~~~~
//##458. ret when should and shouldnt

def doings(){
	trans{12}//returns when should not
	f=trans{}//doesnt return when should
	
	""
}

~~~~~
//##459. ambigious thanks to generic qualification constructors

class MyClass<X>{
	public val whathappened String
	
	this(x X, b int[]){
		whathappened = 'one'
	}
	
	this(a int[], c X){
		whathappened = 'two'
	}
}

def doings() {
	mc2 = new MyClass<int[]>([1 2], [1 2])//ambigious, not permitted
	
 	"" + mc2
}

~~~~~
//##460. ambigious thanks to generic qualification method calls

class MyClass<X>{
	def ambigola(x X, b int[]){
		'one'
	}
	
	def ambigola(a int[], c X){
		'two'
	}
}

def doings() {
	mc2 = new MyClass<int[]>()
	
 	"" + mc2.ambigola([1 2], [1 2])//ambigious, not permitted
}

~~~~~
//##461. type error on match

class MyClass(a int, b int){
	override equals(a Object) => false
	override hashCode() => 1
	override toString() => getClass().getSimpleName() + " " + [a,b]
}


def f() => MyClass.class.name

class MyProvider{
	def \new(className String, args Object...){
		match(className){
			case(10){ new MyClass(args[0] as int, args[1] as int) }
			//above should fail at scopeAndTypeCheckTime
			else{ null }
		}
	}
}


def doings(){
	mp = MyProvider()
	"" + mp.new MyClass(1,2)
}

~~~~~
//##462. classloaders return type Object

from com.concurnas.runtime import ConcurnasClassLoader


class MyClassLoader extends ConcurnasClassLoader{
	override equals(a Object) => false
	override hashCode() => 1
	
	normalClassLoader = MyClassLoader.class.getClassLoader() as ConcurnasClassLoader
	 
	defineInThisLoader  = new java.util.HashSet<String>()
	defAlready  = new java.util.HashMap<String, Class<?>>()
	
	def loadHere(fromx String){
		defineInThisLoader.add(fromx)
	}
	
	override loadClass( name String) Class<?>  {
		if(name in defAlready){
			return defAlready[name]
		}
		
		if(name in defineInThisLoader){
			defAlready[name] = super.defineClass(name, normalClassLoader.getBytecode(name))
			defAlready[name]
		}
		else{
			normalClassLoader.loadClass(name)
		}
	}
}

def doings(){
	mc = MyClassLoader()
	
	class AClass(a String, b String){
		override equals(a Object) => false
		override hashCode() => 1
		override toString() => "" + [a,b]
		def thing() => 'a thing' + [a,b]
	}
	
	mc.loadHere(AClass.class.name)
	got  = mc.new AClass('one', 'two')
	"" + got.thing()
}

~~~~~
//##463. match case always resolve to true

def matcher(a Object) {
	match(a){
		case(n Object; (1==1)){//its been assigned always returns true
			"case1"
		}
		else{
			"case other"
		}
	}
}

def doings(){
	"" + [matcher(1), matcher(2)]
}

~~~~~
//##464. this qualifier must exist and be in nest path

class Outerclass{
	private variable = 'outer variable'
	def aMethod(){
		"outer method"
	}
	
	public class Innerclass{
		private variable = 'inner variable'
		
		def aMethod(){
			"inner method"
		}
		
		public class Innerclass2{ 
			private variable = 'inner2 variable'
		
			def aMethod(){
				"inner2 method"
			}
			
			def work(){
				outer = this[String]
				inner = this[Innerclasssdf]
				""
			
			}
			
		}
		
	}
}

def doings(){
	outer = Outerclass()
	inner = outer. Innerclass()
	inst = inner. Innerclass2()
	""+inst.work()// -> [inner method, 2]
}

~~~~~
//##465. extension function only access public stuff

class MyClass{
	override equals(a Object)  =>false
	override hashCode() => 1
	override toString() => 'MyClass'
	private myvar = 12
	private def amethod() => 12
}


def MyClass myFunc(  ) {
	"" + [myvar, 
			this.myvar,
			amethod, 
			this.amethod(),
		]
}

def doings(){
	res = MyClass()
	res.myFunc()
}

~~~~~
//##466. extension methods only private or protected

class MyClass{
	override equals(a Object)  =>false
	override hashCode() => 1
	override toString() => 'MyClass'
	myvar = 12
	def amethod() => 12
}

class AnotherClass{
	override equals(a Object)  =>false
	override hashCode() => 1
	
	public def MyClass repeater(  ) {
		x1 = amethod&()
		x2 = this.amethod&()
	
		"" + [x1(), x2()]		
	}
	
	def worker(){
		res = MyClass()
		res.repeater()
	}
}

~~~~~
//##467. extension functions only called on extendee

class MyClass{
	override equals(a Object)  =>false
	override hashCode() => 1
	override toString() => 'MyClass'
	def amethod() => 12
}


def MyClass myFunc(  ) {
	"ok"
}

def doings(){
	res = MyClass()
	myFunc()//cannot be called by itself
	myFunc(res)//cannot be called by itself
}

~~~~~
//##468. arg clash on ext func duplicate

class MyClass{
	override equals(a Object)  =>false
	override hashCode() => 1
	override toString() => 'MyClass'
	def amethod() => 12
}


def MyClass myFunc(  ) {
	"ok"
}

def myFunc(x MyClass  ) {
	"non ext function"
}

def doings(){
	res = MyClass()
	res.myFunc()//cannot be called by itself
}

~~~~~
//##469. bit shift operations only on integral types

def doings(){
	oop1 = false
	oop2 = 1.0
	oop3 = 2.f
	
	
	f1 = false << 2
	f2 = 1.0 << 2
	f3 = 1.2f >> 2
	
	oop1 <<= 2
	oop2 >>= 2
	oop3 >>>= 2

	"" 
}

~~~~~
//##470. bitwise operators and or xor and comp type erros need to be integrals

def doings(){
	oop1 = false
	oop2 = 1.0
	oop3 = 2.f
	
	f1 = false bor 2
	f2 = 1.0 band 2
	f3 = 1.2f bxor 2
	
	oop1 bor= 2
	oop2 band= 2
	oop3 bxor= 2
	
	x1 = comp oop1
	x2 = comp oop2
	x3 = comp oop3
	

	"" 
}

~~~~~
//##471. asis - avoid accidental is cast

class Myclass{
	def athing() => "lovely"
}

def proc(an Object){
	f1=if(an is Object){
		z = an is Myclass
		an.athing()//cannot find this above call doesnt accidentally cast
	}elif(an is Object){
		z = an is Myclass
		an.athing()//cannot find this
	}else{""}
	
	f2 = {z = an is Myclass; an.athing()} if (an is Object) else ""
	
	""+f1 + f2
}

def doings(){
	proc(Myclass())
}

~~~~~
//##472. asis - not auto cast as short cirucuited

class Myclass{
	def athing() => "lovely"
}

def dd() => true

def proc(an Object){
	f1 = if(dd() or an is Myclass){
		an.athing()//not auto cast as short cirucuited
	}else {'fail' }
	
	f2 = an.athing() if dd() or an is Myclass else 'fail'
	//not auto cast as short cirucuited
	""+f1+f2
}

def doings(){
	proc(Myclass())
}

~~~~~
//##473. no valid expression list interpreatation
class Myclass(b int){
	def doit(a int) => (a+b)*2
}

def doings(){
	mc = Myclass(4)
	res = mc doitd 4
	"" + res
}

~~~~~
//##474. ambigious expression list
def bar() => 1
def bar(a int) => 1

def foo(a int) => a
def foo(a int, b int) => a


def doings(){
	res = foo bar 4
	"" + res
}

~~~~~
//##475. unable to intepret return best match so far

class MyClass{
	def afunc(){
		12
	}
}

def getMc() => MyClass()

def doings(){
res = getMc afunc 11 99
	"" + res
}

~~~~~
//##476. no valid interp

def nn() => 9
def myfunc(a int, b int) => a+b
nn = 3

def doings(){
	res = myfunc nn() 12
	"" + res
}

~~~~~
//##477. matrix contatinations cannot vary by more than one ar level

a= [[ 1 2; 3 4]]
b=1

def doings(){
	"" + [a ; b]
}

~~~~~
//##478. graceful failure on no ambiguate here
a=9 //cannot disambigaute the below (as no b)
myAr1 = [ b [1 7] ]
def doings(){
	"" + myAr1
}

~~~~~
//##479. for compri with parfor and gate no no

def doings(){
	res = a parforsync a in [1 2 3 4 5 6 7 8 9 10] if a mod 2==0
	fine = a parforsync a in [1 2 3 4 5 6 7 8 9 10]
	""
}

~~~~~
//##480. list compri type error

//better error message
mylist = [1 2 3 4 5 6 7 8 9 10]
mynewlist = {a+100} for a String in mylist 

def doings(){
	"" + mynewlist
}

~~~~~
//##481. horizontal concat fail

m = [ 11 12 ; 13 14]
m8 = [ 21 22 ; 23 24 ; 25 26]//fail too many elements

def doings(){
	try{
		d = [m m8]
		"fail"
	}catch(e){
		"" + e.message
	}
}

~~~~~
//##482. array dec may not have more than one null

def doings(){
	res1 = new int[5,][];//this is ok, can have more than one null at end slots
	res2 = new int[5,][6];//complain as null most be last
	"ok: " 
}

~~~~~
//##483. array dec may not have more than one null 2

def doings(){
	myArray =  Integer[2,][3,]//only last uniquali
	"ok: " + myArray
}

~~~~~
//##484. default value type being incompatible with taht provided should err

def fella(a int = 100 ) => a + 10

ok = [1. 2. 3.]

def doings(){
	"" +fella(ok)//cannot do this
}

~~~~~
//##485. invalid vectorization
myAr1 = [3 4]
myAr2 = [1 2 ; 3 4; 5 6]

def doings(){
	"" + (myAr1 == myAr2^)//no, one must be scalar
}

~~~~~
//##486. bugfix on funcinvoke

def fella(a int ) => a + 10

ok = [1 2 3]

def doings(){
	thing = [fella&(1) fella&(2)]
	res = thing[0]()//this is fine
	"" + thing() //cannot call like this
}

~~~~~
//##487. bugfix on funcinvoke 2

def fella(a int ) => a + 10

ok = [1 2 3]

def doings(){
	thing = fella&(ok^)
	"" + thing() //canot call like this
}

~~~~~
//##488. ambigious func invocation

def foo(a int, b String){

}
 
def foo(b String, a int){

}

def doings(){//saw this online, just had to try it, ooh, concurnas does the right thing!
	foo(a=12, b="hi")
	""
}

~~~~~
//##489. no double nested vect for you
//used to blow up now errs ok

class Myclass{
	override hashCode()=>1
	override equals(an Object)=>false
}

def Myclass \in(a int) => a >== 2 and a < 10


A = [[Myclass() Myclass() Myclass()]]

def doings() {
	//res = 6 in A^
	res1 = A^contains(6)
	res2 = not A^contains([1 2 3]^)^
	"" + [res1, res2]
}

~~~~~
//##490. only left or right may be vect

class Myclass{
	override hashCode()=>1
	override equals(an Object)=>false
}

def Myclass \in(a int) => a >== 2 and a < 10

elea = [1 2 35 4]
ele = [elea;elea]

A = Myclass()

def doings() {
	res = ele^ in A^
	"" + res
}

~~~~~
//##491. field not accessible to thing of arraylevels though present on individual items

class Myclass(field int){
	override hashCode()=>1
	override equals(an Object)=>false
	override toString() => 'Myclass: {field}'
}

A = Myclass([[12 13 14 15]  [1 2 3]]^) 

def doings() {
	"" + (A.field)
}

~~~~~
//##492. Only single ^ may be used for vectorized field operations

class Myclass(field int){
	def getField() => "hi: " + field//go via getter
	override hashCode()=>1
	override equals(an Object)=>false
	override toString() => 'Myclass: {field}'
}

A = Myclass([[12 13 14 15] ; [1 2 3]]^) 

def doings() {
	"" + (A^^field)
}

~~~~~
//##493. Field referece cannot be vectorized at this location

class Myclass(public field int){
	override hashCode()=>1
	override equals(an Object)=>false
	override toString() => 'Myclass: {field}'
}

A = Myclass( [1 2  1 2 3 4 5 6]^) 

//A = [1 2 3 4 5]

def doings() {
	//(A^field)^ = 99
	A^field
	//h=A^field + 9
	//A^ = 99

	"" + A
}

~~~~~
//##494. Only single ^ may be used for vectorized new operations

class Myclass(a int){
	public class SubClass(b int){
		override hashCode()=>1
		override equals(an Object)=>false
		override toString() => 'SubClass: {a, b}'
	}

	override hashCode()=>1
	override equals(an Object)=>false
	override toString() => 'FAIL Myclass: {a}'
}

A = Myclass([1 2 3 4 5]^)

def doings() {
	xxx = A^^new SubClass(8)
	"" + xxx
}

~~~~~
//##495. no more than one dot for auto vect

class Myclass(a int){

	def afunc() => "hi: {a}"

	override hashCode()=>1
	override equals(an Object)=>false
	override toString() => 'Myclass: {a}'
}

A = Myclass([1 2 3 4 5]^) 

def doings() {
	x = A..afunc()
	x2 = A\.afunc()//no double dot or direct access
	"" + x
}

~~~~~
//##496. wtf is null in a list all by itself

def doings(){
	bug4 = [23.34  666.78 ; [null] ]
	"" + bug4
}

~~~~~
//##497. cannot be just all empty arrays
def doings(){
	bug5 = [ [] ; [] ]
	bug6 = [ []  [] ]
	bug7 = [ [] , [] ]
	"" 
}

~~~~~
//##498. missing commas

myLista= [ 1]
myLista2= [ 1]

def obtination() String{//nice little ninja test of modulo operator there...
	a = "" + [""+myLista[0 0 4]   ""+myList[5 mod myLista[0].length ] ]
	b = "" + myLista[0 0 1 ... 3]
	prefix = "" + myLista[0 0  ... 3]
	postfix = "" + myLista[0 0 1 ... ]
	return "" + [a b  prefix  postfix]
}

def obtination2() String{//try boxed type: Integer
	a = "" + [""+myLista2[0 0 4]  ""+myList2[5 mod myLista2[0].length ] ]
	b =  ""+ myLista2[0 0 1 ... 3]
	prefix = "" + myLista2[0 0  ... 3]
	postfix = "" + myLista2[0 0 1 ... ]
	return "" + [a b  prefix  postfix]
}

~~~~~
//##499. no array like this

myPiggie1  = [ null ; null]

~~~~~
//##500. not supported nested null arrays

myPiggie1 Integer[2] = [null  [null  null]]
myPiggie2  = [null  [null  null]]


def doings() String{
	return ""+ [myPiggie1  myPiggie2]
}

~~~~~
//##500. was a bug now its fine

ar = [1,2,3,4,5,6,7]

def doings(){

	ar[1:3] = [7,8,9]//this would blow up

	"" + ar
}

~~~~~ 
//##501. was a bug now its fine on thing non vectable

class MyClass(an int){
	override toString() => "MyClass" + an
	def anoperation() => an + 100
}

myAr = [1 2 ; 3 4]

res1 = actor MyClass(myAr[0,0])

def doings(){
	res2 = res1^anoperation()
	"" //+ [res1, res2]
}

~~~~~
//##502. used to blow up

import com.concurnas.runtime.ref.RefArray 

def doings() {
	xx = new int::RefArray(2)
	xx[0] := 9
	xx[0]++
	nice  = xx[0]++
	xx[0] += 1
	"" + [xx.get() [xx::get()] nice]
}

~~~~~
//##503. used to blow up now ok

@SuppressWarnings("all")
from java.util import Map

myPiggie1 Map<Boolean, HashMap<Boolean, Integer[]>> = {true ->{true ->[null null]}}

def doings() String{
	return "" 
}

~~~~~
//##504. Only single hat may be used for vectorized array assignment operations

B int[] = [1 2 3 4 5 6 7 8 9 10]
ext int[] = [ 5 6 7]

def doings(){
	B[ext^^] = 99
	
	"" + B
}

~~~~~
//##505. Vectorized array references may not make use  of the double hat operator ^^ denoting self vectorization

B int[] = [1 2 3 4 5 6 7 8 9 10]
ext int[] = [ 5 6 7]

def doings(){

	B[ext^]^^ + 100
	B[ext]^^ + 100//auto version also no!

	
	"" + B
}

~~~~~
//##506. Vectorized array ref errors

A = [1 2 3]
B = [1 2 3 ; 1 2 3]

def doings(){
	A^[0]
	A^^[0]
	w = B^[ [ 1 2; 3 4]^]
	"" + w
}

~~~~~
//##507. lhs rhs of range
def doings(){
	q = 1 to 2
	""
}

~~~~~
//##508. bugfix join not exist

def String join(delim String, items Object...){
	delim.join(items)//since we are dealing with an ext func, bug used to add type as first arg twice which resolved toa match
}

def doings(){
	e1 = [1]
	e2 = a[1]
	e3 = [,]//empty list

	"".join(',', e1, e2, e3)
}

~~~~~
//##509. class refs cant be used like this

def doings(){
	tick  = java.lang.System//no!
	 "" + tick 
}

~~~~~
//##510. onchange no refs to monitor

def doings(){
	x := 10
	def xSquared() => x ** 2

	"" + onchange{ xSquared()}//x will NOT be automatically monitored
}

~~~~~
//##511. funcInvoke and args differing levels

class Myclass{
	override hashCode()=>1
	override equals(an Object)=>false
}

def Myclass \in(a int) => a >== 2 and a < 10


A = [Myclass() Myclass() Myclass()]

def doings() {
	res2 =  A^contains([[1 2 3]]^)
	""
}

~~~~~
//##512. correct error on long used as array index

ab = [1 2 3 4 5]


thing = new Integer(2)

def doings(){
	"" + for(x in ab; idx){//actually this is fine
		ab[idx]
	}
}

~~~~~
//##513. used to blow up

import com.concurnas.lang.gpus

def chooseGPUDeviceGroup(gpuDev gpus.DeviceGroup[], cpuDev gpus.DeviceGroup[]) {
	if(not gpuDev){//no gpu return first cpu
		cpuDev[0]
	}else{//intel hd graphics not as good as nvidea dedicated gpu or ati so deprioritize
		for(grp in gpuDev){
			if('Intel' not in grp.platformName){
				return grp
			}
		}
		gpuDev[0]//intel device then...
	}
}

def doings(){
	gps = gpus.GPU()
	deviceGrp = chooseGPUDeviceGroup(gps.getGPUDevices(), gps.getCPUDevices())
	device = deviceGrp.devices[0]
	intoGPU1 = device.makeOffHeapArrayIn(128)//now they are fine
	intoGPU2 = device.makeOffHeapArrayOut(128)
	outofGPU = device.makeOffHeapArrayMixed(128)
	
	"" + (x.getClass().simpleName for x in [intoGPU1 intoGPU2 outofGPU])
}

~~~~~
//##514. used to blow up 2

import com.concurnas.lang.gpus

def chooseGPUDeviceGroup(gpuDev gpus.DeviceGroup[], cpuDev gpus.DeviceGroup[]) {
	if(not gpuDev){//no gpu return first cpu
		cpuDev[0]
	}else{//intel hd graphics not as good as nvidea dedicated gpu or ati so deprioritize
		for(grp in gpuDev){
			if('Intel' not in grp.platformName){
				return grp
			}
		}
		gpuDev[0]//intel device then...
	}
}

def doings(){
	gps = gpus.GPU()
	deviceGrp = chooseGPUDeviceGroup(gps.getGPUDevices(), gps.getCPUDevices())
	device = deviceGrp.devices[0]
	intoGPU1 = device.makeOffHeapArrayIn(int[].class, 10)//method level generic not being captured/gennerated correctly?
	
	"" + intoGPU1
}

~~~~~
//##515. bugfix on missing refname rhs of dot

class MyCls{
	def thing(an Object){
	
	}
}

def doings(){
	mc = MyCls()
	mc.thing([ad 2 3 4] )//bug as was missing the fact that we are not inside the dop anymore
	""
}

~~~~~
//##516. better error message for import override

def doings(){
	//gps = gpu.GPU()
	String = 898
	"auto import"
}

~~~~~
//##517. inf loop mitigation

a String = ""

def thing(){
	if(a && 4>5){//&& is invalid and used to result in infinite copy loop
		3
	}
	4
}


def doings(){
	"" + thing()
}

~~~~~
//##518. DeleteOnUnusedReturn annotation can only be used on methods which

delCalled = 0

class ClassWithResource{
	override hashCode() => 1
	override equals(an Object) => false
	override delete(){
		delCalled++;;
	}
}

@com.concurnas.lang.DeleteOnUnusedReturn
def doWorkAndGetClassWithResouce(retNull bool){
	ClassWithResource()
}

@com.concurnas.lang.DeleteOnUnusedReturn
def invalid1(retNull bool){
	99
}

@com.concurnas.lang.DeleteOnUnusedReturn
def invalid2(retNull bool){
	[ClassWithResource()]
}

def doings(){
	"cool"
}

~~~~~
//##519. forced assign operator
def doings(){
	thing1 \= 12//not permitted for new items
	thing2 int \= 12//not permitted for new items
	
	""// + [thing1 thing2]
}

~~~~~
//##520. Sublist cannot be operated on
class MyClass{
	override hashCode() => 1
	override equals(an Object) => false
	
}

def doings(){
	mc = MyClass()
	mc[1 ... 5] = "something"
	"" + mc
}

~~~~~
//##521. sizeof with variant
def arMarker(size int) int[]{
	ret = int[size]
	n=0
	while(n < size){
		ret[n++] = n
	}
	
	ret
}

private class GPUSizeof{
	def gpusizeof(an Object) int{
		12
	}
	
	private def sizeofSomething(){11}
}

def gpusizeof(an Object) => GPUSizeof().gpusizeof(an)

def sillyFunc(a int) => 33

def sillyFunc2(an Object) => 'nope'

def doings(){
	leAr = arMarker(20)
	gpusize = sizeof<gpusizeof> leAr//ok
	a=sizeof<nope> leAr//missing func
	b=sizeof<sillyFunc> leAr//func taking wrong args
	c=sizeof<sillyFunc2> leAr//func ret wrong type
	"" + gpusize
}

~~~~~
//##522. something to non local ref implicit not permitted

class GPURef<X>(type Class<?>[], ~event int) < com.concurnas.runtime.ref.Local<X>(type){
}


def ok<Typex>(a Typex) Typex: {
	null
}

def fail<Typex>(a Typex) Typex:GPURef {
	null//no cannot do this//error thrown at runtime
}

def doings(){
	"fine" 
}

~~~~~
//##523. gpu restrictions in satc
annotation MyAnnot{}

gpukernel 1 okfunc()  {
	//ok
}

gpukernel 4 myFunc1() void {
	//incorrect levels
}

gpudef a() => false//ok
gpukernel 1 myFunc2() int {
	a =1 if a() else 3
	a//no ret int
}

gpukernel 1 myFunc3()  {//infir to int
	a =1 if a() else 3
	a//no ret int
}

class MyClass1{
	gpukernel 1 myFunc4() void {
		//no class level def
	}
}

gpukernel 1 okFunc2() void {
	gpukernel 1 myFunc6() void {
		//no nesting
	}
}

@MyAnnot
gpukernel 1 myFunc9()  {
	//no annotation
}

gpukernel  1 int myFunc10()  {
	//not permitted as extension function
} 

gpukernel 1 myFunc11(global a String = "hi")  {
	//no default value
} 

gpukernel 1 myFunc12(global a int...){
	//no vararg
} 

gpukernel 1 myFunc13(global a String){
	//must be prim
} 

gpukernel 1 myFunc14(global a int[2]){
	//must 1d
}  

gpukernel 1 myFunc15(a int[]){
	//missing qualifer
}  

def myFunc16(global a int[]){
	//applies to gpu stuff only
}  
 
gpudef myFunc17(global a int[]){
	super.acall()//super only in methods or ext func
} 

gpudef myFunc18(global a int[]){
	this[A].acall() //no qualified this
}
 
gpukernel 1 myFunc19(@MyAnnot global a int[]){
	//no arg annotations 
} 

def notOK20(){
	myFunc17(2)//its a gpu func, no calling for you!
}

def okFunc() => 12

gpukernel 1 myFunc21() void {
	okFunc()//can only call other gpu stuff
}

~~~~~
//##524. gpu restrictions in satc - part 2

gpukernel 1 myFunc1() void {//no nesting of anything
	def myFunc6() void {
		
	}
}

gpukernel 1 myFunc2() void {//no nesting of anything
	class Local{}
}

~~~~~
//##525. ensure that precompile classes abstract methods correctly captured

abstract class Holder(thing String) < com.concurnas.lang.precompiled.SimpleAbstractClass

class TrueHolder(thingx String) < Holder(thingx)

def doings(){
	tt = TrueHolder("hi")
	tt.thing
}

~~~~~
//##526. private class cannot be used like this

def doings(){
	xx  = com.concurnas.lang.precompiled.PrivateClassHeirarchy.getInstance()
	
	"" + xx.getClass().getSimpleName()
}

~~~~~
//##527. in out only with global

gpukernel 1 myFunc(global in A int[], global B int[], local in mul int, global out ret int[]) void {
	gid = get_global_id(0)
	ret[gid] = A[gid] + (B[gid]*mul);
}

~~~~~
//##528. what can be tagged as a stub function

@GPUStubFunction
def definedDef(dim int) int{
	0//optional body
}

@GPUStubFunction
def abstractDef(dim int) int//abstract optional

@GPUStubFunction
gpudef asgpudef(global dim int) int//must be abstract

@GPUStubFunction
gpudef asgpudefnobody(global dim int) int{
	0//no body permitted
}

@GPUStubFunction
gpukernel 1 kernelstub(global dim int) void {
	l=0//no body permitted
}

@GPUStubFunction
gpukernel 1 okkernel(global dim int) void

def doings() => "ok"

~~~~~
//##529. gpu kernel ambiguity

typedef gentype = float|double

gpukernel 1 myfunc1(global avar int){
	
}

gpukernel 1 myfunc1(local avar int){//ambigius
	
}

gpukernel 1 myfunc1(global in avar int){//not ambigius as in param
	
}

gpukernel 1 myfunc1(global in avar int){//ambigius as we have one already
	
}


def doings() => "ok"


~~~~~
//##530. gpu kerenel type erasure

gpudef fib(n int) long {
	if(n == 0){
		return 0
	}elif(n <== 2){
		return 1	
	}else{
		r = 0L; n1 = 1L; n2 = 1L       
		for(i = 2; i < n; i++) {      
	      r = n1 + n2               
	      n1 = n2                        
	      n2 = r                         
	    }                                   
	    return r
	}	
}


gpukernel 1 myFunc(global in A int[], global out ret int[]) void {
	gid = get_global_id(0)
	ret[gid] = fib(A[gid])
}

gpukernel 1 myFunc(global in A float[], global out ret int[]) void {//type erased - ambigoius
	gid = get_global_id(0)
	ret[gid] = 3
}
gpukernel 1 myFunc(global out A float[], global out ret int[]) void {//type erased -  its ok
	gid = get_global_id(0)
	ret[gid] = 3
}

def chooseGPUDeviceGroup(gpuDev gpus.DeviceGroup[], cpuDev gpus.DeviceGroup[]) {
	if(not gpuDev){//no gpu return first cpu
		cpuDev[0]
	}else{//intel hd graphics not as good as nvidea dedicated gpu or ati so deprioritize
		for(grp in gpuDev){
			if('Intel' not in grp.platformName){
				return grp
			}
		}
		gpuDev[0]//intel device then...
	}
}

def doings(){
	gps = gpus.GPU()
	deviceGrp = chooseGPUDeviceGroup(gps.getGPUDevices(), gps.getCPUDevices())
	device = deviceGrp.devices[0]
	inGPU1 = device.makeOffHeapArrayMixed(int[].class, 20)
	result = device.makeOffHeapArrayMixed(int[].class, 20)
	
	c1 := inGPU1.writeToBuffer([1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20])
	
	inst = myFunc(inGPU1, result)
	compute := device.exe(inst, [20], null, c1)//rest param detault
	
	ret = result.readFromBuffer(compute)
	
	del inGPU1, result
	del c1, compute
	del deviceGrp, device
	del inst
	
	'nice: ' + ret
}

~~~~~
//##531. was a bug now its fine

gpukernel 2 matMult(M int, N int, K int, global in A float[], global in B float[], global out C float[]) {
    globalRow = get_global_id(0) // Row ID of C (0..M)
    globalCol = get_global_id(1) // Col ID of C (0..N)
 
    // Compute a single element (loop over K)
    acc = 0.0f;
    for (k=0; k<K; k++) {
        acc += A[k*M + globalRow] * B[globalCol*K + k]
    }
    // Store the result
    C[globalCol*M + globalRow] = acc;
}


def chooseGPUDeviceGroup(gpuDev gpus.DeviceGroup[], cpuDev gpus.DeviceGroup[]) {
	if(not gpuDev){//no gpu return first cpu
		cpuDev[0]
	}else{//intel hd graphics not as good as nvidea dedicated gpu or ati so deprioritize
		for(grp in gpuDev){
			if('Intel' not in grp.platformName){
				return grp
			}
		}
		gpuDev[0]//intel device then...
	}
}


def doings(){
	gps = gpus.GPU()
	cpus = gps.getCPUDevices()
	deviceGrp = chooseGPUDeviceGroup(gps.getGPUDevices(), cpus)
	device = deviceGrp.devices[0]
	inGPU1 = device.makeOffHeapArrayIn<float[2]>(float[2].class, 2, 2)
	inGPU2 = device.makeOffHeapArrayIn<float[2]>(float[2].class, 2, 2)
	result = device.makeOffHeapArrayOut<float[2]>(float[2].class, 2, 2)
	
	c1 := inGPU1.writeToBuffer([ 1.f 2; 3.f 4])
	c2 := inGPU2.writeToBuffer([ 1.f 2; 3.f 4])
	
	inst = matMult(2, 2, 2, inGPU1, inGPU2, result)
	compute := device.exe(matMult, [2 2], null, c1, c2)//rest param detault
	//remove null
	
	ret = result.readFromBuffer(compute)
	
	del inGPU1, inGPU2, result
	del c1, c2, compute
	del deviceGrp, device
	del inst
	
	
	'nice: ' + ret
}

~~~~~
//##532. gens

class genClass<T>


def doings(){
	inst1 genClass<Object> = new genClass<String>()//no
	inst2 genClass<?> = new genClass<String>()//ok

	'ok'
} 

~~~~~
//##533. restrictions with arrays in gpus
 gpukernel 1 fails1(global in A int[], global out B int[]) {
	ida = get_global_id(0) 
	
	fail1 int[2] = a[[1 2 3] , [ 2 3]]
	
	B[ida] = A[ida]
}

  gpukernel 1 fails2(global in A int[], global out B int[]) {
	ida = get_global_id(0) 
	
	fail1  = a[[1 2 3] , [ 2 3]]
	fail2  = a[[1 2 3] , null]//no!
	
	B[ida] = A[ida]
}

 gpukernel 1 individualAssign(global in A int[], global out B int[]) {
	ida = get_global_id(0) 
	
	thing = new int[2,3]
	thing = thing //no! Array items must be individually assigned when used within a gpudef or gpukernel
	
	B[ida] = A[ida]
}

~~~~~
//##534. use of global local etc
def nope(){
	global a int = 9
	global b = 9
	global a = 9
}

~~~~~
//##535. local array with initalizer

 gpukernel 1 aKernel(global in A int[], global out B int[]) {
	ida = get_global_id(0) 
	
	//assign new...
	local  xyz3 int[] = [ 1 2 3 ] //no
	local  xyz3a = [ 1 2 3 ] //no
	
	B[ida] = A[ida]
}

~~~~~
//##536. global variables may only be of pointer type

 gpukernel 1 aKernel(global in A int[], global out B int[]) {
	ida = get_global_id(0) 
	
	global xyz1 int[] = new int[3] //no
	global xyz2 = new int[3] //no

	B[ida] = A[ida]
}

~~~~~
//##537. no const reassign

 gpukernel 1 aKernel(global in A int[], global out B int[]) {
	ida = get_global_id(0) 
	
	constant  v1 int = 1 
	constant  v1a int[] = [1 2 3 4] 
	
	constant  v2 = 1 
	constant  v2a = [1 2 3 4] 
	
	v1 = 0
	v1a[0] = 0
	
	v2 = 0
	v2a[0] = 0
	
	v1++
	++v1
	v2++
	++v2
	
	
	B[ida] = A[ida]
}

~~~~~
//##538. size_t and pointer useage

def thing() => 12

def nopes(pnt *int){
	pntA *int
	x = 9
	y = ~x//cannot be used here
	z size_t //cannot be used here
	nopz = ~thing()//cannot do this
	what = *nopz//can only be used within kernels
}


 gpukernel 1 fail(global in A int[], global out B int[]) {
	pntA *int = 12 //cast, ok
	andadd1 long = ~thing //need * to make long a pointer
	andadd2 int = ~thing //need * to make long a pointer
	pnt *size_t = ~thing //need * to make long a pointer
	what = **pntA //pting to dereference a pointer type w too many
	thing =99
	nopz = *thing//its not a pointer
}


 gpukernel 1 onlyPlusPntArith(global in A int[], global out B int[]) {
	ida = get_global_id(0) 
	anArra = [11.f 22.f 33.f 44.f 55.f 66.f]
	what = ~anArra[0]
	
	incla = what * 1//cannot use this operator
	
	B[ida] = *incla as int
}


 gpukernel 1 errpointerarith(global in A int[], global out B int[]) {
	ida = get_global_id(0) 
	
	 anArra = [11.f 22.f 33.f 44.f 55.f 66.f]
	 what = ~anArra[0]

	
	incla = what + what//only one pointer can be operated on
	
	B[ida] = *incla as int
}


 gpukernel 1 invalidopinpointerArith(global in A int[], global out B int[]) {
	ida = get_global_id(0) 
	 
	 anArra = [11.f 22.f 33.f 44.f 55.f 66.f]
	 what = ~anArra[1]
	
	g=-what//no!
	incla = what
	
	B[ida] = *incla as int
}
 gpukernel 1 onlyPlusMinusInfixOps(global in A int[], global out B int[]) {
	ida = get_global_id(0) 
	 
	 
	myAr = new int[3, 4] 
	
	myAr[0, 0] = 12
	myAr[0, 1] = 14
	
	pnt *int = ~myAr[0][0]
	
	pnt *= 1//no!
	
	B[ida] = *pnt
}

def doings() => "ok"

~~~~~
//##539.pointer type muyst match

gpudef ohno(){
	aint = 12
	afloat = 12.f
	
	pnt1 *int = ~aint //ok int == int
	pnt2 *int = ~afloat //invalid, type mismatch, int <> float
		
}

~~~~~
//##540. always check lhs on assignment

gpudef thingx() => 12

 gpukernel 1 pntAssignk(global out B int[]) {
	ida = get_global_id(0)
	thing = 12 
	a *int = ~thing
	*thingx() = 99
	
	B[ida] = thing
}

~~~~~
//##541. no array init on its own

 gpukernel 1 pntAssignk(global out B int[]) {
	ida = get_global_id(0)
	abb = [1 2 3]
	abb = [1 2 3]//cannot reassign with a array like this
	
	B[ida] = 11
}

~~~~~
//##542. Cannot combine differing degrees of pointer type

 gpukernel 1 pntAssignk(global out B int[]) {
	ida = get_global_id(0)
	thng = 9
	abb = a[1, ~thng]
	y = 12 if tf() else ~thng
	
	B[ida] = 11
}

~~~~~
//##543. custom refs ensure correct subtyping

class MyRef<X>(type Class<?>[]) < com.concurnas.runtime.ref.Local<X>(type){
	override delete(){
		System.err.println("del called")
	}
}


class MyCls{
	@com.concurnas.lang.DeleteOnUnusedReturn
	def subto(a int){
		writeComplete = boolean:MyRef()
		
		writeComplete:=true //no cannot set like this Local is not subtype of GPURef
		writeComplete:
	}
	
}

def doings(){
	mc = new MyCls()
	a = mc[... 2]
	"" + a
}

~~~~~
//##544. custom refs ensure correct subtyping

gpudef afunc(global A int[]) int {
	global pnt *int = A//only poitners can be valid for global
	pnt2 *int = A //implicit global
	pnt3 = A//implicit global
	
	local thing = A//not permitted as convert from global to local 
	local thing2 *int = A//not permitted as convert from global to local
	 
	12
}

~~~~~
//##545. memory space control

gpudef afunc(global A int[]) int {
	a = 12
	local pnt = ~a //a is not from local...
	12
}

~~~~~
//##546. memory space control 2

gpudef afunc(global A int[]) int {
	local a = 12
	local pnt = ~a 
	x = A if ss() else pnt//no cannot combine this
	x[0]
}

~~~~~
//##547. more gpu restrictions

gpukernel 1 myFunc(global out ret float[]) void {
	gid = get_global_id(0)
	
	afloat = 12.f
	afloat += 12.f
	
	afloat **= 2
	afloat mod= 2
	afloat mod= 2.f
	
	ret[gid] = afloat
}

~~~~~
//##548. module restructions on class packages etc

//##MODULE com.myorg.code

public class PubClass{
	override hashCode() => 1
	override equals(an Object) => false
}

private class PrivClass{
	private this(a int){}
	override hashCode() => 1
	override equals(an Object) => false
}

package class PackageClass{
	private this(a int){}
	override hashCode() => 1
	override equals(an Object) => false
}

package class PackageClasspackageThis{
	package this(a int){}
	override hashCode() => 1
	override equals(an Object) => false
}

class MyClass{
	override hashCode() => 1
	override equals(an Object) => false
	def resolveHere(t1 Object, t2 Object, t3 Object){
		
		a PrivClass = new PrivClass(1)
		a2 PrivClass = t1 as PrivClass

		b PackageClass = new PackageClass(1)
		b2 PackageClass = t2 as PackageClass
		
		c PackageClasspackageThis = new PackageClasspackageThis(1)
		c2 PackageClasspackageThis = t3 as PackageClasspackageThis 
	}
}

def getPPrivClass(){
	return new PrivClass(1)
}

//##MODULE com.myorg.more.package.code

from com.myorg.code import PackageClass//ok

class MyClass{
	override hashCode() => 1
	override equals(an Object) => false
	
	def myMethod(t1 Object, t2 Object, t3 Object){
		
		a PrivClass = new PrivClass(1)//no
		a2 PrivClass = t1 as PrivClass//no, not accessible
		
		b2 PackageClass = t2 as PackageClass//no
		b2v2 com.myorg.code.PackageClass = t2 as com.myorg.code.PackageClass//no
	}
}


//##MODULE com.myorg.code2
from com.myorg.code import PubClass//ok
from com.myorg.code import PrivClass//ok
from com.myorg.code import PackageClass//ok
from com.myorg.code import PackageClasspackageThis
from com.myorg.code import getPPrivClass

class MyClass{
	override hashCode() => 1
	override equals(an Object) => false
	def myMethod(t1 Object, t2 Object?, t3 Object?){
		
		a PrivClass = new PrivClass(1)//no
		a2 PrivClass = t1 as PrivClass//no, not accessible
		a2.hashCode()
		
		b2 PackageClass = t2 as PackageClass//ok
		b2v2 com.myorg.code.PackageClass = t2 as com.myorg.code.PackageClass//ok
		b PackageClass = new PackageClass(1)//no, constructor not vis
		bv2 com.myorg.code.PackageClass = new com.myorg.code.PackageClass(1)//no, constructor not vis
		
		c PackageClasspackageThis = new PackageClasspackageThis(1)//ok
		c2 PackageClasspackageThis = t3 as PackageClasspackageThis//ok
	}
}

def doings(){
	
	"ok: " +new MyClass().myMethod(getPPrivClass(),null,null)
}

//##MODULE
from com.myorg.code2 import doings as dd

def doings() => dd()

~~~~~
//##549. better checks on array assignment

def doings(){
	li = [1, 2, 3]
	ar = [1 2 3]
		
	li[0] = [9 2]//no
	ar[0] = [9 2]//no
	
	""
}

~~~~~
//##550. this should fail as wrong type

def myMethod(a = 100, bs int[]){//sth like that
	for(bss in bs) { bss + a  }
}

def doings() {
	well = myMethod( [1, 2, 3, 4, 5])
	"" + well
} 

~~~~~
//##551. better error message

from java.util import Iterator

class IntSequence<T>(fromx int, tox int) ~ Iterable<Integer>{
	def step(step int){
		
	}
	
	def iterator() Iterator<T>{
		ret = class with Iterator<Integer>{
			
		}
		null
	} 
}

~~~~~
//##552. to used to blow up

ax int[2] = [ 2 3 4 5; 4 5 6 7 8 ; 7 8 9 10 11]

def doings(){
	w = ax[(0 to ax.length)^, 0]
	"" + w
}

~~~~~
//##553. gpu multi assign restrictions

gpukernel 1 myFunc(global A int[], global B int[], global ret int[]) void {
	gid = get_global_id(0)
	
	c = 1000
	a = b = c += A[gid]//no +=, only eq
	global h = s = ~A //no global here
	
	ret[gid] = a + b + c + B[gid];
}

~~~~~
//##554. tuples no more than 24 

def doings(){
	x = 1,2,3,4,5,6, 7, 8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26
	"" + x
}

~~~~~
//##555. tuples rhs must be tuple in decomp

def doings(){
	(x, y) = 12
	"" 
}

~~~~~
//##556. tuples rhs no

def doings(){
	(a, b) += 1, 2
	(c, d int) += 1, 2
		
	""
}

~~~~~
//##557. no tuples in gpu 

gpukernel 1 myFunc(global A int[], global B int[], global ret int[]) void {
	gid = get_global_id(0)
	
	x = 1,2
	(a, b) = x
	
	ret[gid] = a + b
}

~~~~~
//##558. anon lambda ret type incompatible

class MyClass(items int...){
	def takesLambda(lam (int) long){
		lam(x) for x in items
	}
}

def doings(){
	mc = new MyClass(1, 2, 3)
	
	lam (int) long = a int => a*2
	
	"" + mc.takesLambda(lam)
}

~~~~~
//##559. anon lambda ret type incompatible 2

class MyClass(items int...){
	def takesLambda(lam (long, int) int){
		lam(x, 10) for x in items
	}
}

def doings(){
	mc = new MyClass(1, 2, 3)
	
	lam (long, int) int = (a int, b) => a + b
	
	"" + mc.takesLambda(lam)
}

~~~~~
//##560. anon lambda in gpu

gpukernel 1 myFunc() void {
	asdasd (int) int = a => a+2
}

def doings(){
	"" 
}

~~~~~
//##561. lambdas wrong rhs type

from com.concurnas.lang.precompiled import CompiledSAMFunc

def doings(){
	fella1 CompiledSAMFunc.MySAM = a double => a**2
	fella2 CompiledSAMFunc.MySAM = def (a double) => a**2 //should err
	"" //+ (x.doer(10) for x in [fella1 fella2])
}

~~~~~
//##562. fields missing on copy of precompile type

class MyClass(a int, b int, c String){
	override hashCode()=>1
	override equals(an Object) => false
	
	override toString(){
		"{(a, b, c)}"
	}
}


def doings(){
	mc = [MyClass(12, 14, "hi there"),]
	mc2 = mc@(c='cool',
		a=92
	)
	"" + String.join("\n" , "" + x for x in [mc, mc2])
}

~~~~~
//##563. copy specification on copiers

open class Sup(thing int = 99){}

class MyClass(a int=24, b int=25, c String="default") < Sup(9){
	override hashCode()=>1
	override equals(an Object) => false
	
	override toString(){
		"{(a, b, c, super.thing)}"
	}
}

def doings(){
	mc1 = MyClass(12, 14, "hi there")
	
	x1 = mc1@(b@())//copier specification can only be applied to object types
	x2 = mc1@(a=10, a=10)//may be overriden only once in copier
	x3 = mc1@(ff)//field which does not exist
	x4 = mc1@(a="hi")//cannot assign value of type
	x5 = mc1@(<a, a>)//Duplicate field names
	x6 = mc1@(<ff>)//declared in exclude specification of copier does not exist
	x7 = mc1@(a, <a>)//field cannot be both explicity included and excluded
	x8 = mc1@(<a>, a=9)//cannot also have an override or copier defined
	x9 = mc1@(a=9, <a>)//cannot also have an override or copier defined
	x10 = mc1@(<a>, <b>)//only one exclude specification may be included in a copier
	x11 = mc1@(ff@())//Field: ff with copier does not exist
	x12 = mc1@(super@(), super@())//Only one super copier may be defined
	x13 = mc1@(; sdfsdf, dfgfdg)//unknown keyword in copier
	x14 = mc1@(; unchecked, unchecked)//unchecked may not be repeated
	x14 = mc1@(; nodefault, nodefault)//nodefault may not be repeated
	
	"" 
}

~~~~~
//##564. incorrectly qualified supertype generic having an upper bound
open class MyClass<X Number>{
	override hashCode() => 1
	override equals(an Object) => false
	~held X?
}

class Child<XX> < MyClass<XX>//fail
class Child2<XX String> < MyClass<XX>//fail
class Child3 < MyClass<String>

def doings(){
	x = new Child<Integer>()
	x.held = 12
	res Number? = x.held
	""+res
}

~~~~~
//##565. qualifciation of generic types with upper bound
open class MyClass<X Number>{
	override hashCode() => 1
	override equals(an Object) => false
	~held X?
}

def doings(){
	x = new MyClass<String>()//cannot be qualified like this
	""
}

~~~~~
//##566. qualify local generics check upper bound

def myThing<X Number>(a X){
	a
}

def doings(){
	x1 = myThing<String>("2")//invalid
	x2 = myThing("2")//invalid
	""
}

~~~~~
//##567. wildcard generics

from java.util import ArrayList

class MyList<X Number> extends ArrayList<X>{
	
	override toString() => super.toString()
}


def doings(){
	g = new MyList<int>()
	fail1 MyList<Number> = g
	ar MyList<int> = g
	ar.add(12)
	"" + ar
}

~~~~~
//##568. transient implies new

class Moi{
	myLists = [1,2, 3, 4, 5, 6, 7]
	transient myLists = [1,2, 3, 4, 5, 6, 7]//transient implies new
}

~~~~~
//##569. shared params may not be primatives

def nope(shared va int){}//no cannot share primative type

class MyNope(shared va int){}//no cannot share primative type

def doings(){
	shared va = 1//no cannot share primative type
	""
}

~~~~~
//##570. with expression must be an Object type

def doings(){
	what = with(12){//no must be object type
		44
	}
	
	"" + what
}

~~~~~
//##571. all return statements must return a value
def thing() => 12

def callee(a int){
	if(a == 9){
		return
	}
	thing()
}


def doings(){
	callee(5)
	"ok"
}



~~~~~
//##572. all return statements must return a value
from com.concurnas.runtime import ConcurnasClassLoader


class MyClassLoader extends ConcurnasClassLoader{
	override equals(a Object) => false
	override hashCode() => 1
	
	normalClassLoader = MyClassLoader.class.getClassLoader() as ConcurnasClassLoader
	 
	defineInThisLoader  = new java.util.HashSet<String>()
	defAlready  = new java.util.HashMap<String, Class<?>>()
	
	def loadHere(fromx String){
		defineInThisLoader.add(fromx)
	}
	
	override loadClass( name String) Class<?>  {
		if(name in defAlready){
			return defAlready[name]
		}
		
		if(name in defineInThisLoader){
			defAlready[name] = super.defineClass(name, normalClassLoader.getBytecode(name))
			defAlready[name]
		}
		else{
			normalClassLoader.loadClass(name)
		}
	}
}

def doings(){
	mc = MyClassLoader()
	
	class AClass(a String, b String){
		override equals(a Object) => false
		override hashCode() => 1
		override toString() => "" + [a,b]
		def thing() => 'a thing' + [a,b]
	}
	
	mc.loadHere(AClass.class.name)
	got  = mc.new AClass&('one', _ String)//used to blow up
	"" + got('ok')
}

~~~~~
//##573. used to complain about incorrect line 
items = a[(1, 2), (3, 4), (5, 6)]

def doings(){
	r1= a+b for (a, b String) in items
	"" + r1
}

~~~~~
//##574. tuple typedef use

typedef myTuple = (int, int)

items myTuple[] = a[(1, 2), (3, 4), (5, 6)]
items2 myTuple[] = a[(1, 2.), (3, 4), (5, 6)]

def doings(){
	r1= a+b for (a, b) in items
	"" + r1
}

~~~~~
//##575. tuple size mismatch on match stmt

def matcher(n (int, int)){
	match(n){
	  (a, b, c); a > b => "got {a, b}"//tuple size mismatch
	  x => x
	}
}

~~~~~
//##576. no match on differing tuple type

def mmerr(n (int, int)){
	match(n){
		(int, int, int) => "weird"
		x => "'"
	}
}

~~~~~
//##577. tuple size mismatch on match stmt pt 2
def mmerr(n (int, int)){
	match(n){
		(a, b, c) => "weird"
		x => "'"
	}
}

~~~~~
//##578. no actors on classrefs 

open class ID{
	def operate(a int) int => a
	override hashCode() => 1
	override equals(an Object) => false
}

def dd(){
	tmp = class < ID{}
	return new actor tmp()
}

def doings(){
	"" + dd().operate(10)
}

~~~~~
//##579. no clever calls inside this or super invocation
avar = 88

class MyClass(){
	override hashCode() => 1
	override equals(an Object) => false
	
	this(a int){}
	
	g = 99
	
	this(){
		this({f="ok"; thing(); 9})
	}
	this(f float){
		this({ hh=this; 9})
	}	
	this(a String){//no funcrefs
		this({f="ok"; d=thing&(); d()})
	}
	
	
	def thing() => 2
}

def doings(){
	""
}

~~~~~
//##580. no lazy in super

avar = 88

open class MyClass(lazy operate int){
	override toString() => ""+[avar operate avar]
	override hashCode() => 1
	override equals(an Object) => false
}

class SubMyClass < MyClass( 300 ){
	override toString() => super.toString()
	override hashCode() => 1
	override equals(an Object) => false
}

def doings(){
	xx = SubMyClass()
	"" + xx
}

~~~~~
//##581. ambigious lazy

def thing(lazy a Integer)=> 222
def thing(a Integer)=> a


def doings(){
	""+ thing(2)
}

~~~~~
//##582. asunc executor must be of approperiate type

def doings(){
	rm = Remote()
	ans = {1+2}!(66)//(rm.onfail(e => { System.err.println("retry exe"); retry() }))
	
	"ok"
}

~~~~~
//##583. await can nest ref related items

actor Instance(~a int){}

def doings(){
	a1 = Instance(12)
	await({a1.a = 9}!)//should be ok
	"ok" + a1.a
}

~~~~~
//##584. bug on match with leg missing returns

first = false

enum Choices{ ONE, TWO }

log = def (a String) void => ;;

def dmm(a Choices?){
	ac=0
	while(ac++ < 10){
		ret = match(a){
			Choices.ONE => if(first){first=true;}; //oops missing ret
			null => log('ok'); false
			else => log('ok'); false
		}
		ret
	}
}

def doings(){
	"" + dmm(Choices.ONE)
}

~~~~~
//##585. double declare

public var1 = "resset"
public var1 = "resset"

def doings(){
	"ok" + var1
}

~~~~~
//##586. prohibited primative type casting
an Integer = Double(3) //cannot do this

def doings() {
	"nope"
}

~~~~~
//##587. class marked shared no copy for you
open shared class ParentClass{
	~a =9
}

class Child < ParentClass{
	~b =9
}


def doings(){
	mc = ParentClass()
	c = mc@
	mc.a=7
	
	mcc = Child()
	cc = mcc@
	mcc.b=7
	
	"" + [c.a, cc.b]
}

~~~~~
//##588. shared trait no copy for you

shared trait MyTrait

class ParentClass ~ MyTrait{
	~a =9
}

def doings(){
	mc = ParentClass()
	c = mc@
	
	"ok"
}

~~~~~
//##589. blow up on wrong name
from com.concurnas.lang.dist import startRemoteServer, SessionStateProvider, SessionID, ServerMessageConverter
from com.concurnas.tests.helpers.distHelpers import LogCapture
from java.nio.channels import SocketChannel
from java.net import InetSocketAddress
import java.util.concurrent.TimeUnit

def doings(){
	
	{
		for(x in 0 to 10){//TODO: why loop fails?
			System.err.println("" + com.concurnas.lang.xxconcurrent.getWorkerStatus())//doesnt blow up anymore
			TimeUnit.SECONDS.sleep(2);
		}
		
	}!
	
	
	
	"ok"  
}

~~~~~
//##590. used to blow up
from com.concurnas.runtime import ConcurnasClassLoader
from com.concurnas.lang.offheap.serialization import SerializationEncoder, SerializationDecoder


inject class DistFetchingClassLoader < ConcurnasClassLoader{
	private parent ConcurnasClassLoader
	sid = "sid"
	this(){
		super(new String[]{"bin"}, new String[]{"installed"});//java way
		parent = DistFetchingClassLoader.class.getClassLoader() as ConcurnasClassLoader
		System.err.println("Parent classloader: {parent}")
	}
	
	override getBytecode(name String) byte[]{//check parent first
		fromParent = parent.getBytecode(name)
		if(fromParent == null){
			System.err.println("No local bytecode found for: getBytecode({name}) requesting from code store associated with session: {sid}")
			null
		}else{
			fromParent
		}
	}
	
	override findClass(name String) Class<?> {
		System.err.println("Requesting class: {name}")
		try{
			what = parent.findClass(name)
			if(what <> null){
				return what
			}
		}catch(e ClassNotFoundException){
		}
		System.err.println("No local bytecode found for: findClass({name}) requesting from code store associated with session: {sid}")
		code byte[]? = null
		super.defineClass(name, code)
	}
}


def doings(){
	a int: = 100
	cl = new DistFetchingClassLoader()
	thing = SerializationEncoder.encode(a:)
	got = SerializationDecoder.decode(thing, cl) as int:
	"ok: " + got
}

~~~~~
//##591. no copy actor
actor MyActor(){
	def myID() => System.identityHashCode(this)
}

def doings(){
	inp = MyActor()
	inp2 = inp@ //no cannot do this!
	
	"" + (inp &== inp2)
}

~~~~~
//##592. missing Annot
class AnotherClass(name = "freddie")

trait ATrait

open class SuperClass(a String)



@Annot
class MyClass(a String, b AnotherClass) < SuperClass(a) ~ ATrait{
	
}



def doings(){ 
	"deps are: " + com.concurnas.lang.DependencyAnalyzer.getDependenciesOf(MyClass.class).keySet()
}

~~~~~
//##593. used to blow up now its fine
from java.security import Policy

class SandboxSecurityPolicy < Policy {
    override getPermissions(domain ProtectionDomain ) PermissionCollection{
		return pluginPermissions() if isPlugin(domain) else applicationPermissions();
    }
 
    def isPlugin(domain ProtectionDomain) boolean {
        return true//domain.getClassLoader() instanceof PluginClassLoader;
    }
 
    private def pluginPermissions() PermissionCollection {
        permissions = new Permissions(); // No permissions
        return permissions;
    }
 
    private def applicationPermissions() PermissionCollection {
        permissions = new Permissions();
        permissions.add(new AllPermission());
        return permissions;
    }
}


def doings(){
	"ok"
}

~~~~~
//##594. correct type inferece
open class Bsup
class Achi < Bsup

class MyGenericThing<X Achi, Y Achi>

def doings(){
	mylist MyGenericThing<Bsup, Bsup>\//two different errors
				= MyGenericThing()//this has not been infered
	"nope"
}

~~~~~
//##595. correct type inferece cannot use here
class Thing < java.util.ArrayList<String>

def doings(){
	mylist1 Thing = list()//correctly qualified but cannot set here of course
	"res: " + mylist1
}

~~~~~
//##596. usage qualification even when lhs of new is not helpful

//more than one?
something=true

def doings(){
	a Object = \
		new list()//gets qualified correctly
	a = list<String>()
	a.add("ok")
		
	"res: " + a
} 

~~~~~
//##597. gen type inference can only do one
class MyGenericClass<X, Y>(){
	~x X?
	~y Y?
	override equals(an Object) => false
	override hashCode() => 1
	override toString(){
		"MyGenericClass[x: {x}, y: {y}]"
	}
	
}

def doings(){
	//myset = list()
	mygen = new MyGenericClass()
	
	mygen.x = "hey" 
	mygen.x = 12 
		
	"res: " + mygen
}

~~~~~
//##598. used to blow up
from java.util import HashSet, ArrayList, HashMap, Collection, List, Collections, Comparator

def sorted<X>(what List<X>, comparator Comparator<X>?=null, inplace = false) List<X> {
	ret = what if inplace else what@
	Collections.sort(ret)
	ret
}

def doings(){
	xyz1 = [1, 4, 3, 2, 5, 4, 3, 2]
	res1 = sorted(xyz1, Comparator.reversed())
	"" + res1
}

~~~~~
//##599. used to blow up

from java.util import HashSet, ArrayList, HashMap, Collection, List, Collections, Comparator

def sorted<X>(what List<X>, comparator Comparator<X>?=null, inplace = false) List<X> {
	ret = what if inplace else what@
	Collections.sort(ret)
	ret
}

def doings(){
	xyz1 = [1, 4, 3, 2, 5, 4, 3, 2]
	res1 = sorted(xyz1, {(a, b) -> a > b})
	"" + res1
}

~~~~~
//##600. no import all if thing does not exist
from com.myorg.code2 import *

def doings(){
	""
}

~~~~~
//##601. no same path name
//##MODULE com.myorg.code2
from com.myorg.code2 import *


//##MODULE
def doings(){
	""
}

~~~~~
//##602. validate onchange every options
def doings(){
	mything int:
	done boolean:
	every(mything; onlyclose, onlyclose ){
		if(mything:isClosed()){
			done = true
		}
	}
	every(mything; onlyclose, onlycloseasd ){
		if(mything:isClosed()){
			done = true
		}
	}
	
	await(done)
	
	"done?"
}

~~~~~
//##603. in qualification cannot be used as output param
def doings(){
	strList list<in String> = list<String>()//strList may only have elements added to it 
	//objList list<Object> = strList
	strList.add('')
	w=strList.get(0)//nope!
	
	"" + strList
}

~~~~~
//##604. smart casts respect this.me vs thing.me vs me
class Thing{
	item String = "ok"
	def hi() => "ok"
}

def doings(){
	obj Object = new Thing()
	item = obj
	if(obj is Thing and item is Thing){
		obj.item.hi()//used to bug due to above
	}
	
	"uh oh"
}

~~~~~
//##605. trait needs to map generic types
def doings(){
	a = 'asd&asd'
	cols = a.split("&")
	x = cols[0] > 1//was a bug before as generic type returned from trait was not being mapped, thus matche everything!
	""
}

~~~~~
//##606. trait needs to map generic types - vectorized version
def doings(){
	a = 'asd&asd'
	cols = a.split("&")
	x = cols > 1
	""
}

~~~~~
//##607. errors concerning gpu constants

constant nonsimple2 = 300**2//ok
constant fixedInc = constant fixedInc2  = 100//no, not in multi assign

gpudef plus(a int, b int) => a + b

gpukernel 1 incrementor(global in A int[], global out B int[]) {
	ida = get_global_id(0) 
	
	B[ida] = plus(A[ida], fixedInc + fixedInc)
}

~~~~~
//##608. errors concerning gpu constants - 2
constant nonsimple2 = 300**2//ok

def thing() => nonsimple2//this is fine

gpudef asdas() => 55
constant nonsimple = asdas()//no! must be simple


def thingx(){
	constant hh = 9//no, cannot be defined here
}

gpukernel 1 incrementor(global in A int[], global out B int[]) {
	ida = get_global_id(0) 
	constant hh = 9//no, cannot be defined here
}

~~~~~
//##609. constant like val no reassign
constant sdf = 9

def ffdsdf(){
	constant tstdsf =98
}

gpudef sdfsdf(){
	sdf = 99//no reassign
}

def doings(){
	sdf = 99//no reassign to constant
	"ok"
}

~~~~~
//##610. import star scopes
def doings(){
	from java.util import *
	"ok" + new ArrayList<String>()//ok
}

x = new ArrayList<String>()//complain still

~~~~~
//##611. top level del on func
def thing() => 12
del thing

def doings(){
	"ok"
}