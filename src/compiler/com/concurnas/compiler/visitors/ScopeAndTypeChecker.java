package com.concurnas.compiler.visitors;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;
import java.util.concurrent.atomic.AtomicLong;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import java.util.stream.Collectors;

import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;

import com.concurnas.bootstrap.lang.Lambda;
import com.concurnas.bootstrap.lang.Lambda.ClassRef;
import com.concurnas.bootstrap.lang.Lambda.Function0;
import com.concurnas.bootstrap.lang.Lambda.Function0v;
import com.concurnas.bootstrap.lang.offheap.Decoder;
import com.concurnas.bootstrap.lang.offheap.Encoder;
import com.concurnas.bootstrap.runtime.InitUncreatable;
import com.concurnas.bootstrap.runtime.ReifiedType;
import com.concurnas.bootstrap.runtime.ref.LocalArray;
import com.concurnas.bootstrap.runtime.transactions.Transaction;
import com.concurnas.compiler.CaseExpression;
import com.concurnas.compiler.CaseExpressionAnd;
import com.concurnas.compiler.CaseExpressionAssign;
import com.concurnas.compiler.CaseExpressionAssignTuple;
import com.concurnas.compiler.CaseExpressionObjectTypeAssign;
import com.concurnas.compiler.CaseExpressionOr;
import com.concurnas.compiler.CaseExpressionPost;
import com.concurnas.compiler.CaseExpressionPre;
import com.concurnas.compiler.CaseExpressionTuple;
import com.concurnas.compiler.CaseExpressionWrapper;
import com.concurnas.compiler.ErrorHolder;
import com.concurnas.compiler.JustAlsoCaseExpression;
import com.concurnas.compiler.MainLoop;
import com.concurnas.compiler.ModuleCompiler;
import com.concurnas.compiler.SchedulerRunner;
import com.concurnas.compiler.TypedCaseExpression;
import com.concurnas.compiler.ast.*;
import com.concurnas.compiler.ast.Annotation.AnnotationLocation;
import com.concurnas.compiler.ast.ArrayRefElement.LISTorMAPType;
import com.concurnas.compiler.ast.ArrayRefLevelElementsHolder.ARElementType;
import com.concurnas.compiler.ast.AutoVectorizableElements.VectorizationConfig;
import com.concurnas.compiler.ast.DeleteStatement.DSOpOn;
import com.concurnas.compiler.ast.Type.Vectorization;
import com.concurnas.compiler.ast.interfaces.Expression;
import com.concurnas.compiler.ast.interfaces.FuncDefI;
import com.concurnas.compiler.ast.util.JustLoad;
import com.concurnas.compiler.bytecode.FuncLocation;
import com.concurnas.compiler.bytecode.FunctionGenneratorUtils;
import com.concurnas.compiler.bytecode.FuncLocation.ClassFunctionLocation;
import com.concurnas.compiler.bytecode.FuncLocation.StaticFuncLocation;
import com.concurnas.compiler.constants.UncallableMethods;
import com.concurnas.compiler.typeAndLocation.Location;
import com.concurnas.compiler.typeAndLocation.LocationClassField;
import com.concurnas.compiler.typeAndLocation.LocationLocalVar;
import com.concurnas.compiler.typeAndLocation.LocationStaticField;
import com.concurnas.compiler.typeAndLocation.TypeAndLocation;
import com.concurnas.compiler.utils.Fiveple;
import com.concurnas.compiler.utils.Fourple;
import com.concurnas.compiler.utils.GenericTypeUtils;
import com.concurnas.compiler.utils.ITEM_TYPE;
import com.concurnas.compiler.utils.Sevenple;
import com.concurnas.compiler.utils.Sixple;
import com.concurnas.compiler.utils.Thruple;
import com.concurnas.compiler.utils.TypeDefTypeProvider;
import com.concurnas.compiler.visitors.NestedFuncRepoint.ClassDefStateObject;
import com.concurnas.compiler.visitors.Utils.CurriedVararg;
import com.concurnas.compiler.visitors.algos.ExpressionListExpander;
import com.concurnas.compiler.visitors.algos.ProviderCreator;
import com.concurnas.compiler.visitors.datastructs.TheScopeFrame;
import com.concurnas.compiler.visitors.datastructs.TheScopeFrame.ExisitsAlready;
import com.concurnas.compiler.visitors.lca.LowestCommonAncestor;
import com.concurnas.compiler.visitors.util.CastCheck;
import com.concurnas.compiler.visitors.util.ConstArg;
import com.concurnas.compiler.visitors.util.ErrorRaiseableSupressErrors;
import com.concurnas.compiler.visitors.util.ErrorRaiseableSupressErrorsAndLogProblem;
import com.concurnas.compiler.visitors.util.LanguageExtensionRunner;
import com.concurnas.compiler.visitors.util.MactchCase;
import com.concurnas.compiler.visitors.util.MiscUtils;
import com.concurnas.compiler.visitors.util.TraitFieldEncoderDecoder;
import com.concurnas.compiler.visitors.util.VarAtScopeLevel;
import com.concurnas.lang.GPUBuffer;
import com.concurnas.lang.GPUBufferInput;
import com.concurnas.lang.GPUBufferLocal;
import com.concurnas.lang.GPUBufferOutput;
import com.concurnas.lang.LangExt.Context;
import com.concurnas.lang.LangExt.SourceLocation;
import com.concurnas.lang.Named;
import com.concurnas.lang.ObjectProvider;
import com.concurnas.lang.Shared;
import com.concurnas.lang.Trait;
import com.concurnas.lang.Transient;
import com.concurnas.repl.REPLState;
import com.concurnas.repl.REPLState.REPLTopLevelImports;
import com.concurnas.runtime.Pair;
import com.concurnas.runtime.ref.Local;

public class ScopeAndTypeChecker implements Visitor, ErrorRaiseable {

	private final String fullPathFileName;
	
	public TheScopeFrame moduleLevelFrame = TheScopeFrame.buildTheScopeFrame_Module();
	public TheScopeFrame currentScopeFrame =  moduleLevelFrame;
	
	public Stack<FuncDefI> currentlyInFuncDef = new Stack<FuncDefI>();
	private Stack<Pair<String, NamedType>> currentlyInWithStatement = new Stack<Pair<String, NamedType>>();
	private Stack<FuncType> currentlyInFuncTypeDecl = new Stack<FuncType>();
	private Stack<Type> returnTypeExpected = new Stack<Type>();
	private Stack<Type> onchangeRetType = new Stack<Type>();
	private Stack<String> currentlyInRet = new Stack<String>();
	public Stack<ClassDef> currentlyInClassDef = new Stack<ClassDef>();
	private Stack<HashMap<Pair<String, Boolean>, NullStatus>> nullableOverwriteType = new Stack<HashMap<Pair<String, Boolean>, NullStatus>>();
		
	LinkedHashSet<ErrorHolder> errors = new LinkedHashSet<ErrorHolder>();
	LinkedHashSet<ErrorHolder> warnings = new LinkedHashSet<ErrorHolder>();
	private final ErrorRaiseable ers = new ErrorRaiseableSupressErrors(this);
	private final Stack<String> packageName = new Stack<String>();
	private final Stack<String> nestorParens = new Stack<String>();
	private final String truePackageName;
	public MainLoop mainLoop;
	
	public final  ModuleCompiler mc;
	public final String justPackageName;
	
	private final ClassDef moduleLevelNamedType;
	
	private final HashMap<String, ClassDef> typeDirectory;

	private int tempVarCnt = 0;

	public boolean hasSharedModuleLevelVars;
	
	protected int lastLineVisited = -1;

	private boolean prevRunHadErrors = true;

	private final REPLState isREPL;
	
	public void resetLastLineVisited(){
		lastLineVisited = -1;
	}
	public int getLastLineVisited(){
		return lastLineVisited;
	}
	public void setLastLineVisited(int lineNo){
		if(lineNo <= 0){
			return;//HACK: messy, what if it actually is zero? - rare so doesnt matter
		}
		//System.err.println("last line: " + lineNo);
		
		this.lastLineVisited = lineNo;
	}
	
	public ScopeAndTypeChecker(MainLoop mainLoop, ModuleCompiler mc, String fullPathFileName, String packageAndClassName, TheScopeFrame theCurrentScopeFrame, HashMap<String, ClassDef> typeDirectory, boolean prevRunHadErrors, REPLState isREPL)
	{
		this(mainLoop, mc, fullPathFileName, packageAndClassName, typeDirectory, prevRunHadErrors, isREPL);
		this.currentScopeFrame = theCurrentScopeFrame;
		//but clear out the variables - preserver functions and classes only for fwd references
		if(null == isREPL) {
			this.currentScopeFrame.resetVars();
		}
		
		this.currentScopeFrame.moduleName = packageAndClassName;
		this.tempVarCnt  = 0;
		moduleLevelFrame = currentScopeFrame;
	}
	
	public ScopeAndTypeChecker(MainLoop mainLoop, ModuleCompiler mc, String fullPathFileName, String packageAndClassName, HashMap<String, ClassDef> typeDirectory, boolean prevRunHadErrors, REPLState isREPL)
	{
		this.isREPL  = isREPL;
		this.mc = mc;
		this.fullPathFileName = fullPathFileName;
		this.prevRunHadErrors  = prevRunHadErrors;
		assert fullPathFileName != null;
		assert packageAndClassName != null;
		this.justPackageName = packageAndClassName;
		for(String item : packageAndClassName.split("\\."))
		{
			packageName.push(item);
		}
		
		this.truePackageName = packageAndClassName.replace('.','/');
		
		//currentScopeFrame = new ModuleScopeFrame(mainLoop);
		this.mainLoop = mainLoop;
		
		StringBuilder pacageNameDforDef = new StringBuilder();
		String[] bnits = packageAndClassName.split("\\.");
		for(int n=0; n < bnits.length; n++){
			if(n < bnits.length-1){
				pacageNameDforDef.append(bnits[n]);
			}
			
			if(n < bnits.length-2){
				pacageNameDforDef.append(".");
			}
		}
		String classNameforDef = bnits[bnits.length-1];

		this.typeDirectory = typeDirectory;
		addDefaultsToTypeDirectory();
		
		this.moduleLevelNamedType = new ClassDef(0,0, classNameforDef, pacageNameDforDef.toString());
		
	}
	
	private void addDefaultsToTypeDirectory(){
		this.typeDirectory.put("com.concurnas.bootstrap.runtime.ref.LocalArray", new ClassDefJava(LocalArray.class));
	}

	public LinkedHashSet<ErrorHolder> getErrors() {
		return this.errors;
	}
	
	public LinkedHashSet<ErrorHolder> getWarnss() {
		return this.warnings;
	}
	
	Stack<HashMap<Integer, ErrorHolder>> errorForLine = new Stack<HashMap<Integer, ErrorHolder>>();
	Stack<HashMap<Integer, ErrorHolder>> warnForLine = new Stack<HashMap<Integer, ErrorHolder>>();

	private void enterLine()
	{
		errorForLine.add(new HashMap<Integer, ErrorHolder>());
		warnForLine.add(new HashMap<Integer, ErrorHolder>());
	}
	
	private void leaveL(Stack<HashMap<Integer, ErrorHolder>> thingsOnLineTracker, LinkedHashSet<ErrorHolder> something){
		if(!thingsOnLineTracker.isEmpty())
		{
			HashMap<Integer, ErrorHolder> errs = thingsOnLineTracker.pop();
			if(null != errs)
			{
				for(ErrorHolder err: errs.values())
				{
					something.add(err);//TODO: change this such that the first eror for a line is reported, not the last, or permit multiple?
				}
			}
		}
	}
	
	private void leaveLine()
	{
		leaveL(errorForLine, errors);
		leaveL(warnForLine, warnings);
	}
	
	public static class CapMaskedErrs{ 
		public final int line;
		public final int column;
		public final String somthing;
		public final Stack<HashMap<Integer, ErrorHolder>> thingsOnLineTracker;
		public final WarningVariant wv;
		public final FuncDef context;
		
		public CapMaskedErrs(boolean ignorecurrentContext, int line, int column, String somthing, Stack<HashMap<Integer, ErrorHolder>> thingsOnLineTracker, WarningVariant wv, FuncDef context){
			this.line= line;
			this.column= column;
			this.somthing= somthing;
			this.thingsOnLineTracker= thingsOnLineTracker;
			this.wv= wv;
			this.context= ignorecurrentContext?null:context;
		}
		
		public boolean passedIsSmaller(CapMaskedErrs passed){
			return passed.line < this.line || passed.column < this.column;
		}
		
		public String toString() {
			return String.format("%s: %s", line, somthing);
		}
		
	}
	
	
	private Stack<Boolean> maskErrors = new Stack<Boolean>();
	private Stack<ArrayList<CapMaskedErrs>> captureMaskedErrors = new Stack<ArrayList<CapMaskedErrs>>();

	private void maskErrors(){
		maskErrors(false);
	}
	
	public void maskErrors(boolean capture){
		maskErrors.push(false);
		//System.err.println(">errs push: " + maskErrors.size());
		captureMaskedErrors.push(capture?new ArrayList<CapMaskedErrs>():null);
	}
	
	public boolean maskedErrors(){
		//System.err.println("<errs pop:  " + (maskErrors.size() -1));
		captureMaskedErrors.pop();
		return maskErrors.pop(); 
	}
	
	public ArrayList<CapMaskedErrs> getmaskedErrors(){
		//System.err.println("<errs pop:  " + (maskErrors.size() -1));
		maskErrors.pop();
		return captureMaskedErrors.pop();
	}
	
	
	private boolean applyMaskedErrors(){
		//System.err.println("<errs pop:  " + (maskErrors.size() -1));
		maskErrors.pop();
		ArrayList<CapMaskedErrs> stuff = captureMaskedErrors.pop();
		if(!stuff.isEmpty()){
			applyMaskedErrors(stuff);
			return true;
		}
		return false;
		
	}
	
	public void applyMaskedErrors(ArrayList<CapMaskedErrs> what){
		applyMaskedErrors(what, "");
	}
	
	private void applyMaskedErrors(ArrayList<CapMaskedErrs> what, String linePrefix){
		applyMaskedErrors(what, linePrefix, "");
	}
	
	private void applyMaskedErrors(ArrayList<CapMaskedErrs> what, String linePrefix, String linePostfix){
		for(CapMaskedErrs w : what){
			raiseSomething(false, w.line, w.column, linePrefix+w.somthing+linePostfix, w.thingsOnLineTracker, w.wv);
		}
	}
	
	protected Stack<FuncDef> errorLocation = new Stack<FuncDef>();
	public void pushErrorContext(FuncDef xxx) {
		errorLocation.push(xxx);
	}
	public FuncDef popErrorContext(){
		return errorLocation.pop();
	}
	
	private void raiseSomething(boolean ignorecurrentContext, int line, int column, String somthing, Stack<HashMap<Integer, ErrorHolder>> thingsOnLineTracker, WarningVariant wv){
		
		String err = "incompatible type: int vs java.lang.String";
		if(somthing.contains(err) && !maskErrors.isEmpty()/* && line == 1660*/ ){
			int h=999;
		}
		
		if(maskErrors.isEmpty()){
			if(thingsOnLineTracker.isEmpty()){
				enterLine();
			}

			//System.err.println(somthing);
			HashMap<Integer, ErrorHolder> currentLineToErr = thingsOnLineTracker.peek();
			if(null != currentLineToErr)
			{
				if(!currentLineToErr.containsKey(line))
				{//add if one has not already been assigned
					currentLineToErr.put(line, new ErrorHolder(this.fullPathFileName, line, column, somthing, wv, ignorecurrentContext?null:errorLocation.isEmpty()?null:errorLocation.peek()) );
				}
			}
		}
		else{
			//System.err.println(error);
			if(!maskErrors.peek()){
				maskErrors.pop();
				maskErrors.push(true);//errors have occured!
			}
			
			if(captureMaskedErrors.peek() != null){
				captureMaskedErrors.peek().add(new CapMaskedErrs(ignorecurrentContext, line, column, somthing, thingsOnLineTracker, wv, (null == wv || errorLocation.isEmpty())?null:errorLocation.peek()));
			}
		}
	}
	
	
	
	public void raiseWarning(int line, int column, String warning, WarningVariant wv){
		HashSet<WarningVariant> supressed = this.currentScopeFrame.getSupressedWarnings();
		if(wv == null || (!supressed.contains(WarningVariant.ALL) && !supressed.contains(wv))){
			raiseSomething(false, line, column, warning, warnForLine, wv);
		}
	}
	
	public void raiseError(int line, int column, String template, Object... bits){
		raiseSomething(false, line, column, String.format(template, bits), errorForLine, null);
	}
	public void raiseError(boolean ignorecurrentContext, int line, int column, String template, Object... bits){
		raiseSomething(ignorecurrentContext, line, column, String.format(template, bits), errorForLine, null);
	}
	
	public void raiseError(int line, int column, String error){
		raiseSomething(false, line, column, error, errorForLine, null);
	}
	
	public void raiseError(boolean ignorecurrentContext, int line, int column, String error){
		raiseSomething(ignorecurrentContext, line, column, error, errorForLine, null);
	}
	
	
	private Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> vectorizedOperator(Type thing){
		return vectorizedOperator(thing, null);
	}
	private Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> vectorizedOperator(Type thing, Expression expr){
		ArrayList<Pair<Boolean, NullStatus>> vectStrict=null;
		
		if(thing != null && thing.isVectorized()) {
			vectStrict = TypeCheckUtils.getVectorizedStructure(ers, thing);
			thing = TypeCheckUtils.extractVectType(thing);
			thing = (Type)thing.copy();
			thing.setVectorized(null);
		}else if(expr != null){
			if(expr instanceof VectorizedArrayRef) {
				return vectorizedOperator(thing, ((VectorizedArrayRef)expr).astOverridearrayRef);
			}
			
			if(expr instanceof ArrayRef) {
				ArrayRef ar = (ArrayRef)expr;
				 ArrayList<ArrayRefElement> elements = ar.getFlatALE();
				 
				 ArrayList<Pair<Boolean, NullStatus>> arRefVectStruct = null;

				 boolean itemVectorized=false;
				 if(ar.vectArgumentDepth != null) {
					 arRefVectStruct = new ArrayList<Pair<Boolean, NullStatus>>(ar.vectArgumentDepth);
					 itemVectorized=true;
				 }
				 
				 for(ArrayRefElement are : elements) {
					 
					 Type e1Type = are.e1.getTaggedType();
					 if(null != e1Type && e1Type.isVectorized()) {
						 itemVectorized = true;
						 if(e1Type.getVectorized() == Vectorization.SELF) {
							 this.raiseError(are.getLine(), are.getColumn(), "Only single ^ may be used for vectorized array refernce operations");
						 }

						 ArrayList<Pair<Boolean, NullStatus>> e1vectStruct = TypeCheckUtils.getVectorizedStructure(ers, e1Type);
						 if(null == arRefVectStruct) {
							 arRefVectStruct = e1vectStruct;
						 }
						 
					 }
					 
					 if(are instanceof ArrayRefElementSubList) {
						 Type e2Type = ((ArrayRefElementSubList)are).e2.getTaggedType();
						 
						 if(null != e2Type && e2Type.isVectorized()) {
							 itemVectorized = true;
							 
							 if(e2Type.getVectorized() == Vectorization.SELF) {
								 this.raiseError(are.getLine(), are.getColumn(), "Only single ^ may be used for vectorized array reference operations");
							 }
						 }
						 
						 ArrayList<Pair<Boolean, NullStatus>> e2vectStruct = TypeCheckUtils.getVectorizedStructure(ers, e2Type);
						 if(null == arRefVectStruct) {
							 arRefVectStruct = e2vectStruct;
						 }
					 }
				 }
				 
				 if(itemVectorized) {
					vectStrict = arRefVectStruct;//TypeCheckUtils.getVectorizedStructure(errorRaisableSupression, thing);
					thing = TypeCheckUtils.extractVectType(thing);
					thing = (Type)thing.copy();
					thing.setVectorized(null);
				 }
			}
			
			
			if(expr instanceof ExpressionList) {
				ExpressionList exprList = (ExpressionList)expr;
				if(exprList.astRedirect instanceof Expression) {
					expr = (Expression)exprList.astRedirect;
				}
			}
			
			if(expr instanceof DotOperator) {
				expr = ((DotOperator)expr).getElements(this).get(0);
			}
			
			if( expr instanceof VectorizedFieldRef) {
				VectorizedFieldRef asFieldRef = (VectorizedFieldRef)expr;
				Type fromFieldRef = (Type)asFieldRef.getTaggedType().copy();
				fromFieldRef.setVectorized(asFieldRef.doubledot?Vectorization.SELF:Vectorization.NORMAL);
				return vectorizedOperator(fromFieldRef, null);
			}
		}
		
		return new Pair<>(vectStrict, thing);
	}
	
	private ArrayList<Type> vectorizeElementsIfApproperiate(AutoVectorizableElements item) {
		return vectorizeElementsIfApproperiate(item, false);
	}
	private ArrayList<Type> vectorizeElementsIfApproperiate(AutoVectorizableElements item, boolean isAssignment) {
		//TODO: to hotwire this to avoid recalc, because we always need to use the func in order to extract the expression types
		Boolean shouldVectorize = null;
		
		ArrayList<Type> resolvedTypes = new ArrayList<Type>();
		HashSet<Integer> itemToVectorize = new HashSet<Integer>();
		
		List<VectorizationConfig> origItems = item.getAllElements();
		int n=0;
		for(VectorizationConfig itemz : origItems) {
			Expression exp = itemz.expr;
			
			this.maskErrors(true);
			Type got = (Type)exp.accept(this);
			
			if(null != got) {
				got = (Type)got.copy();
				if(exp instanceof VarNull) {
					shouldVectorize=false;
				}
			}
			
			if(n++ == 0 && isAssignment && exp instanceof VectorizedFieldRef) {
				got.setVectorized(((VectorizedFieldRef)exp).doubledot?Vectorization.SELF:Vectorization.NORMAL);
			}
			
			resolvedTypes.add(got != null?got:null);
			ArrayList<CapMaskedErrs> errs = this.getmaskedErrors();
			
			if(null == got || !errs.isEmpty()) {
				this.applyMaskedErrors(errs);
				shouldVectorize=false;
			}
		}
		
		if(shouldVectorize == null) {
			n=0;
			boolean skipNext = false;
			for(VectorizationConfig itemz : origItems) {
				if(!skipNext) {
					boolean isLast = n == origItems.size()-1;
					
					Type got = resolvedTypes.get(n);
					
					if(/*!got.isVectorized() &&*/ (shouldVectorize == null || shouldVectorize)) {//skip stuff already vectorized, and skip if cannot vectorize expr
						Boolean canBeObject = itemz.canBeObject;
						
						Boolean canBeString = itemz.canBeString;
						 
						Thruple<Boolean, Boolean, Boolean> shouldVectAndIsOpOverload = isVectorizableType( ((Node)item).getLine(), ((Node)item).getColumn(), this.getErrorRaiseableSupression(), got, isLast?null:resolvedTypes.get(n+1), isLast?null:origItems.get(n+1).expr,  itemz.opOverloadString, canBeString==null?false:canBeString, canBeObject==null?false:canBeObject, itemz.isUnary, itemz.oneMustBeScalar);
						
						Boolean shouldVect = shouldVectAndIsOpOverload.getA();
						if(null != shouldVect) {
							if(shouldVect) {
								if(shouldVectorize == null) {
									shouldVectorize = true;
								}
								if(!shouldVectAndIsOpOverload.getB()) {
									if(!got.isVectorized()) {
										itemToVectorize.add(n);
									}
									
								}
							}else {
								shouldVectorize=false;
							}
						}
						
						if(shouldVectAndIsOpOverload.getC()) {	//if consumes next...
							skipNext=true;
						}
					}
				}else {
					skipNext=false;
				}
				
				n++;
			}
			
			if(shouldVectorize != null && shouldVectorize) {
				ArrayList<Expression> newOnes = new ArrayList<Expression>();
				for(n = 0; n < resolvedTypes.size(); n++) {
					Expression element = origItems.get(n).expr;
					if(itemToVectorize.contains(n)) {
						element = new Vectorized(element);
						Type typeForEle = resolvedTypes.get(n);
						
						typeForEle = TypeCheckUtils.getRefTypeToLocked(typeForEle);
						typeForEle.setVectorized(Vectorization.NORMAL);
						resolvedTypes.set(n,typeForEle);
					}
					
					newOnes.add(element);
				}
				
				item.setAllElements(newOnes);
			}
		}
		
		return resolvedTypes;
	}
	
	private void flagNullableForOperation(int line, int col, Type elmType) {
		flagNullableForOperation(line, col, elmType, "Operand for operation might be null");
	}
	
	private void flagNullableForOperation(int line, int col, Type elmType, String msg) {
		if(elmType instanceof VarNull) {//ignore explicit null
			return;
		}
		
		if(TypeCheckUtils.isNullable(elmType)) {
			this.raiseError(line, col, msg);
		}
	}
	
	
	@Override
	public Object visit(Additive addMinusExpression) {
		ArrayList<Type> elementTypes = vectorizeElementsIfApproperiate(addMinusExpression);
		
		Type lhsorig = elementTypes.get(0);//(Type)addMinusExpression.head.accept(this);
		
		if(!TypeCheckUtils.isValidType(lhsorig, true) && lhsorig != null){
			this.raiseError(addMinusExpression.head.getLine(), addMinusExpression.head.getColumn(), String.format("Invalid type %s", lhsorig) );
		}
		
		Type lhs = TypeCheckUtils.extractRawRefType(lhsorig);
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(lhs);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = lhsvec.getA();
		
		if(vectorized != null) {
			lhs = lhsvec.getB();
		}
		
		addMinusExpression.headType= lhs;
		
		flagNullableForOperation(addMinusExpression.head.getLine(), addMinusExpression.head.getColumn(), lhs);
		
		boolean isFirst = true;
		int n=1;
		boolean lastWasOpOverload = false;
		for(AddMinusExpressionElement i : addMinusExpression.elements)
		{
			lastWasOpOverload=false;
			Type rhs = elementTypes.get(n++);//(Type)i.exp.accept(this);
			if(!TypeCheckUtils.isValidType(rhs, true) && rhs != null){
				this.raiseError(i.getLine(), i.getColumn(), String.format("Invalid type %s", rhs) );
			}
			
			if(rhs instanceof ModuleType){
				this.raiseError(i.getLine(), i.getColumn(), ""+rhs );
			}
			
			TypeCheckUtils.assertRefIsGettable(this, i.getLine(), i.getColumn(), rhs, -1);
			
			rhs = TypeCheckUtils.extractRawRefType(rhs);
			
			Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> rhsvec = vectorizedOperator(rhs);
			ArrayList<Pair<Boolean, NullStatus>> instVect = rhsvec.getA();
			if(instVect  != null) {
				rhs = rhsvec.getB();
				vectorized = instVect;
			}
			
			if(!i.isPlus)
			{//-
				FuncInvoke overloaded = canBeOperatorOverloaded(lhs, rhs, "minus", i.exp, i.getLine(), i.getColumn(), i.astOverrideOperatorOverload);
				if(null != overloaded){
					i.astOverrideOperatorOverload = overloaded;
					this.dotOperatorLHS.push(lhs);
					lhs = (Type)i.accept(this);
					this.dotOperatorLHS.pop();
					lastWasOpOverload=overloaded.vectroizedDegreeAndArgs != null;
				}
				else{
					lhs = TypeCheckUtils.checkNumericalInfix(this, lhs, rhs, addMinusExpression.head.getLine(), addMinusExpression.head.getColumn(), i.getLine(), i.getColumn(), makeMissingOpOverLoadMessage("minus", lhs, rhs, null));
					flagNullableForOperation(i.getLine(), i.getColumn(), rhs);
				}
			}
			else
			{
				if(TypeCheckUtils.isString(lhs))
				{
					if(!TypeCheckUtils.isString(rhs)){
						i.shouldStringyFyAtBCTime = true;
					}
				}
				else if(TypeCheckUtils.isString(rhs))
				{
					if(TypeCheckUtils.getRefLevelsIfLockedAsRef(lhsorig) > 0){
						addMinusExpression.headType= lhsorig;//such that 12: + "" => 12:
					}
					
					if(isFirst && !TypeCheckUtils.isString(lhs)){
						//cater for a :=9; b = a + "" //b is a str
						addMinusExpression.headshouldStringyFyAtBCTime=true;
					}
					lhs = rhs;
					if(!TypeCheckUtils.isString(rhs)){
						i.shouldStringyFyAtBCTime = true;
					}
				}
				else
				{
					FuncInvoke overloaded = canBeOperatorOverloaded(lhs, rhs, "plus", i.exp, i.getLine(), i.getColumn(), i.astOverrideOperatorOverload);
					if(null != overloaded){
						i.astOverrideOperatorOverload = overloaded;
						this.dotOperatorLHS.push(lhs);
						lhs = (Type)i.accept(this);
						this.dotOperatorLHS.pop();
						lastWasOpOverload=overloaded.vectroizedDegreeAndArgs != null;
					}
					else{
						lhs = TypeCheckUtils.checkNumericalInfix(this, lhs, rhs, addMinusExpression.head.getLine(), addMinusExpression.head.getColumn(), i.getLine(), i.getColumn(), makeMissingOpOverLoadMessage("plus", lhs, rhs, null));
						flagNullableForOperation(i.getLine(), i.getColumn(), rhs);
					}
				}
			}
			i.setTaggedType(lhs);
			isFirst=false;
		}
		
		if(vectorized != null) {
			addMinusExpression.depth = vectorized;
			if(null != lhs && !lastWasOpOverload) {
				lhs = TypeCheckUtils.applyVectStruct(vectorized, lhs);
				//lhs.setVectorized(Vectorization.NORMAL);
			}
		}else {
			lhs = validateAndReturnPointerType(addMinusExpression.getLine(), addMinusExpression.getColumn(), elementTypes, lhs, true);
		}
		//elementTypes
		return addMinusExpression.setTaggedType(TypeCheckUtils.unboxTypeIfBoxed(lhs));
	}
	
	
	private Type validateAndReturnPointerType(int line, int col, ArrayList<Type> types, Type normalType, boolean isvalid) {
		
		if(types.stream().anyMatch(a -> a == null)) {
			return normalType;
		}
		
		List<Type> withPointer = types.stream().filter(a -> a.getPointer() > 0).collect(Collectors.toList());
		
		if(withPointer.size() > 0) {
			if(!isvalid) {
				this.raiseError(line, col, "Invalid operator in expression involving pointer" );
			}else if(withPointer.size() != 1) {
				this.raiseError(line, col, "Only one pointer may be included in an expression involving pointer arithmetic" );
			}
			
			return withPointer.get(0);
		}
		
		return normalType;
	}

	private FuncInvoke canBeOperatorOverloaded(Type lhs, Type rhs, String operation, Expression rhsExprssion, int line, int col, Node prevAttempt){
		ArrayList<Type> rhss = new ArrayList<Type>();
		rhss.add(rhs);
		
		ArrayList<Expression> rhsExprssions = new ArrayList<Expression>();
		rhsExprssions.add(rhsExprssion);
		
		return canBeOperatorOverloaded(lhs, rhss, null, operation, rhsExprssions, line, col, false, null, false, prevAttempt);
	}
	
	private FuncInvoke canBeOperatorOverloaded(Type lhs, Type rhs, String operation, Expression rhsExprssion, int line, int col, boolean checkReturnIsSupertype, Type returnTypeEQ, Node prevAttempt){
		ArrayList<Type> rhss = new ArrayList<Type>();
		rhss.add(rhs);
		
		ArrayList<Expression> rhsExprssions = new ArrayList<Expression>();
		rhsExprssions.add(rhsExprssion);
		
		return canBeOperatorOverloaded(lhs, rhss, null, operation, rhsExprssions, line, col, checkReturnIsSupertype, returnTypeEQ, false, prevAttempt);
	}
	
	private FuncInvoke extractFuncInvoke(Node expr) {
		if(expr instanceof FuncInvoke) {
			return (FuncInvoke)expr;
		}else if(expr instanceof DotOperator) {
			ArrayList<Expression> elms = ((DotOperator)expr).getElements(this);
			return extractFuncInvoke((Node)elms.get(elms.size()-1));
		}
		
		return null;
	}
	
	private FuncInvoke canBeOperatorOverloaded(Type lhs, List<Type> rhss, HasNameMap argsz, String operation, ArrayList<Expression> rhsExprssions, int line, int col, boolean checkReturnIsSupertype, Type returnTypeEQ, boolean noVoidret, Node prevAttempt){
		//checkReturnIs eq or Supertype of lhs- e.g. for operator overloading we wish for incrementors to always return copies, this helps ensure this (though ppl cna still do weird things)
		if(lhs != null && rhsExprssions != null && lhs instanceof NamedType){
			NamedType lhsNamed = (NamedType)lhs;
			
			List<Type> args = new ArrayList<Type>();
			for(Type rhs : rhss){
				if(rhs == null){
					return null;
				}
				args.add(rhs);
			}
			
			FuncInvoke prevAttemptFI = extractFuncInvoke(prevAttempt);
			if(null != prevAttemptFI) {
				List<Expression> argsvmp = prevAttemptFI.args.getArgumentsWNPs();
				if(null != argsvmp && argsvmp.stream().noneMatch(a -> a == null)) {
					ArrayList<Expression> prevrhsExprssions = prevAttemptFI.args.asnames;
					List<Type> prevTypes = prevAttemptFI.args.getArgumentsWNPs().stream().map(a -> a.getTaggedType()).collect(Collectors.toList());
					if(args != null && prevTypes != null && args.size() == prevTypes.size()) {
						int sz = args.size();
						boolean match = true;
						for(int n =0; n < sz; n++) {
							Type prevt = prevTypes.get(n);
							Type currT = args.get(n);
							//TypeCheckUtils.checkSubType(ers, lhs, rhs)
							prevt = TypeCheckUtils.getRefType(prevt);
							currT = TypeCheckUtils.getRefType(currT);
							
							if(prevt==null || currT == null || !prevt.equals(currT)) {
								match=false;break;
							}
						}
						
						
						if(match) {
							rhsExprssions = prevrhsExprssions;
							args = prevTypes;
							argsz = prevAttemptFI.args;
						}
					}
				}
			}
			
			
			ArrayList<Pair<String, Type>> namessMap = argsz==null?null:getNameMap(argsz);
			
		//	boolean hazNameMap = namessMap != null && !namessMap.isEmpty();
			
			boolean actingOnActor = TypeCheckUtils.isTypedOrUntypedActor(this, lhsNamed);
			boolean isLockedAsActor = lhsNamed.isLockedAsActor;
			
			HashSet<TypeAndLocation> gots;
			if(actingOnActor){
				if(isLockedAsActor){
					String tryName = operation + "$ActorSuperCall";
					
					gots = lhsNamed.getFuncDef(line, col, tryName, args, namessMap, this);
					if(!gots.isEmpty()){
						operation = tryName;
					}else{//try as normal
						gots = lhsNamed.getFuncDef(line, col, operation, args, namessMap, this);
					}
				}
				else{
					if(!operation.endsWith("$ActorSuperCall") && !operation.endsWith("$ActorCall")){
						String tryName = operation + "$ActorCall";
						gots = lhsNamed.getFuncDef(line, col, tryName, args, namessMap, this);
						if(!gots.isEmpty()){
							operation = tryName;
						}
						else{
							tryName = operation + "$ActorSuperCall";
							gots = lhsNamed.getFuncDef(line, col, tryName, args, namessMap, this);
							if(!gots.isEmpty()){
								operation = tryName;
							}
						}
					}
					else{//try as normal
						gots = lhsNamed.getFuncDef(line, col, operation, args, namessMap, this);
					}
				}
			}
			else{
				dotOperatorLHS.push(lhs);
				Pair<HashSet<TypeAndLocation>,Boolean> opoverload = getMatchingFuncNames(null, this.getErrorRaiseableSupression(), operation,  0,0, false, true, args, namessMap);
				dotOperatorLHS.pop();
				gots=null;
				
				if(opoverload != null & opoverload.getA() == null) {
					opoverload = null;
				}
				
				if(opoverload != null && !opoverload.getB()){
					gots = opoverload.getA();
					gots.removeIf( a -> !(a.getType() instanceof FuncType) || !((FuncType)a.getType()).extFuncOn);
				}//see if it's an operator overload
				
				if(gots == null || gots.isEmpty()){
					gots = lhsNamed.getFuncDef(line, col, operation, args, namessMap, this);
				}
				
				
			}
			//as normal
			
			//dont think there can be more than one
			//TODO: when we do varargs this is going to need to be refactored quite a lot
			HashSet<TypeAndLocation> got = new HashSet<TypeAndLocation>();
			boolean haveAdjustedArgsForExtFuncs = false;
			for( TypeAndLocation tal : gots){
				FuncType ft = (FuncType)tal.getType();
				
				if(ft.extFuncOn && !haveAdjustedArgsForExtFuncs){
					args.add(0, lhs);
					haveAdjustedArgsForExtFuncs=true;
				}
					
				
				List<Type> ffargs = args;
				//if(hazNameMap){
					ffargs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, ft, args, namessMap, 0, true, false);
				//}
				
				if(ft.getInputs().size() == ffargs.size()){
					boolean argsMatchok = true;
					for(int an = 0 ; an < ft.getInputs().size(); an++) {
						if(null == TypeCheckUtils.checkSubType(this.ers, ft.getInputs().get(an), ffargs.get(an), 0, 0, 0, 0)){
							argsMatchok=false;
							break;
						}
					}
					
					if(!argsMatchok) {
						continue;
					}
					
					if(checkReturnIsSupertype && null == TypeCheckUtils.checkSubType(this.ers, lhs, ft.retType, 0, 0, 0, 0)){
						continue;
					}
					
					if(returnTypeEQ != null && !returnTypeEQ.equals(ft.retType)){
						continue;
					}
					
					if(noVoidret && TypeCheckUtils.isVoid(ft.retType) ) {
						continue;
					}
					
					got.add(tal);
				}
			}
			
			if(!got.isEmpty()){
				FuncInvokeArgs fia = new FuncInvokeArgs(line, col);
				for(Expression rhsExprssion : rhsExprssions){
					fia.add(rhsExprssion);
				}
				
				if(null != argsz){
					for(Pair<String, Object> tem : argsz.getNameMap()){
						fia.addName(tem.getA(), (Expression)tem.getB());
					}
				}
					
				//}
				
				return new FuncInvoke(line, col, operation, fia);
			}
		}
		
		return null;
	}
	

	@Override
	public Object visit(AddMinusExpressionElement addMinusExpressionElement) {
		return addMinusExpressionElement.exp.accept(this);
	}

	
	
	@Override
	public Object visit(BitwiseOperation input) {
		//always returns int or long versions
		ArrayList<Type> elementTypes = vectorizeElementsIfApproperiate(input);
		
		Expression head = input.head;
		int line = head.getLine();
		int col = head.getColumn();
		
		Type lhs = elementTypes.get(0);//(Type)head.accept(this);
		lhs = lhs == null?null:TypeCheckUtils.getRefTypeToLocked((Type)lhs.copy());
		flagNullableForOperation(line, col, lhs);
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(lhs);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = lhsvec.getA();

		if(vectorized != null) {
			lhs = lhsvec.getB();
		}

		boolean lastWasOpOverload=false;
		int n=1;
		for(RedirectableExpression i : input.things){
			lastWasOpOverload=false;
			Type rhs = elementTypes.get(n++);//(Type)i.exp.accept(this);
			rhs = rhs == null?null:TypeCheckUtils.getRefTypeToLocked((Type)rhs.copy());
			
			Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> rhsvec = vectorizedOperator(rhs);
			ArrayList<Pair<Boolean, NullStatus>> instVect = rhsvec.getA();
			if(instVect != null) {
				rhs = rhsvec.getB();
				vectorized = instVect;
			}	
			
			FuncInvoke overloaded = canBeOperatorOverloaded(lhs, rhs, input.getMethodEquiv(), i.exp, i.getLine(), i.getColumn(), (Node)i.astOverrideOperatorOverload);
			if(null != overloaded){
				i.astOverrideOperatorOverload = overloaded;
				this.dotOperatorLHS.push(lhs);
				rhs = (Type)i.accept(this);
				this.dotOperatorLHS.pop();
				lastWasOpOverload=overloaded.vectroizedDegreeAndArgs != null;
			}else{
				flagNullableForOperation(i.getLine(), i.getColumn(), rhs);
				rhs = TypeCheckUtils.checkNumericalOpGeneric(this, lhs, rhs, line, col, i.getLine(), i.getColumn(), "bitwise", makeMissingOpOverLoadMessage(input.getMethodEquiv(), lhs, rhs, null), true, false);
			}
			i.setTaggedType(rhs);
			lhs = rhs;
		}
		
		if(vectorized != null) {
			input.depth = vectorized;
			if(lhs != null && !lastWasOpOverload) {
				lhs = TypeCheckUtils.applyVectStruct(vectorized, lhs);
			}
		}else {
			lhs = validateAndReturnPointerType(input.getLine(),input.getColumn(), elementTypes, lhs, false);
		}
		
		return input.setTaggedType(lhs);
	}
	
	
	
	private Object visit(BooleanAndOrExpression input)
	{
		Expression head = input.getHead();
		Type lhs = (Type)head.accept(this);
		lhs = lhs == null?null:TypeCheckUtils.getRefTypeToLocked((Type)lhs.copy());
		//TypeCheckUtils.unlockAllNestedRefs(lhs);
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(lhs);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = lhsvec.getA();
		
		if(vectorized != null) {
			lhs = lhsvec.getB();
		}
		
		int line = head.getLine(); 
		int col = head.getColumn(); 
		String name = input.getName();
		
		TypeCheckUtils.assertNotVoid(lhs, this, line, col, name);
		flagNullableForOperation(line, col, lhs);
		
		for(RedirectableExpression i : input.getElems())
		{
			Type rhs = (Type)i.exp.accept(this);
			
			rhs = rhs == null?null:TypeCheckUtils.getRefTypeToLocked((Type)rhs.copy());
			
			Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> rhsvec = vectorizedOperator(rhs);
			ArrayList<Pair<Boolean, NullStatus>> instVect = rhsvec.getA();
			if(instVect != null) {
				rhs = rhsvec.getB();
				vectorized = instVect;
			}	
			
			//TypeCheckUtils.unlockAllNestedRefs(rhs);
			TypeCheckUtils.assertNotVoid(rhs, this, line, col, name);
			
			FuncInvoke overloaded = canBeOperatorOverloaded(lhs, rhs, input.getMethodEquiv(), i.exp, i.getLine(), i.getColumn(), (Node)i.astOverrideOperatorOverload);
			if(null != overloaded){
				i.astOverrideOperatorOverload = overloaded;
				this.dotOperatorLHS.push(lhs);
				rhs = (Type)i.accept(this);
				this.dotOperatorLHS.pop();
			}else {
				flagNullableForOperation( i.getLine(), i.getColumn(), rhs);
			}
			i.setTaggedType(rhs);
			lhs = rhs;
			//lhs = TypeCheckUtils.checkLogicalAndOrInfix(this, lhs, rhs, input.head.getLine(), input.head.getColumn(), i.getLine(), i.getColumn());
		}
		
		if(vectorized != null) {
			input.depth = vectorized;
			if(lhs != null) {
				lhs = TypeCheckUtils.applyVectStruct(vectorized, lhs);
			}
		}
		
		return lhs;
	}
	
	@Override
	public Object visit(AndExpression andExpression) {
		Type tt = (Type)	this.visit((BooleanAndOrExpression)andExpression);
		andExpression.setTaggedType(tt);
		return tt;
	}

	@Override
	public Object visit(OrExpression orExpression) {
		Type tt = (Type)	 this.visit((BooleanAndOrExpression)orExpression);
		orExpression.setTaggedType(tt);
		return tt;
	}
	
	@Override
	public Object visit(ArrayConstructor arr) {
		Type ret = (Type)arr.type.accept(this);
		ret = ret==null?null:(Type)ret.copy();
		//TODO: named type cannot be genenric, this is not allowed: private T[] aa = new T[];
		if(ret != null)
		{
			//int nullcnt=0;
			boolean hsnull=false;
			for(Expression e: arr.arrayLevels)
			{  
				if(e == null){
					hsnull=true;
				}else{
					if(hsnull){
						this.raiseError(arr.getLine(), arr.getColumn(), "Only the last dimension(s) of an array constructor may be unqualified" );
					}
					
					this.dotOperatorLHS.push(null);
					TypeCheckUtils.assertInteger(this, (Type)e.accept(this), e.getLine(), e.getColumn(), "");
					this.dotOperatorLHS.pop();
				}
			}
			
			if(hsnull && arr.defaultValue != null) {
				this.raiseError(arr.getLine(), arr.getColumn(), "All arry dimensions must be qualified in order to use an element wise initialiser" );
			}
			
			if(ret instanceof GenericType)
			{
				this.raiseError(arr.getLine(), arr.getColumn(), String.format("Cannot create a generic array of %s", ret) );
				return null;
			}
				
				
				
			if(arr.defaultValue != null) {
				/*if(ret instanceof PrimativeType) {
					int cnt = arr.defaultConstructor.asnames.size();
					if(cnt > 1) {
						this.raiseError(arr.getLine(), arr.getColumn(), "There can be only one argument to an element wise initialiser for a primative type" );
					}else {
						Type dcType = (Type)arr.defaultConstructor.asnames.get(0).accept(this);
						TypeCheckUtils.checkAssignmentCanBeDone(this, AssignStyleEnum.EQUALS, ret, dcType, arr.getLine(), arr.getColumn(), arr.getLine(), arr.getColumn(), "");
					}
				}else if(ret instanceof FuncType){
					int cnt = arr.defaultConstructor.asnames.size();
					if(cnt > 1) {
						this.raiseError(arr.getLine(), arr.getColumn(), "There can be only one argument to an element wise initialiser for a primative type" );
					}else {
						
					}
				}else {
					arr.defaultConstructor.accept(this);
				}*/
				Type dcType = (Type)arr.defaultValue.accept(this);
				TypeCheckUtils.checkAssignmentCanBeDone(this, AssignStyleEnum.EQUALS, ret, dcType, arr.getLine(), arr.getColumn(), arr.getLine(), arr.getColumn(), "");
				
				ret.setArrayLevels(arr.arrayLevels.size());
				
				arr.astRedirect = createDefaultValueARConInitalizer(arr, ret, dcType);
				ret = (Type)arr.astRedirect.accept(this);
			}else {
				ret.setArrayLevels(arr.arrayLevels.size());
			}
			
			if(hsnull && TypeCheckUtils.hasArrayRefLevels(ret)) {
				this.raiseError(arr.getLine(), arr.getColumn(), "All arry dimensions must be qualified for ref array creation" );
			}
		}
		
		arr.setTaggedType(ret);
		
		return ret;
	}
	
	private Block createDefaultValueARConInitalizer(ArrayConstructor arr, Type retType, Type valueType) {
		/*new int[2,3](99. as int) => { 
		 * value = 99. as int; 
		 * ret = new int[2,3]; 
		 * for(n1 = 0; n1 < ret.length; n1++){ 
		 * 		for(n2 = 0; n1 < ret[n1].length; n2++){ 
		 * 			ret[n1][n2] = value# ; 
		 *	    }
		 * } 
		 * ret; }
		*/
		arr = (ArrayConstructor)arr.copy();
		Expression defaultValue = arr.defaultValue;
		arr.defaultValue = null;
		
		int line = arr.getLine();
		int col = arr.getColumn();
		
		Block blk = new Block(line, col);
		blk.isolated = true;
		blk.setShouldBePresevedOnStack(true);
		
		blk.add(new AssignNew(null, line, col, "value", defaultValue.getTaggedType(), AssignStyleEnum.EQUALS, defaultValue));
		blk.add(new AssignNew(null, line, col, "ret", arr.getTaggedType(), AssignStyleEnum.EQUALS, arr));
		
		int levels = arr.arrayLevels.size();
		int n=0;
		
		Expression extractingFrom = new RefName("ret");
		Block addTo = blk;
		ArrayList<String> forNs = new ArrayList<String>();
		while( n < levels) {
			String forN = "n" + n;
			forNs.add(forN);
			Block forBlock = new Block(line, col);
			
			ArrayList<GrandLogicalElement> elements = new ArrayList<GrandLogicalElement>(1);
			elements.add( new GrandLogicalElement(line, col, GrandLogicalOperatorEnum.LT, DotOperator.buildDotOperator(line, col, extractingFrom, new RefName("length") ) ) );
			Expression check = new EqReExpression(line, col, new RefName(line, col, forN), elements);
			
			ForBlockOld fbo = new ForBlockOld(line, col, null, 
					forN, null, AssignStyleEnum.EQUALS, new VarInt(line, col, 0), 
				check, 
				new PostfixOp(line, col, FactorPostFixEnum.PLUSPLUS, new RefName(line, col, forN)), 
				forBlock, null);
			
			addTo.add(fbo);
			addTo = forBlock;
			n++;
			
			if(n == levels) {
				//ret[n1][n2] = value# ; 
				ArrayRefLevelElementsHolder areh = new ArrayRefLevelElementsHolder();
				ArrayList<ArrayRefElement> item = new ArrayList<ArrayRefElement>();
				for(String aa : forNs){
					item.add(new ArrayRefElement(line, col, new RefName(line, col, aa)));
				}
				areh.add(false, item);
				ArrayRef assignTo = new ArrayRef(line, col, new RefName(line, col, "ret"), areh);
				
				Expression what = valueType instanceof PrimativeType ? new RefName("value") : new CopyExpression( line,  col, new RefName("value"), null, null);
				forBlock.add(new AssignExisting(line, col, assignTo, AssignStyleEnum.EQUALS_STRICT, what));
			}else {
				ArrayRefLevelElementsHolder areh = new ArrayRefLevelElementsHolder();
				ArrayList<ArrayRefElement> item = new ArrayList<ArrayRefElement>();
				for(String aa : forNs){
					item.add(new ArrayRefElement(line, col, new RefName(line, col, aa)));
				}
				areh.add(false, item);
				extractingFrom = new ArrayRef(line, col, new RefName(line, col, "ret"), areh);
			}
		}
		
		blk.add(new DuffAssign(new RefName(line, col, "ret")));
		
		return blk;
	}
	
	@Override
	public Object visit(ArrayRefElementPrefixAll arrayRefElementPrefixAll) {
		Type tt = (Type)arrayRefElementPrefixAll.e1.accept(this);
		if(tt.isVectorized()) {
			tt = TypeCheckUtils.extractVectType(tt);
		}
		
		TypeCheckUtils.assertInteger(this, tt, arrayRefElementPrefixAll.e1.getLine(), arrayRefElementPrefixAll.e1.getColumn() , "");
		return (Object)true;
	}
	
	@Override
	public Object visit(ArrayRefElementPostfixAll arrayRefElementPostfixAll) {
		Type tt = (Type)arrayRefElementPostfixAll.e1.accept(this);
		if(tt != null && tt.isVectorized()) {
			tt = TypeCheckUtils.extractVectType(tt);
		}
		
		TypeCheckUtils.assertInteger(this, tt, arrayRefElementPostfixAll.e1.getLine(), arrayRefElementPostfixAll.e1.getColumn() , "");
		return (Object)true;

	}

	@Override
	public Object visit(ArrayRefElementSubList arrayRef) {
		Type tt1 = (Type)arrayRef.e1.accept(this);
		if(tt1 != null && tt1.isVectorized()) {
			tt1 = TypeCheckUtils.extractVectType(tt1);
		}
		
		Type tt2 = (Type)arrayRef.e1.accept(this);
		if(tt2 != null && tt2.isVectorized()) {
			tt2 = TypeCheckUtils.extractVectType(tt2);
		}
		
		TypeCheckUtils.assertInteger(this, tt1, arrayRef.e1.getLine(), arrayRef.e1.getColumn() , "");
		TypeCheckUtils.assertInteger(this, tt2, arrayRef.e2.getLine(), arrayRef.e2.getColumn() , "");
		return (Object)true;
	}
	
	@Override
	public Object visit(ArrayRefElement arrayRefElement) {
		Type gotType = (Type)arrayRefElement.e1.accept(this);
		if(!arrayRefElement.isNotActingOnArray && (gotType == null || !gotType.isVectorized())){
			TypeCheckUtils.assertInteger(this,  gotType, arrayRefElement.e1.getLine(), arrayRefElement.e1.getColumn(), ". Also, no approperiate overloaded setter/getter operator found" );//good enough error for lack of operator overloader
		}
		arrayRefElement.setTaggedType(gotType);
		return (Object)false;
	}
	
	
	/*
	 * x = y[k]              => check key on get     | return type associated with gettter
	 * y[k] = x              => check key on put key | return type associated with rhs of putter (and functype)
	 * y[k] +=1 (y[k]++ etc) => check key on get key | return type associated with getter :: validate put rhs takes returnable type
	 */
	
	private Pair<FuncType, FuncType> getKeyAndValueOfMAp(ErrorRaiseable er, NamedType map, LISTorMAPType liOrMapType, Type keyType, int line, int col, String putFuncName, Expression e1, Expression e2){
		//TODO: extend this to lists - special logic here concerning potentially overloaded get and put definitions
		
		if(liOrMapType == LISTorMAPType.REMOVE){
			HashSet<FuncType> rems = new HashSet<FuncType>();
			
			//TODO: remove ext func
			
			
			for(TypeAndLocation putChoice : map.getFuncDef(line, col, "remove", null, null, this)){
				FuncType fType = (FuncType)putChoice.getType();
				if(1 == fType.getInputs().size() && fType.retType !=null && !(fType.retType instanceof PrimativeType && ((PrimativeType)fType.retType).type == PrimativeTypeEnum.VOID)){
					rems.add(fType);
				}
			}
			ArrayList<Type> args = new ArrayList<Type>();
			args.add(keyType);
			
			FuncType got = TypeCheckUtils.getMostSpecificFunctionForChoicesFT( ers, ers, rems, args, null, "index get reference call", 0,0, false , this, false).getA();
			if (null == got) {// this seems unlikely...
				//String tt = TypeCheckUtils.checkSubType(this.errorRaisableSupression, map_object, map, 0, 0, 0, 0)!=null?"map":"list";
				er.raiseError(line, col, String.format("Cannot find remove function on %s with arguments: %s", map, args));
				return null;
			}
			
			return new Pair<FuncType, FuncType>(got, null);
			
		}else {
			HashSet<FuncType> gets = new HashSet<FuncType>();
			HashSet<FuncType> puts = new HashSet<FuncType>();
			
			
			FuncInvoke opOverloadGet = null;
			FuncInvoke opOverloadPut = null;
			
			Type gotTypeForPutterIfGetAndPut = null;
			
			if(liOrMapType == LISTorMAPType.GET || liOrMapType == LISTorMAPType.GETANDPUT ){
				//put ext functions
				opOverloadGet = canBeOperatorOverloaded(map, keyType, "get", e1, line, col, null);//we are not inputting the last arg op overload?
				
				if(null == opOverloadGet) {
					for(TypeAndLocation putChoice : map.getFuncDef(line, col, "get", null, null, this)){
						FuncType fType = (FuncType)putChoice.getType();
						if(1 == fType.getInputs().size() && fType.retType !=null && !(fType.retType instanceof PrimativeType && ((PrimativeType)fType.retType).type == PrimativeTypeEnum.VOID)){
							gets.add(fType);
						}
					}
				}else {
					this.maskErrors(false);
					this.dotOperatorLHS.push(map);
					gotTypeForPutterIfGetAndPut = (Type)opOverloadGet.accept(this);
					this.dotOperatorLHS.pop();
					if(this.maskedErrors() || opOverloadGet.resolvedFuncTypeAndLocation==null) {
						opOverloadGet=null;
					}
				}
			}
			
			if(liOrMapType == LISTorMAPType.PUT || liOrMapType == LISTorMAPType.GETANDPUT ){
				//put ext functions
				{
					ArrayList<Type> rhss = new ArrayList<Type>();
					rhss.add(e1.getTaggedType());
					if(null != gotTypeForPutterIfGetAndPut) {
						TypeReturningExpression tre = new TypeReturningExpression(gotTypeForPutterIfGetAndPut);
						tre.setTaggedType(gotTypeForPutterIfGetAndPut);
						e2 = tre;
					}
					
					rhss.add((e2==null?e1:e2).getTaggedType());
					
					ArrayList<Expression> rhsExprssions = new ArrayList<Expression>();
					rhsExprssions.add(e1);
					rhsExprssions.add((e2==null?e1:e2));
					
					opOverloadPut = canBeOperatorOverloaded(map, rhss, null, putFuncName, rhsExprssions, line, col, false, null, false, null);//we are not inputting the last arg op overload?
				}
				
				if(null == opOverloadPut) {
					for(TypeAndLocation putChoice : map.getFuncDef(line, col, putFuncName, null, null, this)){
						FuncType fType = (FuncType)putChoice.getType();
						if(2 == fType.getInputs().size()){
							puts.add(fType);
						}
					}
				}else {
					this.maskErrors(true);
					this.dotOperatorLHS.push(map);
					opOverloadPut.accept(this);
					this.dotOperatorLHS.pop();
					
					ArrayList<CapMaskedErrs> cap = this.getmaskedErrors();
					
					if(!cap.isEmpty() /*this.maskedErrors() */|| opOverloadPut.resolvedFuncTypeAndLocation==null) {
						opOverloadPut=null;
					}
				}
			}
			
			if(liOrMapType == LISTorMAPType.GET || liOrMapType == LISTorMAPType.PUT)
			{
				boolean isGet = liOrMapType == LISTorMAPType.GET;
				
				FuncInvoke whichOpOverload; HashSet<FuncType> which;
				if(liOrMapType == LISTorMAPType.GET) {
					whichOpOverload = opOverloadGet;
					which = gets;
				}else {
					whichOpOverload = opOverloadPut;
					which = puts;
				}
				
				ArrayList<Type> args = new ArrayList<Type>();
				args.add(keyType);
				
				if(!isGet){
					Type pendingRhs = rhsPendingAssignmeng.peek();
					args.add(pendingRhs);
				}
				
				FuncType got = TypeCheckUtils.getMostSpecificFunctionForChoicesFT( ers, ers, which, args, null, "index get reference call", 0,0, false, this, false).getA();
				if (null == got && (opOverloadGet ==null && opOverloadPut == null)) {// this seems unlikely...
					//String tt = TypeCheckUtils.checkSubType(this.errorRaisableSupression, map_object, map, 0, 0, 0, 0)!=null?"map":"list";
					er.raiseError(line, col, String.format("Cannot find %s function on %s with arguments: %s", isGet?"get":putFuncName, map, args));
					return null;
				}
				
				return new Pair<FuncType, FuncType>(whichOpOverload != null?(FuncType)whichOpOverload.resolvedFuncTypeAndLocation.getType():got, null);
			}
			else{
				//get then put
				ArrayList<Type> getargs = new ArrayList<Type>();
				getargs.add(keyType);
				
				FuncType gotget = TypeCheckUtils.getMostSpecificFunctionForChoicesFT(  ers, ers, gets, getargs, null, "index get reference call", 0,0, false, this, false).getA();
				if (null == gotget  && opOverloadGet ==null ) {// this seems unlikely...
					//String tt = TypeCheckUtils.checkSubType(this.errorRaisableSupression, map_object, map, 0, 0, 0, 0)!=null?"map":"list";
					er.raiseError(line, col, String.format("Cannot find get function on %s with arguments: %s", map, getargs));
					return null;
				}
				
				ArrayList<Type> putargs = new ArrayList<Type>();
				putargs.add(keyType);
				//Type rhsType = rhsPendingAssignmeng.peek();
				putargs.add(gotget==null?opOverloadGet.getTaggedType():gotget.retType);
				
				FuncType gotput = TypeCheckUtils.getMostSpecificFunctionForChoicesFT(  ers,ers, puts, putargs, null, "index get reference call", 0,0, false, this, false).getA();
				if (null == gotput && opOverloadPut == null ) {// this seems unlikely...
					//String tt = TypeCheckUtils.checkSubType(this.errorRaisableSupression, map_object, map, 0, 0, 0, 0)!=null?"map":"list";
					er.raiseError(line, col, String.format("Cannot find %s function on %s with arguments: %s", putFuncName, map, putargs));
					return null;
				}
				
				
				return new Pair<FuncType, FuncType>(opOverloadPut != null ? (FuncType)opOverloadPut.resolvedFuncTypeAndLocation.getType(): gotput, opOverloadGet != null ?(FuncType)opOverloadGet.resolvedFuncTypeAndLocation.getType():gotget );
			}
		}
	}

	private ArrayConstructor validAsArrayConstructor(ArrayRef arrayRef, int extraTrailingBracks) {
		
		int line = arrayRef.getLine();
		int col = arrayRef.getColumn();
		
		if(arrayRef.expr instanceof RefName){
			NamedType nt = new NamedType(line, col, ((RefName)arrayRef.expr).name);
			this.maskErrors();
			Type got = (Type)nt.accept(this);
			if(!this.maskedErrors() && TypeCheckUtils.isValidType(got)){
				
				ArrayList<ArrayRefElement> ares = new ArrayList<ArrayRefElement>();
				for(Pair<Boolean, ArrayList<ArrayRefElement>> levelx  : arrayRef.arrayLevelElements.getAll()){
					ares.addAll(levelx.getB());
				}
				
				ArrayList<Expression> arrayLevels = new ArrayList<Expression>();
				if(ares.stream().allMatch(a -> a.isSingleElementRefEle())){
					for(ArrayRefElement a : ares){
						arrayLevels.add(a.e1);
						if(a.trailingCommas != null){
							for(int n=0; n < a.trailingCommas; n++){
								arrayLevels.add(null);
							}
						}
					}
					
					
					if(extraTrailingBracks > 0){
						for(int n=0; n < extraTrailingBracks; n++){
							arrayLevels.add(null);
						}
					}
					
					ArrayConstructor res = new ArrayConstructor(line, col, nt, arrayLevels, null);
					
					return res;
				}
			}
		}
		return null;
	}
	
	private Pair<Type, Expression> replaceIfVectorizable(Expression orig) {
		this.maskErrors(true);
		Type retType = (Type)orig.accept(this);
		ArrayList<CapMaskedErrs> maskedErrs = this.getmaskedErrors();
		
		if(!maskedErrs.isEmpty()) {
			this.applyMaskedErrors(maskedErrs);
		}
		else if(!(orig instanceof Vectorized)) {
			ArrayList<Type> comps = TypeCheckUtils.extractIntermediateVectTypes(ers, retType, false);
			if(!comps.isEmpty()) {//it's a list or an array, which is not valid for this callsite, so, better vectorize this
				Vectorized newExpr = new Vectorized(orig);
				retType = (Type)newExpr.accept(this);
				return new Pair<Type, Expression>(retType, newExpr);
			}
		}

		return new Pair<Type, Expression>(retType, null);
	}
	
	private Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> processArrayRefElements(int line, int col, Type retSoFar, ArrayRefLevelElementsHolder holder, ArrayRef arrayRef) {
		Type retSoFarOrig = retSoFar;
		
		ArrayList<Pair<Boolean, NullStatus>> extractVectorized = null;
		
		ArrayList<Pair<Boolean, ArrayList<ArrayRefElement>>> allelements = holder.getAll();
		
		int n0=0;
		for (Pair<Boolean, ArrayList<ArrayRefElement>> elementsx : allelements) {
			boolean isNullSafe = elementsx.getA();
			ArrayList<ArrayRefElement> elements = elementsx.getB();
			
			boolean isLast1 = n0 == allelements.size() -1;
			n0++;
			// cater for int[2]-> [2,3], [2:3, 5], [:3, 5]
			// [2,3] -> -2 int
			// [2:3, 5] -> -1 int[1]
			// [:3, :5] -> -0 int[2]
			int nextract = elements.size();
			if (nextract > 255) {
				this.raiseError(line, col, String.format("Too many array reference dimensions: %s. Maximum is 255", retSoFar));
			}
			
			this.dotOperatorLHS.push(null);// fresh new scope without any dot operator nonsense
			this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
			int arrayReducing = 0;
			Integer firstAOLine = null;
			Integer firstAOCol = null;
			boolean sublistOp = false;

			int n1=0;
			for (ArrayRefElement arrayOp : elements) {
				boolean isLast = isLast1 && (n1 == elements.size() -1);
				n1++;
				
				boolean isNamedType= retSoFar instanceof NamedType;
				retSoFarOrig = retSoFar;
				
				if(retSoFar.getNullStatus() == NullStatus.NULLABLE) {
					if(!isNullSafe) {
						this.raiseError(line, col, "Array operation cannot be performed, array is nullable and might be null");
					}
				}else if(retSoFar.getNullStatus() == NullStatus.NONNULL && isNullSafe) {
					this.raiseError(line, col, "Null safe array operation may only be performed on array having a nullable type");
				}
				
				if(isNamedType){
					if(TypeCheckUtils.hasRefLevels(retSoFar)){
						//retSoFar = ((NamedType)retSoFar).getGenTypes().get(0);
						
						//if it cannot be extracted via get, e.g. ( [1,2]: )[2] - this can be got, but refarray cannot since it doesnt implement directlygettable 
						if(TypeCheckUtils.assertRefIFaceImpl(null, null, 0, 0, retSoFar, TypeCheckUtils.getRefLevels(retSoFar) - TypeCheckUtils.getRefLevlstoLocked(retSoFar), false, TypeCheckUtils.Cls_DirectlyGettable)){
							retSoFar = TypeCheckUtils.getRefTypeToLocked(retSoFar);
						}
						
						
						isNamedType= retSoFar instanceof NamedType;
					}
				}
				
				
				//boolean isMap = isNamedType && null != TypeCheckUtils.checkSubType(this.errorRaisableSupression, map_object, retSoFar, 0, 0, 0, 0);
				boolean isList = isNamedType && null != TypeCheckUtils.checkSubType(this.ers, list_object, retSoFar, 0, 0, 0, 0);
				
				if (firstAOLine == null) {
					firstAOLine = arrayOp.getLine();
					firstAOCol = arrayOp.getColumn();
				}

				ARElementType arele;

				arrayOp.isNotActingOnArray = !retSoFar.hasArrayLevels() && !(retSoFar.getPointer() > 0);//isMap || isList;

				ArrayList<Type> rhsTypes = new ArrayList<Type>(2);
				ArrayList<Expression> expressions = new ArrayList<Expression>(2);

				
				Pair<Type, Expression> eiana = replaceIfVectorizable(arrayOp.e1);
				if(eiana.getB() != null) {
					arrayOp.e1 = eiana.getB();
				}
				
				rhsTypes.add(eiana.getA() /*(Type)arrayOp.e1.accept(this)*/);
				expressions.add(arrayOp.e1);
				if(arrayOp instanceof ArrayRefElementSubList){
					ArrayRefElementSubList ass = (ArrayRefElementSubList)arrayOp;
					
					Pair<Type, Expression> eiass = replaceIfVectorizable(ass.e2);
					if(eiass.getB() != null) {
						ass.e2 = eiass.getB();
					}
					
					
					rhsTypes.add(eiass.getA() /*(Type)ass.e2.accept(this)*/);
					expressions.add(ass.e2);
				}
				
				if(arrayOp.rhsOfAssigmentType != null){
					rhsTypes.add(((Node)arrayOp.rhsOfAssigmentType).getTaggedType());
					expressions.add(arrayOp.rhsOfAssigmentType );
				}
				
				Type retThisInstance = null;
				
				if(arrayOp.astOverrideOperatorOverload != null) {
					this.dotOperatorLHS.push(retSoFar);
					arrayOp.accept(this);
					this.dotOperatorLHS.pop();
				}else {
					arrayOp.accept(this);
				}
				
				
				
				sublistOp = !arrayOp.isSingleElementRefEle();
				if (!sublistOp) {// abs referencing array indexes reduce array levels, sublists don't
					arrayReducing += 1;
				}
				
				// a[2], a[2:], a[:2], a[2:3] <-works on Arrays and Lists

				if (!isList && !retSoFar.hasArrayLevels() && retSoFar instanceof NamedType ) {
					arele = ARElementType.MAP;
					
					NamedType asNamed = (NamedType)retSoFar;
					
					if(!sublistOp){//single get/set
						Pair<FuncType,FuncType> signatureOfOperation =  getKeyAndValueOfMAp(this, asNamed, arrayOp.liToMap, arrayOp.getTaggedType(), arrayOp.getLine(), arrayOp.getColumn(), "put", arrayOp.e1, arrayOp.rhsOfAssigmentType);
						if(null != signatureOfOperation){//if null err already
							arrayOp.mapTypeOperatingOn = retSoFar;
							arrayOp.mapOperationSignature = signatureOfOperation.getA();//setter or setter
							arrayOp.mapOperationSignatureforGetter = signatureOfOperation.getB();//both, but other is setter
							if(arrayOp.liToMap == LISTorMAPType.GET || arrayOp.liToMap == LISTorMAPType.REMOVE){
								retThisInstance = arrayOp.mapOperationSignature.retType;
							}
							else if(arrayOp.liToMap == LISTorMAPType.GETANDPUT){
								retThisInstance = arrayOp.mapOperationSignatureforGetter.retType;
							}
							else{//arrayOp.liToMap == LISTorMAPType.PUT, get and put
								retThisInstance = signatureOfOperation.getA().getInputs().get(1);
							}
						}
					}else{//sublist operation
						String methodName = arrayOp.getMethodEquivName();
						
						HashSet<TypeAndLocation> chocies = asNamed.getFuncDef(line, col, methodName, null, null, this);
						
						ArrayList<Type> wantedArguments = new ArrayList<Type>();
						wantedArguments.add(new PrimativeType(PrimativeTypeEnum.INT));
						if(methodName.equals("sub") || methodName.equals("subAssign")){
							wantedArguments.add(new PrimativeType(PrimativeTypeEnum.INT));
						}
						
						if(arrayOp.rhsOfAssigmentType != null) {
							wantedArguments.add(arrayOp.rhsOfAssigmentType.getTaggedType());
						}

						FuncType got = TypeCheckUtils.getMostSpecificFunctionForChoices(ers, ers, chocies, wantedArguments, null, "index get reference call", line, col, false, this, false);
						if (null == got) {
							this.raiseError(firstAOLine, firstAOCol, "Sublist cannot be operated on" + makeMissingOpOverLoadMessage(methodName, asNamed, wantedArguments, null));
							this.dotOperatorLHS.pop();
							this.currentDotOperatorTracker.pop();
							return null;
						}
						
						if(arrayOp.rhsOfAssigmentType != null) {//via op overload not normal method
							FuncInvoke fi;
							if(methodName.equals("sub") || methodName.equals("subAssign") ){
								fi = new FuncInvoke(firstAOLine, firstAOCol, methodName, (Expression)arrayOp.e1.copy(), (Expression)((ArrayRefElementSubList)arrayOp).e2.copy(), (Expression)arrayOp.rhsOfAssigmentType.copy());
							}else {
								fi = new FuncInvoke(firstAOLine, firstAOCol, methodName, (Expression)arrayOp.e1.copy(), (Expression)arrayOp.rhsOfAssigmentType.copy());
							}
							arrayOp.astOverrideOperatorOverload = fi;
							this.dotOperatorLHS.push(asNamed);
							retThisInstance = (Type)arrayOp.astOverrideOperatorOverload.accept(this);
							
							
							if(TypeCheckUtils.hasRefLevels(retThisInstance)) {
								fi.waitForRefToReturnSomething=true;
							}
							
							this.dotOperatorLHS.pop();
						}else {
							
							if(null != TypeCheckUtils.checkSubType(this.ers, const_map, asNamed)) {
								arrayOp.mapOperationSignature = got;//reused oops
								retThisInstance = got.retType;
							}else {//not a map
								
								FuncInvoke fi;
								if(methodName.equals("sub") || methodName.equals("subAssign") ){
									fi = new FuncInvoke(firstAOLine, firstAOCol, methodName, (Expression)arrayOp.e1.copy(), (Expression)((ArrayRefElementSubList)arrayOp).e2.copy());
								}else {
									fi = new FuncInvoke(firstAOLine, firstAOCol, methodName, (Expression)arrayOp.e1.copy());
								}
								arrayOp.astOverrideOperatorOverload = fi;
								this.dotOperatorLHS.push(asNamed);
								retThisInstance = (Type)arrayOp.astOverrideOperatorOverload.accept(this);
								
								if(arrayOp.astOverrideOperatorOverload.vectroizedDegreeAndArgs != null) {
									//for case: A = [ 3 5 6]; res = mc[A ... A+2] //where mc operator overloads the sublist operator
									int which = arrayOp.astOverrideOperatorOverload.vectroizedDegreeAndArgs.getA().size();
									ArrayList<Type> iterme = TypeCheckUtils.extractIntermediateVectTypes(ers, retThisInstance, false);
									retThisInstance = iterme.get(which-1);
								}
								
								if(TypeCheckUtils.hasRefLevels(retThisInstance)) {
									fi.waitForRefToReturnSomething=true;
								}
								
								this.dotOperatorLHS.pop();
							}
						}
					}
				}
				 else if (retSoFar.hasArrayLevels() || retSoFar.getPointer() > 0) {// if it's an array
					arele = ARElementType.ARRAY;
					if (nextract - arrayReducing <0) {
						this.raiseError(firstAOLine, firstAOCol, String.format("Array index operation levels of: %s exceeds refernce array levels of: %s ", nextract, retSoFar.getArrayLevels()));
						this.dotOperatorLHS.pop();
						this.currentDotOperatorTracker.pop();
						return null;
					} else if (isNamedType || retSoFar instanceof PrimativeType || retSoFar instanceof FuncType) {
						if (retSoFar instanceof NamedType) {
							// retThisInstance = (Type)
							// ((NamedType)retSoFar).copy();
							ClassDef setClsDef = ((NamedType) retSoFar).getSetClassDef();
							if(null == setClsDef){
								this.dotOperatorLHS.pop();
								this.currentDotOperatorTracker.pop();
								return null;
							}
							NamedType clon = new NamedType(line, col, setClsDef);
							clon.setGenTypes(((NamedType) retSoFar).getGenericTypeElements());
							clon.setIsRef(((NamedType) retSoFar).getIsRef());
							clon.setLockedAsRef(((NamedType) retSoFar).getLockedAsRef());
							retThisInstance = clon;
						} else if (retSoFar instanceof PrimativeType) {
							retThisInstance = new PrimativeType(((PrimativeType) retSoFar).type);
							retThisInstance.setPointer(retSoFar.getPointer());
						} else {
							retThisInstance = ((FuncType) retSoFar).clone();
						}

						
						if(retSoFar.hasArrayLevels()) {
							List<NullStatus> nsar = retSoFar.getNullStatusAtArrayLevel();
							if(sublistOp) {
								retThisInstance.setArrayLevels(retSoFar.getArrayLevels());
								retThisInstance.setNullStatusAtArrayLevel(nsar);
							}else {
								retThisInstance.setArrayLevels(retSoFar.getArrayLevels()-1);
								NullStatus lasone = nsar.get(nsar.size()-1);
								retThisInstance.setNullStatusAtArrayLevel(nsar.subList(0, nsar.size()-1));
								retThisInstance.setNullStatus(lasone);
							}
							
						}else  if(retSoFar.getPointer() > 0) {// a[3:4] <- returns another array
							retThisInstance.setPointer(retThisInstance.getPointer()-1);
						}
						
						if(isLast && arrayOp.rhsOfAssigmentType != null){//ensure rhs can be assigned to lhs here
							Type rhsOfThing = ((Node)arrayOp.rhsOfAssigmentType).getTaggedType();
							checkASsignmentForArrayRef(retThisInstance, rhsOfThing, line, col, arrayOp.rhsOfAssigmentEQ);
						}

					} else {
						this.raiseError(firstAOLine, firstAOCol, String.format("Array index operation can only be performed on object that is an array, Map or List or object having approperiate operator overloading '%s' method not: %s" , arrayOp.getMethodEquivName(), retSoFar));
						this.dotOperatorLHS.pop();
						this.currentDotOperatorTracker.pop();
						return null;
					}
				} else if (isList ) {// if  it's  a list
					arele = ARElementType.LIST;
					NamedType NretSoFar = (NamedType) retSoFar;
					// can reduce by only 1 level
					if (sublistOp) {
						// TODO: if it's a non abstract list implementing class
						// then call addAll. cos u want a list of the origonal
						// thing no?
						// but for now cheat and make it an arraylist (naughty)
						HashSet<TypeAndLocation> chocies = NretSoFar.getFuncDef(line, col,"subList", null, null, this);

						ArrayList<Type> wantedArguments = new ArrayList<Type>();
						wantedArguments.add(new PrimativeType(PrimativeTypeEnum.INT));
						wantedArguments.add(new PrimativeType(PrimativeTypeEnum.INT));

						FuncType got = TypeCheckUtils.getMostSpecificFunctionForChoices(this, ers, chocies, wantedArguments, null, "index get reference call", line, col, false, this, false);
						if (null == got) {// this seems unlikely...
							this.dotOperatorLHS.pop();
							this.currentDotOperatorTracker.pop();
							return null;
						}
						
						retThisInstance = got.retType;
					} else {// just get one element
						Pair<FuncType,FuncType> signatureOfOperation =  getKeyAndValueOfMAp(this, (NamedType)retSoFar, arrayOp.liToMap, arrayOp.getTaggedType(), arrayOp.getLine(), arrayOp.getColumn(), "set", arrayOp.e1, arrayOp.rhsOfAssigmentType);
						if(null != signatureOfOperation){//if null err already
							arrayOp.mapTypeOperatingOn = retSoFar;
							arrayOp.mapOperationSignature = signatureOfOperation.getA();
							arrayOp.mapOperationSignatureforGetter = signatureOfOperation.getB();
							if(arrayOp.liToMap == LISTorMAPType.GET || arrayOp.liToMap == LISTorMAPType.REMOVE){
								retThisInstance = signatureOfOperation.getA().retType;
							}else if(arrayOp.liToMap == LISTorMAPType.GETANDPUT){
								retThisInstance = arrayOp.mapOperationSignatureforGetter.retType;
							}else{//arrayOp.liToMap == LISTorMAPType.PUT, get and put
								retThisInstance = signatureOfOperation.getA().getInputs().get(1);
							}
							
							if(isLast && arrayOp.rhsOfAssigmentType != null){//ensure rhs can be assigned to lhs here
								Type rhsOfThing = ((Node)arrayOp.rhsOfAssigmentType).getTaggedType();
								checkASsignmentForArrayRef(retThisInstance, rhsOfThing, line, col, arrayOp.rhsOfAssigmentEQ);
							}
						}
					}
				}
				else{//TODO: is this code used?
					boolean foundAsThingOnNamed = false;
					
					arele = ARElementType.OBJ;
					
					//search thing held by ref first, then search ref itself
					
					//check to see if we have a get/set method
					while(!foundAsThingOnNamed && null != retSoFar){
						if(retSoFar instanceof NamedType && !sublistOp  ){
							
							LISTorMAPType optype = arrayOp.liToMap;
							if(arrayOp.liToMap == LISTorMAPType.PUT && !rhsPendingAssignmeng.isEmpty() && TypeCheckUtils.hasRefLevels(retSoFar)){//
								NamedType NretSoFar = (NamedType) retSoFar;
								
								int rhsItems = TypeCheckUtils.getRefLevels(rhsPendingAssignmeng.peek());
								
								if(TypeCheckUtils.getRefLevels(NretSoFar.getGenTypes().get(0)) > rhsItems){
									optype = LISTorMAPType.GET;
								}
							}
							
							Pair<FuncType,FuncType> signatureOfOperation = getKeyAndValueOfMAp(this.getErrorRaiseableSupression(), (NamedType)retSoFar, optype, arrayOp.getTaggedType(), arrayOp.getLine(), arrayOp.getColumn(), "put", arrayOp.e1, arrayOp.rhsOfAssigmentType);
							if(null != signatureOfOperation){//if null err already
								arrayOp.mapTypeOperatingOn = retSoFar;
								arrayOp.mapOperationSignature = signatureOfOperation.getA();
								arrayOp.mapOperationSignatureforGetter = signatureOfOperation.getB();
								if(optype == LISTorMAPType.GET){
									retThisInstance = signatureOfOperation.getA().retType;
								}
								else{//arrayOp.liToMap == LISTorMAPType.PUT, get and put
									retThisInstance = signatureOfOperation.getA().getInputs().get(1);
								}
								foundAsThingOnNamed=true;
							}
							else{
								retSoFar = retSoFarOrig == retSoFar?null:retSoFarOrig;
							}
						}
						else{
							break;
						}
					}
					
					if(!foundAsThingOnNamed){
						//uh oh
						this.raiseError(firstAOLine, firstAOCol, String.format("Array index operation can only be performed on object that is an array, Map, List or object having approperiate operator overloading '%s' method not: %s", arrayOp.getMethodEquivName(), retSoFarOrig));
						
						this.dotOperatorLHS.pop();
						this.currentDotOperatorTracker.pop();
						return null;
					}
				}
				
					
				if(retThisInstance == null){
					this.dotOperatorLHS.pop();
					this.currentDotOperatorTracker.pop();
					return null;
				}
				
				ArrayList<Pair<Boolean, NullStatus>> aropvect = isArrayOpVectorized(arrayOp);
				if(aropvect != null) {
					retThisInstance.setArrayLevels(retThisInstance.getArrayLevels() + 1);
					
					if(extractVectorized != null) {
						if(aropvect.size() != extractVectorized.size()) {
							this.raiseError(line, col, String.format("When multiple elements array reference are vectorized, they must all be vectorized to the same degree: %s != %s", extractVectorized.size(), aropvect.size()));
						}
					}else {
						extractVectorized = aropvect;
					}
					
				}
				
				
				if(arrayRef != null) {
					arrayRef.penultimateOperatingOnType = retSoFar;
				}
				
				retSoFar = retThisInstance.getSelf();
				
				if (!elements.isEmpty()) {// TODO: this is wrong because
					//arrayOp.setTaggedType(retSoFar);
					elements.get(elements.size() - 1).setTaggedType(retSoFar);
				}

				Type castTo = retSoFar;
						
				if(isNullSafe) {
					castTo = (Type)retSoFar.copy();
					castTo = TypeCheckUtils.boxTypeIfPrimative(castTo, false);
					castTo.setNullStatus(NullStatus.NULLABLE);
				}
				
				holder.tagType(retSoFar, castTo, arele);
				retSoFar = castTo;
				
			}
			if(!this.dotOperatorLHS.isEmpty()){
				this.dotOperatorLHS.pop();
				this.currentDotOperatorTracker.pop();
			}
			
		}
		
		return new Pair<ArrayList<Pair<Boolean, NullStatus>>, Type>(extractVectorized, retSoFar);
	}
	
	private void checkASsignmentForArrayRef(Type retThisInstance, Type rhsOfThing, int line, int col, AssignStyleEnum rhsOfAssigmentEQ) {
		
		
		
		
		TypeCheckUtils.checkAssignmentCanBeDone(this, rhsOfAssigmentEQ, retThisInstance, rhsOfThing, line, col, line, col, "");
		
		
		/*
		
		
		if(rhsOfAssigmentEQ == AssignStyleEnum.PLUS_EQUALS) {//string concat
			Type lhsUnref = TypeCheckUtils.getRefType(retThisInstance);
			if(lhsUnref != null ) {
				if(ScopeAndTypeChecker.const_string.equals(lhsUnref)) {
					return;//its a string concat operation
				}
			}
		}
		else if(rhsOfAssigmentEQ == AssignStyleEnum.POW_EQUALS) {
			Type lhsUnref = TypeCheckUtils.unboxTypeIfBoxed(TypeCheckUtils.getRefType(retThisInstance));
			Type rhsUnref = TypeCheckUtils.unboxTypeIfBoxed(TypeCheckUtils.getRefType(rhsOfThing));
			if(lhsUnref != null && rhsUnref != null && lhsUnref instanceof PrimativeType && rhsUnref instanceof PrimativeType) {
				if(((PrimativeType)lhsUnref).type.isNumerical() &&  ((PrimativeType)rhsUnref).type.isNumerical()) {
					return;
				}
			}
		}*/
		
		
		//TypeCheckUtils.checkSubType(this, retThisInstance, rhsOfThing, line, col, line, col );
	}
	
	@Override
	public Object visit(ArrayRef arrayRef) {//asyncref problem maybe
		this.maskErrors(true);
		Type retSoFar = (Type) arrayRef.expr.accept(this);
		ArrayList<CapMaskedErrs> errs = this.getmaskedErrors();
		if(!errs.isEmpty() || null != arrayRef.arrayConstructorExtraEmptyBracks){//Integer[2] - doesnt resolve to anything, see if it can be accessed as an array constructor
			int extraTarailingEmptyBRacks = arrayRef.arrayConstructorExtraEmptyBracks==null?0:arrayRef.arrayConstructorExtraEmptyBracks;//for this: Integer[2][][]//bit of an edge case...
			ArrayConstructor resolvesToArrayConstructor = validAsArrayConstructor(arrayRef, extraTarailingEmptyBRacks);
			
			if(null != resolvesToArrayConstructor){
				arrayRef.astRedirectArrayCons = resolvesToArrayConstructor;
				return arrayRef.astRedirectArrayCons.accept(this);
			}
			
			this.applyMaskedErrors(errs);
		}
		
		arrayRef.arrayLevelElements.reset();
		ArrayList<Pair<Boolean, NullStatus>> extractVectorized = null;
		if (null != retSoFar) {
			//int n=0;
			//extractVectorized, retSoFar
			Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> evRsf = processArrayRefElements(arrayRef.getLine(), arrayRef.getColumn(), retSoFar, arrayRef.arrayLevelElements, arrayRef);
			if(null == evRsf) {
				return null;
			}
			
			extractVectorized = evRsf.getA();
			retSoFar = evRsf.getB();
		}
		
		if(extractVectorized != null) {
			arrayRef.vectDepth = extractVectorized;
		}
		
		retSoFar = Utils.removeGenericUpperBounds(retSoFar);
		arrayRef.setTaggedType(retSoFar);
		
		return retSoFar;
	}

	private ArrayList<Pair<Boolean, NullStatus>> isArrayOpVectorized(ArrayRefElement test) {
		ArrayList<Pair<Boolean, NullStatus>> ret = null;
		
		if(test instanceof ArrayRefElementSubList ) {
			ArrayRefElementSubList subl = (ArrayRefElementSubList)test;
			Type one = subl.e1.getTaggedType();
			Type two = subl.e2.getTaggedType();
			
			boolean oneVect = one==null?false:one.isVectorized();
			boolean twoVect = two==null?false:two.isVectorized();
			
			if(oneVect || twoVect) {
				if(oneVect && twoVect) {
					ArrayList<Pair<Boolean, NullStatus>> r1levels = TypeCheckUtils.getVectorizedStructure(this.getErrorRaiseableSupression(), one);
					ArrayList<Pair<Boolean, NullStatus>> r2levels = TypeCheckUtils.getVectorizedStructure(this.getErrorRaiseableSupression(), two);
					//int r1levels = one.getArrayLevels();
					//int r2levels = two.getArrayLevels();
					if(r1levels.size() !=  r2levels.size()) {
						this.raiseError(test.getLine(), test.getColumn(), String.format("When both elements of sublist array reference are vectorized, they must be vectorized to the same degree: %s != %s", r1levels.size(), r2levels.size()));
						ret=null;
					}/*else if(!r1levels.equals(r2levels.size())){
						this.raiseError(test.getLine(), test.getColumn(), "When both elements of sublist array reference are vectorized, they must be vectorized with the same array/list substructure");
						ret=null;
					}*/else{
						ret =  r1levels;
					}
				}else{
					if(oneVect) {
						ret = TypeCheckUtils.getVectorizedStructure(this.getErrorRaiseableSupression(), one);
					}else {
						ret = TypeCheckUtils.getVectorizedStructure(this.getErrorRaiseableSupression(), two);
					}
				}
			}
			
		}else {//ArrayRefElement
			Type one = test.e1.getTaggedType();
			if(one != null && one.isVectorized()) {
				ret = TypeCheckUtils.getVectorizedStructure(this.getErrorRaiseableSupression(), one);
			}
		}
		
		return ret;
	}
	
	private boolean concatOrAppendValid(ArrayList<Expression> arrayElements){
		PrimativeTypeEnum trackprimAndObjectTypesMized = null; 
		boolean elementIsObject = false;
		for(Expression e: arrayElements){
			Type gotType = e.getTaggedType();
			
			if(gotType instanceof PrimativeType){
				PrimativeTypeEnum me = ((PrimativeType)gotType).type;
				if(elementIsObject){
					return false;
				}else if(trackprimAndObjectTypesMized == null){
					trackprimAndObjectTypesMized = me;
				}else if( trackprimAndObjectTypesMized != me){
					return false;
				}
			}else{
				if(trackprimAndObjectTypesMized != null){
					return false;
				}
				elementIsObject = true;
			}
		}
		return true;
	}
	
	private int getComplexAppendArLevels(ArrayList<Expression> arrayElements, boolean isArray, boolean isArTopLevel){
		//[ [1 2 3 4] 8] => intepreted as => [  1 2 3 4 8 ] and not: [ [1 2 3 4],  [8] ] (i.e. a matrix)
		//or [[1 2; 3 4] ; 1 2] => [ [1 2 ; 3 4; 5 6]
		int isComplexAppendOp = -1;
		if(null != arrayElements){
			int cnt = arrayElements.size();
			ArrayList<Integer> arLevelsForAppendMaybe = (isArray && cnt > 1)?new ArrayList<Integer>(cnt):null;
			ArrayList<Boolean> isRefArras = new ArrayList<Boolean>();
			/*
			PrimativeTypeEnum trackprimAndObjectTypesMized = null; 
			boolean elementIsObject = false;*/
			
			for(Expression e: arrayElements){
				Type gotType = (Type)e.accept(this);
				if(e instanceof VarNull) {//hacktastic
					gotType = (Type)e;
				}
				
				if(null != arLevelsForAppendMaybe && gotType != null){
					int arle = gotType.getArrayLevels();
					if(arle == 0 && isArTopLevel){
						arle = 1;
					}
					
					arLevelsForAppendMaybe.add(arle);
					isRefArras.add(TypeCheckUtils.hasRefLevelsAndIsArray(gotType) || TypeCheckUtils.isRefArray(gotType));
				}
				/*
				if(gotType instanceof PrimativeType){
					PrimativeTypeEnum me = ((PrimativeType)gotType).type;
					if(elementIsObject){
						return -1;
					}else if(trackprimAndObjectTypesMized == null){
						trackprimAndObjectTypesMized = me;
					}else if( trackprimAndObjectTypesMized != me){
						return -1;
					}
				}else{
					if(trackprimAndObjectTypesMized != null){
						return -1;
					}
					elementIsObject = true;
				}
				*/
			}
			
			if(isRefArras.contains(true) && isRefArras.contains(false)) {
				//dont combine ref arrays and objects together in concat operation
				//[[1: 2:] 'hi']//no dont combine
				//this is a bit of a hack
				return -1;
			}
			
			
			if(null != arLevelsForAppendMaybe){
				//see if its an append operation, e.g. [ [1 2 3 4] 8] => intepreted as => [  1 2 3 4 8 ] and not: [ [1 2 3 4],  [8] ] (i.e. a matrix)
				int marlevels = arLevelsForAppendMaybe.stream().max((p1, p2) -> Integer.compare( p1, p2)).get();
				if(marlevels >= 1){
					if(arLevelsForAppendMaybe.stream().allMatch(a -> a == marlevels || (marlevels==1 && a == marlevels-1))){
						//if(arLevelsForAppendMaybe.stream().anyMatch(a -> a == marlevels-1)){//any to append
							isComplexAppendOp = marlevels;
						//}
					}
				}
			}
		}
		
		
		return isComplexAppendOp;
		
	}
	
	private Type processArrayElements(int line, int col, ArrayList<Expression> arrayElements, ArrayList<Expression> arEleForComplexArrayDef, int isComplexAppendOp, boolean isList, boolean emptyArrayOk, Type ifEmpty){
		//arEleForComplexArrayDef !=null means being called from complex array so logic slightly different concerning elements, namely that ; is used signifying concatination
		List<Type> types= new ArrayList<Type>(arrayElements.size());
		Map<Type,Pair<Integer,Integer>> offenders = new HashMap<Type,Pair<Integer,Integer>>();
		if(!emptyArrayOk && (null == arrayElements || arrayElements.isEmpty())){
			if(isList) {
				NamedType retolax = (NamedType)ScopeAndTypeChecker.const_arrayList.copy();
 				retolax.setGenTypes(ScopeAndTypeChecker.const_object.copyTypeSpecific());
				return retolax;
			}else {
				this.raiseError(line, col, "Empty arrays are not instantiable");
				return null;
			}
		}
		else
		{
			Type firstFail = null;
			
			HashSet<Integer> arLevels = arEleForComplexArrayDef!=null /*|| isComplexAppendOp > -1*/ ? new HashSet<Integer>() : null;
			
			boolean hasVarNull=false;

			for(Expression e : arrayElements)
			{
				Type type = (Type)e.accept(this);//e.getTaggedType();//(Type)e.accept(this);

				if(type instanceof VarNull) {
					hasVarNull = true;
				}
				
				if(!TypeCheckUtils.isValidType(this, type, e.getLine(), e.getColumn()))
				{
					firstFail= type;
				}

				Type origType = type;
				type = TypeCheckUtils.getRefTypeToLocked(type);
				
				if(null != origType && !type.equals(origType)){
					TypeCheckUtils.assertRefIsGettable(this, e.getLine(), e.getColumn(), origType, -1);
				}
				
				if(null != arEleForComplexArrayDef && type!=null){
					if(!type.hasArrayLevels() && isComplexAppendOp == -1 && !(e instanceof VarNull)){
						ArrayDef ad = new ArrayDef(e.getLine(), e.getColumn(), e);
						ad.isArray=true;
						type = (Type)ad.accept(this);//single item convert to arraydef
						arEleForComplexArrayDef.add(ad);
					}else{
						arEleForComplexArrayDef.add(e);
					}
				}
				
				if(type != null) {
					types.add(type);
					offenders.put(type, new Pair<Integer,Integer>(e.getLine(), e.getColumn()));
					
					if(null != arLevels){
						arLevels.add(type.getArrayLevels());
					}
				}
				
			}
			
			if(arLevels != null ){
				int min = arLevels.stream().min((p1, p2) -> Integer.compare( p1, p2)).get();
				int max = arLevels.stream().max((p1, p2) -> Integer.compare( p1, p2)).get();
				
				if(max - min > 1){
					this.raiseError(line, col, "Individual expressions being concatinated cannot vary by more than one array level");
				}
			}
			
			if(null != firstFail){
				return firstFail;
			}
			
			//int extraLevelsDueToVarNullArray=0;
			if(hasVarNull) {
				List<Type> nonNulls = new ArrayList<Type>(types.size());
				types.stream().filter(a -> !(a instanceof VarNull)).forEach(a -> nonNulls.add(a));
				
				if(!nonNulls.isEmpty()) {
					Type nonNull = nonNulls.get(0);
					boolean boxAll=false;
					int n=0;
					for(Type what : types) {
						if(what instanceof VarNull) {
							if(what.hasArrayLevels()) {
								boxAll=true;
								what = (Type)nonNull.copy();
							}else if(arEleForComplexArrayDef == null){
								what = TypeCheckUtils.boxTypeIfPrimative(nonNull, true); //(Type)nonNull.copy();
							}else {
								what = (Type)nonNull.copy();
							}
							nonNulls.add(what);
						}
					}
					
					//types.stream().filter(a -> (a instanceof VarNull)).forEach(a -> nonNulls.add(nonNull));
					
					if(boxAll) {
						List<Type> boxAlls = new ArrayList<Type>(types.size());
						
						n=0;
						for(Type tt: nonNulls) {
							tt = TypeCheckUtils.boxTypeIfPrimative(tt, true);
							arrayElements.get(n++).setTaggedType(tt);
							boxAlls.add(tt);
						}
						
						types = boxAlls;
					}else{
						types = nonNulls;
					}
					
					//add VarNull types to end of list - but pretend that they are not a null type
					
				}else {
					/*List<Type> nullsAsObjectType = new ArrayList<Type>(types.size());
					int n=0;
					for(Type tt: types) {
						NamedType repl = ScopeAndTypeChecker.const_object.copyTypeSpecific();
						//repl.setArrayLevels(tt.getArrayLevels());
						//arrayElements.get(n++).setTaggedType(repl);
						nullsAsObjectType.add(repl);
					}
					
					types = nullsAsObjectType;*/
					
					HashSet<Integer> nullLevels = new HashSet<Integer>();
					types.forEach(a -> nullLevels.add(a.getArrayLevels()));
					
					if(arEleForComplexArrayDef != null || nullLevels.size() > 1){
						this.raiseError(line, col, "At least one element of an array declaration must be non null in order to be instantiable");
						return null;
					}
					//this.raiseError(line, col, "At least one element of an array declaration must be non null in order to be instantiable");
					//return null;
					//REPLACE WITH OBJECT?
				}
				
			}
			
			
			int uneuqalconcatlevels = -1;
			if(arEleForComplexArrayDef != null){
				/* a = [1 2 ; 3 4] 
				   myAr = [ a ; 5 6] //detect this case
				 */
				HashSet<Integer> arSizes = new HashSet<Integer>();
				types.stream().forEach(a -> arSizes.add(a.getArrayLevels()));
				
				if(arSizes.size() > 1){
					uneuqalconcatlevels = arSizes.stream().max((p1, p2) -> Integer.compare(p1, p2)).get();
				}
			}
			
			//int setArLevels = -1;
			if(isComplexAppendOp > -1 || uneuqalconcatlevels > -1/*|| arEleForComplexArrayDef != null*/){//special case, strip off array levels for [[ 2 3] 9] ==> [ 2 3 9 ]
				//also caters for: [1 2; 3 4] ; 1 2
				/*if(arEleForComplexArrayDef != null){
					setArLevels = types.stream().max((p1, p2) -> Integer.compare( p1.getArrayLevels(), p2.getArrayLevels())).get().getArrayLevels();				}*/
				ArrayList<Type> striptypes= new ArrayList<Type>(arrayElements.size());
				for(Type t : types){
					if(t != null){
						Type ta = (Type)t.copy();
						if(TypeCheckUtils.hasRefLevelsAndIsArray(ta)) {
							((NamedType)ta).setLockedAsRef(true);
						}
						ta.setArrayLevels(0);
						striptypes.add(ta);
					}
				}
				types = striptypes;
			}
			
			Type ret = emptyArrayOk && types.isEmpty() && ifEmpty != null?null:TypeCheckUtils.getMoreGeneric(this, this, line, col, types, offenders, true );
			
			if(null != ret )
			{
				Type retola = (Type)ret.copy();
				
				TypeCheckUtils.unlockAllNestedRefs(retola);//array declarations shouldnt be ref locked
				ret = retola;
								
				TypeCheckUtils.assertAllSubtypeIfUnrefNeeded(this, line, col, ret, offenders);
				
				if(isList) {
					
					NamedType retolax = (NamedType)ScopeAndTypeChecker.const_arrayList.copy();
					
					if(ret instanceof VarNull) {
						ret = ScopeAndTypeChecker.const_object.copyTypeSpecific();
					}
					
					Type genArg = TypeCheckUtils.boxTypeIfPrimative(ret, false);
					
					if(hasVarNull) {
						genArg.setNullStatus(NullStatus.NULLABLE);
					}
					
					retolax.setGenTypes(genArg);
					
					return retolax;
				}
				boolean setarlevels = false;
				if(isComplexAppendOp > -1 ){
					ret.setArrayLevels(isComplexAppendOp);
					setarlevels=true;
				} else if(uneuqalconcatlevels > -1){
					ret.setArrayLevels(uneuqalconcatlevels);
					setarlevels=true;
				}
				
				/*if(setArLevels > -1){//caters for: [1 2; 3 4] ; 1 2
					ret.setArrayLevels(setArLevels+1);
				}
				else*/ else if(arEleForComplexArrayDef == null || arrayElements.size() > 1){
					if(arEleForComplexArrayDef != null && ret.getArrayLevelsRefOVerride() >=2 ){
						//dont adjust ref levels for ar=[1 2 ; 3 4], but do for thing [ar ; ar]
					}else{
						
						ret.setArrayLevels(ret.getArrayLevelsRefOVerride() + 1 /*+ extraLevelsDueToVarNullArray*/);
						if(ret.getNullStatus() == NullStatus.NULLABLE) {
							ret.setNullStatus(NullStatus.NONNULL);
							ret.setNullStatusAtArrayLevel(NullStatus.NULLABLE);
						}
						
						setarlevels=true;
					}
					
				}
				
				if(hasVarNull) {
					if(setarlevels) {
						retola.setNullStatusAtArrayLevel(NullStatus.NULLABLE);
					}else {
						retola.setNullStatus(NullStatus.NULLABLE);
					}
				}
				
			}else if(ifEmpty != null) {
				ret = ifEmpty;
			}
			
			return ret;
		}
	}
	
	private ArrayList<Expression> expandExprList(Expression ee){
		if(ee instanceof ExpressionList){
			return ((ExpressionList)ee).exprs;
		}else{
			ArrayList<Expression> ret = new ArrayList<Expression>();
			ret.add(ee);
			return ret;
		}
		
	}
	
	private ArrayList<Expression> extractExprsFromExpression(Expression expr, boolean convertToArrayDef){
		ArrayList<Expression> ret = new ArrayList<Expression>();
		if(expr instanceof ArrayRef){
			ArrayRef ar =(ArrayRef)expr;
			ret.add(ar.expr);
			ArrayList<Pair<Boolean, ArrayList<ArrayRefElement>>> ares = ar.arrayLevelElements.getAll();//[1, 2, 3...5][2,3//etc

			for(Pair<Boolean, ArrayList<ArrayRefElement>> item : ares){
				ArrayList<ArrayRefElement> are = item.getB();
				if(are.stream().anyMatch(a -> !a.isSingleElementRefEle())){
					ret = null;
					break;//we process this as [1 ... 2] etc MUST be an arrayref
				}
				
				ArrayList<Expression> arrayElements = new ArrayList<Expression>(are.size());
				for(ArrayRefElement arx : are){
					arrayElements.addAll(expandExprList(arx.e1));
				}
				ArrayDef ad = new ArrayDef(expr.getLine(), expr.getColumn(), arrayElements);
				ad.isArray=true;
				ret.add(ad);
			}
			
		}else if(expr instanceof FuncInvoke){
			//can only be one argument
			FuncInvoke afi = (FuncInvoke)expr;
			if(afi.args.asnames.size()==1 && afi.args.nameMap.isEmpty()){
				ret.add(new RefName(afi.funName));
				ret.add(afi.args.asnames.get(0));
			}
		}else if(expr instanceof FuncRefInvoke){
			//can only be one argument
			FuncRefInvoke afi = (FuncRefInvoke)expr;
			if(afi.args.asnames.size()==1 && afi.args.nameMap.isEmpty()){
				ArrayList<Expression> rec = extractExprsFromExpression(afi.funcRef, convertToArrayDef);//e.g. [ x18  (x23-20) (x23-20)  9]
				if(null != rec && !rec.isEmpty()) {
					ret.addAll(rec);
				}else {
					ret.add(afi.funcRef);
				}
				ret.add(afi.args.asnames.get(0));
			}
		}else if(expr instanceof DotOperator) {
			DotOperator asDot = (DotOperator)expr;
			ArrayList<Expression> tmp = new ArrayList<Expression>();
			for(Expression exprx : asDot.getElements(this)) {//pull out individual elements, see if those work
				exprx = (Expression)exprx.copy();
				if(exprx instanceof AsyncRefRef) {
					AsyncRefRef asarr = (AsyncRefRef)exprx;
					asarr.checkRefLevels=false;
					exprx = asarr;
				}
				tmp.add(exprx);
			}
			if(!tmp.isEmpty()) {
				if(convertToArrayDef) {
					Expression first = tmp.get(0);
					ArrayDef ad = new ArrayDef(first.getLine(), first.getColumn(), tmp);
					ad.isArray=true;
					ret.add(ad);
				}else {
					ret.addAll(tmp);
				}
			}
		}
		
		
		if(!ret.isEmpty()){
			for(Expression teste : ret){
				this.maskErrors();
				Type got = (Type)teste.accept(this);
				if(this.maskedErrors() || !TypeCheckUtils.isValidType(got)){
					return null;//dang it, doesnt resolve to the thing we thought it would
				}
			}
			return ret;
		}
		
		return null;
	}
	
	@Override
	public Object visit(ArrayDef arrayDef) {
		//ArrayList<Expression> elements = arrayElementDisambiguate(arrayDef.getArrayElements(this));
		ArrayList<Expression> elements = arrayDef.getArrayElements(this);

		int line = arrayDef.getLine();
		int col = arrayDef.getColumn();
		
		if(arrayDef.isArray && (arrayDef.removedAmig == null || arrayDef.removedAmig==true)){//disambiguiate this case:  [ a [1 7] ] which should result in: [a 1 7] and not be interp as [a[exprlist], ]
			
			Pair<Boolean, ArrayList<Expression>> diambi = disambiguateElements(line, col, elements, false);
			 ArrayList<Expression> remapped = diambi.getB();
			
			if(remapped != elements) {
				elements = remapped;
				arrayDef.removedAmig = diambi.getA()?null:remapped != null;//
				arrayDef.setDisambiguatedElements(remapped);
			}
		}
		
		if(!arrayDef.supressArrayConcat) {//if not a[1, 2, 3]
			arrayDef.isComplexAppendOp = getComplexAppendArLevels(elements, arrayDef.isArray, false);
			
			if(!concatOrAppendValid(elements)){
				arrayDef.isComplexAppendOp =-1;
			}
		}
		
		Type ret = processArrayElements(line, col, elements, null, arrayDef.isComplexAppendOp, !arrayDef.isArray, arrayDef.emptyArrayOk, arrayDef.getTaggedType());
		
		Type taggedAlready = arrayDef.getTaggedType();
		if(taggedAlready != null) {
			if(taggedAlready.equals(TypeCheckUtils.boxTypeIfPrimative(ret, true))) {
				return taggedAlready;
			}
		}
		
		return arrayDef.setTaggedType(ret);
		
		/*if(ret == null && arrayDef.emptyArrayOk) {
			return arrayDef.getTaggedType();
		}else {
			return arrayDef.setTaggedType(ret);
		}*/
	}
	
	private Pair<Boolean, ArrayList<Expression>> disambiguateElements(int line, int col, ArrayList<Expression> elements, boolean convertToArrayDef){
		int n=0;
		ArrayList<Expression> remapped = null;
		boolean failed = false;
		int emptyArCount = 0;
		for(Expression expr : elements){
			this.maskErrors();
			
			if(expr instanceof ArrayDef) {
				if(((ArrayDef)expr).getArrayElements(this).isEmpty()) {
					((ArrayDef)expr).emptyArrayOk = true;
					emptyArCount++;
				}
			}
			
			Type got = (Type)expr.accept(this);
			if(this.maskedErrors() || !TypeCheckUtils.isValidType(got)){
				//try to remap expression to 'components', e.g. a[3] (arrayref) =>  a (refname), [3] (arrayDef)
				//this fails: [1: 2], should map to 1:, 2 instead of 1:2
				ArrayList<Expression> toAdd = extractExprsFromExpression(expr, convertToArrayDef);
				if(null != toAdd){
					if(remapped == null){
						remapped = new ArrayList<Expression>(elements.subList(0, n));//so far
					}
					remapped.addAll(toAdd);
				}else{
					remapped=null;
					failed = true;
					break;
				}
				//elements
			}else if(remapped != null){
				remapped.add(expr);
			}
			n++;
		}
		
		if(emptyArCount == elements.size() && 1 < elements.size()) {
			this.raiseError(line, col, "At least one element of an array declaration must be non empty in order to be instantiable");
			remapped=null;
			failed=true;
		}
		
		return new Pair<Boolean, ArrayList<Expression>>(failed, remapped != null?remapped:elements);
	}
	
	
	@Override
	public Object visit(ArrayDefComplex arrayDefComplex){
		arrayDefComplex.bcarrayElements = new ArrayList<Expression>();
		
		ArrayList<Expression> elements = arrayDefComplex.getArrayElements(this);
		
		/*if(arrayDefComplex.concatValid){//ignore nulls
			elements = new ArrayList<Expression>(elements.stream().filter(a -> !(a instanceof VarNull)).collect(Collectors.toList()));
		}*/
		
		int line = arrayDefComplex.getLine();
		int col = arrayDefComplex.getColumn();
		
		if(arrayDefComplex.removedAmig == null || arrayDefComplex.removedAmig==true){//disambiguiate this case:  [ a [1 7] ] which should result in: [a 1 7] and not be interp as [a[exprlist], ] - and others
			Pair<Boolean, ArrayList<Expression>> diambi = disambiguateElements(line, col, elements, true);
			ArrayList<Expression> remapped = diambi.getB();
			
			if(remapped != elements) {
				elements = remapped;
				arrayDefComplex.removedAmig = diambi.getA()?null:remapped != null;//
				arrayDefComplex.setDisambiguatedElements(remapped);
			}
		}
		
		Type ret = processArrayElements(line, col, elements, arrayDefComplex.bcarrayElements, -1, false, false, null);
		
		arrayDefComplex.concatValid=concatOrAppendValid(arrayDefComplex.bcarrayElements);
		
		//concatinate items together...
		return arrayDefComplex.setTaggedType(ret);
	}
	

	private boolean tagLhsOfAsyncRefRefExprSupressUnassign(Expression lhs) {
		if(lhs instanceof RefName) {
			((RefName)lhs).supressUnassign=true;
			return true;
		}else if(lhs instanceof DotOperator) {
			return tagLhsOfAsyncRefRefExprSupressUnassign(((DotOperator)lhs).getLastElement());
		}
		return true;
	}
	
	@Override
	public Object visit(AsyncRefRef asyncRefRef){
		
		boolean lhsResolvestoRefName = false;
		if(asyncRefRef.b instanceof RefQualifiedGenericNamedType){
			((RefQualifiedGenericNamedType)asyncRefRef.b).isInDotOperator=true;
		}
		else {
			lhsResolvestoRefName = tagLhsOfAsyncRefRefExprSupressUnassign(asyncRefRef.b);
		}
		
		Type lhsType = (Type)asyncRefRef.b.accept(this);
		Type origLhs = lhsType==null?null:(Type)lhsType.copy();
		
		int refCntLevels = asyncRefRef.refCntLevels;
		//boolean fail = false;
		
		//needs upgrade
		if(lhsType instanceof PrimativeType && ((PrimativeType)lhsType).type == PrimativeTypeEnum.VOID){
			this.raiseError(asyncRefRef.getLine(), asyncRefRef.getColumn(), "type on left hand side of : cannot be void");
		}
	
		
		if(lhsType instanceof NamedType && lhsResolvestoRefName) {
			Type lhsUnref = TypeCheckUtils.getRefType(lhsType);
			FuncInvoke unassign = typeHasUnassign(asyncRefRef.getLine(), asyncRefRef.getLine(), lhsUnref, null); 
			if(null != unassign) {
				refCntLevels--;
				if(refCntLevels == 0) {
					asyncRefRef.setTaggedType(lhsUnref);
					return lhsUnref;
				}
			}
		}
		
		if(asyncRefRef.checkRefLevels){
			int lshRefLevels = TypeCheckUtils.getRefLevels(lhsType);
			if(refCntLevels > lshRefLevels){
				
				//could be an actor
				if(lhsType instanceof NamedType){
					NamedType lhsAsNamed = (NamedType)lhsType;
					
					if(TypeCheckUtils.isActor(this, lhsAsNamed)){
						asyncRefRef.setTaggedType(lhsAsNamed);
						lhsAsNamed = lhsAsNamed.copyTypeSpecific();
						lhsAsNamed.isLockedAsActor = true;
						return lhsAsNamed;
					}
				}
				
				this.raiseError(asyncRefRef.getLine(), asyncRefRef.getColumn(), String.format("type %s has fewer than %s ref levels", lhsType, refCntLevels));
			}
		}
		
		boolean creating = false;
		
		if(!(lhsType instanceof NamedType) || (lhsType instanceof NamedType && !((NamedType)lhsType).getIsRef())){
			//fail = true;
			//not a ref so upgrade...
			lhsType = TypeCheckUtils.boxTypeIfPrimative(lhsType, false);
			if(null == lhsType){// || lhsType instanceof VarNull ){
				lhsType = const_object;
			}
			
			for(int n =0; n < refCntLevels; n++){
				lhsType = new NamedType(asyncRefRef.getLine(), asyncRefRef.getColumn(), lhsType);
				((NamedType)lhsType).setLockedAsRef(true);
				creating=true;
			}
		}
		else{//ref so maybe downref
			//check we can...
			TypeCheckUtils.assertRefIsGettable(this, asyncRefRef.getLine(), asyncRefRef.getColumn(), lhsType, refCntLevels);
			
			lhsType = lhsType == null?null:(Type)lhsType.copy();
			NamedType asNamed = ((NamedType)lhsType);//.copyTypeSpecific();
			
			if(asNamed.getIsRef()){
				int levels = TypeCheckUtils.getRefLevels(asNamed);
				if(levels < refCntLevels){
					//upgrade
					for(int n =levels; n < refCntLevels; n++){
						lhsType = new NamedType(asyncRefRef.getLine(), asyncRefRef.getColumn(), lhsType);
						((NamedType)lhsType).setLockedAsRef(true);
						creating=true;
					}
				}
				else{
					if(asyncRefRef.checkRefLevels){
						//g=8::
						//gotRef = g:get() // gotRef -> int:
						for(int m=0; m < levels - (refCntLevels+1); m++){
							asNamed = (NamedType)asNamed.getGenTypes().get(0);
						}
						asNamed.setLockedAsRef(true);
						lhsType = asNamed;
					}
					else{
						//lock from deepest upwards
						for(int n = 0; n < levels - refCntLevels; n++){
							lhsType = ((NamedType)lhsType).getGenTypes().get(0);
						}
						((NamedType)lhsType).setLockedAsRef(true);
					}
					
				}
			}
		}
		
		if(creating && null != origLhs && TypeCheckUtils.hasRefLevels(lhsType)){
			HashSet<GenericType> unbounded = TypeCheckUtils.findUnboundedGenerics(origLhs);
			if(!unbounded.isEmpty()){
				warnOnUnboundedGenerics(unbounded, asyncRefRef.getLine(), asyncRefRef.getColumn(), ":");
			}
		}
		
		asyncRefRef.setTaggedType(lhsType);
		return lhsType;
	}


	

	
	private String getFullModuleAndClassName()
	{
		return this.justPackageName.replace('.', '/');
	}	
	
	private boolean hasVarNullInIt(Type thing){
		if(TypeCheckUtils.getRefType(thing) instanceof VarNull){//varnull itself or a ref of a varnull
			return true;
		}
		else if(thing instanceof NamedType){
			NamedType asNT = (NamedType)thing;
			ClassDef cls = asNT.getSetClassDef();
			if(cls != null && cls.toString().equals("java.util.HashMap")){
				for(Type mapGenT :asNT.getGenericTypeElements()){
					if(hasVarNullInIt(mapGenT)) {
						return true;
					}
				}
			}
			
		}
		
		return false;
	}

	private void validateAnnotaionLocationVsPrefix(Annotations annotations, String prefix){
		//boolean allok = true;
		for(Annotation annot : annotations.annotations){
			for(String loc : annot.locations){
				if(loc.equals("getter")){
					if(prefix == null || prefix.equals("+")){//null or setter only
						this.raiseError(annot.getLine(), annot.getColumn(), String.format("getter location can only be used where a getter is defined") );
						//allok=false;
					}
				}
				else if(loc.equals("setter")){
					if(prefix == null || prefix.equals("-")){//null or getter only
						this.raiseError(annot.getLine(), annot.getColumn(), String.format("setter location can only be used where a setter is defined") );
						//allok=false;
					}
				}
			}
		}
		//return allok;
	}
	
	private void tagFieldLevelBlock(Expression rhs){
		if(currentScopeFrame.isClass() && rhs instanceof Block){
			((Block)rhs).isClassFieldBlock=true;
		}
		
	}
	
	//private Pattern tupleNamePattern = Pattern.compile("Tuple[0-9][0-9]*|my.Tuple[0-9][0-9]*");
	//Tuple[0-9][0-9]*
	
	public Pair<Type, Expression> convertExpressionToNewLazy(int line, int col, Type lhsType, Type rhsType, Expression rhsExpr, boolean justLambda){
		Expression ret = Utils.createNewLazyObject(this, line, col, lhsType, rhsType, rhsExpr, justLambda);
		return new Pair<Type, Expression>((Type)ret.accept(this), ret);
	}
	public Pair<Type, Expression> convertExprToArgLessLambda(int line, int col, Type toType, Type rhsType, Expression rhsExpr){
		Expression ret = Utils.createNewNoArgLambda(line, col, toType, rhsType, rhsExpr);
		return new Pair<Type, Expression>((Type)ret.accept(this), ret);
	}
	
	@Override
	public Object visit(AssignNew assignNew) {
		//a Int = 8
		//a Int;
		//err if exists already in this scope
		String varname = assignNew.name;
		
		assignNew.isModuleLevelShared = false;
		
		boolean addInjectAnnotation = validateInjectAssignLocation(assignNew);

		setForceCastIfVarNull(assignNew.expr, assignNew.type);
		
		//see if we map directly onto an expression list...
		if(assignNew.isFinal == false && assignNew.isVolatile == false && assignNew.prefix == null && !assignNew.isOverride && assignNew.accessModifier==null){
			Type tt = assignNew.type;
			if(tt instanceof NamedType && !tt.hasArrayLevels()){
				this.maskErrors();
				tt.accept(this);
				if(this.maskedErrors()){//unknown type, try to convert to expr list
					
					if(assignNew.expr == null) {
						int line = assignNew.getLine();
						int col = assignNew.getColumn();
						
						ArrayList<Expression> exprs = new ArrayList<Expression>();
						exprs.add(new RefName(assignNew.name));
						exprs.add(new RefName(((NamedType)tt).namedType ) );
						ExpressionList exprList = new ExpressionList(line, col, exprs);
						this.maskErrors();
						exprList.accept(this);
						if(!this.maskedErrors()){//TODO: notice how we are visiting assignNew.astRedirect twice, let's visit only once!
							assignNew.astRedirect = exprList;
							return assignNew.astRedirect.accept(this);
						}
					}else{
						if(null != assignNew.astRedirect) {//dont need to regenerate as structure will not change (besides, its not copied...)
							return assignNew.astRedirect.accept(this);
						}else {
							ArrayList<Expression> exprs = new ArrayList<Expression>();
							exprs.add(new RefName(assignNew.name));
							exprs.add(new RefName(((NamedType)tt).namedType ) );
							ExpressionList exprList = new ExpressionList(assignNew.getLine(), assignNew.getColumn(), exprs);
							
							AssignExisting asse = new AssignExisting(assignNew.getLine(), assignNew.getColumn(), exprList, assignNew.eq, assignNew.expr);
							asse.setShouldBePresevedOnStack(false);
									
							this.maskErrors(true);
							Object ret = asse.accept(this);
							if(!this.maskedErrors()){
								assignNew.astRedirect = asse;
								return ret;
							}
						}
					}
				}
			}
		}
		
		
		assignNew.isAnnotationField=this.currentScopeFrame.isAnnotation;
		
		if(addInjectAnnotation) {
			if(assignNew.annotations == null){
				assignNew.annotations = new Annotations();
			}else {
				if(!assignNew.annotations.hasAnnotation(const_InjectAnnotationStr)) {
					assignNew.annotations.annotations.add((Annotation)const_InjectAnnotation.copy());
				}
			}
		}
		
		if(assignNew.isShared) {
			if(currentScopeFrame.isClass() || currentScopeFrame.paThisIsModule) {
				boolean adShared = true;
				if(assignNew.annotations == null) {
					assignNew.annotations = new Annotations(assignNew.getLine(), assignNew.getColumn(), new ArrayList<Annotation>(1));
				}else {
					for(Annotation annot : assignNew.annotations.annotations) {
						Type tt = annot.getTaggedType();
						if(tt != null && tt.equals(const_sharedAnnot)) {
							adShared = false;
							break;
						}
					}
				}
				
				if(adShared) {
					Annotation annot = new Annotation(assignNew.getLine(), assignNew.getColumn(),const_SharedStr , null, null, new ArrayList<String>(0));
					assignNew.annotations.annotations.add(annot);
				}
			}
			
		}
		
		if(assignNew.annotations != null){
			if(currentScopeFrame.isClass()){
				for(Annotation annot : assignNew.annotations.annotations){
					annot.location = Annotation.AnnotationLocation.FIELD;
				}
			}
			//check getter/setter valid if defined
			validateAnnotaionLocationVsPrefix(assignNew.annotations, assignNew.prefix==null?assignNew.origprefix:assignNew.prefix);

			assignNew.annotations.setUsedAt(ElementType.FIELD);
			assignNew.annotations.accept(this);
		}
		
		if(this.hasImportBeenRegistered(varname))
		{// e.g. String String = "";
			this.raiseError(assignNew.getLine(), assignNew.getColumn(), String.format("Variable definitions cannot override classneames. %s has already been defined as an imported class", varname) );
			return null;
		}
		
		tagFieldLevelBlock(assignNew.expr);
		
		boolean isClassLevel = this.currentScopeFrame.isClass();
		
		//module, field, local var
		AccessModifier am = assignNew.accessModifier;
		if(assignNew.isAnnotationField){
			//skip fiddling with am - they shouldnt have one if they do its a bug
		}
		else if(this.currentScopeFrame.paThisIsModule){
			if(am == null ){
				am = AccessModifier.PRIVATE;
			}
		}
		else if(isClassLevel){
			if(am == null){
				am = this.currentScopeFrame.getClassDef().isEnumSubClass? AccessModifier.PRIVATE : AccessModifier.PROTECTED;
			}
		}
		else{
			//local variable
			if(am != null){
				this.raiseError(assignNew.getLine(), assignNew.getColumn(), "Local variables may not have an access modifier defined");
				//return null;
			}
			if(assignNew.isTransient){
				this.raiseError(assignNew.getLine(), assignNew.getColumn(), "Local variables may not be declared transient");
			}
		}
		
		if(isClassLevel && this.currentScopeFrame.getClassDef().isEnumSubClass){
			if(am != AccessModifier.PRIVATE){
				this.raiseError(assignNew.getLine(), assignNew.getColumn(), "fields of enum elements may only be private");
			}
		}
		
		assignNew.accessModifier=am;
		
		String prefix = assignNew.prefix;
		
		if(prefix != null)
		{
			if(!this.currentScopeFrame.isClass())
			{
				this.raiseError(assignNew.getLine(), assignNew.getColumn(), "Variable definitions with accesor definitions are only applicable to class level variables");
				return null;
			}
			else if(assignNew.isFinal && ("~".equals(prefix) || "+".equals(prefix) ) ){
				this.raiseError(assignNew.getLine(), assignNew.getColumn(), String.format("Cannot autodefine setter for field %s that has been declared val", varname));
				return null;
			}
		}
		
		boolean existsAlready = this.currentScopeFrame.hasVariable(this.currentScopeFrame, varname, false, false, true);
		if(existsAlready && (assignNew.isInsistNew() || this.currentScopeFrame.isClass()|| this.currentScopeFrame.paThisIsModule) && !assignNew.isautogenerated){//wtf...?
			this.raiseError(assignNew.getLine(), assignNew.getColumn(), "Variable " + varname + " has already been defined in current scope");
			return null;
		}
		
		
		if(assignNew.isFinal && assignNew.expr == null  ){
			if(this.currentScopeFrame.isClass() && !assignNew.isautogenerated && existsAlready){
				this.raiseError(assignNew.getLine(), assignNew.getColumn(), "Variable " + varname + " has already been defined in current scope");
				return null;
			}
			else if(this.currentScopeFrame.paThisIsModule){
				this.raiseError(assignNew.getLine(), assignNew.getColumn(), "Variable " + varname + " has been decard val at top level and so must have a value assigned to it");
				return null;
			}
		}
		
		if(!assignNew.isShared){
			Type tt = assignNew.getTaggedType();
			if(tt instanceof NamedType) {
				NamedType nt = (NamedType)tt;
				ClassDef cd = nt.getSetClassDef();
				if(cd != null) {
					Annotations annoots = cd.getAnnotations();
					if(annoots != null) {
						for( Annotation annot : annoots.annotations) {
							if(const_sharedAnnot.equals(annot.getTaggedType() )) {
								assignNew.isShared=true;
								/*Annotation annotx = new Annotation(assignNew.getLine(), assignNew.getColumn(),"com.concurnas.lang.Shared" , null, null, new ArrayList<String>(0));
								if(assignNew.annotations == null) {
									assignNew.annotations = new Annotations();
								}
								assignNew.annotations.annotations.add(annotx);

								assignNew.annotations.setUsedAt(ElementType.FIELD);
								assignNew.annotations.accept(this);*/
							}
						}
					}
				}
			}
		}
		
		if(this.currentScopeFrame.paThisIsModule && assignNew.isShared) {
			this.hasSharedModuleLevelVars = assignNew.expr != null;
			assignNew.isModuleLevelShared = true;
		}
		
		Type retType = null;
		
		TypeAndLocation tal = null;
		if(null!= assignNew.type)
		{//defined a type so certainly new
			//ensure it resolves to something, anything!
			Type lhsType = (Type)assignNew.type.accept(this);
			
			
			if(lhsType == null){
				return null;
			}
			

			if(assignNew.isLazy) {
				lhsType = Utils.convertToLazyType(lhsType);
			}
			
			retType = lhsType;
			
			//lhsType.accept(this);

			if(null != assignNew.gpuVarQualifier) {
				if(assignNew.gpuVarQualifier == GPUVarQualifier.CONSTANT) {
					if(!this.currentlyInFuncDef.empty()) {
						this.raiseError(assignNew.getLine(), assignNew.getColumn(), "GPU constant variable: " +varname +" may only be defined at top level");
					}
				}else {
					if(this.currentlyInFuncDef.empty() || this.currentlyInFuncDef.peek().isGPUKernalOrFunction == null) {
						this.raiseError(assignNew.getLine(), assignNew.getColumn(), "Variable " + varname + " can only be qualified with " + assignNew.gpuVarQualifier + " inside a gpu kernel or function");
					}
					//retType
				}
			}
			
			lhsType.setAutoGenenrated(assignNew.isautogenerated);
			
			
			if(null != TypeCheckUtils.checkSubType(this.ers, ScopeAndTypeChecker.getLazyNT(), lhsType) && assignNew.eq == null) {
				//eq is null but lhs is a lazy type, we must set to it
				int line = assignNew.getLine();
				int col = assignNew.getColumn();
				
				Type tt = ((NamedType)lhsType).getGenTypes().get(0);
				Pair<Type, Expression> conv = convertExpressionToNewLazy(line, col, tt, tt, null, false/*, false*/);
				
				if(null != conv) {
					assignNew.expr = conv.getB();
					assignNew.eq = AssignStyleEnum.EQUALS;
				}
			}
			
			
			
			if(assignNew.eq == null)
			{//there is no equals cos it's a new thingy: a String;
				if(this.currentScopeFrame.hasVariable(this.currentScopeFrame, varname, false, lhsType.getAutoGennerated(), true))
				{
					this.raiseError(assignNew.getLine(), assignNew.getColumn(), "Variable " + varname + " has already been defined in current scope");
				}
				else
				{
					if(!lhsType.getAutoGennerated() && (Type)lhsType instanceof FuncType && null != this.getMatchingFuncNames(null, this, varname, assignNew.getLine(), assignNew.getColumn(), false, true, null, null).getA())
					{
						this.raiseError(assignNew.getLine(), assignNew.getColumn(), String.format("Method reference variable '%s' hides existing named method or method reference definition", varname));
					}
					
					assignNew.isReallyNew=true;
					
					if( null != assignNew.gpuVarQualifier) { lhsType.setGpuMemSpace(assignNew.gpuVarQualifier); }
					tal = createTypeAndLocationVarHolder(assignNew.getLine(), assignNew.getColumn(), (Type)lhsType, assignNew.isFinal, assignNew.accessModifier, false, assignNew.isTransient, assignNew.isShared, assignNew.localClassImportedField, false, assignNew.isOverride, assignNew.isInjected);
					this.currentScopeFrame.setVariable(this.currentScopeFrame, varname, tal, false, this.level, assignNew.annotations, true);
					
					if( TypeCheckUtils.getRefLevels(lhsType) >= 1){
						ClassDef lcls = ((NamedType)lhsType).getSetClassDef();
						if(!lcls.isInstantiable()){//e.g. if ref
							this.raiseError(assignNew.getLine(), assignNew.getColumn(), String.format("Cannot create ref of type: %s as it is uninstantiable", lhsType));
						}
					}
				
				}
			}
			else if(assignNew.eq != AssignStyleEnum.EQUALS)
			{//new things cannot have a Int += 4!
				this.raiseError(assignNew.getLine(), assignNew.getColumn(), String.format("Assignment type: %s not permitted for new variable", assignNew.eq));
				return null;
			}
			else
			{//='s so must be a rhs
				Expression rhsExpr = assignNew.expr;
				if ( null != rhsExpr)
				{
					if(this.currentScopeFrame.isAnnotation){
						validizeAnnotationUseage(rhsExpr);
					}
					
					Utils.inferAnonLambda(this, (Node)rhsExpr, lhsType);
					
					Boolean cannotAssign = null;
					
					this.maskErrors(true);
					Type rhsType = (Type)rhsExpr.accept(this);
					ArrayList<CapMaskedErrs> caps = this.getmaskedErrors();
					if(!caps.isEmpty()) {
						this.applyMaskedErrors(caps);
					}else {
						
						Type convertRetTo = TypeCheckUtils.canConvertRHSToArgLessLambda(this, this.ers, lhsType, rhsType);
						if(null != convertRetTo) {
							Pair<Type, Expression> conv = convertExprToArgLessLambda(assignNew.getLine(), assignNew.getColumn(), convertRetTo, rhsType, rhsExpr);
							rhsType = conv.getA();
							assignNew.expr = conv.getB();
						}
						
						if(null != TypeCheckUtils.checkSubType(this.ers, ScopeAndTypeChecker.getLazyNT(), lhsType)) {
							//so check rhs value to lazy value needed for type...
							Type llhsT = ((NamedType)lhsType).getGenTypes().get(0);
							if(null != TypeCheckUtils.checkSubType(this.ers, llhsT, rhsType )) {
								//now convert to new Lazy...
								Pair<Type, Expression> conv = convertExpressionToNewLazy(assignNew.getLine(), assignNew.getColumn(), llhsT, rhsType, assignNew.expr, false/*, false*/);
								if(null != conv) {
									rhsType = conv.getA();
									assignNew.expr = conv.getB();
								}
							}
						}
						
						
						
					} 
					
					rhsType = overrideVarNull(lhsType, rhsType, rhsExpr);
					if(null != rhsType) {
						if(assignNew.gpuVarQualifier == null) {
							assignNew.gpuVarQualifier = rhsType.getGpuMemSpace();
						}else if(rhsType.getGpuMemSpace() != null && rhsType.getGpuMemSpace() != assignNew.gpuVarQualifier){
							this.raiseError(assignNew.getLine(), assignNew.getColumn(), String.format("GPU memory space mismatch, variables must be declared in the same memory space: %s <> %s", assignNew.gpuVarQualifier, rhsType.getGpuMemSpace()));
						}
						
						//null check:
						if(!assignNew.skipNullableCheck && !TypeCheckUtils.isNullable(lhsType) && TypeCheckUtils.isNullable(rhsType)) {
							if(!TypeCheckUtils.eitherPointer(lhsType, rhsType)) {
								this.raiseError(assignNew.getLine(), assignNew.getColumn(), "Assingment can be null, but assignment type is not nullable");
							}
						}
					}
					
					if(null == cannotAssign) {
						Type tt = TypeCheckUtils.checkAssignmentCanBeDone(this, AssignStyleEnum.EQUALS, lhsType, rhsType, assignNew.getLine(), assignNew.getColumn(), rhsExpr.getLine(), rhsExpr.getColumn(), "");
						cannotAssign = null == tt;
					}
					
					if(rhsType instanceof FuncType && ((FuncType)rhsType).getLambdaDetails() !=null && retType!=null && retType instanceof FuncType ){
						((FuncType)retType).setLambdaDetails(((FuncType)rhsType).getLambdaDetails()); //JPT: this feels a bit dirty here, shouldnt the lambda deltails come form the FuncType on the left hand side?
					}
					
					if(!assignNew.skipNullableCheck && null != rhsType && !assignNew.isShared) {
						NullStatus ns = rhsType.getNullStatus();
						if(ns != NullStatus.UNKNOWN) {
							Pair<String, Boolean> key = new Pair<String, Boolean>(assignNew.name, assignNew.isClassField);
							nullableOverwriteType.peek().put(key, ns);
						}
					}
					
					
					if(null == rhsType || rhsType instanceof ModuleType || cannotAssign )
					{//already errored so we can set the lhs to be that which is defined on the lhs
						if(rhsType instanceof ModuleType)
						{
							this.raiseError(assignNew.getLine(), assignNew.getColumn(), String.format("%s", rhsType));
						}
						else if(rhsType != null && lhsType!=null)
						{
							this.raiseError(assignNew.getLine(), assignNew.getColumn(), String.format("Type mismatch: cannot convert from %s to %s", rhsType, lhsType));
						}
						
						if(!(lhsType instanceof PrimativeType && ((PrimativeType)lhsType).type == PrimativeTypeEnum.VOID))
						{//if void type done set the var
							if(!lhsType.getAutoGennerated() && lhsType instanceof FuncType && null != this.getMatchingFuncNames(null, this, varname, assignNew.getLine(), assignNew.getColumn(), false, true, null, null))
							{
								this.raiseError(assignNew.getLine(), assignNew.getColumn(), String.format("Method reference variable '%s' hides existing named method or method reference definition", varname));
							}
							assignNew.isReallyNew=true;

							if( null != assignNew.gpuVarQualifier) { lhsType.setGpuMemSpace(assignNew.gpuVarQualifier); }
							tal = createTypeAndLocationVarHolder(assignNew.getLine(), assignNew.getColumn(),lhsType, assignNew.isFinal, assignNew.accessModifier, false, assignNew.isTransient, assignNew.isShared, assignNew.localClassImportedField, true, assignNew.isOverride, assignNew.isInjected);
							this.currentScopeFrame.setVariable(this.currentScopeFrame, varname, tal, true, this.level, assignNew.annotations, true);
						}
						return null;
					}
				}
				
				//horray types match
				if(this.currentScopeFrame.hasVariable(this.currentScopeFrame, varname, false,  lhsType.getAutoGennerated(), true))
				{//var already exists
					this.raiseError(assignNew.getLine(), assignNew.getColumn(), "Variable " + varname + " has already been defined in current scope");
					return null;
				}
				else
				{//totally new var
					/*if(!retType.getAutoGennerated() && retType instanceof FuncType && null != this.getMatchingFuncNames( varname, assignNew.getLine(), assignNew.getColumn(), false, true))
					{
						this.raiseError(assignNew.getLine(), assignNew.getColumn(), String.format("Method reference variable '%s' hides existing named method or method reference definition", varname));
					}*/
					
					
					assignNew.isReallyNew=true;

					if( null != assignNew.gpuVarQualifier) { retType.setGpuMemSpace(assignNew.gpuVarQualifier); }
					tal = createTypeAndLocationVarHolder(assignNew.getLine(), assignNew.getColumn(),retType, assignNew.isFinal, assignNew.accessModifier, false, assignNew.isTransient, assignNew.isShared, assignNew.localClassImportedField, true, assignNew.isOverride, assignNew.isInjected);
					this.currentScopeFrame.setVariable(this.currentScopeFrame, varname, tal, null != rhsExpr, this.level, assignNew.annotations, true);
				}
			}
		}
		else if(assignNew.isNewWithoutTypeDefined() || !existsAlready)
		{//NEW so type MUST be infered from rhs
			if(assignNew.eq != AssignStyleEnum.EQUALS)
			{//new things cannot have a += 4!
				this.raiseError(assignNew.getLine(), assignNew.getColumn(), String.format("Assignment type: %s not permitted for new variable", assignNew.eq));
				return null;
			}
			Expression rhsExpr = assignNew.expr;
			if ( null == rhsExpr)
			{
				this.raiseError(assignNew.getLine(), assignNew.getColumn(), "Expression must be defined for variable");
				return null;
			}
			
			Type rhsType = (Type)rhsExpr.accept(this);
			int existingRefLevels = TypeCheckUtils.getRefLevels(rhsType);
			
			if(rhsType != null)
			{//thing above will throw errors as approperiate if this is null
				if(!rhsType.getAutoGennerated() && (Type)rhsType instanceof FuncType )
				{
					Pair<HashSet<TypeAndLocation>,Boolean> atching = this.getMatchingFuncNames(null, this, varname, assignNew.getLine(), assignNew.getColumn(), false, true, null, null);
					
					if(null != atching && atching.getA() != null){
						this.raiseError(assignNew.getLine(), assignNew.getColumn(), String.format("Method reference variable '%s' hides existing named method or method reference definition", varname));
					}
				}
				
				if(assignNew.refCnt>0 ){
					int x = 0;
					while(x++ < assignNew.refCnt - existingRefLevels){
						rhsType = new NamedType(assignNew.getLine(), assignNew.getColumn(), rhsType);
					}
					rhsType.accept(this);
				}
				
				assignNew.isReallyNew=true;

				if( null != assignNew.gpuVarQualifier) { rhsType.setGpuMemSpace(assignNew.gpuVarQualifier); }
				tal = createTypeAndLocationVarHolder(assignNew.getLine(), assignNew.getColumn(), rhsType, assignNew.isFinal, assignNew.accessModifier, false, assignNew.isTransient, assignNew.isShared, assignNew.localClassImportedField, true, assignNew.isOverride, assignNew.isInjected);
				this.currentScopeFrame.setVariable(this.currentScopeFrame, varname, tal, null != rhsExpr, this.level, assignNew.annotations, true);
			}
			if(rhsType != null && rhsType.getTaggedType() != null) {
				assignNew.type = rhsType;
			}else {
				assignNew.type = null;
			}
			
			retType = rhsType;
		}
		else //this.currentScopeFrame.hasVariable(varname, false)
		{//just an assignment operation
			TypeAndLocation lhsTypeAlreadyDefined = this.currentScopeFrame.getVariable(this.currentScopeFrame, varname);
			
			Expression rhsExpr = assignNew.expr;
			if ( null == rhsExpr)
			{
				this.raiseError(assignNew.getLine(), assignNew.getColumn(), "Expression must be defined for variable");
				return null;
			}
			Type rhsType = (Type)rhsExpr.accept(this);//next line throws errors if incompatiblke types
			Type already = lhsTypeAlreadyDefined.getType();
			Type checked = TypeCheckUtils.checkAssignmentCanBeDone(this, assignNew.eq, already, rhsType, assignNew.getLine(), assignNew.getColumn(), rhsExpr.getLine(), rhsExpr.getColumn(), "");
			
			if(!TypeCheckUtils.isNullable(already) && TypeCheckUtils.isNullable(rhsType)) {//null check:
				this.raiseError(assignNew.getLine(), assignNew.getColumn(), "Assingment can be null, but assignment type is not nullable");
			}
			
			retType = checked;
		}
		
		if(retType == null)
		{
			return null;
		}else if(assignNew.isShared && TypeCheckUtils.isPurePrimativeNonArray(retType)) {
			this.raiseError(assignNew.getLine(), assignNew.getColumn(), "shared variables of primative type must also be of array type");
		}
		
		if(TypeCheckUtils.hasRefLevelsAndIsLocked(retType)){//uh oh, were going to have to operate...
			NamedType asNamed = retType == null?null:((NamedType)retType).copyTypeSpecific();
			
			
			asNamed.setLockedAsRef(false);
			retType = asNamed;
		}
		
		if(prefix != null && !existsAlready && !assignNew.isAnnotationField){
			addGetterSetter(prefix, varname, retType, assignNew.annotations, assignNew.getLine(), assignNew.getColumn(), false);
			
			assignNew.origprefix = assignNew.prefix;
			assignNew.prefix = null;
		}
		
		if(isClassLevel){
			assignNew.isClassField = true;
		}
		
		boolean createEvenIfOverriden = validateOverrideVar(assignNew.getLine(), assignNew.getColumn(), assignNew.isOverride, isClassLevel, varname, retType);
		
		if(createEvenIfOverriden && tal != null) {
			((LocationClassField)tal.getLocation()).isOverride = false;
		}
		
		return null;//retType;
	}
	
	private TypeAndLocation filterInaccessable(ClassDef currentCD, TypeAndLocation supvar) {
		if(null == supvar) {
			return null;
		}
		Location loc = supvar.getLocation();
		if(loc instanceof LocationClassField) {
			Type tt = ((LocationClassField)loc).ownerType;
			if(tt instanceof NamedType) {
				if(!isAccesible(loc.getAccessModifier(), (NamedType)tt, currentCD, true, this.getFullyDottedPackage())){
					return null;
				}
			}
		}
		return supvar;
	}
	
	private boolean validateOverrideVar(int line, int col, boolean isOverride, boolean isDefinedatClassLevel, String varname, Type verType) {
		if(isOverride) {
			if(!isDefinedatClassLevel) {
				this.raiseError(line, col, "The override keyword can only be used with fields at class level");
			}else {
				//at class level
				ClassDef currentCD = this.currentlyInClassDef.peek();
				
				boolean fromTrait = true;
				TypeAndLocation supvar = null;
				List<NamedType> items = new NamedType(currentCD).getResolvedTraitsAsNamed();
				for(NamedType trait : items) {
					supvar = filterInaccessable(currentCD, trait.getVariable(varname));
					if(null != supvar) {
						Location loc = supvar.getLocation();
						if(loc instanceof LocationClassField) {
							Type tt = ((LocationClassField)loc).ownerType;
							if(tt instanceof NamedType) {
								ClassDef origin = ((NamedType)tt).getSetClassDef();
								if(null != origin && !origin.isTrait) {
									fromTrait=false;
								}
							}
						}
						break;
					}
				}
				
				if(null == supvar) {
					fromTrait=false;
					NamedType supType = currentCD.getSuperAsNamedType(0, 0);
					supvar = filterInaccessable(currentCD, supType.getVariable(varname));
					
					if(null != supvar) {
						Location loc = supvar.getLocation();
						if(loc instanceof LocationClassField) {
							Type ot = ((LocationClassField)loc).ownerType;
							if(ot instanceof NamedType) {
								ClassDef cd = ((NamedType) ot).getSetClassDef();
								if(null != cd) {
									fromTrait = cd.isTrait;
								}
							}
						}
					}
					
				}
				
				if(null == supvar) {
					this.raiseError(line, col, String.format("Field: %s can only be overriden if they exist and are accessible in a superclass or composing trait of class: %s", varname, currentCD));
				}else if(!supvar.getType().equals(verType)) {
					this.raiseError(line, col, String.format("Overriden field: %s must be of type: %s. It is of type: %s", varname, supvar.getType(), verType));
				}
				return fromTrait;
			}
		}else if(isDefinedatClassLevel) {
			//check if it exists at trait level, if it does then it must be overriden
			
			TypeAndLocation supvar = null;
			ClassDef currentCD = this.currentlyInClassDef.peek();
			List<NamedType> items = new NamedType(currentCD).getResolvedTraitsAsNamed();
			for(NamedType trait : items) {
				supvar = trait.getVariable(varname);
			}
			
			if(null != supvar) {
				this.raiseError(line, col, String.format("Overriden trait field: %s must be explicitly overriden with the 'override' keyword in %s: %s as it overrides a trait field", varname, currentCD.isTrait?"trait":"class", currentCD));
			}
		}
		return false;
	}
	
	private void addGetterSetter(String prefix, String varname, Type retType, Annotations annots, int line, int col, boolean viaSuper) {
		ClassDef cd = this.currentlyInClassDef.peek();
		
		if(prefix.equals("-") || prefix.equals("~"))
		{//get
			if(!FunctionGenneratorUtils.hasGetterOrSetter(cd, varname, this.getErrorRaiseableSupression(), retType, true, line, col)) {
				Annotations annotationsForGetter = extractAnnotationsForGS(annots, "getter"); 
				FunctionGenneratorUtils.addGetter(this.ers, this, cd, varname, retType, line, col, annotationsForGetter, viaSuper);
			}
		}
		
		if(prefix.equals("+") || prefix.equals("~"))
		{//TODO: when erasure problem is solved we will be able to have setter for type:::, type::, type:, type. Now we just have type::: and type
			if(!FunctionGenneratorUtils.hasGetterOrSetter(cd, varname, this.getErrorRaiseableSupression(), retType, false, line, col)) {
				Annotations annotationsForSetter = extractAnnotationsForGS(annots, "setter"); 
				FunctionGenneratorUtils.addSetter(this.ers, this, cd, varname, retType, line, col, annotationsForSetter, viaSuper);
									
				if( TypeCheckUtils.hasRefLevels(retType) )
				{//step down the lot of them in here
					Type retTypeAsNonRef = TypeCheckUtils.getRefType(retType);
					FunctionGenneratorUtils.addSetter(this.ers, this, cd, varname, retTypeAsNonRef, line, col, annotationsForSetter, viaSuper);
				}
			}
			
		}
	}

	private Annotations extractAnnotationsForElement(Annotations annots, String loc){
		Annotations anotsRet = null; 
		if(annots != null){
			ArrayList<Annotation> annotsForGetter = new ArrayList<Annotation>();
			for(Annotation annot : annots.annotations){
				ArrayList<String> newLocs = new ArrayList<String>();
				for(String avaiLoc : annot.locations){
					if(!avaiLoc.equals(loc)){
						newLocs.add(avaiLoc);
					}
				}
				if(!newLocs.isEmpty()){
					Annotation cop = (Annotation)annot.copy();
					cop.locations = newLocs;
					annotsForGetter.add(cop);
				}
				
			}
			if(!annotsForGetter.isEmpty()){
				anotsRet = new Annotations(annots.getLine(), annots.getColumn(), annotsForGetter);
			}
		}
		
		return anotsRet;
	}
	
	private Annotations extractAnnotationsForElement(Annotations annots, String loc, boolean includeIfEmpty){
		Annotations anotsRet = null; 
		if(annots != null){
			ArrayList<Annotation> annotsForGetter = new ArrayList<Annotation>();
			for(Annotation annot : annots.annotations){
				if(annot.locations.contains(loc) || (includeIfEmpty && annot.locations.isEmpty())){
					Annotation cop = (Annotation)annot.copy();
					cop.locations = new ArrayList<String>();
					cop.locations.add(loc);
					annotsForGetter.add(cop);
				}
			}
			if(!annotsForGetter.isEmpty()){
				anotsRet = new Annotations(annots.getLine(), annots.getColumn(), annotsForGetter);
			}
		}
		
		return anotsRet;
	}
	
	private Annotations extractAnnotationsForGS(Annotations annots, String loc){
		Annotations anotsRet = null; 
		if(annots != null){
			ArrayList<Annotation> annotsForGetter = new ArrayList<Annotation>();
			for(Annotation annot : annots.annotations){
				if(annot.locations.contains(loc)){
					Annotation cop = (Annotation)annot.copy();
					cop.locations = new ArrayList<String>();
					cop.locations.add(loc);
					annotsForGetter.add(cop);
				}
			}
			if(!annotsForGetter.isEmpty()){
				anotsRet = new Annotations(annots.getLine(), annots.getColumn(), annotsForGetter);
			}
		}
		
		return anotsRet;
	}
	
	private boolean isMatchingClassName(String as)
	{
		if(!this.currentlyInClassDef.isEmpty())
		{
			for(ClassDef cls : this.currentlyInClassDef)
			{
				if(cls.className.equals(as))
				{
					return true;
				}
			}
		}
		
		return false;
	}
	
	private void validizeAnnotationUseage(Expression expr){//doesnt seem massivly safe todo this, but because it is only called within an annotation scope frame, any accidental tagging will be caught by the constant folder
		if(expr instanceof Annotation){
			((Annotation)expr).validAtThisLocation=true;
		}
		else if(expr instanceof ArrayDef){
			ArrayDef ad = (ArrayDef)expr;
			for(Expression expra : ad.getArrayElements(this)){
				validizeAnnotationUseage(expra);
			}
		}
		/*else if(expr instanceof IfExpr){
			IfExpr ie = (IfExpr)expr;
			validizeAnnotationUseage(ie.op1);
			validizeAnnotationUseage(ie.op2);
		}*/
	}
	
	private Stack<Type> rhsPendingAssignmeng = new Stack<Type>();
	
	public boolean checkFinalVarReassignment(int line, int col, Location loc, String varname, Type lhs, Type rhs, String operation){
		if (loc != null && (loc.isFinal() || isLocationConstant(loc)) ) { 
			int refsLhs = TypeCheckUtils.getRefLevels(lhs); //val a int: = 99; a = 9 //this case is ok
			int refsRhs = TypeCheckUtils.getRefLevels(rhs);
					
			if((currentScopeFrame.hasVariableAssigned(varname) || (loc instanceof LocationClassField && !this.currentScopeFrame.isconstructor) )){
				boolean fail =true;
				if(refsLhs > 0){
					fail=refsLhs<=refsRhs;
				}
				//unless lhs is ref and rhs is not a ref or has less ref levels 
				if(fail){
					this.raiseError(line, col, String.format("Variable %s has been decalred as %s and %s", varname, isLocationConstant(loc)?"constant":"val", operation));
					return true;
				}
			}
		}
		return false;
	}
	
	@Override
	public Object visit(AssignMulti multiAssign) {
		for(Assign ass : multiAssign.assignments) {
			if(ass.isLazy) {
				this.raiseError(ass.getLine(), ass.getColumn(), "multi assign variables may not be lazy");
			}
			
			ass.accept(this);
		}
		
		return null;
	}
	
	private boolean validateInjectAssignLocation(Assign ass) {
		if(ass.isInjected) {
			if(!this.currentScopeFrame.isClass()) {
				this.raiseError(ass.getLine(), ass.getColumn(), "Only class level fields may be injected");
				return false;
			}else {
				
				/*if(!this.currentlyInClassDef.isEmpty()) {
					ClassDef cd = this.currentlyInClassDef.peek();
					if(cd.isLocalClass || cd.isAnonClass) {
						this.raiseError(ass.getLine(), ass.getColumn(), "local and anonymous classes may not have fields marked with inject");
					}
				}*/
				
				ClassDef top = this.currentlyInClassDef.peek();
				if(top.isAnonClass || top.isLocalClass) {
					this.raiseError(ass.getLine(), ass.getColumn(), "Anonymous and local classes may not have injectable fields");
					return false;
				}
				
				return true;
			}
		}
		return false;
	}
	
	/*@Override
	public Object visit(AssignExisting assignExisting) {
		assignExisting.isModuleLevelShared = false;
		Object ret = visitAE(assignExisting);
		if(this.currentScopeFrame.paThisIsModule && assignExisting.isReallyNew && assignExisting.isShared && assignExisting.getRHSExpression() != null) {
			this.hasSharedModuleLevelVars = true;//TODO: assignExisting.isReallyNew is sset on next compilation cycle, so this approach means at least 2 cycles are required...
			assignExisting.isModuleLevelShared = true;
		}
		return ret;
	}*/
	
	private void setForceCastIfVarNull(Expression expr, Type as) {
		if(expr instanceof VarNull) {
			((VarNull)expr).forceCheckCast = as;
		}
	}
	
	@Override
	public Object visit(AssignExisting assignExisting) {
		if(this.currentScopeFrame.isAnnotation){
			validizeAnnotationUseage(assignExisting.expr);
		}
		
		ArrayList<Type> elementTypes = vectorizeElementsIfApproperiate(assignExisting, true);
		
		if(elementTypes.isEmpty()) {
			elementTypes = null;
		}
		
		boolean addInjectAnnotation = validateInjectAssignLocation(assignExisting);
		
		Type rhs = elementTypes!=null?elementTypes.get(1):(Type)assignExisting.expr.accept(this);//save a bit of time incase the type has already been derived
		
		if(null != rhs){
			//BUG: cannot accept rhs (again?) cos for some types which are rhs of dot dependant this messes up their set type
			//rhs.accept(this);
			assignExisting.expr.setTaggedType(rhs);//TODO: is this right?
			
			rhs = (Type)rhs.copy();
			rhs.setOrigonalGenericTypeUpperBound(null);
		}
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> rhsvec = vectorizedOperator(rhs);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = rhsvec.getA();
		if(vectorized != null) {
			rhs = rhsvec.getB();
		}
		
		assignExisting.isAnnotationField=this.currentScopeFrame.isAnnotation;
		
		if(addInjectAnnotation) {
			if(assignExisting.annotations == null){
				assignExisting.annotations = new Annotations();
			}else {
				if(!assignExisting.annotations.hasAnnotation(const_InjectAnnotationStr)) {
					assignExisting.annotations.annotations.add((Annotation)const_InjectAnnotation.copy());
				}
			}
		}
		
		if(assignExisting.annotations != null){
			
			if(currentScopeFrame.isClass()){
				for(Annotation annot : assignExisting.annotations.annotations){
					annot.location = Annotation.AnnotationLocation.FIELD;
				}
			}
			assignExisting.annotations.setUsedAt(ElementType.FIELD);
			assignExisting.annotations.accept(this);
			if(!assignExisting.isReallyNew){//not very good, first time round this will throw an error potentially unecisarily
				this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), "annotations can only be defined on new variable assignments");
			}
		}

		//assignExisting.isReallyNew = false;
		
		tagFieldLevelBlock(assignExisting.expr);
		
		Type lhs = null;
		
		if(TypeCheckUtils.isVoid(rhs)){//err arleady
			 this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), "void is not an instantiable type");
		}
		
		if(!TypeCheckUtils.isValidType(this, rhs, assignExisting.getLine(), assignExisting.getColumn())){
			//return null;
			rhs = const_void_thrown;
		}
		
		//TODO: add check for bad: ar = [1,2,3,4]; ar.length = 9:: The final field array.length cannot be assigned
		
		Expression assignee = assignExisting.assignee;
		
		if( assignee instanceof AsyncRefRef ){//MHA: splice
			//sdf[1]  := 9
			//this gets incorrectly parsed as sdf[1]: = 9//so we splice it back here to the right form here...
			AsyncRefRef arr = (AsyncRefRef)assignee;
			assignExisting.assignee = (arr).b;
			assignExisting.refCnt = arr.refCntLevels;
			//this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), "The left-hand side of an assignment cannot be a reference");
		}

		if(assignee instanceof RefName){//yuck!
			RefName asT = (RefName)assignee;
			
			if(null != asT.astRedirectforOnChangeNesting){
				assignee = (Expression)asT.astRedirectforOnChangeNesting;
			}
		}
		
		if(assignExisting.eq.isEquals() && !assignExisting.isShared ){
			if(rhs != null) {
				NullStatus ns = rhs.getNullStatus();
				if(ns != NullStatus.UNKNOWN) {
					Expression opon = assignExisting.assignee;
					
					if(opon instanceof DotOperator) {//this.thing
						DotOperator dop = (DotOperator)opon;
						ArrayList<Expression> elms = dop.getElements(this);
						int sz = elms.size();
						if(sz == 2) {
							Expression last = elms.get(1);
							Expression penul = elms.get(0);
							if(penul instanceof RefThis) {
								if(last instanceof RefName) {
									opon = last;
								}
							}
						}
					}
					
					if(opon instanceof RefName) {
						RefName asrefname = (RefName)opon;
						
						if(!(asrefname.resolvesTo != null && asrefname.resolvesTo.getLocation() != null && asrefname.resolvesTo.getLocation().isShared())) {
							Pair<String, Boolean> key = makeRefNameTypeOverrideKey(asrefname);
							if(!this.nullableOverwriteType.isEmpty() && key != null) {
								nullableOverwriteType.peek().put(key, ns);
							}
						}
					}
				}
			}
		}
		
		
		if(assignee instanceof RefName)
		{//it may already exist... so go find it!
			rhs = (Type)rhs.copy();
			
			RefName lhsRefName = (RefName)assignee;
			lhsRefName.supressUnassign=true;
			Pair<String, TypeAndLocation> talx = getVariable(lhsRefName.name, assignExisting.getLine(), assignExisting.getColumn(), this.currentScopeFrame.isClass());
			this.currentScopeFrame.setVariable(lhsRefName.bytecodename==null?lhsRefName.name:lhsRefName.bytecodename);
			
			TypeAndLocation tal;
			if(talx != null){
				lhsRefName.bytecodename = talx.getA();
				tal = talx.getB();
			}else{
				tal = null;
			}
			
			
			//tal = null==tal?null:tal.copy();
			lhs = null==tal?null: tal.getType();
			filterInOutOnNewAssigment(lhs);

			Location loc = null==tal?null:tal.getLocation();
			
			if(loc != null && loc.redirectExtFuncOrWithExpr != null){
				assignExisting.assignee = DotOperator.buildDotOperator(assignee.getLine(), assignee.getColumn(), new RefName(loc.redirectExtFuncOrWithExpr), (RefName)((RefName)assignee).copy());
				lhs= (Type)assignExisting.assignee.accept(this);
				//refName.astRedirect
			}
			
			if(!assignExisting.ignoreFinalCheck){
				if (loc != null && (loc.isFinal() || isLocationConstant(loc)) ) {
					if(checkFinalVarReassignment(assignExisting.getLine(), assignExisting.getColumn(), loc, lhsRefName.name, lhs, rhs, "cannot be reassigned")){
						return null;
					}
					currentScopeFrame.setVariableAssigned(lhsRefName.name);
				}
			}
			
			
			if(null != lhs){
				if(this.currentScopeFrame.isClass())
				{//note that class Super(x int){} class Child extends Super(x int); // Child extends superclass, so ignore var if it already exists and its not from this current scopeframe
					if(loc instanceof LocationClassField)
					{
						LocationClassField lcf = (LocationClassField)loc;
						if(!lcf.getOwner().equals(gettCurrentClassOwner()))
						{
							lhs=null;
						}
					}
				}
				
				rhs = overrideVarNull(lhs, rhs, assignExisting.expr);
				Utils.inferAnonLambda(this, (Node)assignExisting.expr, lhs);
			}

			assignExisting.isReallyNew = false;//reset this in case it was set below
			if(null == lhs || lhs==const_void_thrown)
			{//it's new! but the type has not been stated
				if(!assignExisting.eq.isEquals())
				{
					this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), String.format("Assignment type not permitted for new variable '%s'", lhsRefName.name));
					return null;
				}
				
				if(rhs instanceof VarNull)
				{
					//this.raiseError(assignExisting.getLine(),assignExisting.getColumn(), "Ambiguous type declaration of null");
					int levels = rhs.getArrayLevels();
					rhs = new NamedType(assignExisting.getLine(), assignExisting.getColumn(), new ClassDefJava(java.lang.Object.class));
					rhs.setArrayLevels(levels);
				}
				/*else if(TypeCheckUtils.hasRefLevels(rhs) && TypeCheckUtils.getRefType(rhs) instanceof VarNull){
					rhs = new NamedType(0, 0, new NamedType(assignExisting.getLine(), assignExisting.getColumn(), new ClassDefJava(java.lang.Object.class)));
				}*/
				else{//could be VarNull::
					int refLevels = TypeCheckUtils.getRefLevels(rhs);
					if(refLevels > 0 && TypeCheckUtils.getRefType(rhs) instanceof VarNull){
						int levels = rhs.getArrayLevels();
						rhs = TypeCheckUtils.makeRef(new NamedType(assignExisting.getLine(), assignExisting.getColumn(), new ClassDefJava(java.lang.Object.class)), refLevels);
						rhs.setArrayLevels(levels);
						assignExisting.expr.setTaggedType(rhs);
						((NamedType)rhs).setLockedAsRef(true);
						//lhs = rhs;
					}
				}
				
				if(null != rhs && !rhs.getAutoGennerated() &&  rhs instanceof FuncType && null != this.getMatchingFuncNames(null, this, lhsRefName.name, assignExisting.getLine(), assignExisting.getColumn(), false, true, null, null).getA())
				{
					this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), String.format("Method reference variable '%s' hides existing named method or method reference definition", lhsRefName.name));
				}
				
				if(null != rhs)
				{
					rhs = rhs.getSelfOrElectChoice();
				}
				
				
				AccessModifier am = null;
				if(this.currentScopeFrame.paThisIsModule){
					am = AccessModifier.PRIVATE;
				}
				else if(this.currentScopeFrame.isClass()){
					am = this.currentScopeFrame.getClassDef().isEnumSubClass? AccessModifier.PRIVATE : AccessModifier.PROTECTED;
				}
				
				int rhsRefCnt = TypeCheckUtils.getRefLevelsIfLockedAsRef(rhs);
				int lockedRefLevels = rhsRefCnt;
				Type origRhs = (Type)rhs.copy();
				
				if( !(rhsRefCnt>0) || (assignExisting.refCnt>=0)  ){
					
					rhsRefCnt = TypeCheckUtils.getRefLevels(rhs);
					if(assignExisting.refCnt>rhsRefCnt){//add levels
						
						rhs = TypeCheckUtils.getRefTypeToLocked(rhs);
						rhsRefCnt = TypeCheckUtils.getRefLevels(rhs);
						int addRefLevels = assignExisting.refCnt>0? assignExisting.refCnt : rhsRefCnt;
						
						int x = 0;
						while(x++ < addRefLevels - rhsRefCnt){
							rhs = new NamedType(assignExisting.getLine(), assignExisting.getColumn(), rhs);
						}
						if(addRefLevels>0){
							rhs.accept(this);
						}
						
					}
					else if( assignExisting.refCnt<rhsRefCnt && (lockedRefLevels ==0 || lockedRefLevels > rhsRefCnt) ){//remove levels //assignExisting.refCnt!= 0 &&
						TypeCheckUtils.assertRefIsGettable(this, assignExisting.getLine(), assignExisting.getColumn(), origRhs, assignExisting.refCnt);
						
						int escp = rhsRefCnt-assignExisting.refCnt;
						int n=0;
						while(n < escp){
							rhs = ((NamedType)rhs).getGenTypes().get(0);//TypeCheckUtils.getRefTypes(nextLevel);
							n++;
						}
						if(TypeCheckUtils.isRefArrayGettable(origRhs, assignExisting.refCnt)){
							rhs.setArrayLevels(rhs.getArrayLevels()+1);
						}
						
					}
					//if eq do nothing
				}
				else if(!(assignExisting.refCnt>0) ){ //rhs is ref. - not sure if this works....
					//So a int:= 8; b = a//b is of type int now
					/*NamedType asRef = (NamedType)rhs;
					if(!asRef.getLockedAsRef()){//extract
						rhs = asRef.getGenTypes().get(0);
					}*/
					
					rhs = TypeCheckUtils.getRefTypeToLocked(rhs);
					TypeCheckUtils.checkSubType(this, rhs, origRhs, assignExisting.getLine(), assignExisting.getColumn(), assignExisting.getLine(), assignExisting.getColumn(), false);
					
					//ELSE: //So a int:= 8; b := a//b is of type int: now
				}
				
				
				if(assignExisting.eq != AssignStyleEnum.EQUALS) {
					this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), String.format("Only = may be used for new variable assignment not: %s", assignExisting.eq));
				}
				
				
				if(TypeCheckUtils.hasRefLevelsAndIsLocked(rhs) ){
					NamedType asNamedrhs = rhs == null?null:((NamedType)rhs).copyTypeSpecific();
					
					//asNamedrhs.setLockedAsRef(false);
					TypeCheckUtils.unlockAllNestedRefs(asNamedrhs);
					rhs = asNamedrhs;
				}
				rhs = findAccessaibleTypeIfNotAccesable(rhs);//TODO: really need to use reflection to ensure that this has been declared correctly
								
				assignExisting.isReallyNew = true;//TypeCheckUtils.isValidType(rhs);//rhs needs to be valid


				if(null != assignExisting.gpuVarQualifier) {
					if(assignExisting.gpuVarQualifier == GPUVarQualifier.CONSTANT) {
						if(!this.currentlyInFuncDef.empty()) {
							this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), "GPU constant variable: " +(lhsRefName.bytecodename==null?lhsRefName.name:lhsRefName.bytecodename) +" may only be defined at top level");
						}
					}else {
						if(this.currentlyInFuncDef.empty() || this.currentlyInFuncDef.peek().isGPUKernalOrFunction == null) {
							this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), "Variable " + (lhsRefName.bytecodename==null?lhsRefName.name:lhsRefName.bytecodename )+ " can only be qualified with " + assignExisting.gpuVarQualifier + " inside a gpu kernel or function");
						}
					}
					
					
				}			
				
				filterInOutOnNewAssigment(rhs);
				
				if(assignExisting.isLazy) {
					Pair<Type, Expression> conv = convertExpressionToNewLazy(assignExisting.getLine(), assignExisting.getColumn(), rhs, rhs, assignExisting.expr, false/*, false*/);
					
					if(null != conv) {
						assignExisting.expr = conv.getB();
						assignExisting.isLazy = false;//only conver it once
					}

					rhs = Utils.convertToLazyType(rhs);
				}
				
				if(rhs.getNullStatus() == NullStatus.UNKNOWN) {
					rhs.setNullStatus(NullStatus.NONNULL);
				}
				
				TypeAndLocation taldet = createTypeAndLocationVarHolder(assignExisting.getLine(), assignExisting.getColumn(), rhs, false, am, false, assignExisting.isTransient, assignExisting.isShared, false, true, assignExisting.isOverride, assignExisting.isInjected);//cannot create final varibale via this path (though you can create a new one)

				if(!this.currentlyInFuncDef.empty() && this.currentlyInFuncDef.peek().isGPUKernalOrFunction != null) {
					if(assignExisting.gpuVarQualifier == null) {
						assignExisting.gpuVarQualifier = taldet.getType().getGpuMemSpace();
					}else if(taldet.getType().getGpuMemSpace() != null && taldet.getType().getGpuMemSpace() != assignExisting.gpuVarQualifier){
						this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), String.format("GPU memory space mismatch, variables must be declared in the same memory space: %s <> %s", assignExisting.gpuVarQualifier, taldet.getType().getGpuMemSpace()));
					}
				}
				
				if( null != assignExisting.gpuVarQualifier) { taldet.getType().setGpuMemSpace(assignExisting.gpuVarQualifier); }
				this.currentScopeFrame.setVariable(this.currentScopeFrame, lhsRefName.bytecodename==null?lhsRefName.name:lhsRefName.bytecodename, taldet, null != rhs, this.level, assignExisting.annotations, false);
				lhsRefName.resolvesTo =taldet;
				
				assignExisting.setTaggedType(rhs);
				
				/*int rhsLevels = TypeCheckUtils.getRefLevels(rhs);
				if(assignExisting.refCnt==0 && rhsLevels>0){
					assignExisting.refCnt=rhsLevels;
				}*/
				
				//checkSubType(this, lhs, x, line, column, lc.getA(), lc.getB(), false)
				
				boolean createEvenIfOverriden = validateOverrideVar(assignExisting.getLine(), assignExisting.getColumn(), assignExisting.isOverride, this.currentScopeFrame.isClass(), lhsRefName.name, taldet.getType());
				if(createEvenIfOverriden) {
					((LocationClassField)taldet.getLocation()).isOverride = false;
				}

				setForceCastIfVarNull(assignExisting.expr, rhs);
				return null;
			}
			else if(this.currentScopeFrame.isClass() && this.currentScopeFrame.hasVariable(this.currentScopeFrame, lhsRefName.name, false, false, true))
			{//at class level all are treated as declarations even if thing exists already (in whihch case must be a fail)...
				/* class C() {
				 * x boolean = false;
	 			 * x = false; //error as already declared
	 			 * }
				 */
				this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), String.format("Variable %s has already been defined in current scope", lhsRefName.name));
				return null;
			}
			else if(assignExisting.refCnt>0){
				//e.g. a int:com.concurnas.runtime.ref.Ref
				// a := 9 //this is ok, we want to create a local on the rhs, to overritw the lhs
				int rhsRefLeels = TypeCheckUtils.getRefLevels(rhs);
				int dd = assignExisting.refCnt - rhsRefLeels;
				if(dd > 0){
					int x=0;
					while(x++ < dd){
						rhs = new NamedType(assignExisting.getLine(), assignExisting.getColumn(), rhs);
					}
				}
			}
			
			if(null != assignExisting.gpuVarQualifier) {
				this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), String.format("Qualifier: %s can only be used for new variables", assignExisting.gpuVarQualifier));
			}	
			
			String nnnname = lhsRefName.bytecodename != null ? lhsRefName.bytecodename:lhsRefName.name;
			boolean imporreg = this.hasImportBeenRegistered(nnnname);
			if(!assignExisting.whitelist && ( imporreg || isMatchingClassName(nnnname) ))
			{
				String importedFrom = "";
				if(imporreg){
					RefName rn = new RefName(nnnname);
					this.maskErrors();
					rn.accept(this);
					assignExisting.whitelist = !this.maskedErrors();//was thought to be an override but isnt so white listed
					
					if(!assignExisting.whitelist){
						importedFrom = "imported from: '" + getImportBeenRegistered(nnnname) + "' ";
					}
					
				}
				
				if(!assignExisting.whitelist){
					this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), String.format("variable name '%s' overrides an existing type name %s- this is confusing", nnnname, importedFrom));
				}
			}
			//this.currentScopeFrame.setVariable(this.currentScopeFrame, nnnname, createTypeAndLocationVarHolder(lhs), Modifier.PUBLIC);
			if(!assignExisting.whitelist && lhsRefName.bytecodename==null ){//only set variable if its not imported
				if( null != assignExisting.gpuVarQualifier) { 
					tal.getType().setGpuMemSpace(assignExisting.gpuVarQualifier); 
				}
				this.currentScopeFrame.setVariable(this.currentScopeFrame, nnnname, tal, null != rhs, this.level, assignExisting.annotations, false);
			}else if(lhsRefName.bytecodename!=null && lhsRefName.bytecodename != lhsRefName.name){//messy
				assignExisting.isReallyNew = false;
			}
			lhsRefName.resolvesTo =tal;
			
			boolean isClassLevel=false;
			//if we're assinging to a private module field within a class of that module 
			if(loc != null && (loc instanceof LocationStaticField || loc instanceof LocationClassField) /*&& null==loc.getPrivateStaticAccessorRedirectFuncSetter()*/  && !this.currentlyInClassDef.isEmpty() ){
				Type type = tal.getType();
				
				if(loc instanceof LocationStaticField){
					if(TypeCheckUtils.hasRefLevels(type)){//Use the getter instead
						loc.setPrivateStaticAccessorRedirectFuncGetter(this.getNextPrivateStaticAccessorRedirectFuncName(), nnnname);
					}
					else{
						loc.setPrivateStaticAccessorRedirectFuncSetter(this.getNextPrivateStaticAccessorRedirectFuncName(), nnnname, type);
						if(!assignExisting.eq.isEquals() ){
							loc.setPrivateStaticAccessorRedirectFuncGetter(this.getNextPrivateStaticAccessorRedirectFuncName(), nnnname);
						}
					}
					
				}
				else{//class
					isClassLevel=true;
					LocationClassField lcf = (LocationClassField)loc;
					NamedType creator =  (NamedType)lcf.ownerType;
					ClassDef topCls = this.currentlyInClassDef.peek();
					if(!topCls.equals(creator.getSetClassDef())){//if declard in parent nestor...
						
						if(topCls.isEnumSubClass){//enum subclasses are not really nested, rather they are subclasses of whatever
							if(lcf.getAccessModifier() == AccessModifier.PRIVATE){//thus private is invalid
								this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), String.format("private variable %s is not visible to enum item", nnnname));
							}
						}
						else{
							if(TypeCheckUtils.hasRefLevels(type)){//Use the getter instead
								loc.setPrivateStaticAccessorRedirectFuncGetter(this.getNextPrivateStaticAccessorRedirectFuncName(), nnnname);
							}
							else{
								loc.setPrivateStaticAccessorRedirectFuncSetter(this.getNextPrivateStaticAccessorRedirectFuncName(), nnnname, type);
								if(!assignExisting.eq.isEquals() ){
									loc.setPrivateStaticAccessorRedirectFuncGetter(this.getNextPrivateStaticAccessorRedirectFuncName(), nnnname);
								}
							}
						}
					}
				}
			}
			
			boolean createEvenIfOverriden = validateOverrideVar(assignExisting.getLine(), assignExisting.getColumn(), assignExisting.isOverride, isClassLevel, lhsRefName.name, tal.getType());
			
			if(createEvenIfOverriden) {
				((LocationClassField)tal.getLocation()).isOverride = false;
			}
			
			//assign to something that already exists ... carry on with logic below...
		}
		else
		{
			if(assignExisting.isOverride) {
				this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), "The override keyword can only be used with fields at class level");
			}
			
			//not a name so make sure u are not triyng to do something like this: new JJ().aa() = 9
			//TODO: The final field array.length cannot be assigned -> a.length=9;
			//assignee.accept(this);
			Pair<Boolean, RefName> eSure = null;
			if(!(assignExisting.assignee instanceof FuncInvoke)) {
				eSure = ensureValidLHSAssignment(assignExisting, assignee, !assignExisting.eq.isEquals());
			}
			
			Type pendingrhs = rhs;
			if(assignExisting.refCnt > 0){
				pendingrhs = TypeCheckUtils.getRefType(pendingrhs);
				pendingrhs = TypeCheckUtils.makeRef(pendingrhs, assignExisting.refCnt);
			}
			
			taglhsArrayRefWihType(assignee, assignExisting.expr, assignExisting.eq);
			
			rhsPendingAssignmeng.push(pendingrhs);
			
			if(assignee instanceof FuncInvoke) {//unlikely to Work...
				this.maskErrors(true);
				lhs = (Type)assignee.accept(this);
				ArrayList<CapMaskedErrs> errs = this.getmaskedErrors();
				if(!errs.isEmpty()) {//map f(int, String) and f(String, String) to AssignNew tuple: f (int, String) instead of a function invokation
					FuncInvoke asFI = (FuncInvoke)assignee;
					
					ArrayList<Expression> args = asFI.args.asnames;
					
					if(!args.isEmpty()) {
						boolean fail = false;
						ArrayList<Type> items = new ArrayList<Type>();
						for(Expression expr : args) {
							if(expr instanceof RefName) {
								items.add(new NamedType(expr.getLine(), expr.getColumn(), ((RefName)expr ).name));
							}else if(expr instanceof TypeReturningExpression) {
								items.add(((TypeReturningExpression)expr).type);
							}else {
								fail=true;break;
							}
						}
						if(!fail) {
							ArrayList<Pair<String, ArrayList<Type>>> nestorSegments = new ArrayList<Pair<String, ArrayList<Type>>>();
							NamedType tupleType = new NamedType(assignExisting.getLine(), assignExisting.getColumn(), "Tuple" + items.size(), items, nestorSegments);
							
							AssignNew astRedirect = new AssignNew(null, assignExisting.getLine(), assignExisting.getColumn(), false, false, ((FuncInvoke) assignee).funName, null, tupleType, assignExisting.eq, assignExisting.expr);
							astRedirect.annotations = assignExisting.annotations;
							((AssignNew) astRedirect).isReallyNew = assignExisting.isReallyNew;
							astRedirect.gpuVarQualifier = assignExisting.gpuVarQualifier;
							
							this.maskErrors();
							Type ret = (Type)astRedirect.accept(this);
							if(!this.maskedErrors()) {
								assignExisting.astOverrideOperatorOverload = astRedirect;
								setForceCastIfVarNull(assignExisting.expr, ret);
								return ret;
							}
						}
					}
					
					this.applyMaskedErrors(errs);
				}
			}else {
				lhs = (Type)assignee.accept(this);
			}
			if(assignExisting.assignee instanceof FuncInvoke) {//try to get esure again
				eSure = ensureValidLHSAssignment(assignExisting, assignee, !assignExisting.eq.isEquals());
			}else if(assignee instanceof ArrayRef) {
				Type arLhs = ((ArrayRef)assignee).expr.getTaggedType();
				if(null != arLhs && TypeCheckUtils.isNullable(arLhs)) {//null check:
					this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), "Assignee may be null");
				}
			}
			
			TypeCheckUtils.unlockAllNestedRefs(lhs);
			
			Utils.inferAnonLambda(this, (Node)assignExisting.expr, lhs);
			
			rhsPendingAssignmeng.pop();
			
			rhs = overrideVarNull(lhs, rhs, assignExisting.expr);
			
			RefName lhsName =  eSure.getB();
			if(null != lhsName){
				TypeAndLocation tal = lhsName.resolvesTo;
				if(tal != null){
					Location loc = tal.getLocation();
					if(null!=loc && (isLocationConstant(loc) || loc.isFinal()) && assignExisting.expr != null){
						
						if(this.currentScopeFrame.isconstructor){//if in constructor then fail only  if its already been set
							
						}
						else{
							this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), String.format("The field %s has been decalred as %s and cannot be reassigned", lhsName.name, isLocationConstant(loc)?"constant":"val"));
						}
					}
				}
				else if(lhsName.isMapGetter != null){
					//resolves to a map setter
					//convert hh.one.two = 12; where hh = {'one' : {'two':12}}
					//convert assignee to ArrayRef
					NamedType namedT = lhsName.isMapGetter.getB();
					
					ClassDef setCD = namedT.getSetClassDef();
					if(null != setCD){
						String setterName = lhsName.name;
						setterName = "set" + setterName.substring(0, 1).toUpperCase() + setterName.substring(1);
						if(setCD.getFuncDef(setterName, true, false).isEmpty()){//no setter
							assignee = convertDotOpMapThingToArrayRef((DotOperator)assignee);
							assignExisting.assignee = assignee;
							//redo work from above
							rhsPendingAssignmeng.push(pendingrhs);
							lhs = (Type)assignee.accept(this);
							//lhs = lhs == null?null:(Type)lhs.copy();
							//asNamedrhs.setLockedAsRef(false);
							TypeCheckUtils.unlockAllNestedRefs(lhs);
							
							rhsPendingAssignmeng.pop();
							
							rhs = overrideVarNull(lhs, rhs, assignExisting.expr);
							
						}
					}
				}
			}
			
			//TODO: lhs.get FuncLocation - use this to see if the thing ends up pointing to a.length which is a final field
		}
		
		if(null != lhs && null != rhs && TypeCheckUtils.isNotNullable(lhs) && TypeCheckUtils.isNullable(rhs) && assignExisting.eq != AssignStyleEnum.PLUS_EQUALS) {//null check:
			this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), "Assingment can be null, but assignment type is not nullable");
		}
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(lhs, assignee);
		ArrayList<Pair<Boolean, NullStatus>> instVect = lhsvec.getA();
		if(instVect != null) {
			lhs = lhsvec.getB();
			//lhs = (Type)lhs.copy();
			//lhs.setVectorized(null);
			vectorized=instVect;
			
			
		}else if(vectorized != null) {
			if( !lhs.hasArrayLevels() && !TypeCheckUtils.isList(this.getErrorRaiseableSupression(), lhs, false) && !assignExisting.eq.isEquals() ) {
				this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), String.format("Assignee must be a list or array"));
				return null;
			}else if(assignExisting.eq.isEquals() ) {
				this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), String.format("Direct assignment is not possible with vectoried assignment or assignee"));
				return null;
			}
		} 
		
		if(TypeCheckUtils.hasRefLevelsAndIsLocked(lhs) ){
			//TODO: can this if be removed?
			NamedType asNamedrhs = lhs == null?null:((NamedType)lhs).copyTypeSpecific();
			asNamedrhs.setLockedAsRef(false);
			lhs = asNamedrhs;
		}
		
		if(assignExisting.refCnt > TypeCheckUtils.getRefLevels(lhs)){
			if(TypeCheckUtils.getRefLevels(lhs) == 0){
				this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), String.format("Existing variable is not a ref. It is of type: %s", lhs));
			}
			else{
				this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), String.format("Too many assignment levels: %s for existing ref of type: %s", assignExisting.refCnt, lhs));
			}
		}
		
		int rhsLevels = TypeCheckUtils.getRefLevelsIfLockedAsRef(rhs);//rhs MUST be locked! else messes up x:1; ref2l := 12; x = ref2l //x ref would be overriden when really we just want to override the value
		if(assignExisting.refCnt==0 && rhsLevels>0){
			assignExisting.refCnt=TypeCheckUtils.getRefLevels(lhs);
		}else{
			if(assignee instanceof ArrayRef){
				/*
				 * caters for this case:
				 * xx Integer::RefArray = new Integer::RefArray(1)
				 * ok : =2
				 * xx[0] = ok //translated to: x[0] := 2
				 * 
				 */
				Type lhsARTYpe = ((ArrayRef)assignee).expr.getTaggedType();
				if(TypeCheckUtils.isRefArraySettable(lhsARTYpe, -1)){
					assignExisting.refCnt=TypeCheckUtils.getRefLevels(lhs);
				}
			}
			
			
		}
		
		if(null != lhs && lhs.getInOutGenModifier() == InoutGenericModifier.OUT){
			this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), "Cannot assign to generic parameter qualified as an out type: " + lhs);
		}
		
		
		assignExisting.setTaggedType(lhs);
		
		Type convertRetTo = TypeCheckUtils.canConvertRHSToArgLessLambda(this, this.ers, lhs, rhs);
		if(null != convertRetTo) {
			Pair<Type, Expression> conv = convertExprToArgLessLambda(assignExisting.getLine(), assignExisting.getColumn(), convertRetTo, rhs, assignExisting.expr);
			rhs = conv.getA();
			assignExisting.expr = conv.getB();
		}
		
		if(null != TypeCheckUtils.checkSubType(this.ers, ScopeAndTypeChecker.getLazyNT(), lhs)) {
			//so check rhs value to lazy value needed for type...
			Type llhs = ((NamedType)lhs).getGenTypes().get(0);
			if(null != TypeCheckUtils.checkSubType(this.ers, llhs, rhs )) {
				//now convert to new Lazy...
				Pair<Type, Expression> conv = convertExpressionToNewLazy(assignExisting.getLine(), assignExisting.getColumn(), llhs, rhs, assignExisting.expr, true/*, false*/);
				
				if(null != conv) {
					rhs = conv.getA();
					assignExisting.expr = conv.getB();
				}
			}
		}
		
		
		if( assignExisting.eq != AssignStyleEnum.EQUALS_STRICT && !assignExisting.isReallyNew){
			//maybe operator overloaded
			int line = assignExisting.getLine();
			int col = assignExisting.getColumn();
			
			FuncInvoke overloaded = canBeOperatorOverloaded(lhs, rhs, assignExisting.eq.methodString, assignExisting.expr, line, col, false/*assignExisting.eq != AssignStyleEnum.EQUALS*/, null, assignExisting.astOverrideOperatorOverload);
			if(null != overloaded){

				flagNullableForOperation(assignExisting.assignee.getLine(), assignExisting.assignee.getColumn(), lhs);
				Expression rhsAss;
				if(vectorized != null) {
					rhsAss = new VectorizedFuncInvoke(line, col, overloaded.funName, overloaded.args, overloaded.genTypes, (Expression)((Vectorized)assignExisting.assignee).expr.copy(), true, false);
					((Node)rhsAss).setShouldBePresevedOnStack(false);
					DuffAssign newass = new DuffAssign(rhsAss);
					if(null == assignExisting.astOverrideOperatorOverload) {//MHA:hopefully this wont change in later comp iterations...
						assignExisting.astOverrideOperatorOverload = newass;
					}

					assignExisting.astOverrideOperatorOverload.accept(this);
				}else {
					assignExisting.astOverrideOperatorOverload = DotOperator.buildDotOperator(line, col, (Expression)assignExisting.assignee.copy(), overloaded);
					assignExisting.astOverrideOperatorOverload.setShouldBePresevedOnStack(false);

					assignExisting.astOverrideOperatorOverload.accept(this);
					
					if(overloaded.resolvedFuncTypeAndLocation != null &&  TypeCheckUtils.hasRefLevels((((FuncType)overloaded.resolvedFuncTypeAndLocation.getType()).retType))){
						overloaded.waitForRefToReturnSomething=true;
					}
				}
				
				return null;
			}else if(null != assignExisting.expr){
				if( assignExisting.eq != AssignStyleEnum.EQUALS) {
					flagNullableForOperation(assignExisting.assignee.getLine(), assignExisting.assignee.getColumn(), lhs);

					if( assignExisting.eq != AssignStyleEnum.PLUS_EQUALS) {
						flagNullableForOperation(assignExisting.expr.getLine(), assignExisting.expr.getColumn(), rhs);
					}
				}
				
			}
		}		
		
		if(!this.currentScopeFrame.isClass() && assignExisting.isTransient){
			this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), "only fields may be declared transient");
		}
		
		if(vectorized != null) {
			assignExisting.depth = vectorized;
		}
		
		//really is assignment to existing thing: either non eq or thing above non overloaded
		String missingOpMsg = !assignExisting.eq.isEquals() ? makeMissingOpOverLoadMessage(assignExisting.eq.methodString, lhs, rhs, lhs): "";
		
		
		if(null == vectorized && !(assignExisting.assignee instanceof ArrayRef)) {
			TypeCheckUtils.checkAssignmentCanBeDone(this, assignExisting.eq, lhs, rhs, assignee.getLine(), assignee.getColumn(), assignExisting.expr.getLine(), assignExisting.expr.getColumn(), missingOpMsg);
		}
		
		if(assignExisting.eq != AssignStyleEnum.EQUALS){
			ArrayList<Type> leftAndRgith = new ArrayList<Type>();
			leftAndRgith.add(assignExisting.expr.getTaggedType());
			leftAndRgith.add(assignExisting.assignee.getTaggedType());
			validateAndReturnPointerType(assignExisting.getLine(), assignExisting.getColumn(), leftAndRgith, lhs, assignExisting.eq == AssignStyleEnum.PLUS_EQUALS || assignExisting.eq == AssignStyleEnum.MINUS_EQUALS);
		}
		setForceCastIfVarNull(assignExisting.expr, lhs);
		return null;
	}
	
	private boolean isLocationConstant(Location loc) {
		if(loc instanceof LocationStaticField) {
			LocationStaticField statField = (LocationStaticField)loc;
			Type tt = statField.type;
			if(tt != null) {
				return tt.getGpuMemSpace() == GPUVarQualifier.CONSTANT;
			}
		}
		return false;
	}
	
	
	private void filterInOutOnNewAssigment(Type input){
		if(null != input && input.getInOutGenModifier() != null){
			input.setInOutGenModifier(null);
		}
	}
	
	private String makeMissingOpOverLoadMessage(String method, Type lhsType, ArrayList<Type> inputType, Type retType){
		if(lhsType instanceof NamedType){
			StringBuilder sb = new StringBuilder("(");
			
			if(null != inputType && !inputType.isEmpty()){
				for(int n=0;n < inputType.size(); n++){
					sb.append(""+inputType.get(n));
					if(n != inputType.size()-1){
						sb.append(", ");
					}
				}
			}
			
			sb.append(")");
			
			String inputARg = sb.toString();
			String retstr = retType ==null?"":" " + retType;
			return String.format(". No overloaded '%s' operator found for type %s with signature: '%s%s'", method, lhsType, inputARg, retstr);
		}
		return "";
	}
	
	private String makeMissingOpOverLoadMessage(String method, Type lhsType, Type inputType, Type retType){
		ArrayList<Type> inputz = null;
		if(null!= inputType){
			inputz = new ArrayList<Type>();
			inputz.add(inputType);
		}
		
		return makeMissingOpOverLoadMessage(method, lhsType, inputz, retType);
	}
	
	
	private void taglhsArrayRefWihType(Expression LHS, Expression typa, AssignStyleEnum eq)
	{//e.g. tag xyz.asd[1] = 99//int
		if(LHS instanceof ArrayRef){
			((ArrayRef)LHS).setlhsOfAssignment(typa, eq);
		}
		else if(LHS instanceof DotOperator){
			taglhsArrayRefWihType(((DotOperator)LHS).getLastElement(), typa, eq);
		}
		return;
	}
	
	private ArrayRef convertDotOpMapThingToArrayRef(DotOperator asDot){
		Expression end = asDot.getLastElement();
		
		ArrayRefLevelElementsHolder areh = new ArrayRefLevelElementsHolder();
		while(end instanceof RefName && ((RefName)end).isMapGetter != null){
			ArrayList<ArrayRefElement> elements = new ArrayList<ArrayRefElement>();
			elements.add(new ArrayRefElement(end.getLine(), end.getColumn(), new VarString(end.getLine(), end.getColumn(), ((RefName)end).name)));
			areh.add(false, elements);
			asDot.snipOffEnd();
			end=asDot.getLastElement();
		}

		ArrayList<Expression> elms = asDot.getElements(this);
		Expression startRemain = elms.size() == 1?elms.get(0):asDot;
		return new ArrayRef(asDot.getLine(), asDot.getColumn(), startRemain, areh);
	}

	private Type findAccessaibleTypeIfNotAccesable(Type rhs) {
		if(rhs instanceof NamedType){
			NamedType asNamed = (NamedType)rhs;
			int refLevels = TypeCheckUtils.getRefLevels(asNamed);
			if(refLevels > 0){
				Type got = TypeCheckUtils.getRefTypeIgnoreRefArray(asNamed);
				if(got instanceof NamedType){
					asNamed = (NamedType)got;
				}
				else{//primative etc
					return asNamed;//just return the origonal thing
				}
			}
			
			while(!isNamedTypeAccessable(asNamed, false)){//#err111
				//TODO: check interface is accable, not just superclass: mixins |: when adding mixins
				int ar = rhs.getArrayLevels();
				asNamed = new NamedType(asNamed.getLine(), asNamed.getColumn(), asNamed.getSetClassDef().getSuperclass());
				asNamed.setArrayLevels(ar);
			}
			
			if(refLevels > 0){
				//asNamed = (NamedType)TypeCheckUtils.makeRef(asNamed, refLevels);
				
				rhs = ((NamedType) rhs).copyTypeSpecific();
				TypeCheckUtils.getRefTypeLastRef(rhs).getGenTypes().set(0, asNamed);
				asNamed = (NamedType)rhs;
			}
						
			return asNamed;
		}
		
		return rhs;
	}

	private Type overrideVarNull(Type lhs, Type rhs, Expression asignment) {
		return overrideVarNull(lhs, rhs, (Node)asignment);
	}
	
	private Type overrideVarNull(Type lhs, Type rhs, Node asignment) {
		if(lhs !=null && rhs != null && TypeCheckUtils.isNamedTypeOrLambda(lhs) && lhs.getArrayLevels() >= rhs.getArrayLevels()){
			if(hasVarNullInIt(rhs)){
				//special case to deal with xsz String[] = [null, null]
				Type lhsTypetoUse = (Type)TypeCheckUtils.getRefType(lhs).copy();
				lhsTypetoUse.setNullStatus(rhs.getNullStatus());
				rhs=asignment.setTaggedType(lhsTypetoUse); // &&   rhsExpr instanceof ArrayDef
				rhs.setOrigonalGenericTypeUpperBound(null);
			}
		}
		return rhs;
	}
	
/*	private boolean isArrayRefToSplice(Expression left, Expression right){
		return left instanceof AsyncRefRef && right instanceof ArrayDef;
	}
	
	private Expression spliceDotOperatorIfAsyncRefandArrayDef(DotOperator dotop){
		//oops, antlr will output xx:[2] as, DotOperator(AsyncArrayRef, ArrayDef), it should be ArrayRef(AsyncArrayRef)
		//so, either splice in or replace
		ArrayList<Expression> ee = dotop.elements;
		//ArrayList<Expression> directAccess = dotop.isDirectAccess;
		int sz = ee.size();
		if(sz == 2){
			if(isArrayRefToSplice(ee.get(0), ee.get(1))){
				AsyncRefRef left = (AsyncRefRef)ee.get(0);
				ArrayDef ar = (ArrayDef)ee.get(1);
				ArrayRefLevelElementsHolder arleh = new ArrayRefLevelElementsHolder();
				
				ArrayRefLevelElements arle = new ArrayRefLevelElements();
				arle
				
				arleh.add(ar.arrayElements);
				return new ArrayRef(left.getLine(), left.getColumn(), left, );
			}
		}
		else if(sz > 2){
			//step through and replace
		}
		
		return dotop;
		
	}*/

	private Pair<Boolean, RefName> ensureValidLHSAssignment(AssignExisting assignExisting, Expression LHS, boolean notEquals) {
		/*if(LHS instanceof DotOperator){
			LHS = spliceDotOperatorIfAsyncRefandArrayDef((DotOperator)LHS);
		}
		*/
		if(LHS instanceof Vectorized) {
			LHS = ((Vectorized)LHS).expr;
		}
		if(LHS instanceof VectorizedArrayRef) {
			VectorizedArrayRef asvar = (VectorizedArrayRef)LHS;
			if(asvar.astOverridearrayRef != null) {
				return ensureValidLHSAssignment( assignExisting, asvar.astOverridearrayRef, notEquals);
			}
		}
		
		if(LHS instanceof ExpressionList) {
			ExpressionList elist = (ExpressionList)LHS.copy();
			this.maskErrors();
			elist.accept(this);//may not yet have been accepted
			if(!this.maskedErrors()) {
				if(elist.astRedirect instanceof Expression) {
					LHS = (Expression) elist.astRedirect;
				}
			}
		}
		
		if (LHS instanceof RefName) {
			RefName lhsrefName = (RefName)LHS;
			lhsrefName.supressUnassign = true;
			return new Pair<Boolean, RefName>(true, lhsrefName);
		} else if (LHS instanceof ArrayRef) {//if not equals then must be a get and set += style operation
			((ArrayRef) LHS).getLastArrayRefElement().liToMap = notEquals?LISTorMAPType.GETANDPUT:LISTorMAPType.PUT;
			return new Pair<Boolean, RefName>(true, null);
		} else if (this.currentScopeFrame.isClass()) {
			this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), "The left-hand side of an assignment must be a variable");
			return new Pair<Boolean, RefName>(false, null);
		/*} else if (LHS instanceof RefNamedType) {
			RefNamedType rnt = (RefNamedType)LHS;
			if(null != rnt.astRedirectToArrayRef){
				((ArrayRef) rnt.astRedirectToArrayRef).getLastArrayRefElement().liToMap = notEquals?LISTorMAPType.GETANDPUT:LISTorMAPType.PUT;
				return new Tuple<Boolean, RefName>(true, null);
			}*/
		} else if (LHS instanceof DotOperator) {
			DotOperator LHSDO = (DotOperator) LHS;
			
			//MHA: this gets triggered once and mutetes the datastructure [nasty]
			Expression lasEle = LHSDO.getLastElement();
			
			if(LHSDO.getLastReturnCallOnSelf()){
				this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), ".. cannot be used for assignment");
			}
			
			if(lasEle instanceof AsyncRefRef){
				int refCnt = 0;
				while( lasEle instanceof AsyncRefRef){ //asd.fgfg :: = 99, convert to [asd, fgfg] [::= 99] from [asd, fgfg ::] [= 99]
					AsyncRefRef asARR = (AsyncRefRef)lasEle;
					lasEle = asARR.b;		
					refCnt+=asARR.refCntLevels;
				}
				LHSDO.replaceLastElement(lasEle);
				assignExisting.refCnt += refCnt;
			}
			
			if(lasEle instanceof RefName){
				RefName asName = (RefName)lasEle;
				if(asName.name.equals("length")){
					Expression penulti = LHSDO.getPenultimate();
					if(null != penulti){
						Type tyo = penulti.getTaggedType();
						if(null != tyo){
							tyo = TypeCheckUtils.getRefType(tyo);
							if(tyo.hasArrayLevels()){
								//no, you cannot assign to a.length = 1; where a = [1,2,3] //etc
								this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), "Cannot change the length of an array");
								return new Pair<Boolean, RefName>(false, null);
							}
						}
								
					}
				}
			}
			
			return ensureValidLHSAssignment(assignExisting, lasEle, notEquals);
		}else if(LHS instanceof VectorizedFieldRef) {
			return ensureValidLHSAssignment(assignExisting, ((VectorizedFieldRef)LHS).expr, notEquals);
		}
		else if(LHS instanceof PointerUnref) {
			return new Pair<Boolean, RefName>(true, null);
		}
		
		
		this.raiseError(assignExisting.getLine(), assignExisting.getColumn(), "The left-hand side of an assignment must be a variable");
		return new Pair<Boolean, RefName>(false, null);
	}
	
	@Override
	public Object visit(DuffAssign duffAssign) {
		Expression expr = duffAssign.e;
		Annotation asAnnot = null;
		if(this.currentlyInBlock.peek().isModuleLevel && expr instanceof Annotation){
			asAnnot = (Annotation)expr;
			asAnnot.validAtThisLocation=true;
			asAnnot.ignoreWhenGenByteCode=true;
		}
		
		Type tt = (Type)expr.accept(this);
		duffAssign.setTaggedType(tt);
		if(null != asAnnot){
			Annotations annots = new Annotations(asAnnot);
			HashSet<WarningVariant> toSupress = Utils.extractSuppressedWarningsFromAnnotations(annots, this);
			if(!toSupress.isEmpty()){
				this.currentScopeFrame.addSuppressedWarnings(toSupress);
			}
		}
		
		return tt;
		//funccall()
		//but x.a <- is a nop if it doesn't call getA(), the filed access should get overwritten
		//DUFF: x.a
		//NO DUFF: x.a - where it gets rewritten to x.getA();
	}
	
	@Override
	public Object visit(AssertStatement assertStatement) {
		TypeCheckUtils.assertNotVoid((Type)assertStatement.e.accept(this), this, assertStatement.e.getLine(), assertStatement.e.getColumn(), "assert");
		//TypeCheckUtils.isBoolean(this, (Type)assertStatement.e.accept(this), assertStatement.getLine(), assertStatement.getColumn());
		
		nullableTypeLogic.processTest(assertStatement.e);
		
		
		if(assertStatement.message == null){
			PrintSourceVisitor psv = new PrintSourceVisitor();
			assertStatement.e.accept(psv);
			assertStatement.messageFromExpr=String.format("assert %s failed", psv.toString());
		}else {
			assertStatement.message.accept(this);
		}
		
		return null;
	}

	@Override
	public Object visit(MulerExpression mulerExpression) {
		ArrayList<Type> elementTypes = vectorizeElementsIfApproperiate(mulerExpression);
		
		Type lhs = elementTypes.get(0);//(Type)mulerExpression.header.accept(this);
		lhs = TypeCheckUtils.extractRawRefType(lhs);
		flagNullableForOperation(mulerExpression.header.getLine(), mulerExpression.header.getColumn(), lhs);
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(lhs);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = lhsvec.getA();

		if(vectorized != null) {
			lhs = lhsvec.getB();
		}
		
		int n=1;
		boolean lastWasOpOverload = false;
		for(MulerElement e : mulerExpression.elements)
		{
			lastWasOpOverload=false;
			
			Type rhs = elementTypes.get(n++);//(Type)e.expr.accept(this);
			rhs = TypeCheckUtils.extractRawRefType(rhs);
			
			Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> rhsvec = vectorizedOperator(rhs);
			ArrayList<Pair<Boolean, NullStatus>> instVect = rhsvec.getA();
			if(instVect != null) {
				rhs = rhsvec.getB();
				vectorized = instVect;
			}	
			
			FuncInvoke overloaded = canBeOperatorOverloaded(lhs, rhs, e.mulOper.methodName, e.expr, e.getLine(), e.getColumn(), e.astOverrideOperatorOverload);
			if(null != overloaded){
				e.astOverrideOperatorOverload = overloaded;
				this.dotOperatorLHS.push(lhs);
				lhs = (Type)e.accept(this);
				this.dotOperatorLHS.pop();
				lastWasOpOverload=overloaded.vectroizedDegreeAndArgs != null;
			}
			else{
				flagNullableForOperation(e.expr.getLine(), e.expr.getColumn(), rhs);
				lhs = TypeCheckUtils.checkNumericalInfix(this, lhs, rhs, mulerExpression.header.getLine(), mulerExpression.header.getColumn(), e.getLine(), e.getColumn(), makeMissingOpOverLoadMessage(e.mulOper.methodName, lhs, rhs, null));
			}
			
			e.setTaggedType(lhs);
		}
		
		if(vectorized != null) {
			mulerExpression.depth = vectorized;
			if(null != lhs && !lastWasOpOverload) {
				lhs = TypeCheckUtils.applyVectStruct(vectorized, lhs);
			}
		}else {
			lhs = validateAndReturnPointerType(mulerExpression.getLine(), mulerExpression.getColumn(), elementTypes, lhs, false);
		}
		
		mulerExpression.setTaggedType(lhs);
		
		return lhs;
	} 
	
	@Override
	public Object visit(MulerElement mulerElement) {
		return mulerElement.expr.accept(this);
	}
	

	@Override
	public Object visit(ShiftExpression shiftExpression) {
		ArrayList<Type> elementTypes = vectorizeElementsIfApproperiate(shiftExpression);

		Type lhs = elementTypes.get(0);//(Type)shiftExpression.header.accept(this);
		lhs = TypeCheckUtils.extractRawRefType(lhs);
		flagNullableForOperation(shiftExpression.header.getLine(), shiftExpression.header.getColumn(), lhs);
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(lhs);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = lhsvec.getA();

		if(vectorized != null) {
			lhs = lhsvec.getB();
		}

		int n=1;
		boolean lastWasOpOverload=false;
		for(ShiftElement e : shiftExpression.elements)
		{
			lastWasOpOverload=false;
			Type rhs = elementTypes.get(n++);//(Type)e.expr.accept(this);
			rhs = TypeCheckUtils.extractRawRefType(rhs);
			
			Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> rhsvec = vectorizedOperator(rhs);
			ArrayList<Pair<Boolean, NullStatus>> instVect = rhsvec.getA();
			if(instVect != null) {
				rhs = rhsvec.getB();
				vectorized = instVect;
			}	
			
			FuncInvoke overloaded = canBeOperatorOverloaded(lhs, rhs, e.shiftOp.methodName, e.expr, e.getLine(), e.getColumn(), e.astOverrideOperatorOverload);
			if(null != overloaded){
				e.astOverrideOperatorOverload = overloaded;
				this.dotOperatorLHS.push(lhs);
				lhs = (Type)e.accept(this);
				this.dotOperatorLHS.pop();
				lastWasOpOverload=overloaded.vectroizedDegreeAndArgs != null;
			}
			else{
				flagNullableForOperation(e.expr.getLine(), e.expr.getColumn(), rhs);
				lhs = TypeCheckUtils.checkNumericalOpGeneric(this, lhs, rhs, e.expr.getLine(), e.expr.getColumn(), e.getLine(), e.getColumn(), "bit shift", makeMissingOpOverLoadMessage(e.shiftOp.methodName, lhs, rhs, null), true, false);
			}
			
			e.setTaggedType(lhs);
		}
		
		if(vectorized != null) {
			shiftExpression.depth = vectorized;
			if(lhs != null && !lastWasOpOverload) {
				lhs = TypeCheckUtils.applyVectStruct(vectorized, lhs);
			}
		}else {
			lhs = validateAndReturnPointerType(shiftExpression.getLine(),shiftExpression.getColumn(), elementTypes, lhs, false);
		}
		
		return shiftExpression.setTaggedType(lhs);
	}
	
	@Override
	public Object visit(ShiftElement shiftElement) {
		return  shiftElement.expr.accept(this);
	}
	
	@Override
	public Object visit(MapDef mapDef) {
		
		List<Type> keys = new ArrayList<Type>();
		List<Type> values = new ArrayList<Type>();
		int line = mapDef.getLine();  
		int col =mapDef.getColumn();
		Map<Type, Pair<Integer,Integer>> offendersKeys = new HashMap<Type, Pair<Integer,Integer>>();
		Map<Type, Pair<Integer,Integer>> offendersValues = new HashMap<Type, Pair<Integer,Integer>>();
		Map<Type, Pair<Integer,Integer>> offendersKeysOrig = new HashMap<Type, Pair<Integer,Integer>>();
		Map<Type, Pair<Integer,Integer>> offendersValuesOrig = new HashMap<Type, Pair<Integer,Integer>>();
		int defaultCnt=0;
		for ( IsAMapElement ea : mapDef.elements  ){
			if(ea instanceof MapDefElement){
				MapDefElement mapDefElement = (MapDefElement)ea;
				
				this.maskErrors(true);
				Expression key =  mapDefElement.getKey(this);
				Type keyType = TypeCheckUtils.boxTypeIfPrimative((Type)key.accept(this), false);
				ArrayList<CapMaskedErrs> keyerrs = this.getmaskedErrors();
				if(!keyerrs.isEmpty() && !TypeCheckUtils.isValidType(keyType)) {//see if we can map refName to String
					if(key instanceof RefName) {
						VarString vs = new VarString(key.getLine(), key.getColumn(), ((RefName)key).name);
						keyType = vs.setTaggedType(ScopeAndTypeChecker.const_string);
						mapDefElement.setKeyOverride(vs);
					}else {
						this.applyMaskedErrors(keyerrs);
					}
				}
				
				
				this.maskErrors(true);
				Expression value =  mapDefElement.getValue(this);
				Type valType = TypeCheckUtils.boxTypeIfPrimative((Type)value.accept(this), false);
				ArrayList<CapMaskedErrs> valueerrs = this.getmaskedErrors();
				if(!valueerrs.isEmpty() && !TypeCheckUtils.isValidType(valType)) {//see if we can map refName to String
					if(value instanceof RefName) {
						VarString vs = new VarString(value.getLine(), value.getColumn(), ((RefName)value).name);
						valType = vs.setTaggedType(ScopeAndTypeChecker.const_string);
						mapDefElement.setValueOverride(vs);
					}else {
						this.applyMaskedErrors(valueerrs);
					}
				}
				
				offendersKeysOrig.put(keyType, new Pair<Integer, Integer>(key.getLine(), key.getColumn()) );
				offendersValuesOrig.put(valType, new Pair<Integer, Integer>(value.getLine(), value.getColumn()));
				
				if(TypeCheckUtils.hasRefLevelsAndNotLocked(keyType)){ keyType = TypeCheckUtils.getRefType((Type)keyType.copy()); }
				if(TypeCheckUtils.hasRefLevelsAndNotLocked(valType)){ valType = TypeCheckUtils.getRefType((Type)valType.copy()); }
				
				keys.add( keyType );
				values.add( valType );
				offendersKeys.put(keyType, new Pair<Integer, Integer>(key.getLine(), key.getColumn()) );
				offendersValues.put(valType, new Pair<Integer, Integer>(value.getLine(), value.getColumn()));
			}
			else{//default
				defaultCnt++;
				mapDef.defaultMapElement = (MapDefaultElement)ea;
				
				//Type keyType = TypeCheckUtils.boxTypeIfPrimative((Type) defaultMapElement.key.accept(this), false);
				Type valType = (Type)mapDef.defaultMapElement.accept(this);
				
				if(TypeCheckUtils.isValidType(valType) || mapDef.defaultMapElement.value instanceof VarNull){//if null then must have done wrong earlier, unless varnull, which is valid...
					if(!(valType instanceof FuncType)){//normal value
						//wrap this up inside a lambda def...
						//xxx -> fun () valType { xxx } 
						LambdaDef lambda = new LambdaDef(line, col, null, new FuncParams(line, col), new Block(line, col, mapDef.defaultMapElement.value), valType, new ArrayList<Pair<String, NamedType>>());
						mapDef.defaultMapElement.astRedirect = lambda;
						//and now accept it
						valType = TypeCheckUtils.boxTypeIfPrimative((Type) mapDef.defaultMapElement.accept(this), false);
					}
					
					valType = TypeCheckUtils.boxTypeIfPrimative((Type)valType, false);
					
					Type retType = TypeCheckUtils.boxTypeIfPrimative(((FuncType) valType).retType, false);
					if(!TypeCheckUtils.isValidType( retType )){
						this.raiseError(mapDef.getLine(), mapDef.getColumn(), "default function has invalid return type: " + retType);
					}
					
					/*if(TypeCheckUtils.isValidType(retType) && !(retType instanceof VarNull)){
						TypeCheckUtils.assertRefIsGettable(this, mapDef.defaultMapElement.getLine(),mapDef.defaultMapElement.getColumn(), retType);//get
					}*/
					
					if(TypeCheckUtils.isValidType(retType) && !(retType instanceof VarNull)){
						offendersValuesOrig.put(retType, new Pair<Integer, Integer>(mapDef.defaultMapElement.value.getLine(), mapDef.defaultMapElement.value.getColumn()) );
					}
					
					if(TypeCheckUtils.hasRefLevelsAndNotLocked(retType)){ retType = TypeCheckUtils.getRefType( (Type)retType.copy() ); }
					
					if(TypeCheckUtils.isValidType(retType) && !(retType instanceof VarNull)){
						
						values.add( retType );
						offendersValues.put(retType, new Pair<Integer, Integer>(mapDef.defaultMapElement.value.getLine(), mapDef.defaultMapElement.value.getColumn()) );
					}
					//input value
					
					ArrayList<Type> inputs = ((FuncType) valType).inputs;
					int ssz = inputs.size();
					if(ssz > 1){
						this.raiseError(mapDef.getLine(), mapDef.getColumn(), "default function must take either no or one inputs not: " + inputs);
					}
					if(ssz == 1){
						Type input = TypeCheckUtils.boxTypeIfPrimative(inputs.get(0), false);
						if(!TypeCheckUtils.isValidType( input )){
							this.raiseError(mapDef.getLine(), mapDef.getColumn(), "default function has invalid input type: " + input);
						}
						//TypeCheckUtils.assertRefIsGettable(this, mapDef.defaultMapElement.getLine(), mapDef.defaultMapElement.getColumn(), input);//get
						
						
						offendersKeysOrig.put(input, new Pair<Integer, Integer>(mapDef.defaultMapElement.value.getLine(), mapDef.defaultMapElement.value.getColumn()) );
						
						if(TypeCheckUtils.hasRefLevelsAndNotLocked(input)){ input = TypeCheckUtils.getRefType((Type)input.copy()); }
						keys.add( input );
						
						offendersKeys.put(input, new Pair<Integer, Integer>(mapDef.defaultMapElement.value.getLine(), mapDef.defaultMapElement.value.getColumn()) );
					}
					
					//offendersValues.put(valType, new Tuple<Integer, Integer>(mapDef.defaultMapElement.value.getLine(), mapDef.defaultMapElement.value.getColumn()));
				}
			}
		}
		
		if(defaultCnt > 1){
			this.raiseError(mapDef.getLine(), mapDef.getColumn(), "Map may only have one default definition");
		}
		
		Type keyType   = TypeCheckUtils.getMoreGeneric(this, this, line, col,  keys, offendersKeys);
		keyType = keyType == null?null:(Type)keyType.copy();
		TypeCheckUtils.unlockAllNestedRefs(keyType);
		
		Type valueType = TypeCheckUtils.getMoreGeneric(this, this, line, col,  values, offendersValues);
		valueType = valueType == null?null:(Type)valueType.copy();
		TypeCheckUtils.unlockAllNestedRefs(valueType);
		
		if(null == keyType || null == valueType)
		{
			return null;
		}
		else
		{
			NamedType map = new NamedType(line, col, new ClassDefJava(mapDef.defaultMapElement != null?com.concurnas.lang.DefaultMap.class:java.util.HashMap.class));
			ArrayList<Type> ar = new ArrayList<Type>();
			ar.add(keyType);
			ar.add(valueType);
			map.setGenTypes(ar);
			mapDef.setTaggedType(map);
			
			TypeCheckUtils.assertAllSubtypeIfUnrefNeeded(this, mapDef.getLine(), mapDef.getColumn(), keyType, offendersKeysOrig);
			TypeCheckUtils.assertAllSubtypeIfUnrefNeeded(this, mapDef.getLine(), mapDef.getColumn(), valueType, offendersValuesOrig);
			
			return map;
		}
	}
	
	@Override
	public Object visit(MapDefElement mapDefElement) {
		throw new RuntimeException("Internal compiler error MapDefElement not callable");
	}
	
	@Override
	public Object visit(MapDefaultElement mapDefElement) {
		return mapDefElement.value.accept(this);
	}

	@Override
	public Object visit(CastExpression castExpression) {
		Type castType = (Type)castExpression.t.accept(this);
		if( TypeCheckUtils.hasRefLevels(castType)     ){
			((NamedType)castType).setLockedAsRef(true);
		}
		if(castExpression.o instanceof RefName){
			((RefName)castExpression.o).inCastExpr = true;
		}
		
		Type origrhs = (Type)castExpression.o.accept(this);
		
		Type rhs  = origrhs;
		
		ArrayList<Pair<Boolean, NullStatus>> vectorizedLevels = null;
		if(null != rhs && rhs.isVectorized()){
			if(rhs.getVectorized() == Vectorization.SELF){
				this.raiseError(castExpression.getLine(), castExpression.getColumn(), "Cast operator may not have vectorized argument of '^^' form - only '^' can be used");
				return castType;
			}
			
			rhs = (Type)rhs.copy();
			rhs.setVectorized(null);
			vectorizedLevels = TypeCheckUtils.getVectorizedStructure(ers, rhs);;
			castExpression.vectorizedExpr = vectorizedLevels;
			rhs = TypeCheckUtils.extractVectType(rhs);

		}
		
		if( TypeCheckUtils.hasRefLevels(rhs)     ){
			NamedType asNamedRhs = ((NamedType)rhs).copyTypeSpecific();
			asNamedRhs.setLockedAsRef(true);
			rhs=asNamedRhs;
		}
		
		Type castedTo;
		if(rhs instanceof NamedType && castType instanceof NamedType && ((NamedType) castType).isInterface()){
			castedTo = castType;
		}else{
			castedTo = CastCheck.checkCast(this, castExpression.getLine(), castExpression.getColumn(), castType, rhs,true);
		}
		
		//MHA mega ugly... - do this above because we make a copy above so that we can do the locked as ref logic...
		int wantLEvels = TypeCheckUtils.getRefLevels(origrhs);
		
		if(wantLEvels >0 && wantLEvels == TypeCheckUtils.getRefLevels(castedTo)){
			Type unRefCastTo = TypeCheckUtils.getRefType(castedTo);
			Type unRefExpType = TypeCheckUtils.getRefType(origrhs);
			if(unRefCastTo instanceof NamedType && unRefExpType instanceof VarNull){
				//ref levels match and wei're going from varnull to type; e.g. a String: = null!
				TypeCheckUtils.mutatleRefType(wantLEvels, (NamedType)origrhs, (NamedType)unRefCastTo);
			}
		}
		
		
		HashSet<GenericType> unbounded = TypeCheckUtils.findUnboundedGenerics(castedTo);
		if(!unbounded.isEmpty()){
			warnOnUnboundedGenerics(unbounded, castExpression.getLine(), castExpression.getColumn(), "as");
		}
		
		//
		if(vectorizedLevels != null){
			//castedTo = (Type)castedTo.copy();
			//castedTo.setArrayLevels(vectorizedLevels);
			castedTo = TypeCheckUtils.applyVectStruct(vectorizedLevels, castedTo);
		}
		
		return castExpression.setTaggedType(castedTo);
	}

	private void warnOnUnboundedGenerics(HashSet<GenericType> unbounded, int line, int column, String optype){
		warnOnUnboundedGenerics( unbounded,  line,  column,  optype, "");
	}
	
	private void warnOnUnboundedGenerics(HashSet<GenericType> unbounded, int line, int column, String optype, String postMsg){
		ArrayList itemz = new ArrayList(unbounded);
		Collections.sort(itemz);
		
		ArrayList<String> genNames = new ArrayList<String>(itemz.size());
		ArrayList<String> ubNames = new ArrayList<String>(itemz.size());
		for(Object titm : itemz){
			GenericType gen = (GenericType)titm;
			genNames.add(gen.name);
			ubNames.add(gen.upperBound.toString());
		}
		boolean many=ubNames.size() > 1;
		this.raiseWarning(line, column, String.format("Unable to determine type for generic%s: %s for %s operation. Wil use upper bounds of: %s %sinstead%s", many?"s":"", Utils.justJoin(genNames), optype, Utils.justJoin(ubNames), many?"respectfully ":"", postMsg), WarningVariant.GENERICCAST);
	}
	
	@Override
	public Object visit(Is isa) {
		//ArrayList<Type> elementTypes = vectorizeElementsIfApproperiate(isa);

		Type rhs = (Type)isa.e1.accept(this);
		if(rhs instanceof ModuleType){
			this.raiseError(isa.e1.getLine(), isa.e1.getColumn(), ""+rhs );
		}
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(rhs);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = lhsvec.getA();

		if(vectorized != null) {
			rhs = lhsvec.getB();
			isa.depth = vectorized;
		}
		
		HashSet<Type> checkedAlready = new HashSet<Type>();
		Map<Type, Pair<Integer,Integer>> offenders = new HashMap<Type, Pair<Integer,Integer>>();
		for(Type oneof : isa.typees){
			Type castType = (Type)oneof.accept(this);
			
			if(castType == null){
				//this.raiseError(instanceOf.e1.getLine(), instanceOf.e1.getColumn(), "unable to determine cast type" );
				return null;
			}
			
			boolean failed = false;
			if(castType instanceof NamedType)
			{
				NamedType asNamed = (NamedType)castType;
				boolean isDefaultActor = TypeCheckUtils.isTypedActorExactly(this, asNamed);
				if(!asNamed.getIsRef() && asNamed.isGeneric() && !isDefaultActor && !TypeCheckUtils.isTypedOrUntypedActor(this, asNamed) && !TypeCheckUtils.isReifiedType(asNamed))
				{
					ArrayList<Type> gte =  asNamed.getGenericTypeElements();
					int cnt = gte.size();
					
					for(Type genElem :gte)
					{
						if(!(genElem instanceof GenericType) || !((GenericType)genElem).name.equals("?"))
						{
							if(!(genElem instanceof NamedType && ((NamedType)genElem).fromisWildCardAny)) {//from ? is ok
								StringBuilder quest = new StringBuilder();
								for(int n = 1; n <= cnt; n++){
									quest.append('?');
									
									if(n <= cnt-1){
										quest.append(", ");
									}
								}
								
								this.raiseError(asNamed.getLine(), asNamed.getColumn(), String.format("Cannot perform is or isnot check against parameterized type %s. Use the form %s<%s> instead since further generic type information will be erased at runtime ", asNamed, asNamed.toStringNoGeneric(), quest));
								failed=true;
								break;
							}
						}
					}
				}
			}
			if(!failed)
			{
				if(castType instanceof PrimativeType && !castType.hasArrayLevels() &&  (castType instanceof PrimativeType && ((PrimativeType)castType).type != PrimativeTypeEnum.LAMBDA))
				{
					this.raiseError(isa.getLine(), isa.getColumn(), "Cannot perform is or isnot check on primative type");
				}
				
				if(rhs instanceof PrimativeType && !castType.hasArrayLevels() && ((PrimativeType)rhs).type != PrimativeTypeEnum.LAMBDA)
				{
					this.raiseError(isa.e1.getLine(), isa.e1.getColumn(), "Cannot perform is or isnot check against expression of primative type");
				}
				
				if(rhs instanceof NamedType){
					NamedType rhsAsNamed = (NamedType)rhs;
					if(rhsAsNamed.getIsRef()){
						rhs = ((NamedType) rhs).copyTypeSpecific();
						((NamedType)rhs).setLockedAsRef(true);
					}
				}
				
				
				CastCheck.checkCast(this, isa.getLine(), isa.getColumn(), castType, rhs, false);
			}
			
			if(checkedAlready.contains(castType)){
				this.raiseError(((Node)oneof).getLine(), ((Node)oneof).getColumn(), String.format("Attempted to compare instance of type: %s more than once in the same %s statement", castType, isa.inverted?"is not":"is"));
			}
			checkedAlready.add(castType);

			offenders.put(castType, new Pair<Integer,Integer>( ((Node)oneof).getLine(), ((Node)oneof).getColumn() ));
			
			HashSet<GenericType> unbounded = TypeCheckUtils.findUnboundedGenerics(castType);
			if(!unbounded.isEmpty()){
				warnOnUnboundedGenerics(unbounded, isa.getLine(), isa.getColumn(), "is");
			}
		}
		
		//
		
		if(isa.canBeUsedAsIsas && !isa.inverted){
			if(isa.e1 instanceof RefName){
				if(!asisOverwriteType.isEmpty()){
					HashMap<Pair<String, Boolean>, Type> topLevel = asisOverwriteType.peek();
					
					if(null != topLevel){
						int line = isa.getLine();
						int col = isa.getColumn();
						
						Type typeOfChoices;
						if(checkedAlready.size() > 1){
							typeOfChoices =  TypeCheckUtils.getMoreGeneric(this, this, line, col, new ArrayList<Type>(checkedAlready), offenders, true );//TODO change getMoreGeneric to take collection
						}else{
							typeOfChoices = checkedAlready.iterator().next();
						}
						Pair<String, Boolean> keyx = makeRefNameTypeOverrideKey((RefName)isa.e1);
						if(null != keyx) {
							topLevel.put(keyx, typeOfChoices);
						}
					}
				}
			}
		}
		
		Type ret = new PrimativeType(PrimativeTypeEnum.BOOLEAN);
		
		if(vectorized != null) {
			if(ret != null) {
				ret = TypeCheckUtils.applyVectStruct(vectorized, ret);
			}
		}
		
		isa.setTaggedType(ret);
		
		return ret;
	}
	
	private  Pair<String, Boolean> makeRefNameTypeOverrideKey(RefName refname){
		boolean isclassLevel = refname.name.contains("$n");
		
		if(!isclassLevel) {
			if(!this.dotOperatorLHS.isEmpty() && null != this.dotOperatorLHS.peek()) {
				if(precceededByThis()) {
					isclassLevel=true;
				}else {
					return null;
				}
			}else {
				if(null != refname.resolvesTo && refname.resolvesTo.getLocation() instanceof LocationClassField) {
					LocationClassField loc = (LocationClassField)refname.resolvesTo.getLocation();
					Type locT = loc.ownerType;
					if(locT instanceof NamedType) {
						NamedType asNamed = (NamedType)locT;
						ClassDef cd = asNamed.getSetClassDef();
						if(null != cd) {
							for(ClassDef mathto : this.currentlyInClassDef) {
								if(mathto.equals(cd)) {
									isclassLevel=true;
									break;
								}
							}
						}
					}
				}
			}
		}
		
		
		return new Pair<String, Boolean>(refname.name, refname.name.contains("$n") || isclassLevel);
	}
	
	/*private  Tuple<String, Boolean> makeRefNameTypeOverrideKey(RefName refname){
		boolean isclassLevel = refname.name.contains("$n");
		
		if(!isclassLevel) {
			Expression prev = refname.getPreceedingExpression();
			if(null != prev) {
				if(prev instanceof RefThis) {
					isclassLevel=true;
				}else {
					return null;
				}
			}else {
				if(null != refname.resolvesTo && refname.resolvesTo.getLocation() instanceof LocationClassField) {
					LocationClassField loc = (LocationClassField)refname.resolvesTo.getLocation();
					Type locT = loc.ownerType;
					if(locT instanceof NamedType) {
						NamedType asNamed = (NamedType)locT;
						ClassDef cd = asNamed.getSetClassDef();
						if(null != cd) {
							for(ClassDef mathto : this.currentlyInClassDef) {
								if(mathto.equals(cd)) {
									isclassLevel=true;
									break;
								}
							}
						}
					}
				}
			}
		}
		
		
		return new Tuple<String, Boolean>(refname.name, isclassLevel);
	}*/
	
	private Pair<String, Boolean> makeRefNameTypeOverrideKey(FuncInvoke refname){
		//yuck copy paste
		boolean isclassLevel = refname.funName.contains("$n");
		
		if(!isclassLevel) {
			Expression prev = refname.getPreceedingExpression();
			if(null != prev) {
				if(prev instanceof RefThis) {
					isclassLevel=true;
				}else {
					return null;
				}
			}else {
				if(null != refname.resolvedFuncTypeAndLocation && refname.resolvedFuncTypeAndLocation.getLocation() instanceof LocationClassField) {
					LocationClassField loc = (LocationClassField)refname.resolvedFuncTypeAndLocation.getLocation();
					Type locT = loc.ownerType;
					if(locT instanceof NamedType) {
						NamedType asNamed = (NamedType)locT;
						ClassDef cd = asNamed.getSetClassDef();
						if(null != cd) {
							for(ClassDef mathto : this.currentlyInClassDef) {
								if(mathto.equals(cd)) {
									isclassLevel=true;
									break;
								}
							}
						}
					}
				}
			}
		}
		
		return new Pair<String, Boolean>(refname.funName, isclassLevel);
	}
	
	private Pair<String, Boolean> makeRefNameTypeOverrideKey(String name, FuncType refname){
		boolean isclassLevel = false;
		TypeAndLocation tal = refname.getLambdaDetails();
		if(tal != null) {
			isclassLevel = tal.getLocation() instanceof ClassFunctionLocation;
		}
		
		return new Pair<String, Boolean>(name, isclassLevel);
	}
	
	@Override
	public Object visit(ImportStar importStar) {
		int line = importStar.getLine();
		int col = importStar.getColumn();
		String nameSoFar = importStar.from;		
		String packname = this.getFullyDottedPackage();
		if(nameSoFar.equals(packname)) {
			this.raiseError(line, col, String.format("Cannot import all assets from: %s as path name is the same as where it is defined" , nameSoFar));
		}

		boolean isUsing = !importStar.normalImport;
		
		NamedType what = new NamedType(line, col, nameSoFar);
		this.maskErrors();
		what.accept(this);
		if(!this.maskedErrors()) {
			List<Pair<String, TypeAndLocation>> toregister = what.getAllStaticAssets();

			HashSet<String> nameAlready = new HashSet<String>();
			for(Pair<String, TypeAndLocation> item : toregister) {
				String name = item.getA();
				if(!nameAlready.contains(name)) {
					if(isUsing) {
						registerUsing(name, nameSoFar + "." + name, line, col);
					}else {
						registerImport(name, nameSoFar + "." + name, line, col);
					}
					
					nameAlready.add(name);
				}
			}
		}else {
			//see if we can extract a module compiler - add all public and package things from here
			
			ModuleCompiler mc = this.mainLoop.getModuleCompiler(nameSoFar);
			
			if(mc != null) {
				for(String name : new HashSet<String>(mc.getAllStaticAssets())) {
					if(isUsing) {
						registerUsing(name, nameSoFar + "." + name, line, col);
					}else {
						registerImport(name, nameSoFar + "." + name, line, col);
					}
				}
			}else {
				this.raiseError(line, col, String.format("Cannot import all assets from: %s as it cannot be resolved to a path" , nameSoFar));
			}
		}
		
		
		return null;
	}
	
	
	
	
	private Stack<Map<String, String> > scopedshortNameToLongNameaa = UncallableMethods.cloneAutoImports();  //bootstrap from the auto imported stuff
	private Stack<Map<String, ClassDefJava> > scopedshortNameToLongNameaaUsing = new Stack<Map<String, ClassDefJava> >();
	private HashMap<String, ClassDefJava> precompiledBytecodeExistsCache = new HashMap<String, ClassDefJava>();
	private Stack<Set<String> > rawImports = new Stack<Set<String>>();  
	private Stack<Set<String> > rawUsings = new Stack<Set<String>>();

	
	private void enterScopedNameMapREPL() {
		REPLTopLevelImports topL = this.isREPL.tliCache;
			scopedshortNameToLongNameaa.add(new HashMap<String, String>(topL.topshortNameToLong));
			scopedshortNameToLongNameaaUsing.add(new HashMap<String, ClassDefJava>(topL.topshortNameToLongUsing));
			rawImports.add(new HashSet<String>(topL.toprawImports));
			rawUsings.add(new HashSet<String>(topL.toprawUsings));
			typedefsAtThisLevel.add(new HashMap<Pair<String, Integer>, TypeDefTypeProvider>(topL.toptypeDef));
	}
	
	private void enterScopedNameMap()
	{
		scopedshortNameToLongNameaa.add(new HashMap<String, String>());
		scopedshortNameToLongNameaaUsing.add(new HashMap<String, ClassDefJava>());
		rawImports.add(new HashSet<String>());
		rawUsings.add(new HashSet<String>());
		typedefsAtThisLevel.add(new HashMap<Pair<String, Integer>, TypeDefTypeProvider>());
	}
	
	public REPLTopLevelImports replLastTopLevelImports = new REPLTopLevelImports();
	
	private void leaveScopedNameMapREPL() {
		replLastTopLevelImports.topshortNameToLong = scopedshortNameToLongNameaa.pop();
		replLastTopLevelImports.topshortNameToLongUsing = scopedshortNameToLongNameaaUsing.pop();
		replLastTopLevelImports.toprawImports = rawImports.pop();
		replLastTopLevelImports.toprawUsings = rawUsings.pop();
		replLastTopLevelImports.toptypeDef = typedefsAtThisLevel.pop();
	}
	
	private void leaveScopedNameMap()
	{
		scopedshortNameToLongNameaa.pop();
		scopedshortNameToLongNameaaUsing.pop();
		rawImports.pop();
		rawUsings.pop();
		typedefsAtThisLevel.pop();
	}
	
	public boolean hasImportBeenRegistered(String shortname){
		return hasImportBeenRegistered(shortname, false);
	}
	
	public boolean hasUsingBeenRegistered(String shortname){
		return hasUsingBeenRegistered(shortname, false);
	}
	
	private <X> boolean hasThingBeenRegistered(Stack<Map<String/*ref anme*/, X> > thing, String shortname, boolean onlyCheckCurrentLevel) {
		if(shortname == null){
			return false;
		}
		
		for(int pos = thing.size()-1; pos >=0; pos--){
			Map<String/*ref anme*/, X> level = thing.get(pos);
			
			if(level.containsKey(shortname)){ //if first then doesnt matter
				return true;
			}
			
			if(onlyCheckCurrentLevel){
				break; //so false
			}
		}
		return false;
	}
	
	private boolean hasImportBeenRegistered(String shortname, boolean onlyCheckCurrentLevel) {
		return hasThingBeenRegistered(scopedshortNameToLongNameaa, shortname, onlyCheckCurrentLevel);
	}
	
	private boolean hasUsingBeenRegistered(String shortname, boolean onlyCheckCurrentLevel) {
		return hasThingBeenRegistered(scopedshortNameToLongNameaaUsing, shortname, onlyCheckCurrentLevel);
	}
	
	public String getImportBeenRegistered(String shortname)
	{
		for(int pos = scopedshortNameToLongNameaa.size()-1; pos >=0; pos--){
			Map<String/*ref anme*/, String> level = scopedshortNameToLongNameaa.get(pos);
			
			if(level.containsKey(shortname)){
				return  level.get(shortname);
			}
		}
		
		return null;
	}
	
	private boolean getImportOrUsingBeenRegisteredRaw(String shortname){
		for(Set<String> level : rawImports){
			if(level.contains(shortname)){
				return true;
			}
		}
		for(Set<String> level : rawUsings){
			if(level.contains(shortname)){
				return true;
			}
		}
		
		return false;
	}

	private void addImport(String shortname, String longname, boolean rawImport){
		scopedshortNameToLongNameaa.peek().put(shortname, longname);
		if(rawImport){
			rawImports.peek().add(shortname);
		}
	}
	

	private void registerImport(String shortname, String longname, int line, int col)
	{
		if(shortname.indexOf('.') > -1 )
		{
			this.raiseError(line, col, String.format("Import mapped name of: '%s' cannot contain dots" , shortname));
		}
		else
		{
			if(!this.mainLoop.doesImportedNameResolveToSomething(longname, mc))
			{
				this.raiseError(line, col, String.format("Imported name: %s cannot be resolved to a type" , longname));
			}
			else
			{
				if(this.currentScopeFrame.paThisIsModule && this.isREPL != null && this.isREPL.tliCache.topshortNameToLong.containsKey(shortname)) {//allow redefinition
					addImport(shortname, longname, true);
				}else {
					if(hasImportBeenRegistered(shortname, true)){//true so as to permit nested imports overwriting import name scopes
						this.raiseError(line, col, "Import name has already been declared: " + shortname + " as: " + longname);	
					}
					else{
						addImport(shortname, longname, true);
					}
				}
				
				
			}
		}
		
	}
	
	@Override
	public Object visit(ImportImport importImport) {
		//imports right now are top level only, but actually we do allow inner scope level declarations
		//TODO: have to remember on leaving the scope to invaidate the declared imports when doing lower down...
		//imports are not multilayerableded

		boolean isUsing = !importImport.normalImport;
		//boolean isJava = !importImport.isNormalImport;
		for(DottedAsName entry : importImport.imports)
		{
			//import x.y.z -> z = x.y.z
			//import x.y.z as p-> p= x.y.z
			if(entry.singleEntry)
			{
				int lastDot = entry.refName.lastIndexOf('.');
				if( lastDot != -1)
				{
					if(isUsing) {
						registerUsing(entry.refName.substring(lastDot+1), entry.origonalName, importImport.getLine(), importImport.getColumn());
					}else {
						registerImport(entry.refName.substring(lastDot+1), entry.origonalName, importImport.getLine(), importImport.getColumn());
					}
				}
				else
				{
					if(isUsing) {
						registerUsing(entry.refName, entry.origonalName, importImport.getLine(), importImport.getColumn());
					}else {
						registerImport(entry.refName, entry.origonalName, importImport.getLine(), importImport.getColumn());
					}
				}
			}
			else
			{
				if(isUsing) {
					registerUsing(entry.refName, entry.origonalName, importImport.getLine(), importImport.getColumn());
				}else {
					registerImport(entry.refName, entry.origonalName, importImport.getLine(), importImport.getColumn());
				}
			}
		}
		return null;
	}

	
	@Override
	public Object visit(ImportFrom importFrom) {
		//from x import y
		
		//from b import x, y as s, z; //import 3 things, not 2!
		//from b import x,y as s, z, x as j;
		
		boolean isUsing = !importFrom.normalImport;
		
		String fromPrefix = importFrom.from;
		
		if(!fromPrefix.equals("") && fromPrefix != null)
		{
			fromPrefix += ".";
		}
		
		for(ImportAsName iasname : importFrom.froms)
		{
			String fullname = fromPrefix + iasname.impt;
			
			if(isUsing) {
				registerUsing(iasname.asName, fullname, importFrom.getLine(), importFrom.getColumn());
			}else {
				registerImport(iasname.asName, fullname, importFrom.getLine(), importFrom.getColumn());
			}
		}
		return null;
	}

	@Override
	public Object visit(ImportAsName importAsName) {
		return null;//doesn't need to be explored further
	}

	private boolean areAllVoidIgnoreable(List<Type> typeChoices){
		boolean allVoidIgnorable = true;
		for(Type t: typeChoices){
			if(!(t==null || t.equals(const_void_thrown))){
				allVoidIgnorable=false;
				break;
			}
		}
		return allVoidIgnorable;
	}
	
	private Type convertSamedFuncType(Type tt) {
		if(tt instanceof FuncType) {
			FuncType asFT = (FuncType)tt;
			if(null != asFT.implementSAM) {
				return asFT.implementSAM.getA();
			}
		}
		return tt;
	}
	
	private Type getMostGenericGeneric(List<Type> typeChoices, Map<Type, Pair<Integer, Integer>> typeOffenders, int line, int cols, boolean takeThatWhichIsntNullVoid){
		Type got = null;
		//ignore null
		
		typeChoices = typeChoices.stream().map(a -> convertSamedFuncType(a)).collect(Collectors.toList());
		
		//boolean anyNullable = typeChoices.stream().anyMatch(a -> a != null && a.getNullStatus()  != NullStatus.NONNULL);
		
		if(takeThatWhichIsntNullVoid){
			//filter out null and voids
			List<Type> typeChoicesOkOnly = new ArrayList<Type>(typeChoices.size());
			for(Type t: typeChoices){
				if(TypeCheckUtils.isValidType(t)){
					typeChoicesOkOnly.add(t);
				}
			}
			
			if( typeChoicesOkOnly.isEmpty()){
				got = null;
			}
			else{
				if(areAllVoidIgnoreable(typeChoicesOkOnly)){//e.g. if(){ throw e; }else{throw e;}//then return void_id_thrown
					got= const_void_thrown;
				}
				got=TypeCheckUtils.getMoreGeneric(this, this, line, cols, typeChoicesOkOnly, typeOffenders);
			}
		}
		else{
			/*HashSet<Type> asSet = new HashSet<Type>(typeChoices);
			if(asSet.size() == 1 && typeChoices.contains(null)) {
				return null;
			}*/
			
			if(typeChoices.contains(null)){
				return null;
			}
			
			
			if(areAllVoidIgnoreable(typeChoices)){//e.g. if(){ throw e; }else{throw e;}//then return void_id_thrown
				return const_void_thrown;
			}
			
			
			while(typeChoices.contains(const_void_thrown)){
				typeChoices.remove(const_void_thrown);
			}
			
			if(!typeChoices.contains(const_void)  ){
				got = TypeCheckUtils.getMoreGeneric(this, this, line, cols, typeChoices, typeOffenders);
			}
		}
		
		/*if(anyNullable) {
			got.setNullStatus(NullStatus.NULLABLE);
		}*/
		
		return got;
	}
	
	private Stack<HashMap<Pair<String, Boolean>, Type>> asisOverwriteType = new Stack<HashMap<Pair<String, Boolean>, Type>>();
	
	
	private static class SetupAutoCastsAndNullCheck extends AbstractVisitor{
		
		@Override
		public Object visit(Is instanceOf) {
			super.visit(instanceOf);
			
			instanceOf.canBeUsedAsIsas = !ispostShortCircuit;
			
			return null;
		}
		
		private boolean ispostShortCircuit = false;
		
		@Override
		public Object visit(OrExpression orExpression) {
			//lastLineVisited=orExpression.getLine();
			orExpression.head.accept(this);
			ispostShortCircuit = true;
			for(Expression i : orExpression.things) {
				i.accept(this);
			}
			return null;
		}
		
		public void doSetup(Expression test){
			ispostShortCircuit=false;//reset
			
			test.accept(this);
		}
		
	}
	
	private final static SetupAutoCastsAndNullCheck autoCastSetterUpper = new SetupAutoCastsAndNullCheck();
	

	
	@Override
	public Object visit(IfStatement ifStatement) {
		//FUT: In a future version if statements will be able to return stuff
		
		List<Type> typeChoices = new ArrayList<Type>(2);
		//List<Expression> typeOrigins = new ArrayList<Expression>(2);
		Map<Type, Pair<Integer, Integer>> typeOffenders = new HashMap<Type, Pair<Integer, Integer>>();
		
		asisOverwriteType.push(new HashMap<Pair<String, Boolean>, Type>());
		autoCastSetterUpper.doSetup(ifStatement.iftest);

		nullableOverwriteType.push(new HashMap<Pair<String, Boolean>, NullStatus>());
		Type typ = TypeCheckUtils.unboxTypeIfBoxed((Type)ifStatement.iftest.accept(this));
		TestedNonNullAndNull testNullables = nullableTypeLogic.processTest(ifStatement.iftest);
		nullableOverwriteType.pop();
		
		
		TypeCheckUtils.assertNotVoid(typ, this, ifStatement.iftest.getLine(), ifStatement.iftest.getColumn(), "if");
		
		/*if(!((typ instanceof PrimativeType ) && ((PrimativeType)typ).type == PrimativeTypeEnum.BOOLEAN)){
			//this.raiseError(ifStatement.iftest.getLine(), ifStatement.iftest.getColumn(), "if statement expression must resolve to type boolean not: " + typ);
		}*/
		ifStatement.ifblock.canContainAContinueOrBreak = null;
		ifStatement.ifblock.canContainAReturnStmt = null;
		asisOverwriteType.push(null);
		
		HashMap<Pair<String, Boolean>, NullStatus> inFitBlock = new HashMap<Pair<String, Boolean>, NullStatus>();
		nullableOverwriteType.push(inFitBlock);
		
		testNullables.addAllNonNullToContainer(inFitBlock);
		Type iftype = (Type) ifStatement.ifblock.accept(this);
		nullableOverwriteType.pop();
		
		
		asisOverwriteType.pop();
		asisOverwriteType.pop();
		
		
		if(iftype !=null || (iftype == null && ifStatement.ifblock.isEmpty())) {
			typeChoices.add(iftype);
		}else if(ifStatement.getShouldBePresevedOnStack() && iftype == null) {
			if(!ifStatement.getHasAttemptedNormalReturn()) {
				this.raiseError(ifStatement.ifblock.getLine(), ifStatement.ifblock.getColumn(), "Return type expected");
			}
		}
		
		//typeChoices.add( iftype);
		typeOffenders.put(iftype, new Pair<Integer, Integer>(ifStatement.ifblock.getLine(), ifStatement.ifblock.getColumn()));
		
		for(ElifUnit elifUnit : ifStatement.elifunits)
		{
			Type elifType;
			{
				asisOverwriteType.push(new HashMap<Pair<String, Boolean>, Type>());
				
				
				autoCastSetterUpper.doSetup(elifUnit.eliftest);
				
				nullableOverwriteType.push(new HashMap<Pair<String, Boolean>, NullStatus>());
				Type typx = TypeCheckUtils.unboxTypeIfBoxed((Type)elifUnit.eliftest.accept(this));
				TestedNonNullAndNull eliftestNullables = nullableTypeLogic.processTest(elifUnit.eliftest);
				nullableOverwriteType.pop();
				
				
				TypeCheckUtils.assertNotVoid(typx, this, elifUnit.eliftest.getLine(), elifUnit.eliftest.getColumn(), "elif");
				
				elifUnit.elifb.canContainAContinueOrBreak = null;
				elifUnit.elifb.canContainAReturnStmt = null;
				asisOverwriteType.push(null);
				
				HashMap<Pair<String, Boolean>, NullStatus> inFitBlockelif = new HashMap<Pair<String, Boolean>, NullStatus>();
				nullableOverwriteType.push(inFitBlockelif);
				
				eliftestNullables.addAllNonNullToContainer(inFitBlockelif);
				testNullables.addAllNullToContainer(inFitBlockelif);//determined null from if test
				elifType = (Type)elifUnit.elifb.accept(this);
				nullableOverwriteType.pop();
				
				asisOverwriteType.pop();
				asisOverwriteType.pop();
			}
			
			
			if(elifType !=null || (elifType == null && elifUnit.elifb.isEmpty())) {
				typeChoices.add(elifType);
			}else if(ifStatement.getShouldBePresevedOnStack() && elifType == null) {
				if(!ifStatement.getHasAttemptedNormalReturn()) {
					this.raiseError(elifUnit.elifb.getLine(), elifUnit.elifb.getColumn(), "Return type expected");
				}
			}
			
			typeChoices.add(elifType);
			typeOffenders.put(elifType, new Pair<Integer, Integer>(elifUnit.getLine(), elifUnit.getColumn()));
		}
		
		if(null != ifStatement.elseb)
		{
			ifStatement.elseb.canContainAContinueOrBreak = null;
			ifStatement.elseb.canContainAReturnStmt = null;

			HashMap<Pair<String, Boolean>, NullStatus> inelseBlock = new HashMap<Pair<String, Boolean>, NullStatus>();
			testNullables.addAllNullToContainer(inelseBlock);
			
			nullableOverwriteType.push(inelseBlock);
			Type elseType = (Type)ifStatement.elseb.accept(this);
			nullableOverwriteType.pop();
			
			if(elseType !=null || (elseType == null && ifStatement.elseb.isEmpty())) {
				typeChoices.add(elseType);
			}else if(ifStatement.getShouldBePresevedOnStack() && elseType == null) {
				if(!ifStatement.getHasAttemptedNormalReturn()) {
					this.raiseError(ifStatement.elseb.getLine(), ifStatement.elseb.getColumn(), "Return type expected");
				}
			}
			typeOffenders.put(elseType, new Pair<Integer, Integer>(ifStatement.elseb.getLine(), ifStatement.elseb.getColumn()));
		}
		else if(ifStatement.getShouldBePresevedOnStack()){
			if(ifStatement.getHasAttemptedNormalReturn()){
				ifStatement.setShouldBePresevedOnStack(false);
			}
			else{
 				//if(forWhileExpectsReturn.isEmpty() || forWhileExpectsReturn.peek().getA()){
					this.raiseError(ifStatement.getLine(), ifStatement.getColumn(), "if statement must have else block when used in this way");
					return null;
				//}
			}
		}
		
		HashMap<Pair<String, Boolean>, NullStatus> inferedNullinBlock = ifStatement.ifblock.inferedNullability;
		
		if (null == ifStatement.elseb && ifStatement.elifunits.isEmpty()) {
			
			if (null != inferedNullinBlock && !inferedNullinBlock.isEmpty()) {
				if (!testNullables.testedNull.isEmpty()) {
					for (Pair<String, Boolean> testedasNull : testNullables.testedNull.keySet()) {
						if (inferedNullinBlock.containsKey(testedasNull)) {
							NullStatus ns = inferedNullinBlock.get(testedasNull);
							if (ns == NullStatus.NONNULL) {
								nullableOverwriteType.peek().put(testedasNull, ns);
							}
						}
					}
				}
				//any resolve to nullable:
				for(Pair<String, Boolean> key : inferedNullinBlock.keySet()) {
					if(inferedNullinBlock.get(key) == NullStatus.NULLABLE ) {
						nullableOverwriteType.peek().put(key, NullStatus.NULLABLE);
					}
				}
			}
		}else {//elif, else...
			boolean fail = false;
			
			List<HashMap<Pair<String, Boolean>, NullStatus>> inferedNullinBlocks = new ArrayList<HashMap<Pair<String, Boolean>, NullStatus>>();
			
			if (null != inferedNullinBlock && !inferedNullinBlock.isEmpty()) {
				inferedNullinBlocks.add(inferedNullinBlock);
			}else {
				fail=true;
			}
			
			for(ElifUnit eu : ifStatement.elifunits) {
				if (null != eu.elifb.inferedNullability && !eu.elifb.inferedNullability.isEmpty()) {
					inferedNullinBlocks.add(eu.elifb.inferedNullability);
				}else {
					fail=true;
				}
			}
			
			if (null != ifStatement.elseb){
				if (null != ifStatement.elseb.inferedNullability && !ifStatement.elseb.inferedNullability.isEmpty()) {
					inferedNullinBlocks.add(ifStatement.elseb.inferedNullability);
				}else {
					fail=true;
				}
			}
			
			if(!inferedNullinBlocks.isEmpty()) {
				Pair<List<Pair<String, Boolean>>, List<Pair<String, Boolean>>> nonnullAndNullable = Utils.filterNullInferMap(inferedNullinBlocks);
				HashMap<Pair<String, Boolean>, NullStatus> addto = this.nullableOverwriteType.peek();
				
				if(!fail) {
					for(Pair<String, Boolean> nonNull : nonnullAndNullable.getA()) {
						addto.put(nonNull, NullStatus.NONNULL);
					}
				}
				
				for(Pair<String, Boolean> nullableNull : nonnullAndNullable.getB()) {
					addto.put(nullableNull, NullStatus.NULLABLE);
				}
			}
		}
		
		if(ifStatement.getHasAttemptedNormalReturn()){
			ifStatement.setShouldBePresevedOnStack(false);
		}
		
		if(ifStatement.getShouldBePresevedOnStack()){
			Type got = getMostGenericGeneric(typeChoices, typeOffenders, ifStatement.getLine(), ifStatement.getColumn(), false);
			
			if(!TypeCheckUtils.isValidType(got, true)){
				String ss = ifStatement.elseb == null || ifStatement.elseb.isSynthetic?"if statement must have else block when used in this way" : "if statement must return something" ;//TODO: this doesnt work as else block always added with conitnue statement
				this.raiseError(ifStatement.getLine(),ifStatement.getColumn(), ss);
				//got = getMostGenericGeneric(typeChoices, typeOffenders, ifStatement.getLine(), ifStatement.getColumn(), true);
				got=const_void_thrown;
			}
			
			return ifStatement.setTaggedType(got);
		}
		else{
			return ifStatement.setTaggedType(null, true);
		}
	}
	
	public static final PrimativeType const_void = new PrimativeType(PrimativeTypeEnum.VOID);
	
	@Override
	public Object visit(ElifUnit elifUnit) {
		return null;
	}
	
	private void tagLambdaDetails(FuncType funcType) {
		ArrayList<Type> accInputs = new ArrayList<Type>();
		boolean missingArgType = false;
		for(Type inp : funcType.getInputs()){
			Type tt = (Type)inp.accept(this);
			
			if(null == tt){
				missingArgType=true;
			}
			
			accInputs.add(tt);
		}
		if(!missingArgType){
			funcType.setInputs(accInputs);
		}
		
		Type retla = (Type)funcType.retType.accept(this);
		if(null != retla){
			funcType.retType = retla;
		}
		
		
		ClassFunctionLocation cfl = new ClassFunctionLocation(null, null);
		
		if(funcType.isClassRefType){
			String name = funcType.retType.getBytecodeType();
			name = FuncType.classRefIfacePrefix + name.substring(1, name.length()-1) + FuncType.classRefIfacePostfix;
			cfl.setLambdaOwner(name);
		}else{
			cfl.setLambdaOwner(funcType.getNonGenericPrettyName());
		}
		
		funcType.setLambdaDetails(new TypeAndLocation(funcType, cfl));
	}
	
	@Override
	public Object visit(FuncType funcType) {
		//method things to localgens
		if(null != funcType.retType || !(funcType.retType instanceof PrimativeType)){
			//TODO: set inputs to in?
			funcType.retType.setInOutGenModifier(InoutGenericModifier.OUT);
		}
		currentlyInFuncTypeDecl.add(funcType);
		tagLambdaDetails(funcType);
		currentlyInFuncTypeDecl.pop();
		return funcType;
	}
	
	private Stack<Boolean> inSuperOrThisConstructorCall = new Stack<Boolean>();//JPT: overkill?
	
	private boolean isInSuperConstructorCall()
	{//super(x,y,4)
		if(inSuperOrThisConstructorCall.isEmpty())
		{
			return false;
		}
		else
		{
			return inSuperOrThisConstructorCall.peek();
		}
	}
	private void enterSuperConstructorCall()
	{
		inSuperOrThisConstructorCall.push(true);
	}
	
	private void leaveSuperConstructorCall()
	{
		inSuperOrThisConstructorCall.pop();
	}
	
	//private static ClassDefJava object_class = new ClassDefJava(java.lang.Object.class, true);
	public static final ClassDefJava const_cls_String = new ClassDefJava(java.lang.String.class, true); 
	public static final ClassDefJava const_ref = new ClassDefJava(com.concurnas.bootstrap.runtime.ref.Ref.class, true); 
	public static final NamedType const_ref_NT = new NamedType(new ClassDefJava(com.concurnas.bootstrap.runtime.ref.Ref.class, true)); 
	public static final NamedType const_constructorRef = new NamedType(new ClassDefJava(ClassRef.class, true)); 
	private static final ClassDefJava const_cls_Pattern = new ClassDefJava(Pattern.class, true); 
	
	public static NamedType const_Pattern = new NamedType(const_cls_Pattern);
	public static Annotation const_extensionFunctionAnnot = new Annotation(0,0, "com.concurnas.lang.ExtensionFunction", null, null,  new ArrayList<String>());
	public static String const_InjectAnnotationStr = "com.concurnas.lang.Inject";
	public static Annotation const_InjectAnnotation = new Annotation(0,0, "com.concurnas.lang.Inject", null, null,  new ArrayList<String>());
	public static ClassDefJava const_object_CD = new ClassDefJava(java.lang.Object.class);
	public static NamedType const_object = new NamedType(new ClassDefJava(java.lang.Object.class, true));
	public static ClassDefJava const_GPUBuffer = new ClassDefJava(GPUBuffer.class, true);
	public static NamedType const_object_1ar = new NamedType(new ClassDefJava(java.lang.Object.class, true));
	static{
		const_object_1ar.setArrayLevels(1);
	}
	public static NamedType const_boolean_nt = new NamedType(new ClassDefJava(Boolean.class, true));
	public static ClassDefJava const_HashMapCLS = new ClassDefJava(HashMap.class, true);
	public static NamedType const_provider = new NamedType(new ClassDefJava(ObjectProvider.class, true));
	public static NamedType cosnt_enum = new NamedType(new ClassDefJava(Enum.class, true));
	public static NamedType const_integer_nt = new NamedType(new ClassDefJava(Integer.class, true));
	public static NamedType const_long_nt = new NamedType(new ClassDefJava(Long.class, true));
	public static NamedType const_float_nt = new NamedType(new ClassDefJava(Float.class, true));
	public static NamedType const_double_nt = new NamedType(new ClassDefJava(Double.class, true));
	public static NamedType const_short_nt = new NamedType(new ClassDefJava(Short.class, true));
	public static NamedType const_byte_nt = new NamedType(new ClassDefJava(Byte.class, true));
	public static NamedType const_char_nt = new NamedType(new ClassDefJava(Character.class, true));
	public static NamedType const_void_nt = new NamedType(new ClassDefJava(Void.class, true));
	public static NamedType const_void_CLnt = new NamedType(new ClassDefJava(Void.class, true));
	public static NamedType const_lambda_nt = new NamedType(new ClassDefJava(Lambda.class, true));
	public static NamedType const_Function0 = new NamedType(new ClassDefJava(Function0.class, true));
	public static NamedType const_Function0v = new NamedType(new ClassDefJava(Function0v.class, true));
	public static ClassDefJava const_actor_class =  new ClassDefJava(com.concurnas.lang.Actor.class, true);
	public static ClassDefJava const_enumClass =  new ClassDefJava(Enum.class, true);
	public static NamedType const_Enum = new NamedType(const_enumClass);
	public static NamedType const_actor = new NamedType(const_actor_class);
	public static NamedType const_sizeof_nt = new NamedType(new ClassDefJava(com.concurnas.lang.Sizeof.class));
	public static NamedType const_Annotation_TargetCls = new NamedType(new ClassDefJava(Target.class, true));
	public static NamedType const_Annotation_SuppressWarningsCls = new NamedType(new ClassDefJava(SuppressWarnings.class, true));
	public static NamedType const_Annotation_DeprecatedCls = new NamedType(new ClassDefJava(Deprecated.class, true));
	public static NamedType const_Annotation_RetentionCls = new NamedType(new ClassDefJava(Retention.class, true));
	public static NamedType const_Annotation_DeleteOnUnusedReturn  = new NamedType(new ClassDefJava(com.concurnas.lang.DeleteOnUnusedReturn.class, true));
	public static NamedType ISOExecutor  = new NamedType(new ClassDefJava(com.concurnas.runtime.cps.ISOExecutor.class, true));
	public static NamedType const_Annotation_GPUStubFunction  = new NamedType(new ClassDefJava(com.concurnas.lang.GPUStubFunction.class, true));

	
	public static ClassDefJava const_typed_actor_class =  new ClassDefJava(com.concurnas.lang.TypedActor.class, true);
	public static NamedType const_typed_actor = new NamedType(const_typed_actor_class);
	
	public static final NamedType const_defaultParamUncre = new NamedType(new ClassDefJava(com.concurnas.runtime.DefaultParamUncreatable.class));
	static{
		const_defaultParamUncre.okToReferenceEvenIfUncreatable=true;
	}
	
	public static NamedType const_object_ref = new NamedType(0, 0, new NamedType(new ClassDefJava(java.lang.Object.class, true)));
	public static ClassDef const_ClassRef_cls = new ClassDefJava(ClassRef.class, true);
	public static ClassDef const_Local_class = new ClassDefJava(Local.class, true);
	public static NamedType const_class_ref = new NamedType(0, 0, new NamedType(new ClassDefJava(java.lang.Class.class, true)));
	public static ClassDef const_class = new ClassDefJava(java.lang.Class.class, true);
	public static NamedType const_class_nt =  new NamedType(new ClassDefJava(java.lang.Class.class, true));
	static{
		NamedType obj = const_object.copyTypeSpecific();
		obj.isWildCardAny = true;
		const_class_nt.setGenTypes(obj);
	}

	public static ClassDef const_classLoader_cls = new ClassDefJava(ClassLoader.class, true);
	public static NamedType const_classLoader = new NamedType(const_classLoader_cls);
	public static NamedType const_string = new NamedType(new ClassDefJava(String.class, true));
	public static NamedType const_reifiedType = new NamedType(new ClassDefJava(ReifiedType.class));
	public static NamedType const_transientAnnot = new NamedType(new ClassDefJava(Transient.class, true));
	public static NamedType const_transientTrait = new NamedType(new ClassDefJava(Trait.class, true));
	public static NamedType const_sharedAnnot = new NamedType(new ClassDefJava(Shared.class, true));
	public static NamedType const_list = new NamedType(new ClassDefJava(List.class, true));
	public static NamedType const_arrayList = new NamedType(new ClassDefJava(ArrayList.class, true));
	public static NamedType const_Named = new NamedType(new ClassDefJava(Named.class));
	public static NamedType const_Number = new NamedType(new ClassDefJava(java.lang.Number.class, true));
	public static NamedType const_string1dAr = new NamedType(new ClassDefJava(String.class, true));
	{
		const_string1dAr.setArrayLevels(1);
	}
	public static PrimativeType const_boolean = new PrimativeType(PrimativeTypeEnum.BOOLEAN);
	public static PrimativeType const_size_t = new PrimativeType(PrimativeTypeEnum.SIZE_T);
	/*public static PrimativeType const_size_t_Pnt = new PrimativeType(PrimativeTypeEnum.SIZE_T);
	static {
		const_size_t_Pnt.setPointer(1);
	}*/
	public static final Type list_object = new NamedType(new ClassDefJava(java.util.List.class, true));//JPT: move to global consts
	public static final Type map_object = new NamedType(new ClassDefJava(java.util.Map.class, true));//JPT: move to global consts
	public static final Type set_object = new NamedType(new ClassDefJava(java.util.Set.class, true));//JPT: move to global consts
	public static final String const_SharedStr = "com.concurnas.lang.Shared";
	
	public static final NamedType const_Optional = new NamedType(new ClassDefJava(Optional.class, true));//JPT: move to global consts
	public static final NamedType const_classArray_nt = new NamedType(new ClassDefJava(Class.class));
	public static final NamedType const_classArray_nt_array;
	static{
		const_classArray_nt.setArrayLevels(1);
		ArrayList<Type> gens = new ArrayList<Type>();
		NamedType obj = const_object.copyTypeSpecific();
		obj.isWildCardAny = true;
		gens.add(obj);
		const_classArray_nt.setGenTypes(gens);
		const_classArray_nt_array = const_classArray_nt.copyTypeSpecific();
		const_classArray_nt_array.setArrayLevels(1);
	}
	
	private static ClassDef lazyCD = null;
	public static ClassDef getLazyCD() {
		if(null == lazyCD) {
			try {
				lazyCD = new ClassDefJava(Class.forName("com.concurnas.lang.types$Lazy"));
			} catch (ClassNotFoundException e) {
				//throw new RuntimeException(e);
				return null;
			}
		}
		return lazyCD;
	}

	private static NamedType lazyNT = null;
	public static NamedType getLazyNT() {
		if(null == lazyNT) {
			lazyNT = new NamedType(getLazyCD());
		}
		return lazyNT;
	}
	
	private static NamedType const_LanguageExtension = null;
	public static NamedType getLanguageExtensionNT() {
		if(null == const_LanguageExtension) {
			try {
				const_LanguageExtension = new NamedType(new ClassDefJava(Class.forName("com.concurnas.lang.LangExt$LanguageExtension")));
			} catch (ClassNotFoundException e) {
				const_LanguageExtension = null;
			}
		}
		return const_LanguageExtension;
	}
	
	private static NamedType providerNT = null;
	public static NamedType getProviderNT() {
		if(null == providerNT) {
			try {
				providerNT = new NamedType(new ClassDefJava(Class.forName("com.concurnas.lang.types$Provider")));
			} catch (ClassNotFoundException e) {
				throw new RuntimeException(e);
			}
		}
		return providerNT;
	}
	
	//private Stack<Boolean> denyMethodInvokationDueToFiberizationImpossible = new Stack<Boolean>();
	
	private EvaluatedConstructor  evaluateConstructor(NamedType nt, List<Type> argsWanted, ArrayList<Pair<String, Type>> namessMap, int line, int col, String superthisetc, boolean hasUnqualifiedGenerics)
	{
		NamedType on = nt;
		int extraArgsAdded = 0;
		if(null == argsWanted){
			argsWanted = new ArrayList<Type>();
		}
		
		if(!nt.isInstantiable())
		{
			if(!superthisetc.equals("super ")){//can invoke an superconstructor of an abstract class
				this.raiseError(line, col, String.format("Cannot instantiate type: '%s'", nt));
				return null;
			}
		}
		
		boolean isActor = false;
		if(null != TypeCheckUtils.checkSubType(this.ers, const_actor, nt, 0, 0, 0, 0)){
			//its an actor, so check, track back all the way to actor
			//nt = ((NamedType)TypeCheckUtils.extractTypedActorType(this, nt));
			if(superthisetc.equals("")){//if its an actor call and non this/super invokation, then we need to add the type array
				NamedType acteent = ((NamedType)TypeCheckUtils.extractTypedActorType(this, nt));
				if(null != acteent){
					NamedType par = acteent.getparentNestorFakeNamedType();
					if(null != par){
						//nested so add parent as next argument
						argsWanted.add(0, par.copyTypeSpecific());
						extraArgsAdded++;
					}
				}
				
				argsWanted.add(0, const_classArray_nt_array);
				extraArgsAdded++;
			}
			isActor=true;
		}
		
		if(nt.getSetClassDef() == null){
			this.raiseError(line, col, String.format("Unable to resolve type corresponding to name for constructor: ", nt));
			return null;
		}
		
		boolean refTypeConstructor = TypeCheckUtils.hasRefLevels(nt);
		
		if(refTypeConstructor){
			//add hidden argument, type array as first argumnet
			argsWanted.add(0, const_classArray_nt);
			extraArgsAdded++;
			nt.setLockedAsRef(true);
		}
		
		Set<FuncType> matchingFuncNames = nt.getConstructor(line, col, argsWanted, namessMap, (ErrorRaiseableSupressErrors)ers, this);//turns out this is only useful for private constructors...
		
		if(null == matchingFuncNames || matchingFuncNames.isEmpty()){
			//String withArgs = origArgs.isEmpty()? " - with no arguments" : String.format(" with arguments: %s", origArgs);
			ClassDef res = nt.getSetClassDef();
			if(res != null){
				if(res.getIsAbstract()){
					this.raiseError(line, col, String.format("Unable to resolve reference to %sconstructor for: '%s' as its super class is abstract", superthisetc, nt));
					return null;
				}if(res.isTrait) {
					this.raiseError(line, col, String.format("%s is a trait. Traits cannot be instantiated", nt));
					return null;
				}
			}
			
			this.raiseError(line, col, String.format("Unable to resolve reference to %sconstructor for: '%s'%s", superthisetc, nt, TypeCheckUtils.formatArgs(argsWanted, namessMap)));
			return null;
		}
		else
		{
			Set<FuncType>	 accessableConstructors = getLocallyAccessableConstructors(nt, matchingFuncNames);
			
			//first only those functions that are accesable
			FuncType mostSpec = TypeCheckUtils.getMostSpecificFunctionForChoicesFT( this.getErrorRaiseableSupression(), ers, accessableConstructors, argsWanted, namessMap, "constructor", line, col, false, this, false).getA();
			
			if(null != mostSpec && mostSpec.hasBeenVectorized != null){
				NamedType retnt = (NamedType)nt.copy();
				
				retnt = (NamedType)TypeCheckUtils.applyVectStruct(mostSpec.hasBeenVectorized.getA(), retnt);
				
				mostSpec.retType = retnt;
			}
			
			boolean hadToAddrefTypes = false;
			if(null == mostSpec){//try again but reffing up the tyes
				mostSpec = TypeCheckUtils.getMostSpecificFunctionForChoicesFT( this.getErrorRaiseableSupression(), ers, accessableConstructors, argsWanted, namessMap, "constructor", line, col, true, this, false).getA();
				hadToAddrefTypes=true;	
			}
			
			
			if(null == mostSpec){
				//if none then try all of them inc the ones not accesable
				Pair<FuncType, FuncType> primaryAndNextBest = TypeCheckUtils.getMostSpecificFunctionForChoicesFT( this, ers, matchingFuncNames, argsWanted, namessMap, "constructor", line, col, false, this, hasUnqualifiedGenerics);//.getA();
				mostSpec = primaryAndNextBest.getA();
				if(null != mostSpec) {
					accessableConstructors = getLocallyAccessableConstructors(nt, matchingFuncNames);
					this.raiseError(line, col, "The constructor is not visible");
				}
				return new EvaluatedConstructor(nt, mostSpec, false, extraArgsAdded, primaryAndNextBest.getB()); //dunno if we need to do some bytecode tagging? - well an err gets through doesnt it!?
			}
			else if(null != mostSpec.hasBeenVectorized){
				nt = (NamedType)mostSpec.retType;
				
			}

			for(Type tt : mostSpec.inputs) {
				NamedType upperBound = tt.getOrigonalGenericTypeUpperBound();
				if(null != upperBound) {
					upperBound.accept(this);
				}
			}
			
			List<Type> mappedArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, mostSpec, argsWanted, namessMap, isActor?1:0, true, false);
			if(mappedArgs.stream().allMatch(a -> a != null)){
				if(mappedArgs.stream().anyMatch(a -> a.getNullStatus() == NullStatus.NULLABLE)) {
					int sz = mappedArgs.size();
					if(sz == mostSpec.inputs.size()) {
						for(int n = 0; n < sz; n++) {
							Type wanted = mostSpec.inputs.get(n);
							Type got = mappedArgs.get(n);
							
							if(!TypeCheckUtils.isNullable(wanted) && !TypeCheckUtils.isUnknown(wanted) && TypeCheckUtils.isNullable(got)) {//null check:
								this.raiseError(line, col, String.format("Argument %s passed to constructor (of %s) can be null (%s), but constructor argument type(%s) is not nullable", n+1, nt, got, wanted));
							}
						}
					}
				}
			}
			
			return new EvaluatedConstructor(isActor?on:nt, mostSpec, hadToAddrefTypes, extraArgsAdded); //TODO: generic arguments need to be captured in this arragement?
		}
	}
	
	//EvaluatedConstructor
	private static class EvaluatedConstructor{
		private Type actingOn;
		private FuncType constType;
		private boolean hadToAddrefTypes;
		private int extrArgs;
		private FuncType nextBestConstType;

		public EvaluatedConstructor(Type actingOn, FuncType constType, boolean hadToAddrefTypes, int extrArgs, FuncType nextBestConstType) {
			this.actingOn = actingOn;
			this.constType = constType;
			this.hadToAddrefTypes = hadToAddrefTypes;
			this.extrArgs = extrArgs;
			this.nextBestConstType = nextBestConstType;
		}
		
		public EvaluatedConstructor(Type actingOn, FuncType constType, boolean hadToAddrefTypes, int extrArgs) {
			this(actingOn, constType, hadToAddrefTypes, extrArgs, null);
		}
		
		public Type getA() {
			return this.actingOn;
		}
		
		public FuncType getB() {
			return this.constType;
		}
		
		public boolean getC() {
			return this.hadToAddrefTypes;
		}
		
		public int getD() {
			return this.extrArgs;
		}
		
		public FuncType getNextBest() {
			return this.nextBestConstType;
		}
		
	}
	
	private Set<FuncType> getLocallyAccessableConstructors(NamedType nt, Set<FuncType> matchingFuncNames){
		ClassDef currentCls = this.currentlyInClassDef.isEmpty()?null: this.currentlyInClassDef.peek();
		
		Set<FuncType> funcsWithRestriuctedAccess = new HashSet<FuncType>();
		for(FuncType ft: matchingFuncNames){
			AccessModifier am = ft.getUnderlyingDefAccessMod();
			
			if(am == AccessModifier.PRIVATE || am == AccessModifier.PROTECTED){
				if(!isAccesible(am, nt, currentCls, true, this.getFullyDottedPackage())){
					continue;
				}
			}
			
			funcsWithRestriuctedAccess.add(ft);
		}
		return funcsWithRestriuctedAccess;
	}
	
	
/*	private void tagNeedCheckCastIfClone(FuncInvoke funcInvoke,  TypeAndLocation tal) {
		if(funcInvoke.funName.equals("clone")){
			Location loc = tal==null?null: tal.getLocation();
			funcInvoke.addCheckCastToRetType = null != loc && loc instanceof ClassFunctionLocation && ((ClassFunctionLocation)loc).owner.equals("java.lang.Object");
		}
	}*/
	
	/*private void canInvokeMethod(int line, int col){
		if(!denyMethodInvokationDueToFiberizationImpossible.isEmpty() && denyMethodInvokationDueToFiberizationImpossible.peek()){
			this.raiseError(line, col, String.format("Methods cannot be invoked inside epxresions that are used as arguments for constructors of argumented jdk [child-]classes"));
		}
	}*/
	
	
	/*
	 * findMatchingFunction, ref the types on the second attempt
	 */
	private MatchingFunction findMatchingFunctionTryReff(FuncInvoke funcInvoke, String name, ArrayList<Type> argsWanted, ArrayList<Pair<String, Type>> namessMap, int line, int col, boolean showErrors, boolean ignoreGenericsOnNOMatch){
		MatchingFunction mostSpecificTAL = null;
		mostSpecificTAL = findMatchingFunction(funcInvoke, showErrors?this:this.ers, name,  argsWanted, namessMap, line, col, funcInvoke==null?null:funcInvoke.genTypes, false, showErrors, ignoreGenericsOnNOMatch);
		boolean unrefCanBeConstructed = mostSpecificTAL.getC();
		if(null == mostSpecificTAL.getA()){//try again but reffing up the tyes
			mostSpecificTAL = findMatchingFunction(funcInvoke, showErrors?this:this.ers, name,  argsWanted, namessMap, line, col, funcInvoke==null?null:funcInvoke.genTypes, true, showErrors, ignoreGenericsOnNOMatch);//hadToAddrefTypes=true;	
		}
		
		if(null == mostSpecificTAL.getA()){
			mostSpecificTAL = new MatchingFunction(mostSpecificTAL.getA(), mostSpecificTAL.getB(),mostSpecificTAL.getC() || unrefCanBeConstructed, mostSpecificTAL.getNextBest() );
		}
		
		return mostSpecificTAL;
	}
	
	private boolean precceededByThisSuperOrNothing(){
		boolean actorCanCallPrivatProtected = false;
		if(this.currentDotOperatorTracker.isEmpty()){//myPrivCall()
			actorCanCallPrivatProtected = true;
		}
		else{
			DotOperatorAndIndex dopIdx = this.currentDotOperatorTracker.peek();
			if(dopIdx.ignore && !this.dotOperatorLHS.isEmpty() && null != this.dotOperatorLHS.peek()){
				return false;
			}
			if(dopIdx.idx == 0){//myPrivCall().dox()
				actorCanCallPrivatProtected = true;
			}
			else{//this.supActorCall(); or super.supActorCall(); - ok
				Expression prevItem = dopIdx.dop.getElements(this).get(dopIdx.idx-1);
				if(prevItem instanceof RefThis || prevItem instanceof RefSuper){
					actorCanCallPrivatProtected = true;
				}
			}
		}
		
		return actorCanCallPrivatProtected;
	}
	
	private boolean precceededBySuper(){
		boolean ret = false;
		if(!this.currentDotOperatorTracker.isEmpty()){//myPrivCall()
			DotOperatorAndIndex dopIdx = this.currentDotOperatorTracker.peek();
			if(!dopIdx.ignore && dopIdx.idx != 0){
				return (dopIdx.dop.getElements(this).get(dopIdx.idx-1)) instanceof RefSuper;
			}
		}
		
		return ret;
	}
	private boolean precceededByThis(){
		boolean ret = false;
		if(null == currentlyInExtensionFunction() && !this.currentDotOperatorTracker.isEmpty()){//myPrivCall()
			DotOperatorAndIndex dopIdx = this.currentDotOperatorTracker.peek();
			if(!dopIdx.ignore && dopIdx.idx != 0){
				return (dopIdx.dop.getElements(this).get(dopIdx.idx-1)) instanceof RefThis;
			}
		}
		
		return ret;
	}
	
	private boolean precceededByNothing(){
		boolean actorCanCallPrivatProtected = false;
		if(this.currentDotOperatorTracker.isEmpty()){//myPrivCall()
			actorCanCallPrivatProtected = true;
		}
		else{
			DotOperatorAndIndex dopIdx = this.currentDotOperatorTracker.peek();
			if(dopIdx.idx == 0){//myPrivCall().dox()
				actorCanCallPrivatProtected = true;
			}
		}
		
		return actorCanCallPrivatProtected;
	}
	
	/*private boolean currentlyInAsyncBlock() {
		int csize =  currentlyInBlock.size();
		
		for(int n = csize-1; n >=0; n--) {
			Block par = currentlyInBlock.get(n);
			if(par.isClass) {
				break;
			}
			if(par.isAsyncBlock) {
				return true;
			}
		}

		return false;
	}*/
	
	private String directFunctoActorMethodIfValid(FuncInvoke funcInvoke, FuncType foundFT, String tryNamex, String name, int line, int col){
		//actors private or protected methods can only be accessed when preceeded by this, super or nothing - cannot be accessed from other objects, -> actor violation
		//note the access itself is direct, so "$ActorSuperCall" is not appended
		//this is a special restriction for actors.
		//if it's a public method we only need to direct the actor call to the $Actor[Super?]Call if its on a different object than us, i.e. not this or super
		if(null != foundFT && null != foundFT.origonatingFuncDef){
			AccessModifier am = foundFT.origonatingFuncDef.accessModifier;
			boolean isSelfCall = precceededByThisSuperOrNothing();
			if(am == AccessModifier.PROTECTED || am == AccessModifier.PRIVATE){
				if(!isSelfCall){
					this.raiseError(line, col, "Actors cannot call private or protected methods on instances other than those preceeded with a this or super reference, method: " + name);
				}
			}
			else {
				if(!isSelfCall /*|| currentlyInAsyncBlock() */){//if its a call to a public actor method not preceeded by this or super method then we dont direct to the $ActorCall - it does!
					if(null != funcInvoke){
						funcInvoke.funName = tryNamex;
					}
					return tryNamex;
				}
			}
		}
		
		return null;
	}
	
	private Pair<String, MatchingFunction> findAndRedirectFunctionToActee(String name, ArrayList<Type> argsWanted, ArrayList<Pair<String, Type>> namessMap, FuncInvoke funcInvoke, int line, int col, boolean showErrors, boolean ignoreGenericsOnNOMatch ){
		//only showErrors to true on last hope call to this function
		String redirectTo = null;
		MatchingFunction mostSpecificTAL = null;
		
		
		boolean actingOnActor = false;
		boolean isLockedAsActor=false;
		if(!this.dotOperatorLHS.isEmpty()){
			Type top = this.dotOperatorLHS.peek();
			if(top instanceof NamedType){
				NamedType asNamed = (NamedType)top;
				actingOnActor = TypeCheckUtils.isTypedOrUntypedActor(this, asNamed);
				isLockedAsActor = asNamed.isLockedAsActor;
			}
		}else {//possible local actor call
			if(!this.currentlyInClassDef.isEmpty()) {
				ClassDef cd = this.currentlyInClassDef.peek();
				
				actingOnActor = null != TypeCheckUtils.checkSubType(this.ers, ScopeAndTypeChecker.const_actor, new NamedType(cd));
			}
		}
				
		if(actingOnActor && isLockedAsActor){
			String tryName = name;
			if(!name.endsWith("$ActorSuperCall")){
				tryName = name + "$ActorSuperCall";
			}
			
			mostSpecificTAL = findMatchingFunctionTryReff(funcInvoke, tryName,  argsWanted, namessMap, line, col, showErrors, ignoreGenericsOnNOMatch);
			
			if(null != mostSpecificTAL.getA()){
				if(null != funcInvoke){
					funcInvoke.funName = tryName;
					//no need to bother redirectTo since not used by caller
				}
			}
			else{
				mostSpecificTAL = findMatchingFunctionTryReff(funcInvoke, name,  argsWanted, namessMap, line, col, showErrors, ignoreGenericsOnNOMatch);
				if(null == mostSpecificTAL.getA()){
					this.raiseError(line, col, "Unable to find method with matching name for actor: " + TypeCheckUtils.filterOutActorCall(name));
				}
			}
		}
		else{
			
			if(actingOnActor && !name.endsWith("$ActorSuperCall") && !name.endsWith("$ActorCall")){//look for the actorcall variant of the method if its not defined in the actor itself
				FuncType foundFT;
				String tryName=null;
				if(precceededByThisSuperOrNothing()){//we must be inside the actor, therefore dont try to route to actee
					foundFT=null;
				}
				else{
					//and not already routed to actee
					tryName = name + "$ActorCall";
					/*if(!tryName.endsWith("$ActorCall")){
						tryName += "$ActorCall";
					}*/
					mostSpecificTAL = findMatchingFunctionTryReff(funcInvoke, tryName, argsWanted, namessMap, line, col, showErrors, ignoreGenericsOnNOMatch);
					foundFT = mostSpecificTAL.getA();
				}
				
				if(null != foundFT){
					this.maskErrors(true);
					redirectTo = directFunctoActorMethodIfValid(funcInvoke, foundFT, tryName, name, line, col);//is this possible?
					ArrayList<CapMaskedErrs> err = this.getmaskedErrors();
					if(!err.isEmpty()){
						mostSpecificTAL= new MatchingFunction(null, mostSpecificTAL.getB(), mostSpecificTAL.getC());
						this.applyMaskedErrors(err);
					}
				}
				else{
					String tryNamex = name + "$ActorSuperCall";
														
					mostSpecificTAL = findMatchingFunctionTryReff(funcInvoke, tryNamex, argsWanted, namessMap, line, col, showErrors, ignoreGenericsOnNOMatch);
					foundFT = mostSpecificTAL.getA();
					if(null != foundFT){
						redirectTo = directFunctoActorMethodIfValid(funcInvoke, foundFT, tryNamex, name, line, col);
					}
					else{//try as normal
						mostSpecificTAL = findMatchingFunctionTryReff(funcInvoke, name,  argsWanted, namessMap, line, col, showErrors, ignoreGenericsOnNOMatch);
					}
				}
			}
			else{
				mostSpecificTAL = findMatchingFunctionTryReff(funcInvoke, name,  argsWanted, namessMap, line, col, showErrors, ignoreGenericsOnNOMatch);
			}
			
		}
		
		
		/*for(Type tt : argsWanted) {
			NamedType upperBound = tt.getOrigonalGenericTypeUpperBound();
			if(null != upperBound) {
				upperBound.accept(this);
			}
		}*/
		
		return new Pair<String, MatchingFunction>(redirectTo, mostSpecificTAL);
	}
	
	private Pair<Node, Object> redirectToFuncRef(int line, int col, FuncInvokeArgs args, ArrayList<Type> generics, String name){
		HashMap<Integer, Node> attemptRedirectToFuncRef = new HashMap<Integer, Node>();
		HashMap<Integer, Node> attemptRedirectToFuncRefNameMap = new HashMap<Integer, Node>();
		int n=0;
		for(Expression origItem : args.asnames ){
			isNodeReallyAUnderscoreType((Node)origItem, attemptRedirectToFuncRef, n++);
		}
		
		n=0;
		for(Pair<String, Object> origItem : args.nameMap ){
			Object resolvesTo = origItem.getB();
			if(resolvesTo instanceof Node){
				Node itemAsNode =(Node)resolvesTo;
				isNodeReallyAUnderscoreType(itemAsNode, attemptRedirectToFuncRefNameMap, n);
			}
			
			n++;
		}
		
		if(!attemptRedirectToFuncRef.isEmpty() || !attemptRedirectToFuncRefNameMap.isEmpty()){//e.g. ln = foo(String, 12, 33) => ln = foo&(_ String, 12, 33)
			//try as a function ref instead of a funcinvokation
			ArrayList<Type> genTypes;
			if(null != generics && !generics.isEmpty()){
				genTypes = new ArrayList<Type>(generics.size());
				for(Type genQual : generics){
					genTypes.add((Type)genQual.copy());
				}
			}else{
				genTypes = new ArrayList<Type>(0);
			}
			

			FuncRefArgs fra = new FuncRefArgs(line, col);
			int argCnt = args.asnames.size();
			for(n = 0; n < argCnt; n++){
				if(attemptRedirectToFuncRef.containsKey(n)){//tpye
					fra.addType((Type)attemptRedirectToFuncRef.get(n));
				}else{//expression
					fra.addExpr(args.asnames.get(n));
				}
			}
			
			n=0;
			for(Pair<String, Object> origItem : args.nameMap ){
				if(attemptRedirectToFuncRefNameMap.containsKey(n)){
					fra.addName(origItem.getA(), attemptRedirectToFuncRefNameMap.get(n));
				}else{
					fra.addName(origItem.getA(), origItem.getB());
				}
				
				n++;
			}
			
			FuncRef fr = new FuncRef(line, col, new RefName(name), fra);
			fr.genTypes = genTypes;
			
			this.maskErrors();
			Object what = fr.accept(this);
			if(!this.maskedErrors()){
				//caller can ast redirect and return via this
				return new Pair<>(fr, what);
			}
		}
		return null;
	}
	
	@Override
	public Object visit(FuncInvoke funcInvoke) {
		if(funcInvoke.astRedirectforOnChangeNesting != null){
			this.dotOperatorLHS.push(null);//fresh scope
			this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
			Object x = funcInvoke.astRedirectforOnChangeNesting.accept(this);
			this.dotOperatorLHS.pop();
			this.currentDotOperatorTracker.pop();
			return x;
		}
		
		String name =  funcInvoke.funName;
		
		ArrayList<Type> argsWanted = new ArrayList<Type>(funcInvoke.args.asnames.size());
		
		if(null != funcInvoke.genTypes){//e.g. lc.proc[Integer]("hi", new Integer(12), kid) // [Integer is the gen type]
			for(Type t : funcInvoke.genTypes){
				this.dotOperatorLHS.push(null);
				this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
				t.accept(this);
				this.dotOperatorLHS.pop();
				this.currentDotOperatorTracker.pop();
			}
			funcInvoke.genTypes = TypeCheckUtils.boxTypeIfPrimative(funcInvoke.genTypes, false);
		}
		
		this.dotOperatorLHS.push(null);
		this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
		int firstArgLine = funcInvoke.getLine();
		int firstArgCole = funcInvoke.getColumn();
		
		//canInvokeMethod(firstArgLine, firstArgCole);
		
		//check args see if we can route to a funcref instead of a funcinvokation
		
		Pair<Node, Object> redirectToFuncRef = redirectToFuncRef(firstArgLine, firstArgCole, funcInvoke.args, funcInvoke.genTypes, name);
		if(null != redirectToFuncRef){
			funcInvoke.astRedirect = (FuncRef)redirectToFuncRef.getA();
			this.dotOperatorLHS.pop();
			this.currentDotOperatorTracker.pop();
			return redirectToFuncRef.getB();
		}
		
		for(Expression e : funcInvoke.args.asnames ){
			Type t = (Type)e.accept(this);
			t = t == null?null:(Type)(t).copy();
			Type originRefType = t;
			firstArgLine = e.getLine();//more like the last...
			firstArgCole=e.getColumn();
			if(TypeCheckUtils.hasRefLevelsAndNotLocked(t)){//extract ref like this: functo(refThing) //calls non ref version
				t = TypeCheckUtils.getRefType(t);
			}
			if(t != originRefType){
				//if(t instanceof NamedType) {
					((AbstractType)t).originRefType = originRefType;
				//}
			}
			
			if(t!= null && t.getInOutGenModifier() != null){
				t.setInOutGenModifier(null);
			}
			
			argsWanted.add(t);
		}
		
		ArrayList<Pair<String, Type>> namessMap = getNameMap(funcInvoke.args);
		
		this.dotOperatorLHS.pop();
		this.currentDotOperatorTracker.pop();
		
		//boolean actingOnActor = false;
		NamedType lhsOpOnType = null;
		if(!this.dotOperatorLHS.isEmpty()){
			Type top = this.dotOperatorLHS.peek();
			if(top instanceof NamedType){
				NamedType asNamed = (NamedType)top;
				//actingOnActor = TypeCheckUtils.isTypedOrUntypedActor(this, asNamed);
				lhsOpOnType = asNamed;
			}
		} 
		
		this.maskErrors(true);
		
		
		//next line expect fully generic qualified output
		boolean ignoreGenericsOnNoMatch = argsWanted.stream().anyMatch(a -> (a instanceof NamedType && ((NamedType)a).requiresGenTypeInference))
				|| namessMap.stream().anyMatch(a -> a.getB() instanceof NamedType && ((NamedType)a.getB()).requiresGenTypeInference )
				|| (null != lhsOpOnType && lhsOpOnType.requiresGenTypeInference);
		
		
		if(name.equals("bar")) {
			int h = 9;
		}
		
		MatchingFunction mostSpecificTAL = findAndRedirectFunctionToActee(name, argsWanted, namessMap, funcInvoke,  funcInvoke.getLine(), funcInvoke.getColumn(), true, ignoreGenericsOnNoMatch ).getB();
		ArrayList<CapMaskedErrs> preverrs = this.getmaskedErrors();
			
		if(mostSpecificTAL.getB() != null){
			Location loc = mostSpecificTAL.getB().getLocation();
			if(loc != null && loc.islazyLambdaVar) {
				//x() => redirect to => x:unassign()()
				int line = funcInvoke.getLine();
				int col = funcInvoke.getColumn();
				RefName rn = new RefName(line, col, funcInvoke.funName);
				rn.supressUnassign = true;//else inf loop
				
				DotOperator unassign = DotOperator.buildDotOperatorOneNonDirect(line, col, rn, new FuncInvoke(line, col, "unassign", new FuncInvokeArgs(line, col)));
				

				funcInvoke.isReallyLambda = null!= loc?loc.isLambda():false;
				
				funcInvoke.astRedirect = new FuncRefInvoke(line, col, unassign, funcInvoke.args);
				return funcInvoke.astRedirect.accept(this);
			}
			
			Type tt = mostSpecificTAL.getB().getType();
			if(tt instanceof FuncType){
				funcInvoke.bytecodefunName = ((FuncType)tt).nameRedirect;
			}
		}
		
		//JPT: adjust this function to return the one that's most approperiate given the accesibility contraints, else just ruturn one that will fail meh <- what is this about?
		
		
		if(null == mostSpecificTAL.getA())
		{
			if(mostSpecificTAL.getC()){//saving grace, turns out that this actually resolves to a constructor
				funcInvoke.astRedirect = new New(funcInvoke.getLine(), funcInvoke.getColumn(), new NamedType(funcInvoke.getLine(), funcInvoke.getColumn(), name, funcInvoke.genTypes), funcInvoke.args, true);
				return funcInvoke.astRedirect.accept(this);
			}
			else{
				//see if this resolves to a namedType with invoke overloaded
				//we call this second after conventional look to avoid cases where someone has declared a lambda field called invoke. e.g class X{invoke = def() = "hi";} etc
				this.maskErrors();
				RefName rn = new RefName(0,0, name);
				rn.setPreceedingExpression(funcInvoke);
				Type nameTo = (Type)rn.accept(this);
				nameTo = TypeCheckUtils.getRefTypeToLocked(nameTo);
				String findOpErr="";
				if(nameTo instanceof NamedType && rn.resolvesTo != null && rn.resolvesTo.getLocation() != null){//resolves to a field not a constructor type
					//m = MYClass() <- we dont want this, but m(), <- this we want
					FuncInvoke overloaded = canBeOperatorOverloaded(nameTo, argsWanted, funcInvoke.args, "invoke", funcInvoke.args.asnames, funcInvoke.getLine(), funcInvoke.getColumn(), false, null, false, funcInvoke.astOverrideOperatorOverload);
					if(null != overloaded){
						funcInvoke.astOverrideOperatorOverload = DotOperator.buildDotOperator(funcInvoke.getLine(), funcInvoke.getColumn(), rn, overloaded);
						this.maskedErrors();
						flagNullableForOperation(funcInvoke.getLine(), funcInvoke.getColumn(), nameTo);
						return (Type)funcInvoke.astOverrideOperatorOverload.accept(this);
					}
					findOpErr = makeMissingOpOverLoadMessage("invoke", nameTo, argsWanted, null);
				}
				this.maskedErrors();
				
				this.applyMaskedErrors(preverrs, "", findOpErr);//above failed so place errors from perviously back on
			}
			
			if(!this.currentlyInClassDef.isEmpty()){
				if(precceededByNothing() && currentlyInClassDef.peek().isActor ){
					//see if we can find the thing as: of.theOrigCall();
					//and not prefixed already
					this.maskErrors();
					
					int line = funcInvoke.getLine();
					int col = funcInvoke.getColumn();
					DotOperator prefixedWithFor = DotOperator.buildDotOperator(line, col, new RefOf(line, col), (FuncInvoke)funcInvoke.copy());
					
					Type resolves = (Type)prefixedWithFor.accept(this);
							
					if(!this.maskedErrors()){//it worked!
						funcInvoke.astRedirect = prefixedWithFor;
						return resolves;
					}
				}
			}
			//return const_object;//already erreed - avoid cascade of errors by returning something generic, i.e. object
			
			TypeAndLocation tal = mostSpecificTAL.getNextBest();
			if(null != tal) {
				if(!namessMap.isEmpty()) {
					funcInvoke.args.argsWithNamedParams = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, tal.getType(), funcInvoke.args.asnames, getNameMapExpr(funcInvoke.args), 0, false, false);
				}
				
				funcInvoke.resolvedFuncTypeAndLocation = tal;
			}
			
			
			return const_void_errored;
		}
		
		FuncType mostSpec = mostSpecificTAL.getA();
		
		if(mostSpec.getNullStatus() == NullStatus.NULLABLE) {//a nullable lambda
			
			NullStatus inferedAs = null;
			
			if(!this.nullableOverwriteType.isEmpty()){
				Pair<String, Boolean> key = makeRefNameTypeOverrideKey(funcInvoke);
				inferedAs = inferredAs(key);
			}
			
			
			boolean nullableLambda = inferedAs == null || inferedAs == NullStatus.NULLABLE;
			
			if(nullableLambda) {
				this.raiseError(funcInvoke.getLine(), funcInvoke.getColumn(), String.format("Lamdba: %s is nullable and may be null" , name));
			}
			
		}
				
		if(mostSpec.isAbstarct())
		{//(new AbstractThing()).meth() -- bad,
			
			boolean selfCall = this.dotOperatorLHS.isEmpty() || precceededByThis() || precceededBySuper();
			
			if(!this.currentlyInClassDef.isEmpty() && selfCall){
				ClassDef currentCls = this.currentlyInClassDef.peek();
				
				ClassDef parentInwhichDef = currentCls.isParentNestorEQOrSUperClass(mostSpec.origin);
				if(null != parentInwhichDef ){
					if(!(parentInwhichDef.equals(currentCls) || currentCls.isParentNestor(parentInwhichDef)) ){
						//if NOT same as current class then, and its abstract
						if(!(currentCls.isTrait && precceededBySuper())) {
							this.raiseError(funcInvoke.getLine(), funcInvoke.getColumn(), String.format("Cannot directly invoke the abstract method: %s" , name));
						}
					}
				}
			}
		}
			

		TypeAndLocation tal = mostSpecificTAL.getB();

		funcInvoke.isReallyLambda = null!= tal.getLocation()?tal.getLocation().isLambda():false;
		
		if(mostSpec.hasBeenVectorized != null ){
			FuncType ft = (FuncType)tal.getType();
			if(ft.origonatingFuncDef != null && ft.origonatingFuncDef.isNestedFuncionDef) {
				funcInvoke.resolvedFuncTypeAndLocation = tal;
			}
			
			//dealt with later
			funcInvoke.vectroizedDegreeAndArgs = mostSpec.hasBeenVectorized; 
			
			mostSpec.retType = mostSpec.hasBeenVectorized.getD();
			
			//JPT: nasty copy paste from below, see if this can be removed
			ArrayList<Expression> exprArgs = funcInvoke.args.asnames;
			ArrayList<Pair<String, Expression>> namessMapExpr = getNameMapExpr(funcInvoke.args);
			
			List<Expression> mappedArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, tal.getType(), exprArgs, namessMapExpr, 0, false, false);
			
			if(!TypeCheckUtils.typeListEquals(mappedArgs, exprArgs)){//changes made?
				funcInvoke.args.argsWithNamedParams = mappedArgs;
			}
			
			return funcInvoke.setTaggedType(mostSpec.retType);
		}else {
			funcInvoke.resolvedFuncTypeAndLocation = tal;
		}
		
		if(tal.getLocation().redirectExtFuncOrWithExpr != null){//i.e. repoint to: "this$extFunc. xxx ()..."
			funcInvoke.primaryASTOverride = null;
			funcInvoke.primaryASTOverride = DotOperator.buildDotOperator(funcInvoke.getLine(), funcInvoke.getColumn(), new RefName(tal.getLocation().redirectExtFuncOrWithExpr), (FuncInvoke)funcInvoke.copy());
			
			this.dotOperatorLHS.push(null);//fresh scope
			this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
			Object x = funcInvoke.primaryASTOverride.accept(this);
			this.dotOperatorLHS.pop();
			this.currentDotOperatorTracker.pop();
			
			return x;
		}
		
		

		Type fromTal = tal.getType();
		if(fromTal instanceof FuncType ) {
			if(this.currentDotOperatorTracker.size()<=1 || this.currentDotOperatorTracker.peek().isProcesingLastElement()) {//only deal with last one
				FuncType asFT = (FuncType)fromTal;
				ArrayList<GenericType> localGenerics = asFT.getLocalGenerics();
				if(localGenerics != null && !localGenerics.isEmpty() && null != funcInvoke.genTypes && funcInvoke.genTypes.isEmpty()) {
					
					Type retType = asFT.retType;
					if(retType instanceof NamedType) {
						NamedType retNT = (NamedType)retType;
						HashSet<GenericType> unbounded = TypeCheckUtils.findUnboundedGenerics(retNT);
						
						if(!unbounded.isEmpty()) {
							//if any local gens in returned named type then tag nt as needing inference, then map back to funcinvoke local gens
							if(localGenerics.stream().anyMatch(a -> unbounded.contains(a))) {
								retNT.requiresGenTypeInference=true;
								funcInvoke.requiresGenTypeInference=true;
								this.attemptGenTypeInference=true;
							}
						}
					}
				}
			}
		}
		
		FuncType funcTBeingCalled = (FuncType)TypeCheckUtils.getRefType(fromTal);
		AccessModifier am = funcTBeingCalled.getUnderlyingDefAccessMod();
		
		if(funcInvoke.isReallyLambda){
			am = tal.getLocation().getAccessModifier();
		}
		else{
			am = funcTBeingCalled.getUnderlyingDefAccessMod();
		}
		
		validateMethodVisibility(am, tal,  name, funcInvoke, mostSpec);
		
		
		
		ArrayList<Expression> exprArgs = funcInvoke.args.asnames;
		ArrayList<Pair<String, Expression>> namessMapExpr = getNameMapExpr(funcInvoke.args);
		List<Expression> mappedArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, tal.getType(), exprArgs, namessMapExpr, 0, false, false);
		//check all mapped
		List<Boolean> assertNonNull = null;
		
		if(mappedArgs.stream().allMatch(a -> null != a && a.getTaggedType() != null)) {
			if(mappedArgs.stream().anyMatch(a -> a.getTaggedType().getNullStatus() != NullStatus.NONNULL)) {//some non null
				ArrayList<Type> wanted = mostSpec.getInputs();
				int sz = wanted.size();
				
				if(mappedArgs.size() == sz) {
					assertNonNull = new ArrayList<Boolean>(sz);
					
					for(int n = 0; n < sz; n++) {
						Type want = wanted.get(n);
						Type got = mappedArgs.get(n).getTaggedType();
						
						boolean checkForNull = false;
						if(TypeCheckUtils.isNotNullable(want) && TypeCheckUtils.isNullable(got)) {//null check:
							this.raiseError(mappedArgs.get(n).getLine(), mappedArgs.get(n).getColumn(), String.format("Argument %s passed to method (of %s) can be null (%s), but method argument type(%s) is not nullable", n+1, name, got, wanted));
						}else if( TypeCheckUtils.isUnknown(got)  &&  TypeCheckUtils.isNoNull(want) ) {
							checkForNull=true;
						}
						
						assertNonNull.add(checkForNull);
					}
				}
			}
		}
		
		if(!TypeCheckUtils.typeListEquals(mappedArgs, exprArgs)){//changes made?
			funcInvoke.args.argsWithNamedParams = mappedArgs;
		}
		funcInvoke.args.assertNonNull = assertNonNull;
			
		if(!funcInvoke.isReallyLambda){
			Type got = tal.getType();
			if(got instanceof NamedType){
				got = TypeCheckUtils.getRefType(got);
			}
			
			ArrayList<Type> actualThingCalledInputs = ((FuncType)got).getInputs();
			
			//type up the null list arguments as approperiate
			int n=0;
			List<Expression> wmps = funcInvoke.args.getArgumentsWNPs();
			for(Expression e : wmps ){
				if(null != e){
					if(n >actualThingCalledInputs.size() -1) {
						break;
					}
					overrideVarNull(actualThingCalledInputs.get(n++), e.getTaggedType(), e);
				}
			}
		}
		
		Type ret = mostSpec.retType;
		
		funcInvoke.setTaggedType(ret);
		
		if(funcInvoke.isSynth && null != funcInvoke.refRepointOrigLhsType){
			TypeCheckUtils.checkAssignmentCanBeDone(this, AssignStyleEnum.EQUALS, funcInvoke.refRepointOrigLhsType, argsWanted.get(0), funcInvoke.getLine(), funcInvoke.getColumn(), firstArgLine, firstArgCole, "");
		}
		
		if (TypeCheckUtils.hasRefLevels(ret)) {//default is unlocked
			NamedType asNamed = ((NamedType) ret);//
			asNamed.setLockedAsRef(false);
		}
		
		if(TypeCheckUtils.hasRefLevels(ret)){
			if(!this.dotOperatorLHS.isEmpty() && TypeCheckUtils.hasRefLevels(this.dotOperatorLHS.peek())){
				//e.g. a.g, where this is directed to a setter/getter - ignore the locking 
				NamedType asNamed = ((NamedType)ret);//
				asNamed.setLockedAsRef(true);
			}
			/*else if(actingOnActor && ret instanceof NamedType){//my =  actor MyClass(12); d = my.plus(8)
				NamedType asNamed = ((NamedType)ret);//
				//asNamed.setLockedAsRef(true);
			}*/
		}
				 
		if (TypeCheckUtils.hasRefLevels(ret)) {
			NamedType asNamed = ((NamedType) ret);//
			if (!this.dotOperatorLHS.isEmpty() && TypeCheckUtils.hasRefLevels(this.dotOperatorLHS.peek())) {
				// e.g. a.g, where this is directed to a setter/getter - ignore the locking
				asNamed.setLockedAsRef(true);
			}
		}
		
		ret = Utils.removeGenericUpperBounds(ret);
		
		Location loc = tal.getLocation();
		if(loc instanceof StaticFuncLocation && !mostSpec.extFuncOn){
			tagIgnorePreviousDopElement(funcInvoke);
			//funcInvoke.popOnEntry = 
		}
		
		if(null != funcTBeingCalled.origonatingFuncDef) {
			boolean exeInGPUFunc = !this.currentlyInFuncDef.isEmpty() && this.currentlyInFuncDef.peek().isGPUKernalOrFunction != null;
			boolean isGPUFunc = funcTBeingCalled.origonatingFuncDef.isGPUKernalFuncOrStub();
			if(isGPUFunc && !exeInGPUFunc) {
				if(funcTBeingCalled.origonatingFuncDef.kernelDim == null) {
					this.raiseError(funcInvoke.getLine(), funcInvoke.getColumn(), String.format("%s is a gpu function, these can only be invoked from a gpu kernel or function", name));
				}
			}else if(!isGPUFunc && exeInGPUFunc) {
				this.raiseError(funcInvoke.getLine(), funcInvoke.getColumn(), String.format("When invoking within a gpu kernal or gpu function only gpu kernels or gpu functions can be called, %s is neither", name));
			}
		}
		
		
		//invalidable non null status of all class variables
		for(HashMap<Pair<String, Boolean>, NullStatus> level : this.nullableOverwriteType) {
			HashSet<Pair<String, Boolean>> levelrem = null;
			for(Pair<String, Boolean> key : level.keySet()) {
				NullStatus ns = level.get(key);
				if(ns == NullStatus.NONNULL && key.getB()) {
					if(null == levelrem) {
						levelrem = new HashSet<Pair<String, Boolean>>();
					}
					levelrem.add(key);
				}
			}
			
			if(null != levelrem) {
				levelrem.forEach(a -> level.remove(a));
			}
		}
		
		
		
		
		return ret;
	}
	
	private void tagIgnorePreviousDopElement(Expression calledon){
		if(!currentDotOperatorTracker.isEmpty()){
			if(!currentDotOperatorTracker.peek().isFirst()){
				if(currentDotOperatorTracker.peek().getcurrent() == calledon){//avoid this being called on mystatic.add(anotherstatic)
					Expression prev = currentDotOperatorTracker.peek().getprevious();
					if(prev instanceof RefName){
						RefName rn = (RefName)prev;
						if(rn.ignoreWhenGenByteCode){
							//the thing was ingored anyway, example: MyEnum.valueOf("ONE");//MyEnum is just a module reference
							return;
						}
						if(rn.resolvesTo != null){
							Location loc = rn.resolvesTo.getLocation();
							if(loc instanceof LocationStaticField){
								LocationStaticField lsf = (LocationStaticField)loc;
								if(null == lsf.owner){
									return;
								}
							}
						}
						
						rn.ignoreWhenGenByteCode=true;
						
					}
				}
			}
		}
	}
	
	private void validateMethodVisibility(AccessModifier am, TypeAndLocation tal, String name, Node node, FuncType ft){
		/*if(tal == null){
			return;
		}
		*/
		
		Location loc = tal.getLocation();

		if(am == AccessModifier.PRIVATE || am == AccessModifier.PROTECTED  || am == AccessModifier.PACKAGE){ 
			if(loc instanceof StaticFuncLocation || loc instanceof LocationStaticField){
				
				String eq =  loc instanceof StaticFuncLocation? ((NamedType)((StaticFuncLocation)loc).getOwnerType()).getSetClassDef().getPrettyName() : ((LocationStaticField)loc).owner;
				
				if(protectedAndNotInPackage(am, loc)  && !this.moduleLevelNamedType.getPrettyName().equals(eq)){
					//if its a static function defined in a different as private, then we cant use it here!
					this.raiseError(node.getLine(), node.getColumn(), String.format("The method %s is not visible" , name));
				}else{//need to mark owner varaible for redirection.
					if(/*null==loc.getPrivateStaticAccessorRedirectFuncGetter() && */!this.currentlyInClassDef.isEmpty() ){
						loc.setPrivateStaticAccessorRedirectFuncGetter(this.getNextPrivateStaticAccessorRedirectFuncName(), name);
					}
				}
			}
			else if(loc instanceof LocationClassField || loc instanceof FuncLocation){
				//check but don't require an accessor
				
				NamedType owner = (NamedType)(loc instanceof FuncLocation? ((FuncLocation)tal.getLocation()).getOwnerType():((LocationClassField)loc).ownerType);
				
				if(protectedAndNotInPackage(am, loc)  && (this.currentlyInClassDef.isEmpty() || !isAccesible(am, owner, this.currentlyInClassDef.peek(), name.equals("<init>"), this.justPackageName))){
					this.raiseError(node.getLine(), node.getColumn(), String.format("The method %s is not visible" , name));
				}
				else if(null==loc.getPrivateStaticAccessorRedirectFuncGetter() && (this.currentlyInClassDef.size()>=2 ||(node instanceof FuncRef && !this.currentlyInClassDef.isEmpty() )) ){//has to be nested class or below (i.e. 2 or more) OR a funcref and in a classdef
					//but we dont do this for the clone method
					boolean insubclassenum = false;
					if(!this.currentlyInClassDef.isEmpty()){
						insubclassenum = this.currentlyInClassDef.peek().isEnumSubClass;
					}
					if(insubclassenum){//enum subclasses are not really nested, rather they are subclasses of whatever
						if(am == AccessModifier.PRIVATE){//thus private is invalid
							this.raiseError(node.getLine(), node.getColumn(), String.format("private function %s is not visible to enum item", name));
						}
					}
					else{
						if(!TypeCheckUtils.isActor(this.ers, owner) && !(owner.getBytecodeType().equals("Ljava/lang/Object;") && name.equals("clone")) && !owner.getBytecodeType().equals("Lcom/concurnas/lang/Actor;") ){
							loc.setPrivateStaticAccessorRedirectFuncGetter(this.getNextPrivateStaticAccessorRedirectFuncName(), name);
						}
					}
				}
			}
			//nothing else locable... local vars dont have am's
		}
		else if(loc instanceof LocationClassField || loc instanceof FuncLocation){
			NamedType owner = (NamedType)(loc instanceof FuncLocation? ((FuncLocation)tal.getLocation()).getOwnerType():((LocationClassField)loc).ownerType);
			
			if(!this.currentlyInClassDef.isEmpty() && !isAccesible(am, owner, this.currentlyInClassDef.peek(), name.equals("<init>"), this.justPackageName) && null == loc.getOriginatesFromConstructorRef()){
				this.raiseError(node.getLine(), node.getColumn(), String.format("The method %s is not visible" , name));
			}
		}
	}
	
	private void removeNestorGenericTypeDefs(Set<GenericType> unbounded){
		//quicker, these are most common
		for(ClassDef cd : this.currentlyInClassDef){
			for(GenericType gen : cd.getClassGenricList()){
				unbounded.remove(gen);
				if(unbounded.isEmpty()){ return; }
			}
		}
		
		//ppl rarely use these, method level generic declarations...
		for(FuncDefI fd : this.currentlyInFuncDef){
			for(GenericType gen : fd.getStringToGenerics().values()){
				unbounded.remove(gen);
				if(unbounded.isEmpty()){ return; }
			}
		}
	}
	
	private String extractPackagePart(String path) {
		int idx = path.indexOf('$');
		
		if(-1 == idx) {
			return path;
		}else {
			return path.substring(0, idx);	
		}
	}
	
	private boolean inSameModule(String fullname1, String fullname2) {
		fullname1 = extractPackagePart(fullname1);
		fullname2 = extractPackagePart(fullname2);
		return fullname1.equals(fullname2);
	}
	
	public boolean isAccesible(AccessModifier am, NamedType ownernt, final ClassDef calledFrom, final boolean isconstructor, String packagename){
		/*if(am == null) {
			return true;
		}*/
		boolean accedible = false;
		packagename = packagename.replace('.', '/');
		
		//if calledFrom parent of ownernt, then it has access
		
		ClassDef owner = ownernt==null?null:(ClassDef)(ownernt).getSetClassDef();
		
		if(calledFrom != null && (owner==null || owner.isParentNestor(calledFrom) ||(calledFrom.isLocalClass && this.currentlyInClassDef.contains(owner) ) )){
			accedible = true;
		}
		else{
			ClassDef ownerCD = ownernt.getSetClassDef();
			if(null != calledFrom){
				if(am == AccessModifier.PRIVATE){
					//private is visible if == cls or thingy is parent nestor, thats it!
					
					if(calledFrom.equals(owner)){
						accedible=true;
					}else if(isconstructor) {
						if(ownerCD != null && inSameModule(ownerCD.bcFullName(), packagename != null?packagename:calledFrom.bcFullName())) {
							accedible=true;
						}
					}
				}
				else if (am == AccessModifier.PROTECTED){
					
					if(ownerCD != null && inSameModule(ownerCD.bcFullName(), packagename != null?packagename:calledFrom.bcFullName())) {
						accedible=true;
					}else {
						//as above or if it's a subclass
						boolean eqCls = calledFrom.equals(owner);
						if(owner.getPrettyName().equals("java.lang.Object") || calledFrom.isParentNestorEQOrSUperClass(owner) != null || eqCls ){
							if(eqCls || precceededByThisSuperOrNothing()){
								accedible=true;
							}
						}
					}
					
				}
				else if (am == AccessModifier.PUBLIC || am == AccessModifier.PACKAGE){//TODO: test here for package
					accedible=true;
				}
			}
		}
		

		if(null != calledFrom && calledFrom.isParentNestor(owner)){
			if(!calledFrom.isEnum){
				//private functions are not accessibale from parent containing enum
				accedible=true;
			}
			else if(isconstructor){//, except for constructors - these get proxied in the parent enum type
				accedible=true;
			}
			else if(calledFrom.isEnumSubClass && owner.isEnum && calledFrom.getSuperclass().equals(owner)){
				//exception being if its a child enum accessing thing in parent
				accedible = am != AccessModifier.PRIVATE;
			}
			else{
				accedible=false;
			}
		}
		
		return accedible;
	}
	
	private FuncType applyLocalGenerics(int line, int col, FuncType asFuncType, List<Type> genTypes, List<Type> invokedTypes ){
		//apply local generics to functype being called, also colorize generic arguments which require it
		FuncType asFuncTypeOgig = asFuncType;
		
		int localGens = asFuncType.getLocalGenerics() == null?0: asFuncType.getLocalGenerics().size();
		int declGens = genTypes==null?0: genTypes.size();
		if(localGens > 0){
			if(localGens==declGens){//filter out methods with differing numbers of type params
				Map<Type, Type> paramToType = new HashMap<Type, Type>();
				for(int n=0; n < localGens; n++){
					//check it can be mapped...
					Type from = asFuncType.getLocalGenerics().get(n);
					Type toa = genTypes.get(n);
					if( null !=	TypeCheckUtils.checkSubType(this.ers, from, toa)) {
						paramToType.put(from, toa);
					}
				}
				asFuncType = (FuncType) GenericTypeUtils.mapFuncTypeGenericsToOtherGenerics( asFuncType, paramToType, false);
				asFuncType.setLocalGenerics(null);
			}
			else if(localGens > 0 && declGens==0){
				if(invokedTypes != null){
					//infer... Attempt to figure out the generic types from the passed in types
					Map<Type, Type> paramToType = TypeCheckUtils.attemptGenericBinding(this.ers, asFuncType.inputs, TypeCheckUtils.boxTypeIfPrimative(invokedTypes, false) );
					
					asFuncType.localGenBindingLast = paramToType;
					
					if(!paramToType.isEmpty()) {//check nullability of infered arguments
						for(Type key :paramToType.keySet()) {
							if(key instanceof GenericType) {
								NullStatus wantedStatus = key.getNullStatus();
								if(wantedStatus == NullStatus.NONNULL) {
									if(NullStatus.NULLABLE == paramToType.get(key).getNullStatus()) {
										return null;//no match gen type not infered in accordance with upper binding.
									}
								}
							}
						}
					}
					
					
					
					if(paramToType.size() == localGens){
						asFuncType = (FuncType) GenericTypeUtils.mapFuncTypeGenericsToOtherGenerics(asFuncType, paramToType, false);
						asFuncType.setLocalGenerics(null);
						//map to arguments if they have sam types too
						for(Type tt: invokedTypes) {
							if(tt instanceof FuncType) {
								FuncType ft = (FuncType)tt;
								if(null != ft.implementSAM) {
									NamedType samA = (NamedType)GenericTypeUtils.mapFuncTypeGenericsToOtherGenerics(ft.implementSAM.getA(), paramToType, false);
									TypeAndLocation oldTal = ft.implementSAM.getB();
									TypeAndLocation newTal = new TypeAndLocation(samA, oldTal.getLocation());
									ft.implementSAM = new Pair<NamedType, TypeAndLocation>(samA, newTal);
								}
							}
						}
					}
				}
				
				if(!this.dotOperatorLHS.isEmpty()) {
					Type dopTop = this.dotOperatorLHS.peek();
					if(dopTop instanceof NamedType) {
						NamedType asNamed = (NamedType)dopTop;
						FuncType asFuncTypeMoreQuali = (FuncType)GenericTypeUtils.filterOutGenericTypes(asFuncType, asNamed.getFromClassGenericToQualifiedType());
						if(!asFuncType.equals(asFuncTypeMoreQuali)) {
							asFuncType = asFuncTypeMoreQuali;
						}
					}
				}
			}
			else{
				asFuncType = null;
			}
		}
		
		if(asFuncType.inputs.size() == invokedTypes.size()) {
			//boolean anyMatch = false;
			int n=0;
			for(Type invokarg : invokedTypes) {
				if(TypeCheckUtils.hasReturnedUnqualifiedLocalGeneric(invokarg)) {
					qualifyReturnedLocalGenericInArg(invokarg, asFuncType.inputs.get(n));//replace with quantified version
				}
				n++;
			}
		}
		
		if(localGens > 0) {
			tagUnqualifiedLocalGenericsReturnedOnly(asFuncTypeOgig);
		}
		
		
		return asFuncType;
	}
	
	private void qualifyReturnedLocalGenericInArg(Type qualify, Type qualifyTo) {
		if(qualify instanceof NamedType && qualifyTo instanceof NamedType) {
			NamedType qualifyAN = (NamedType)qualify;
			NamedType qualifyToAN = (NamedType)qualifyTo;
			
			List<Type> qualifyANGens = qualifyAN.getGenTypes();
			List<Type> qualifyToANGens = qualifyToAN.getGenTypes();
			
			if(qualifyANGens.size() == qualifyToANGens.size()) {
				
				
				ArrayList<Type> qualifyAR = new ArrayList<Type>();
				qualifyAR.add(qualify);
				ArrayList<Type> qualifyToAR = new ArrayList<Type>();
				qualifyToAR.add(qualifyTo);
				
				Map<Type, Type> paramToType = TypeCheckUtils.attemptGenericBinding(this.ers, qualifyAR, qualifyToAR );
				
				qualify = GenericTypeUtils.mapFuncTypeGenericsToOtherGenerics(qualify, paramToType, false);
				qualifyToANGens = ((NamedType)qualify).getGenTypes();
				
				for(int n= 0; n < qualifyANGens.size(); n++) {
					Type toQ = qualifyANGens.get(n);
					Type quantWith = qualifyToANGens.get(n);
					
					if(toQ instanceof GenericType) {
						qualifyANGens.set(n, quantWith);
					}else {
						qualifyReturnedLocalGenericInArg(toQ, quantWith);
					}
				}
			}
		}else if(qualify instanceof FuncType && qualifyTo instanceof FuncType) {
			FuncType qualifyFT = (FuncType)qualify;
			FuncType qualifyToFT = (FuncType)qualifyTo;
			//Bug here XYSASD?
			ArrayList<Type> qualifyFTInput = qualifyFT.inputs;
			ArrayList<Type> qualifyToFTInput = qualifyToFT.inputs;
			
			if(qualifyFTInput.size() == qualifyToFTInput.size()) {
				for(int n=0; n < qualifyFTInput.size(); n++) {
					qualifyReturnedLocalGenericInArg(qualifyFTInput.get(n), qualifyToFTInput.get(n));
				}
			}

			qualifyReturnedLocalGenericInArg(qualifyFT.retType, qualifyToFT.retType);
		}
	}
	
	private void tagUnqualifiedLocalGenericsReturnedOnly(FuncType asFuncType) {
		HashSet<GenericType> lgens = new HashSet<GenericType>(asFuncType.getLocalGenerics());
		HashSet<GenericType> unbounded = new HashSet<GenericType>();
		findUnboundGenericType(asFuncType.retType, lgens, unbounded);
		if(!unbounded.isEmpty()) {
			HashSet<GenericType> unboundedInArgs = new HashSet<GenericType>();
			if(!asFuncType.inputs.stream().anyMatch(a -> {findUnboundGenericType(a, lgens, unboundedInArgs); return !unboundedInArgs.isEmpty();})) {
				//unbounded generic(s) in return detected, tag it as such
				for(GenericType gt : unbounded) {
					gt.isReturnedUnqualifiedLocalGeneric=true;
				}
			}
		}
	}
	
	private void findUnboundGenericType(Type what, HashSet<GenericType> lgens, HashSet<GenericType> unbounded) {
		if(what instanceof NamedType) {
			NamedType asNamed = (NamedType)what;
			for(Type inp : asNamed.getGenericTypeElements()) {
				findUnboundGenericType(inp, lgens, unbounded);
				
			}
		}else if(what instanceof FuncType) {
			FuncType asFuncType = (FuncType)what;
			findUnboundGenericType(asFuncType.retType, lgens, unbounded);
			

			for(Type inp : asFuncType.inputs) {
				findUnboundGenericType(inp, lgens, unbounded);
			}
			
		}else if(what instanceof GenericType) {
			if(lgens.contains(what)) {
				unbounded.add((GenericType)what);
			}
		}
	}
	
	
	private static ErrorRaiseableSupressErrors ersup = new ErrorRaiseableSupressErrors(null);
	
	private HashSet<TypeAndLocation> convertConstructorRefToFuncRefs(HashSet<TypeAndLocation> matchingFuncNames){
		if(null == matchingFuncNames || matchingFuncNames.isEmpty()){
			return matchingFuncNames;
		}
		//(*) String -> (int) String, (byte[]) String etc
		HashSet<TypeAndLocation> ret = new HashSet<TypeAndLocation>();
		for(TypeAndLocation tal : matchingFuncNames){
			Type tt = tal.getType();
			Location oriLoc = tal.getLocation();
			if(tt instanceof FuncType){
				FuncType asFT = (FuncType)tt;
				if(asFT.isClassRefType){
					Type rt = asFT.retType;
					if(rt instanceof NamedType){//oh, we have a (*) Thingy, expand this into individual funcRefs
						NamedType nt = (NamedType)rt;
						
						boolean typedActor = TypeCheckUtils.isActor(ersup, nt);
						boolean typedActorExactly = TypeCheckUtils.isTypedActorExactly(ersup, nt);
						
						List<FuncType> cons;
						if(!typedActorExactly){
							cons = nt.getAllConstructors(this);
						}else{
							Type gen1 = nt.getGenericTypeElements().get(0);
							if(gen1 instanceof NamedType){
								cons = ((NamedType) gen1).getAllConstructors(this);
							}else{
								continue;
							}
						}
						
						
						for(FuncType con: cons){
							if(con.origonatingFuncDef.getAccessModifier() != AccessModifier.PUBLIC ){
								continue;
							}
							
							
							con = con.copyTypeSpecific();
							con.retType = nt;//ScopeAndTypeChecker.const_object.copyTypeSpecific();//nt;
							con.origin = nt.getSetClassDef();
							//con.lambdaDetails = asFT.lambdaDetails;
							
							if(typedActor && !typedActorExactly){//remove the class list from initalizer as first argument
								con.inputs.remove(0);
							}
							
							oriLoc = oriLoc.copy();
							oriLoc.setLambda(true);
							oriLoc.setOriginatesFromConstructorRef((FuncType)tt);
							
							/*
							//con.lambdaDetails
							LocationLocalVar loc = new LocationLocalVar(null);//class or static...
							loc.setLambda(true);
							loc.setLambdaOwner(oriLoc.getLambdaOwner());
							loc.setOriginatesFromConstructorRef(true);
							*/
							
							TypeAndLocation newTal = new TypeAndLocation(con, oriLoc);
							ret.add(newTal);
						}
						continue;
					}
				}
			}
			
			ret.add(tal);
		}
		
		return ret;
	}
	
	private static void filterOutArrayOfFuncs(HashSet<TypeAndLocation> chocies){
		if(null != chocies) {
			ArrayList<TypeAndLocation> toremove = null;
			for(TypeAndLocation choice : chocies) {
				if(choice.getType().hasArrayLevels()) {
					if(null == toremove) {
						toremove = new ArrayList<TypeAndLocation>(1);
					}
					toremove.add(choice);
				}
				
				new HashSet<TypeAndLocation>();
			}
			
			if(null != toremove ) {
				chocies.removeAll(toremove);
			}
		}
	}
	
	private static class MatchingFunction{
		private FuncType ft;
		private TypeAndLocation nextBestTal;
		private TypeAndLocation tal;
		private boolean isConstructor;

		public MatchingFunction(FuncType ft, TypeAndLocation tal, boolean isConstructor, TypeAndLocation nextBestTal) {
			this.ft = ft;
			this.tal = tal;
			this.nextBestTal = nextBestTal;
			this.isConstructor = isConstructor;
		}
		
		public MatchingFunction(FuncType ft, TypeAndLocation tal, boolean isConstructor) {
			this(ft, tal, isConstructor, null);
		}
		
		public FuncType getA() {
			return this.ft;
		}
		
		public TypeAndLocation getB() {
			return this.tal;
		}
		
		public boolean getC() {
			return this.isConstructor;
		}
		
		public TypeAndLocation getNextBest() {
			return this.nextBestTal;
		}
		
	}
	
	private MatchingFunction findMatchingFunction(FuncInvoke funcInvoke, ErrorRaiseable er, String name,  ArrayList<Type> argsWanted, ArrayList<Pair<String, Type>> namessMap, int line, int col, ArrayList<Type> genTypes, boolean refUpArgsIfNeeded, boolean showErrors, boolean ignoreGenericsOnNOMatch)
	{
		argsWanted = argsWanted==null?null:new ArrayList<Type>(argsWanted);
		ClassDef currentCls = this.currentlyInClassDef.isEmpty()?null: this.currentlyInClassDef.peek();
		
		Pair<HashSet<TypeAndLocation>,Boolean> funsAndBool = getMatchingFuncNames(funcInvoke, er, name, line, col, showErrors, false, argsWanted, namessMap);//2nd arg indicates constructor
		
		HashSet<TypeAndLocation> matchingFuncNames = convertConstructorRefToFuncRefs(funsAndBool.getA());
		
		filterOutArrayOfFuncs(matchingFuncNames);
		
		if(null == matchingFuncNames/* || matchingFuncNames.isEmpty()*/) {
			if(!funsAndBool.getB()){
				er.raiseError(line, col, String.format("Unable to find method with matching name: %s%s", TypeCheckUtils.filterOutActorCall(name), TypeCheckUtils.formatArgs(argsWanted, namessMap)));
			}
			return new MatchingFunction(null, null, funsAndBool.getB());
		}
		
		HashMap<FuncType, Location> funcToLocMap = new HashMap<FuncType, Location>();
		HashMap<FuncType, NamedType> fromFTToOrigrefType = new HashMap<FuncType, NamedType>();//logic below is based on FuncRefs, but its valid to have refs to lambdas here...
		
		
		boolean ohnoLambdas = false;
		boolean haveAdjustedArgsForExtFuncs = false;
		for(TypeAndLocation item : matchingFuncNames)
		{
			Type gg = (Type)item.getType().copy();
			
			boolean islazyLambdaVar = false;
			if(gg instanceof NamedType && null != TypeCheckUtils.checkSubType(ers, ScopeAndTypeChecker.getLazyNT(), gg)) {
				gg = ((NamedType)gg).getGenTypes().get(0);
				islazyLambdaVar=true;
			}
			
			if(!ohnoLambdas && gg instanceof PrimativeType && ((PrimativeType)gg).type == PrimativeTypeEnum.LAMBDA){
				ohnoLambdas=true;
			}
			NamedType was = null;
			FuncType asFuncType = null;
			if(gg instanceof FuncType){
				asFuncType = (FuncType)gg;
				
				if(asFuncType.extFuncOn && !haveAdjustedArgsForExtFuncs && !this.dotOperatorLHS.isEmpty()){
					Type opsOn = this.dotOperatorLHS.peek();
					if(null != opsOn) {
						opsOn = (Type)opsOn.copy();
						opsOn.setVectorized(null);
						argsWanted.add(0, opsOn);
						haveAdjustedArgsForExtFuncs=true;	
					}
				}
				
			}
			else if(gg instanceof NamedType && TypeCheckUtils.hasRefLevels(gg)){
				was = (NamedType)gg;
				gg = TypeCheckUtils.getRefType(was);
				if(gg instanceof FuncType){
					asFuncType = (FuncType)gg;
				}
			}
			
			if(null == asFuncType){
				continue;
			}

			//Map<Type, Type> paramToType = TypeCheckUtils.attemptGenericBinding(invoker, inputs, argsPassed)
			
			int genCnt = null == genTypes?0:genTypes.size();
			
			
			if(genCnt > 0){
				ArrayList<GenericType> locGens = asFuncType.getLocalGenerics();
				if(locGens == null && null != asFuncType.getLambdaDetails()){//see if localgens are stored on lambdadetails
					FuncType tt = (FuncType)asFuncType.getLambdaDetails().getType();
					locGens = tt.getLocalGenerics();
				}
				
				if(locGens==null || genCnt != locGens.size()){
					continue;//number of local gens does not match that passed in
				}else {
					//check nullability...
					boolean fail= false;
					for(int n = 0; n < genCnt; n++) {
						GenericType wanted = locGens.get(n);
						Type qualifiedWith = genTypes.get(n);

						NullStatus wantedStatus = wanted.getNullStatus();
						if(wantedStatus != NullStatus.UNKNOWN) {
							if(wantedStatus != qualifiedWith.getNullStatus()) {
								fail = true;
								break;
							}
						}
					}
					
					if(fail) {
						continue;
					}
				}
			}
			
			List<Type> mappedArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, item.getType(), argsWanted, namessMap, 0, true, false);//mapping is specific to each instance
			asFuncType = applyLocalGenerics(line, col, asFuncType, genTypes, mappedArgs);
			
			if(null != asFuncType){
				asFuncType.previousFuncTypeIfCopy=null;//HACK: later operations in getMostSpecificFunctionForChoicesFT map this to prevoius version if we need to make a copy to preseve hashmap changes
				
				Location loc = item.getLocation();
				if(islazyLambdaVar) {
					loc.islazyLambdaVar = islazyLambdaVar;
				}
				
				funcToLocMap.put(asFuncType, loc);
				
				if(null != was){
					fromFTToOrigrefType.put(asFuncType, was);
				}
			}
		}
		
		if(funcToLocMap.isEmpty() && ohnoLambdas){
			this.raiseError(line, col, String.format("Function %s only resolves to lambdas - these cannot be directly invoked, they must be first cast to an invokable type", name ));
			return new MatchingFunction(null, null, funsAndBool.getB());
		}
		
		Set<FuncType> funcsWithAllAccess = funcToLocMap.keySet();
		Set<FuncType> funcsWithRestriuctedAccess = new HashSet<FuncType>();
		for(FuncType ft: funcsWithAllAccess){
			AccessModifier am = ft.getUnderlyingDefAccessMod();
			
			if(am == AccessModifier.PRIVATE || am == AccessModifier.PROTECTED){
				if(this.currentlyInClassDef.isEmpty() || !isAccesible(am, (NamedType)((FuncLocation)funcToLocMap.get(ft)).getOwnerType(), currentCls, name.equals("<init>"), this.justPackageName)){
					continue;
				}
			}
			
			funcsWithRestriuctedAccess.add(ft);
		}
		
		//first only those functions that are accesable
		FuncType mostSpec = TypeCheckUtils.getMostSpecificFunctionForChoicesFT( this.getErrorRaiseableSupression(), ers, funcsWithRestriuctedAccess, argsWanted, namessMap, name, line, col, refUpArgsIfNeeded, this, false).getA();
		if(null == mostSpec){
			//if none then try all of them inc the ones not accesable
			Pair<FuncType, FuncType> primAndNextBest = TypeCheckUtils.getMostSpecificFunctionForChoicesFT( er, ers, funcsWithAllAccess, argsWanted, namessMap, name, line, col, refUpArgsIfNeeded, this, ignoreGenericsOnNOMatch);
			mostSpec = primAndNextBest.getA();
			if(null == mostSpec){
				if(ignoreGenericsOnNOMatch) {
					//show next best function if there is one....
					mostSpec = primAndNextBest.getB();
					return new MatchingFunction(null, null, funsAndBool.getB(), new TypeAndLocation(mostSpec, null));//used for usage based generic type inference 
				}else {
					boolean isConst = funsAndBool.getB();
					if(!isConst) {//check again to see if its a constructor
						isConst = null != funcInvokeIsReallyConstructor(name, funcInvoke, argsWanted, namessMap);
					}
					
					return new MatchingFunction(null, null, isConst);
				}
			}
		}
		
		FuncType ftForExtraction = mostSpec.previousFuncTypeIfCopy != null? mostSpec.previousFuncTypeIfCopy: mostSpec;
		
		Type ret = fromFTToOrigrefType.containsKey(ftForExtraction)? fromFTToOrigrefType.get(ftForExtraction):ftForExtraction;
		
		Location loc = funcToLocMap.get(ftForExtraction);
		
		if(/*loc != null && */loc instanceof ClassFunctionLocation && this.dotOperatorLHS.isEmpty()){
			//steo up classdefs to ensure we are not inside a local class trying to call a method of a 'nestor' class
			ClassDef callsiteCls = ((NamedType)((ClassFunctionLocation)loc).ownerType).getSetClassDef();
			boolean inLocal = false;
			for(int n = this.currentlyInClassDef.size()-1; n >= 0; n--){
				ClassDef cd = this.currentlyInClassDef.get(n);
				if(cd.equals(callsiteCls)){
					if(inLocal){//TODO: imporve error message so that when funcname repointed to NIC$0 etc it does not show up in here but use origonal name instead
						this.raiseError(line, col, String.format("Method %s in: %s cannot be called from within local class: %s (local classes are not nested)", name, callsiteCls, currentCls ));
						return new MatchingFunction(null, null, funsAndBool.getB());
					}
				}
				if(cd.isLocalClass){
					inLocal = true;
				}
			}
			
			
			//in local class trying to access method which is in fake parent nestor class
			
		}
		
		
		return new MatchingFunction(mostSpec, new TypeAndLocation(ret, loc), false);
	}
	

	@Override
	public Object visit(GetSetOperation getSetOperation) {
		//SYN-getXSetX(PLUS, POST, expr[69]) -> obj.setX(obj.getX() + 69 ); | as POST then obj.getX() gets returned
		
		int line = getSetOperation.getLine();
		int col = getSetOperation.getColumn();
		
		//ensure that getter and setter exist
		//MatchingFunction getter = findMatchingFunction(null,this, getSetOperation.getter,  new ArrayList<Type>(), line, col, null, false);
		
		this.maskErrors(true);
		
		Pair<String, MatchingFunction> redirectToAndGetter = findAndRedirectFunctionToActee(getSetOperation.getter, new ArrayList<Type>(), new ArrayList<Pair<String, Type>>(), null, line, col, true, false);
		MatchingFunction getter = redirectToAndGetter.getB();
		
		ArrayList<CapMaskedErrs> preverrs = this.getmaskedErrors();
		
		if(null == getter.getA()){
			this.applyMaskedErrors(preverrs);
			return null;//already err
		}
		else{
			String getterRedirect = redirectToAndGetter.getA();
			if(null != getterRedirect){
				getSetOperation.getter = getterRedirect;
			}
		}
		
		FuncType getterType = getter.getA();
		getSetOperation.getterTAL = getter.getB();
		
		ArrayList<Type> setterArgs = new ArrayList<Type>();
		setterArgs.add(getterType.retType==null?const_void : getterType.retType);
		
		//MatchingFunction setter = findMatchingFunction(null,this, getSetOperation.setter,  setterArgs, line, col, null, false);
		this.maskErrors(true);
		Pair<String, MatchingFunction> redirectToAndSetter = findAndRedirectFunctionToActee(getSetOperation.setter, setterArgs, new ArrayList<Pair<String, Type>>(), null, line, col, true, false);
		MatchingFunction setter = redirectToAndSetter.getB();
		preverrs = this.getmaskedErrors();
		if(null == setter.getA()){
			this.applyMaskedErrors(preverrs);
			return null;//already err
		}
		else{
			String setterRedirect = redirectToAndSetter.getA();
			if(null != setterRedirect){
				getSetOperation.setter = setterRedirect;
			}
		}
		
		getSetOperation.setterTAL = setter.getB();
		
		//got the getter type, now ensure expression result is compatible given that + and - get applied in the following maner: getter()+expr
		this.dotOperatorLHS.push(null);//JPT - refector this? u use this pattern elsewhere
		this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
		Type exprType = (Type)getSetOperation.toAddMinus.accept(this);
		this.dotOperatorLHS.pop();
		this.currentDotOperatorTracker.pop();
		
		getSetOperation.toAddMinus.setTaggedType(exprType);
		
		//Type leftAndRightCompatible =
		boolean lhsStringConcatOperation = TypeCheckUtils.isString(getterType) && getSetOperation.incOperation == AssignStyleEnum.PLUS_EQUALS;
		
		if(lhsStringConcatOperation)
		{
			if(getSetOperation.incOperation != AssignStyleEnum.PLUS_EQUALS)
			{
				this.raiseError(line, col, String.format("numerical operation cannot be performed on type %s", getterType));
			}
		}
		else
		{
			TypeCheckUtils.checkAssignmentCanBeDone(this, getSetOperation.incOperation, getterType.retType, exprType, line, col, line, col, "");
		}
		
		return getterType.retType;
	
	}
	
	
	private HashSet<TypeAndLocation> findFuncRefenceDefsLambdaCurry(int line, int col, FuncInvoke funcInvoke, Type from, String functionName, List<Type> argsWanted, ArrayList<Pair<String, Type>> namessMap)//from type: array or classdef
	{
		//Type dotOpTop = dotOperatorLHS.peek();
		if(from == null){
			return null;
		}
		
		if(functionName.equals("addShutdownHook")) {
			int h = 9;
		}
		
		if(from.hasArrayLevels())
		{//it's an array - so treat as object + length variable
			if(functionName.equals("clone"))
			{//BECAUSE: The class Object does not itself implement the interface Cloneable, so calling the clone method on an object whose class is Object will result in throwing an exception at run time.
				HashSet<TypeAndLocation> ret = new HashSet<TypeAndLocation>();
				FuncType ft = new FuncType(new ArrayList<Type>(), from);
				ft.realReturnType = const_object;
				ft.origonatingFuncDef = new FuncDef(0, 0, null, AccessModifier.PUBLIC, "clone", null,null, false, false, true);
				
				ClassFunctionLocation loc = new ClassFunctionLocation("java.lang.Object", null, false);
				
				ret.add(new TypeAndLocation(ft, loc ));//TODO: funcloc here??? - check moi, does this need a new TAL??? remove and see
				return ret;
			}
			else
			{
				HashSet<TypeAndLocation> got = (const_object).getFuncDef(line, col, functionName, false, argsWanted, namessMap, this);
				if(null == got) {
					return null;
				}
				else {
					HashSet<TypeAndLocation> ret = new HashSet<TypeAndLocation>();
					for(TypeAndLocation item : got ) {
						ret.add(item);
					}
					return ret;
				}
			}
		}
		else if(from instanceof ClassDef)
		{//TODO: check if this code is ever called
			HashSet<TypeAndLocation> got = ((ClassDef)from).getFuncDef(functionName, false, false);
			if(null == got) {
				return null;
			}
			else {
				return got;
			}
		}
		
		if(from instanceof ModuleType){
			String longname = ((ModuleType)from).getNameSoFar() + "." + functionName;
			if(this.mainLoop.doesImportedNameResolveToSomething(longname, mc)){
				return this.mainLoop.getFunctionFromPath(longname, mc, false);
			}
			
		}
		
		
		boolean isReallyALambda = false;
		
		if(from instanceof GenericType){
			GenericType asGen = (GenericType)from;
			from = asGen.getUpperBoundAsNamedType();//TODO: should take the 
		}
		else if(from instanceof FuncType){
			from = TypeCheckUtils.getNamedTypeForFuncType((FuncType)from);
			isReallyALambda=true;
		}
		
		if(from instanceof NamedType){
			Type fromOrig = from;
			from = TypeCheckUtils.getRefTypeToLocked(from);
			boolean tryRef = false;
			while(null != from){
				if(tryRef){
					from = fromOrig; 
				}
				//from could now be int[] for instance
				if(!tryRef && TypeCheckUtils.hasRefLevelsAndNotLocked(from) || !(from instanceof NamedType)){
					//r1 := new MyCls(); r1.get()
					while(TypeCheckUtils.hasRefLevels(from)){
						from = TypeCheckUtils.getRefType(from);
					}
					HashSet<TypeAndLocation> got = findFuncRefenceDefsLambdaCurry(line, col, funcInvoke, from, functionName, argsWanted, namessMap);
					if(got == null || !got.isEmpty()) {
						return nullifyFuncIfOnNullableType(from, got);
					}
				}
				else{
					//r1 := new MyCls(); r1:get()
					NamedType asNamed = ((NamedType)from);
					
					HashSet<TypeAndLocation> got = asNamed.getFuncDef(line, col, functionName, argsWanted, namessMap, this);
					
					if(null == got) {
						if(from == fromOrig){
							return null;
						}
					}
					else {
						HashSet<TypeAndLocation> localGensConflicted = new HashSet<TypeAndLocation>();
						for(TypeAndLocation gotee : got) {
							Type tt = gotee.getType();
							if(tt instanceof FuncType) {
								FuncType asFt = (FuncType)tt;
								if(asFt.getLocalGenerics() != null && null != funcInvoke && funcInvoke.genTypes != null && asFt.getLocalGenerics().size() == funcInvoke.genTypes.size()) {//we infer the generic params from the input arguments, check to see if this matches the declaration of the method at callsite
									FuncType withoutGenerics = asFt.origonatingFuncDef.getFuncType();
									HashMap<GenericType, Type> localGenBinding = NamedType.qualifyGenericMethodTypes(this, asFt.getLocalGenerics(), withoutGenerics.getInputs(), TypeCheckUtils.boxTypeIfPrimative(argsWanted, false));
									//declared binding
									for(int n=0; n < asFt.getLocalGenerics().size(); n++) {
										GenericType genType = asFt.getLocalGenerics().get(n);
										Type mustBeSubtypeOf = funcInvoke.genTypes.get(n);
										Type typeInfered = localGenBinding.get(genType);
										if(null != typeInfered) {
											if(null == TypeCheckUtils.checkSubType(ers, mustBeSubtypeOf, typeInfered)) {
												
												if(typeInfered instanceof GenericType) {
													NamedType infAsNamed = new NamedType(0,0, ((GenericType)typeInfered).name);
													if(mustBeSubtypeOf.equals(infAsNamed)){//A == A etc
														continue;
													}
												}
												
												localGensConflicted.add(gotee);
												break;
											}
										}
									}
								}
							}
						}
						
						if(!localGensConflicted.isEmpty()) {
							got.removeAll(localGensConflicted);
						}
						
						HashSet<TypeAndLocation> ret = new HashSet<TypeAndLocation>();
						for(TypeAndLocation item : got ) {
							Type tt = item.getType();
							if(tt instanceof FuncType) {
								FuncType asFt = (FuncType)tt;
								if(asFt.getLocalGenerics() != null && null != funcInvoke && funcInvoke.genTypes != null && asFt.getLocalGenerics().size() == funcInvoke.genTypes.size()) {
									FuncType withoutGenerics = asFt.origonatingFuncDef.getFuncType();
									//apply passed generics withoutGenerics
									Map<Type, Type> paramToTypeInGlobals = TypeCheckUtils.attemptGenericBinding(this.ers, ftToTypes(withoutGenerics), ftToTypes(asFt) );
									
									HashMap<Type, Type> paramToType = new HashMap<Type, Type>();
									for(int n=0; n < asFt.getLocalGenerics().size(); n++) {
										GenericType genType = asFt.getLocalGenerics().get(n);
										Type mustBeSubtypeOf = funcInvoke.genTypes.get(n);
										paramToType.put(genType,  mustBeSubtypeOf);
									}
									paramToTypeInGlobals.putAll(paramToType);
									
									tt = GenericTypeUtils.mapFuncTypeGenericsToOtherGenerics( withoutGenerics, paramToTypeInGlobals, false);
								}
								
							}
							
							if(isReallyALambda && tt instanceof FuncType){
								FuncType ft = (FuncType)tt.copy();
								ft.setLambdaDetails( new TypeAndLocation(from, item.getLocation()));
								tt=ft;
							}
							
							ret.add(new TypeAndLocation(tt, item.getLocation()));
						}
						if(ret.isEmpty()){
							if( from == fromOrig  ){//if this or super . x then dont go to actor
								Pair<Boolean, HashSet<TypeAndLocation>> foundInActor = getTalsFromActor(line, col, funcInvoke, from, functionName, argsWanted,  namessMap, ret);
								if(foundInActor.getA()) {
									return nullifyFuncIfOnNullableType(from, foundInActor.getB());
								}
								return nullifyFuncIfOnNullableType(from, ret);
							}
						}else{
							if(tryRef){
								if(null != funcInvoke){
									funcInvoke.bcGenStopThingCalledOnBeingUnreffed = true;
								}
							}
							
							return nullifyFuncIfOnNullableType(from, ret);
						}
					}
					//return ((ClassDef)from).getFuncDef(functionName);
				}
				
				if(tryRef || fromOrig==from){
					from=null;
				}
				else{
					tryRef=true;
					from = fromOrig;
				}
				
			}
			
		}

		
		return null;
	}
	
	private List<Type> ftToTypes(FuncType ft){
		ArrayList<Type> ret = new ArrayList<Type>();
		ret.addAll(ft.inputs);
		ret.add(ft.retType);
		return ret;
	}
	
	private static HashSet<TypeAndLocation> nullifyFuncIfOnNullableType(Type from, HashSet<TypeAndLocation> items){
		HashSet<TypeAndLocation> ret = new HashSet<TypeAndLocation>();
		
		if(from.getNullStatus() == NullStatus.NULLABLE) {
			for(TypeAndLocation tal : items) {
				Type tt = tal.getType();
				if(tt instanceof FuncType) {
					tt = (Type)tt.copy();
					((FuncType)tt).retType.setNullStatus(NullStatus.NULLABLE);
				}
				ret.add(tal.cloneWithRetFuncType(tt));
			}
		}else {
			ret = items;
		}
		
		return ret;
	}
	
	
	private Pair<Boolean, HashSet<TypeAndLocation>> getTalsFromActor(int line, int col, FuncInvoke funcInvoke, Type from, String functionName, List<Type> argsWanted, ArrayList<Pair<String, Type>> namessMap, HashSet<TypeAndLocation> ret){
		if(null != TypeCheckUtils.checkSubType(this.ers, const_typed_actor, from)  ){
			//its an actor, so check, track back all the way to actor
			NamedType rootActorType = TypeCheckUtils.extractRootActor(from);
			
			if(null != rootActorType){
				Type tryActorThing;
				boolean fromActee;
				//route above to $ActorSuperCall and $ActorCall
				if(functionName.endsWith("$ActorCall")){
					if(null == rootActorType.getGenTypes() || rootActorType.getGenTypes().isEmpty()){
						return new Pair<Boolean, HashSet<TypeAndLocation>>(true, ret);
					}
					
					tryActorThing = rootActorType.getGenTypes().get(0);
					functionName = functionName.substring(0,  functionName.length() - 10);
					fromActee = true;
				}
				else if(functionName.endsWith("$ActorSuperCall")){
					tryActorThing=rootActorType;
					functionName = functionName.substring(0,  functionName.length() - 15);
					fromActee = false;
				}
				else{
					return new Pair<Boolean, HashSet<TypeAndLocation>>(true, ret);
				}
				
				HashSet<TypeAndLocation> retla = new HashSet<TypeAndLocation>();
				
				HashSet<TypeAndLocation> foundFromActor = findFuncRefenceDefsLambdaCurry(line, col, funcInvoke, tryActorThing, functionName, argsWanted, namessMap);
				if(null != foundFromActor && !foundFromActor.isEmpty()){
					
					//we need to repoint the origin on the functypes to point to the origonal class
					for(TypeAndLocation tal : foundFromActor){
						Type tt = tal.getType();
						if(tt instanceof FuncType){//JPT: this code is a bit nasty where we recreate what we expect the actor will provide
							FuncType asftt = (FuncType)tt.copy();
							if(tryActorThing instanceof NamedType){
								((FuncType) asftt).origin = ((NamedType) tryActorThing).getSetClassDef();
							}
							//asftt.retType = new NamedType(0,0, TypeCheckUtils.boxTypeIfPrimative(asftt.retType, false));
							tt = asftt;
						}
						Location loc = tal.getLocation();
						if(fromActee && loc instanceof ClassFunctionLocation){
							ClassFunctionLocation cfl = (ClassFunctionLocation)(loc.copy());
							if(tryActorThing instanceof NamedType){
								cfl.owner = "x" + ((NamedType) tryActorThing).getSetClassDef().bcFullName() + "$$ActorIterface";
							}
							cfl.isInterface=true;
							cfl.ownerType = new NamedType(0,0, cfl.owner);
							//cfl.ownerType.accept(this);//doesnt exist really so cannot accept it
							loc=cfl;
						}
						
						TypeAndLocation newTal = new TypeAndLocation(tt, loc);
						retla.add(newTal);
					}

					return new Pair<Boolean, HashSet<TypeAndLocation>>(true, retla);//TODO: map to agent
				}
			}
		}
		else if(null != TypeCheckUtils.checkSubType(this.ers, const_actor, from, 0, 0, 0, 0)  ){
			//TODO: remove when we get rid of ActorSuperCall's
			if(functionName.endsWith("$ActorSuperCall")){
				functionName = functionName.substring(0,  functionName.length() - 15);
			}
			else{
				return new Pair<Boolean, HashSet<TypeAndLocation>>(true, ret);
			}
			
			HashSet<TypeAndLocation> retla = new HashSet<TypeAndLocation>();
			
			HashSet<TypeAndLocation> foundFromActor = findFuncRefenceDefsLambdaCurry(line, col, funcInvoke, from, functionName, argsWanted, namessMap);
			if(null != foundFromActor && !foundFromActor.isEmpty()){
				
				//we need to repoint the origin on the functypes to point to the origonal class
				for(TypeAndLocation tal : foundFromActor){
					Type tt = tal.getType();
					if(tt instanceof FuncType){//JPT: this code is a bit nasty where we recreate what we expect the actor will provide
						FuncType asftt = (FuncType)tt.copy();
						if(from instanceof NamedType){
							((FuncType) asftt).origin = ((NamedType) from).getSetClassDef();
						}
						tt = asftt;
					}
					//direct location away from trait, back to actor
					Location loc = tal.getLocation();
					if(loc instanceof ClassFunctionLocation){
						ClassFunctionLocation ascfl = (ClassFunctionLocation)loc;
						Type ownerType = ascfl.ownerType;
						if(ownerType instanceof NamedType) {
							NamedType oasNamed = (NamedType)ownerType;
							ClassDef oCD = oasNamed.getSetClassDef();
							if(null != oCD && oCD.isTrait) {
								//replace location owner
								if(from instanceof NamedType) {
									ascfl.ownerType = from;
									ascfl.owner = ((NamedType)from).getSetClassDef().bcFullName();
								}
									
								
							}
						}
					}
					
					TypeAndLocation newTal = new TypeAndLocation(tt, loc);
					retla.add(newTal);
				}
				return new Pair<Boolean, HashSet<TypeAndLocation>>(true, retla);
			}
			
		}
		return new Pair<Boolean, HashSet<TypeAndLocation>>(false, null);
	}
	
	private boolean okToCallExtFunciton() {
		//in cases such as super.mycall() inside an extension function, we do not want to call the extension function
		//but super[XYZ].mycall() is fine
		if(!this.currentDotOperatorTracker.isEmpty()) {
			DotOperatorAndIndex doppos = this.currentDotOperatorTracker.peek();//cannot be null as called when dop is non empty
			if(doppos.idx > 0) {
				Expression prev = doppos.getprevious();
				if (prev instanceof RefSuper) {
					Type prevSupTypeResolvesTo = prev.getTaggedType();
					
					int sz = this.currentlyInFuncDef.size();
					
					for (int i = sz - 1; i >= 0; i--) {
						FuncDefI ci = this.currentlyInFuncDef.get(i);
						if(ci instanceof ConstructorDef ||ci instanceof LambdaDef) {
							break;
						}else {
							FuncDef fd = (FuncDef)ci;
							if(null != fd.extFunOn) {
								return !fd.extFunOn.equals(prevSupTypeResolvesTo);//if super resolves to the type of the ext function, then dont permit ext functions on it
							}
						}
					}
				}
			}
		}
		
		return true;
	}
	
	
	private Pair<HashSet<TypeAndLocation>,Boolean> findExtensionFunction(FuncInvoke funcInvoke, ErrorRaiseable er, String nameola,  int line, int col, boolean raiseErrors, boolean ignoreLambdas, List<Type> argsWanted, ArrayList<Pair<String, Type>> namessMap, Type lhs, NamedType genericWithBound) {
		if((genericWithBound != null || lhs instanceof NamedType || lhs instanceof PrimativeType) && okToCallExtFunciton()){
			//see if there is a matching extension function
			
			if(genericWithBound != null) {
				lhs = genericWithBound;
			}
			
			this.maskErrors();//ext function on upper bound
			Pair<HashSet<TypeAndLocation>,Boolean> viaExtFunction = getMatchingFuncNamesNonRHSDotOperator(funcInvoke, er, nameola,  line, col, raiseErrors, ignoreLambdas, argsWanted, namessMap, lhs, false);
			if(!this.maskedErrors() && viaExtFunction != null){//found a match, filter out those without first argument not supertype of lhs
				HashSet<TypeAndLocation> filteredTals = new HashSet<TypeAndLocation>();
				if(null != viaExtFunction.getA()){
					for(TypeAndLocation tal : viaExtFunction.getA()){
						FuncType ft = (FuncType)tal.getType();
						//applyLocalGenerics(int line, int col, FuncType asFuncType, List<Type> genTypes, List<Type> invokedTypes )
						
						ArrayList<Type> copyArgsIncExtendee = new ArrayList<Type>(argsWanted);
						copyArgsIncExtendee.add(0, lhs);
						
						FuncType withGenerics = applyLocalGenerics( line,  col,  ft,  new ArrayList<Type>(),  copyArgsIncExtendee );
						
						if(!withGenerics.getInputs().isEmpty()){
							Type shouldbeSuper = withGenerics.getInputs().get(0);
							if(null != TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), shouldbeSuper, lhs)){
								
								filteredTals.add(tal.cloneWithRetFuncType(withGenerics));
								filteredTals.add(tal);//MHA: adding both is a hack...
							}
						}
					}
					
					if(!filteredTals.isEmpty()){
						return new Pair<HashSet<TypeAndLocation>,Boolean>(filteredTals, viaExtFunction.getB());
					}
				}
			}
		}
		
		return null;
		
	}
	
	private boolean isLHSQualifiedSuperToTrait() {
		if(!this.currentDotOperatorTracker.isEmpty()) {
			
			DotOperatorAndIndex dotIdx = this.currentDotOperatorTracker.peek();
			if(!dotIdx.isFirst()) {
				Expression prevExpr = this.currentDotOperatorTracker.peek().getprevious();
				if(prevExpr instanceof RefSuper){
					RefSuper asSuper = (RefSuper) prevExpr;
					if(null != asSuper.superQuali) {
						return TypeCheckUtils.typeIsTrait(asSuper.getTaggedType());
					}
				}else if (prevExpr instanceof RefNamedType) {
					RefNamedType rNamedType = (RefNamedType) prevExpr;
					return TypeCheckUtils.typeIsTrait(rNamedType.getTaggedType());
				}
			}
		}
		
		return false;
	}
	
	
	private boolean isLHSJustSuper() {
		if(!this.currentDotOperatorTracker.isEmpty()) {
			DotOperatorAndIndex dotIdx = this.currentDotOperatorTracker.peek();
			if(!dotIdx.isFirst()) {
				Expression prevExpr = this.currentDotOperatorTracker.peek().getprevious();
				if(prevExpr instanceof RefSuper){
					RefSuper asSuper = (RefSuper) prevExpr;
					if(null == asSuper.superQuali) {
						return true;
					}
				}
			}
		}
		
		return false;
	}
	
	private boolean isLHSAnySuper() {
		if(!this.currentDotOperatorTracker.isEmpty()) {
			DotOperatorAndIndex dotIdx = this.currentDotOperatorTracker.peek();
			if(!dotIdx.isFirst()) {
				Expression prevExpr = this.currentDotOperatorTracker.peek().getprevious();
				if(prevExpr instanceof RefSuper){
					RefSuper asSuper = (RefSuper) prevExpr;
					return true;
				}
			}
		}
		
		return false;
	}
	
	private Pair<HashSet<TypeAndLocation>,Boolean> getMatchingFuncNames(FuncInvoke funcInvoke, ErrorRaiseable er, String nameola,  int line, int col, boolean raiseErrors, boolean ignoreLambdas, List<Type> argsWanted, ArrayList<Pair<String, Type>> namessMap)
	{		/*
		 * search order:
			local: arg, then funcdef
			upper scoped: arg then funcdef {e.g. inner {} in class or loop etc }
			field, then method | superclass field, then method
			global field, then method
			
			imported filed then function
		 */
		
		if(!dotOperatorLHS.isEmpty() && dotOperatorLHS.peek() != null)
		{//in dot op scope, e.g. a.b = 99
			//hmmm, what if it's a funcref itself...? test and find out!
			HashSet<TypeAndLocation> tals = null;
			
			Type lhs = null;
			
			List<Type> lhstoTry = new ArrayList<Type>();
			if(!traitsForSuper.isEmpty()) {//we see if the method exists on the traits of the current class first, then we try the supertype
				List<NamedType> items = traitsForSuper.peek();
				if(null != items) {
					lhstoTry.addAll(items);
				}
			}
			lhstoTry.add(dotOperatorLHS.peek());
			
			boolean lhsIsQualifiedSuperToTrait = isLHSQualifiedSuperToTrait();
			
			while(!lhstoTry.isEmpty()) {
				lhs = lhstoTry.remove(0);
				
				NamedType genericWithBound = (lhs instanceof GenericType && ((GenericType)lhs).upperBound != null)?((GenericType)lhs).upperBound:null;
				
				Pair<HashSet<TypeAndLocation>,Boolean> isExtfunc = findExtensionFunction(funcInvoke, er, nameola,  line, col, raiseErrors, ignoreLambdas, argsWanted, namessMap, lhs, genericWithBound);
				
				if(null != isExtfunc) {
					return isExtfunc;
				}
					
				tals = findFuncRefenceDefsLambdaCurry(line, col, funcInvoke, lhs, nameola, argsWanted, namessMap);
				if(null != tals && !tals.isEmpty()) {
					HashMap<TypeAndLocation, TypeAndLocation> tal2tal = new HashMap<TypeAndLocation, TypeAndLocation>();
					if(lhsIsQualifiedSuperToTrait || !lhstoTry.isEmpty()) {//must be on the right hand side of a trait super. or super[thing]. expression
						for(TypeAndLocation tal : tals) {
							Location loc = tal.getLocation();
							if(loc instanceof ClassFunctionLocation) {
								ClassFunctionLocation cfl = (ClassFunctionLocation)loc;
								if(TypeCheckUtils.typeIsTrait(cfl.ownerType)) {
									cfl = (ClassFunctionLocation)cfl.copy();
									cfl.isRHSOfTraitSuper = true;
									TypeAndLocation talnew = tal.copy();
									talnew.setLocation(cfl);
									tal2tal.put(tal, talnew);
								}
							}
						}
					}
					
					if(!tal2tal.isEmpty()){//ensure we only override this call's location, not ALL instances
						for(TypeAndLocation src : tal2tal.keySet()) {
							tals.remove(src);
							tals.add(tal2tal.get(src));
						}
					}
					
					if(!this.currentlyInClassDef.isEmpty()) {
						ClassDef currDef = this.currentlyInClassDef.peek();
						if(currDef.isTrait && isLHSJustSuper()) {//super.thing() called in trait
							for(TypeAndLocation tal : tals) {
								Location loc = tal.getLocation();
								if(loc instanceof ClassFunctionLocation) {
									loc = loc.copy();
									String name= "traitSuper$" + currDef.bcFullName().replace("/", "$") + "$$" + nameola;
									loc.isRHSOfTraitSuperChainable = new Pair<NamedType, String>(new NamedType(currDef), name);
									currDef.traitSuperRefs.add(new Pair<String, FuncType>(name, (FuncType)tal.getType()) );
									tal.setLocation(loc);
								}
							}
						}
					}
					
					break;
				}
			}
			
			if(null==tals || tals.isEmpty()){//uh oh, no function found, but maybe it's a constructor...
				
				maskErrors();
				String tryAsNamed = nameola;
				
				NamedType asNamed = new NamedType(0, 0, tryAsNamed);
				asNamed.accept(this);
				EvaluatedConstructor constructorHit = evaluateConstructor(asNamed, argsWanted, namessMap, 0, 0, "", false);
				
				maskedErrors();
			
				if(null == constructorHit){//it is not null thus indicating a constructor match is possible
					if(raiseErrors){
						if(lhs instanceof ModuleType){
							er.raiseError(((ModuleType) lhs).getLine(), ((ModuleType) lhs).getColumn(), ""+lhs);//line and columb wrong
						}else{
							er.raiseError(line, col, String.format("Unable to find method with matching name: %s", TypeCheckUtils.filterOutActorCall(nameola) ));
						}
					}
				}
				else{
					return new Pair<HashSet<TypeAndLocation>, Boolean>(null, true);
				}
				
			}
			
			/**/
			
			return new Pair<HashSet<TypeAndLocation>, Boolean>(tals, false);
		}
		else{
			return getMatchingFuncNamesNonRHSDotOperator(funcInvoke, er, nameola,  line, col, raiseErrors, ignoreLambdas, argsWanted, namessMap, null, true);
		}
	}
	
	private Class<?> gpuKernelClass = null; 
	private Class<?> gpubuiltinClass = null; 
	
	private Pair<HashSet<TypeAndLocation>,Boolean> getMatchingFuncNamesNonRHSDotOperator(FuncInvoke funcInvoke, ErrorRaiseable er, String nameola,  int line, int col, boolean raiseErrors, boolean ignoreLambdas, List<Type> argsWanted, ArrayList<Pair<String, Type>> namessMap, Type wantExtensionFunction, boolean checkExtensionFunc){
		//not in a dot operator,  e.g. a = 99
		//check locl scpes, but stop when u get to the class level, then check the class leve, then check the level above the class..
		//nested classes
		TheScopeFrame search = this.currentScopeFrame;
		
		boolean findExtFunc;
		if(wantExtensionFunction != null){
			findExtFunc=true;
			argsWanted = argsWanted==null?null:(ArrayList<Type>) com.concurnas.compiler.ast.Utils.cloneArrayList(argsWanted);
			if(null == argsWanted){
				argsWanted = new ArrayList<Type>();
			}
			argsWanted.add(0, wantExtensionFunction);
		}else{
			findExtFunc=false;
		}
		
		if(nameola.equals("bar")) {
			int h=9;
		}
		
		//if call made in with statement
		if(!this.currentlyInWithStatement.isEmpty()) {
			for(int n = currentlyInWithStatement.size()-1; n>=0; n--){
				Pair<String, NamedType> nameAndType = currentlyInWithStatement.get(n);
				NamedType toTry = nameAndType.getB();
				if(null != toTry) {
					HashSet<TypeAndLocation> tals = findFuncRefenceDefsLambdaCurry(line, col, funcInvoke, toTry, nameola, argsWanted, namessMap);
					if(null != tals && !tals.isEmpty()){
						HashSet<TypeAndLocation> newtals = new HashSet<TypeAndLocation>();
						for(TypeAndLocation tal : tals){
							Location loc = tal.getLocation().copy();
							loc.redirectExtFuncOrWithExpr = nameAndType.getA();//i.e. repoint to: "this$extFunc. xxx ()..."
							newtals.add(new TypeAndLocation(tal.getType(), loc));
						}
						return new Pair<HashSet<TypeAndLocation>, Boolean>(newtals, false);
					}
				}
			}
		}
		
		
		//if call made in extension function, 
		if(checkExtensionFunc && !this.currentlyInFuncDef.isEmpty()){
			for(int n = currentlyInFuncDef.size()-1; n>=0; n--){
				FuncDefI fd = currentlyInFuncDef.get(n);
				if(fd instanceof FuncDef){
					if(((FuncDef)fd).extFunOn != null){
						
						Type extFuncOn = ((FuncDef)fd).extFunOn;
						
						HashSet<TypeAndLocation> tals = findFuncRefenceDefsLambdaCurry(line, col, funcInvoke, extFuncOn, nameola, argsWanted, namessMap);
						if(null != tals && !tals.isEmpty()){
							HashSet<TypeAndLocation> newtals = new HashSet<TypeAndLocation>();
							for(TypeAndLocation tal : tals){
								Location loc = tal.getLocation().copy();
								loc.redirectExtFuncOrWithExpr = "this$extFunc";//i.e. repoint to: "this$extFunc. xxx ()..."
								newtals.add(new TypeAndLocation(tal.getType(), loc));
								
							}
							return new Pair<HashSet<TypeAndLocation>, Boolean>(newtals, false);
						}else{//give up dont search higher
							break;
						}
					}
				}
			}
		}
		
		while(search!=null)
		{//check 'local' scopes until we get to class level
			if(search.isClass())
			{//when u hit a class stop!
				break;
			}
			else
			{
				if(search.hasLambdable(this.currentScopeFrame, nameola, true, findExtFunc))
				{
					Pair<Pair<Boolean /*is functions */, HashSet<TypeAndLocation>>, Boolean /* isclass*/> gota = search.getLambdable(this.currentScopeFrame, nameola, true, findExtFunc);
					//boolean true -> function names, false-> funcref var
					Pair<Boolean /*is functions */, HashSet<TypeAndLocation>> got = gota.getA();
					
					boolean isFuncRefs = got.getA();
					HashSet<TypeAndLocation> ret = got.getB();
					TypeAndLocation first = ret.iterator().next();
					ArrayList<Type> types = new ArrayList<Type>();
					
					if(got != null && first !=null)
					{
						//hack in the location (useful for nested inner functions which have the same name but defined in different methods of a class)
						if(!ret.isEmpty()){
							String definedLocation = search.getFormalLocation();
							for(TypeAndLocation tal : ret){
								Type tt = tal.getType();
								
								if(tt instanceof NamedType && null != TypeCheckUtils.checkSubType(ers, ScopeAndTypeChecker.getLazyNT(), tt)) {
									tt = ((NamedType)tt).getGenTypes().get(0);
								}
								types.add(tt);
								
								tt = TypeCheckUtils.convertTypeToFuncType(tt);
								
								if(tt instanceof FuncType){
									FuncType ft = (FuncType)tt;
									if(ft.origonatingFuncDef != null){
										
										if(ft.origonatingFuncDef.isGPUKernalFuncOrStub()) {//replace args
											boolean convertForNormalCall=true;
											boolean convertForCallInGPUF=false;
											if(!this.currentlyInFuncDef.isEmpty()) {
												convertForNormalCall = this.currentlyInFuncDef.peek().isGPUKernalOrFunction == null;
												convertForCallInGPUF=!convertForNormalCall;
											}
											
											if(convertForNormalCall) {//only convert if we are outside of gpu kernel or function 
												ArrayList<FuncParam> fparams = ft.origonatingFuncDef.params.params;
												
												ArrayList<Type> newtypes = new ArrayList<Type>(ft.inputs.size());
												int cnt = 0;
												for(Type ttx : ft.inputs) {
													if(fparams.get(cnt).gpuVarQualifier != null && !TypeCheckUtils.isGPUBuffer(ttx)) {
														
														Class<?> toUse;
														if(fparams.get(cnt).gpuVarQualifier == GPUVarQualifier.LOCAL) {
															toUse = GPUBufferLocal.class;
														}else {
															GPUInOutFuncParamModifier inoutmodifier = fparams.get(cnt).gpuInOutFuncParamModifier;
															if(inoutmodifier == GPUInOutFuncParamModifier.in) {
																toUse = GPUBufferInput.class;
															}else if(inoutmodifier == GPUInOutFuncParamModifier.out) {
																toUse = GPUBufferOutput.class;
															}else {
																toUse = GPUBuffer.class;
															}
														}
														
														NamedType newtype = new NamedType(new ClassDefJava(toUse));
														
														ArrayList<Type> gens = new ArrayList<Type>();
														gens.add(ttx);
														newtype.setGenTypes(TypeCheckUtils.boxTypeIfPrimative(gens, false));
														newtypes.add(newtype);
													}else {
														newtypes.add(ttx);
													}
													
													cnt++;
												}
												
												ft.inputs=newtypes;
												
												if(gpuKernelClass == null) {//load only once
													try {
														gpuKernelClass = Class.forName("com.concurnas.lang.gpus$Kernel");
													} catch (ClassNotFoundException e) {
														throw new RuntimeException(e);
													}
												}
												
												ft.retType = new NamedType(new ClassDefJava(gpuKernelClass));
											}
											else if(convertForCallInGPUF) {//flatten arrays for global and local and const vars to pointers

												FuncDef fd = /*(FuncDef)*/ft.origonatingFuncDef;//.copy();
												ft.origonatingFuncDef = fd;
												
												ArrayList<FuncParam> fparams = fd.params.params;
												
												ArrayList<Type> newtypes = new ArrayList<Type>(ft.inputs.size());
												int cnt = 0;
												for(Type ttx : ft.inputs) {
													FuncParam fp = fparams.get(cnt);
													if(fp.gpuVarQualifier != null && !TypeCheckUtils.isGPUBuffer(ttx) && ttx.hasArrayLevels()) {
														ttx = (Type)ttx.copy();
														ttx.setArrayLevels(0);
														ttx.setPointer(1);
														newtypes.add(ttx);
														//fp.type = ttx;
														//fp.setTaggedType(fp.type);
													}else {
														newtypes.add(ttx);
													}
													
													cnt++;
												}
												//asdasdasd
												ft.inputs=newtypes;
											}
											
											
										}

										ft.definedLocation = "" + ft.origonatingFuncDef.getLine() + ft.origonatingFuncDef.getColumn();
									}else{
										ft.definedLocation =definedLocation;
									}
								}
							}
						}
						
						//if(ret.size()==1 && !(first.getType() != null && first.getType() instanceof FuncType))
						if(ret.size()==1 && !TypeCheckUtils.isLambda(types.get(0)))
						{
							if(raiseErrors) this.raiseError(line, col, String.format("For variable reference on: '%s' it must be a method or method reference not: %s", nameola, first.getType()) );
							return new Pair<HashSet<TypeAndLocation>, Boolean>(null, false);
						}
						else if(isFuncRefs)
						{
							if(this.isInSuperConstructorCall() && gota.getB() /*isclass?*/ ) {
								if(raiseErrors) this.raiseError(line, col, "Cannot refer to an instance method while explicitly invoking a constructor");
								return new Pair<HashSet<TypeAndLocation>, Boolean>(null, false);
							}
							return new Pair<HashSet<TypeAndLocation>, Boolean>(ret, false);
						}
						else
						{//TODO: cannot refer to a lambda function in a consturor?
							return new Pair<HashSet<TypeAndLocation>, Boolean>(ret, false);
						}
					}
				}
			}
			search = search.getParent();
		}
		
		if(!this.currentlyInFuncDef.isEmpty() && this.currentlyInFuncDef.peek().isGPUKernalOrFunction != null){
			//check to see if it's a built in function
			if(null == gpubuiltinClass) {//load only once
				try {
					gpubuiltinClass = Class.forName("com.concurnas.lang.gpubuiltin");
				} catch (ClassNotFoundException e) {
					throw new RuntimeException("Cannot load gpubuiltin definitions", e);
				}
			}
			
			HashSet<TypeAndLocation> ff = new ClassDefJava(gpubuiltinClass).getFuncDef(nameola, true, false);
			//check for annotation?
			return new Pair<HashSet<TypeAndLocation>, Boolean>(ff, false);
		}
		
		//superclass etc
		if(!this.currentlyInClassDef.isEmpty())
		{// now search nested class heirachy if any
			Object[] classHeriarch = this.currentlyInClassDef.toArray();
			for(int n = classHeriarch.length; n>0; n--){
				ClassDef topCls = (ClassDef)classHeriarch[n-1];
				
				TypeAndLocation tal =  topCls.getVariable(this.currentScopeFrame, nameola);
				Type vartype =tal==null?null: tal.getType();
				
				boolean hasVar = vartype!=null && vartype instanceof FuncType;
				boolean hasFunc = hasVar?false:topCls.hasFuncDef(nameola, ignoreLambdas, wantExtensionFunction!=null); 
				if(hasVar || hasFunc)
				{
					if(this.isInSuperConstructorCall()) {
						if(raiseErrors) this.raiseError(line, col, "Cannot refer to an instance method while explicitly invoking a constructor");
						return new Pair<HashSet<TypeAndLocation>, Boolean>(null, false);
					}
					else
					{
						if(hasVar)
						{
							HashSet<TypeAndLocation> ret = new HashSet<TypeAndLocation>();
							ret.add(tal);
							return new Pair<HashSet<TypeAndLocation>, Boolean>(ret, false);
						}
						else//hasFunc
						{
							HashSet<TypeAndLocation> ff = topCls.getFuncDef(nameola, false, wantExtensionFunction!=null);
							return new Pair<HashSet<TypeAndLocation>, Boolean>(ff, false);
						}
					}
					
				}else if(topCls.isActor) {
					Pair<Boolean, HashSet<TypeAndLocation>> foundInActor = getTalsFromActor(line, col, funcInvoke, new NamedType(topCls), nameola, argsWanted,  namessMap, null);
					if(foundInActor.getA()) {
						HashSet<TypeAndLocation>  rx = foundInActor.getB();
						if(rx != null) {
							return new Pair<HashSet<TypeAndLocation>, Boolean>(rx, false);
						}
					}
					
				}
			}
		}
		//imported thing
		
		while(search != null)
		{//now search parent class
			if(!search.isClass())
			{
				//we've reached the top level - foul copy paste job - JPT: refactor
				if(search.hasLambdable(this.currentScopeFrame, nameola, true, findExtFunc))
				{
					if(this.isInSuperConstructorCall()) {
						if(raiseErrors) this.raiseError(line, col, "Cannot refer to an instance method while explicitly invoking a constructor");
						return new Pair<HashSet<TypeAndLocation>, Boolean>(null, false);
					}
					
					Pair<Pair<Boolean /*is functions */, HashSet<TypeAndLocation>>, Boolean /* isclass*/> gota = search.getLambdable(this.currentScopeFrame, nameola, true, findExtFunc);
					//boolean true -> function names, false-> funcref var
					Pair<Boolean /*is functions */, HashSet<TypeAndLocation>> got = gota.getA();
					if(gota != null)
					{
						boolean isFuncRefs = got.getA();
						HashSet<TypeAndLocation> ret = got.getB();
						
						//if(ret.size()==1 && !(ret.iterator().next().getType() instanceof FuncType))
						if(ret.size()==1 && !TypeCheckUtils.isLambda(ret.iterator().next().getType()))
						{//JPT: remove this cut and paste
							if(raiseErrors) this.raiseError(line, col, String.format("For variable reference on: '%s' it must be a method or method reference not: %s", nameola, got) );
							return new Pair<HashSet<TypeAndLocation>, Boolean>(null, false);
						}
						else if(isFuncRefs)
						{
							if(this.isInSuperConstructorCall() && gota.getB() /*isclass?*/ ) {
								if(raiseErrors) this.raiseError(line, col, "Cannot refer to an instance method while explicitly invoking a constructor");
								return new Pair<HashSet<TypeAndLocation>, Boolean>(null, false);
							}
							return new Pair<HashSet<TypeAndLocation>, Boolean>(ret, false);
						}
						else
						{//TODO: cannot refer to a lambda function in a consturor?
							return new Pair<HashSet<TypeAndLocation>, Boolean>(ret, false);
						}
					}
					
				}
			}
			search = search.getParent();
		}			
	
		String nameRedirect = null;
		if(hasImportBeenRegistered(nameola))
		{//and finnaly search top level imports for the name
			String nameolaz = getImportBeenRegistered(nameola);
			if(!nameolaz.equals(nameola)){
				String[] parts = nameolaz.split("\\.");
				nameRedirect = parts[parts.length-1];
				nameola = nameolaz;
			}
		}
		
		HashSet<TypeAndLocation> finalret = this.mainLoop.getFunctionFromPath(nameola, this.mc, false);
		
		if(finalret == null){
			TypeAndLocation lambdamaybe = this.mainLoop.getVariableFromPath(nameola, mc, false);
			
			if(null != lambdamaybe){
				Type ttype = lambdamaybe.getType();
				if(!TypeCheckUtils.isLambda(ttype)){
					if(raiseErrors) this.raiseError(line, col, String.format("For variable reference on: '%s' it must be a method or method reference not: %s", nameola, ttype) );
					return new Pair<HashSet<TypeAndLocation>, Boolean>(null, false);
				}
				finalret = new HashSet<TypeAndLocation>();
				finalret.add(lambdamaybe);
			}
		}
		
		
		
		EvaluatedConstructor constructorHit=null;
		if(null == finalret) {
			constructorHit = funcInvokeIsReallyConstructor(nameola, funcInvoke, argsWanted, namessMap);
			
			if(null == constructorHit){//it is not null thus indicating a constructor match is possible
				if(null != argsWanted){//dont raise error for zero arg construcotr ref calls: new MyClass&
					if(raiseErrors) this.raiseError(line, col, String.format("Unable to find method with matching name: %s", TypeCheckUtils.filterOutActorCall(nameola)));
				}
			}
		}
		
		if(nameRedirect != null && finalret != null){//map name on origfuncdef
			/*HashSet<TypeAndLocation> finalretnew =new HashSet<TypeAndLocation>();
			for(TypeAndLocation tal : finalret){
				Type tt = tal.getType();
				Location loc = tal.getLocation();
				if(tt instanceof FuncType && loc instanceof LocationStaticField){
					FuncType asFuncType = (FuncType)tt;
					if(asFuncType.origonatingFuncDef != null){
						FuncDef directname = (FuncDef)asFuncType.origonatingFuncDef.copy();
						directname.funcName = nameRedirect;
						asFuncType = asFuncType.copyTypeSpecific();
						asFuncType.origonatingFuncDef = directname;
						LocationStaticField sloc = (LocationStaticField)loc.copy();
						sloc.type = asFuncType;
						tal = new TypeAndLocation(asFuncType, sloc);
						//find a better way
						
						//splice it onto tal
					}
				}
				
				finalretnew.add(tal);
			}
			finalret = finalretnew;*/
			for(TypeAndLocation tal : finalret){
				Type tt = tal.getType();
				if(tt instanceof FuncType){
					((FuncType)tt).nameRedirect = nameRedirect;//MHA: dirty to tag name redirect here
				}
			}
		}
		
		return new Pair<HashSet<TypeAndLocation>, Boolean>(finalret, constructorHit!=null);
	}
	
	private EvaluatedConstructor funcInvokeIsReallyConstructor(String nameola, FuncInvoke funcInvoke, List<Type> argsWanted, ArrayList<Pair<String, Type>> namessMap) {
		EvaluatedConstructor constructorHit=null;
		//try as a constructor... e.g. mc2 = MyClass("one") //no new keyboard!
		
		maskErrors();
		
		NamedType asNamed = new NamedType(0, 0, nameola);
		if(null != funcInvoke){
			asNamed.setGenTypes(funcInvoke.genTypes);
		}
		Type resTo = (Type)asNamed.accept(this);
		if(null != resTo && resTo instanceof NamedType){
			asNamed = (NamedType)resTo;
		}
		constructorHit = evaluateConstructor(asNamed, argsWanted, namessMap, 0, 0, "", false);
		
		maskedErrors();
		
		return constructorHit;
	}
	
	private HashMap<String, Pair<String, String>> lambdaNameToClassName = new HashMap<String, Pair<String, String>>();
	public long localLambdaCount = 0;
	//private int localLambdaInnerCount = 0;
	
	private Pair<String, String> createLambdaDetsObject(String nameWanted){
		String cls = "";
		if(!this.currentlyInClassDef.isEmpty()){
			/*for(ClassDef cd : this.currentlyInClassDef){
				cls += cd.getPrettyName();
			}*/
			cls = this.currentlyInClassDef.peek().getPrettyName();//.replace(".", "");
		}
		else{
			cls = this.justPackageName;//.replace(".", "");
		}
		
		String fullname = cls.replace(".", "") + nameWanted;
		String filename = this.justPackageName.replace('.', '/') + "$" +  (fullname.contains("/")?fullname.substring(fullname.lastIndexOf('/')): fullname);
		//String filename = cls.replace(".", "/") + "$" +  (fullname.contains("/")?fullname.substring(fullname.lastIndexOf('/')): fullname);
		
		
		Pair<String, String> ret = new Pair<String, String>(filename, fullname );
		//System.err.println("create new lambdaDet: " + ret);
		return ret;
	}
	
	private Pair<String, String> getLambdaDetails(String formalLocation, Type ownerType, String methodName, Fourple<FuncType, ArrayList<Type>, ArrayList<Pair<Type, Integer>>, ArrayList<Pair<String, Type>> > fora)
	{
		Pair<String, String> ret;
		//TODO: if we create a lamba on a supertype, then we can share that lambda def with other lambdas created on SUBTYPES
		//this lazy approach will gennerate two lambdas, which is a bit wasteful (meh) - so fix this one day and test as par usual
		String lazyLambdaName = formalLocation + ownerType.toString() + methodName + fora.toString();//ensure genneration of non duplication FuncionX implementations
		if(!lambdaNameToClassName.containsKey(lazyLambdaName)){
			//modulename$$Lambda0
			//com/mycomp/modulename$$Lambda0
			
			//TODO: with defualt actors being gennerated at runtime, in the following needed?
			/*String cls = "";
			if(!this.currentlyInClassDef.isEmpty()){
				for(ClassDef cd : this.currentlyInClassDef){
					cls += cd.getPrettyName();
				}
				cls = this.currentlyInClassDef.peek().getPrettyName().replace(".", "");
			}
			else{
				cls = this.justPackageName;
			}
			
			String fullname = cls + "$$Lambda" +  localLambdaCount++;
			String filename = this.justPackageName.replace('.', '/') + "$" +  (fullname.contains("/")?fullname.substring(fullname.lastIndexOf('/')): fullname);
					
			ret = new Tuple<String, String>(filename, fullname );
			*/
			
			
			ret = createLambdaDetsObject("$$Lambda" +  localLambdaCount++);
			lambdaNameToClassName.put(lazyLambdaName, ret);
		}
		else{
			ret = lambdaNameToClassName.get(lazyLambdaName);
		}
		return ret;
	}
	

	private boolean withinOnChange = false; 

/*	private boolean isWithinAwait = false;
	
	private static class AwaitContentsEchcker extends AbstractVisitor{
		private ScopeAndTypeChecker satc;

		public AwaitContentsEchcker(ScopeAndTypeChecker satc) {
			this.satc = satc;
		}
		
		@Override
		public Object visit(Await await){
			satc.raiseError(await.getLine(), await.getColumn(), "await may not be nested within await");
			return null;
		}
		@Override
		public Object visit(OnChange await){
			satc.raiseError(await.getLine(), await.getColumn(), "onchange may not be nested within await");
			return null;
			
		}
		@Override
		public Object visit(OnEvery await){
			satc.raiseError(await.getLine(), await.getColumn(), "every may not be nested within await");
			return null;
		}
		
		@Override
		public Object visit(AsyncBlock await){
			satc.raiseError(await.getLine(), await.getColumn(), "! may not be nested within await");
			return null;
		}
		
		public Object checkRootAwait(Await await){
			return super.visit((OnChange)await);
		}
	}
	*/
	@Override
	public Object visit(Await await) {
		if(null == await.body){//make a fake one resolving to true
			int line = await.getLine();
			int colu = await.getColumn();
			await.body = new Block(line, colu, new RefBoolean(line, colu, true));
		}
		
		/*AwaitContentsEchcker ace = new AwaitContentsEchcker(this);
		ace.checkRootAwait(await);*/
		
		visit((OnChange)await);
		
		if(null!=await.body){
			Type got = await.body.getTaggedType();
			got = TypeCheckUtils.unboxTypeIfBoxed(got);
			if(got !=null && !got.equals(const_boolean)){
				this.raiseError(await.getLine(), await.getColumn(), String.format("where condition is specified for await, this must evaluate to type boolean not: %s", got));
			}
			await.body.setShouldBePresevedOnStack(true);
		}
		
		return null;//cannot return
	}
	

	@Override
	public Object visit(OnEvery onEvery) {
		return visit((OnChange)onEvery);
		
	}
	
	private ArrayList<Block> mergeBlocks(ArrayList<Block> toMerge){
		ArrayList<Block> ret = new ArrayList<Block>(1);
		Block first  = toMerge.get(0);
		Block newPre = new Block(first.getLine(), first.getColumn());
		
		for(Block stuff : toMerge){
			newPre.addAll(stuff.lines);
		}
		ret.add(newPre);
		
		newPre.setShouldBePresevedOnStack(toMerge.get(toMerge.size()-1).getShouldBePresevedOnStack());
		
		return ret;
	}
	
	private static class FindAssignemntTypesToRefName extends AbstractVisitor{
		private final String toName;
		public final ArrayList<Type> types = new ArrayList<Type>();
		public final Map<Type, Pair<Integer,Integer>> offenders = new HashMap<Type, Pair<Integer,Integer>>();
		
		public FindAssignemntTypesToRefName(String toName){
			this.toName=toName;
		}
		
		@Override
		public Object visit(AssignNew assignNew) {
			if(toName.equals(assignNew.name)){
				Type tt = assignNew.expr.getTaggedType();
				types.add(tt);
				offenders.put(tt, new Pair<Integer,Integer>(assignNew.getLine(), assignNew.getColumn()));
			}
			return null;
		}
		
		@Override
		public Object visit(AssignExisting assign) {
			Expression lhs = assign.assignee;
			if(lhs instanceof RefName){
				RefName asRef = (RefName)lhs;
				if(asRef.isIsolated && asRef.name.equals(toName)){
					Type tt = assign.expr.getTaggedType();
					types.add(tt);
					offenders.put(tt, new Pair<Integer,Integer>(assign.getLine(), assign.getColumn()));
				}
			}
			
			return null;
		}
		
	}
	
	private class FindIllegalExpresionsRefNames extends AbstractVisitor{
		private final String illegal;
		//we do not permit the return varibale to be used within the onchange expressions (cos too hard to figure out the type + its a bit weird) - maybe fix one day
		
		public FindIllegalExpresionsRefNames(String illegal){
			this.illegal=illegal;
		}
		
		@Override
		public Object visit(RefName refName) {
			if(refName.isIsolated && refName.name.equals(this.illegal)){
				raiseError(refName.getLine(), refName.getColumn(), String.format(String.format("async return variable %s cannot be used here", this.illegal) ));
			}
			return null;
		}
	}
	
	private ArrayList<LineHolder> removeAELH(ArrayList<LineHolder> aelh){
		//convert AssignExisting -> AssignNew
		ArrayList<LineHolder> newaelh = new ArrayList<LineHolder>();
		
		for(LineHolder lh : aelh) {
			if(lh.l instanceof AssignExisting) {
				AssignExisting ae = (AssignExisting)lh.l;
				if(ae.isReallyNew) {
					lh.l = new AssignNew(null, ae.getLine(), ae.getColumn(), ((RefName)ae.assignee).name, ae.getTaggedType(), ae.eq, ae.expr);
					lh.l.accept(this);//should already be accepted
				}
			}
			newaelh.add(lh);
		}
		
		return newaelh;
		
	}
	
	@Override
	public Object visit(AsyncBodyBlock asyncBodyBlock) {
		this.level++;
		this.level++;//MHA: this way variables in nested functions within async blocks work ok
		//mrege pre post blocks into one
		boolean retExpected = asyncBodyBlock.getShouldBePresevedOnStack();
		
		if(asyncBodyBlock.preBlocks.size() > 1){
			asyncBodyBlock.preBlocks = mergeBlocks(asyncBodyBlock.preBlocks);
		}
		
		if(asyncBodyBlock.postBlocks.size() > 1){
			asyncBodyBlock.postBlocks = mergeBlocks(asyncBodyBlock.postBlocks);
		}
		//merge done
		
		if(!asyncBodyBlock.preBlocks.isEmpty()){
			Block item = asyncBodyBlock.preBlocks.get(0);
			item.canContainAReturnStmt = true;
			
			if(null != asyncBodyBlock.stateObjectClassDef){
				Type retType = ((ClassDefStateObject)asyncBodyBlock.stateObjectClassDef).spliceToName.get("ret$");
				addToScopeStackVars("ret$", retType, true, true, false);//ret may be referenced inside the pre block if we return here
			}
			
		/*	String inretName = "async";
			if(!this.currentlyInRet.isEmpty()){
				String got = this.currentlyInRet.peek();
				if(got.equals("async-noret")){
					inretName += "-noret";
				}
			}*/
			
			this.currentlyInRet.add(retExpected  ? "async":"async-noret");
			this.returnTypeExpected.add(asyncBodyBlock.getTaggedType());
			
			this.maskErrors(true);
			item.accept(this);
			ArrayList<CapMaskedErrs> mes = this.getmaskedErrors();
			if(mes.isEmpty()) {
				asyncBodyBlock.preBlocks.get(0).lines  = removeAELH(asyncBodyBlock.preBlocks.get(0).lines);
			}else {
				this.applyMaskedErrors(mes);
			}
			
			this.currentlyInRet.pop();
			this.returnTypeExpected.pop();
			
			
			TheScopeFrame inpresf = this.currentScopeFrame.getChild(item);
			for( VarAtScopeLevel var : inpresf.getAllVariablesAtScopeLevel(false, false, false, false)){
				addToScopeStackVars(var.getVarName(), var.getType(), var.isFinal(), true, var.isShared());
			}
			for( Thruple<String, TypeAndLocation, AccessModifier> var : inpresf.getAllMethodsAtScopeLevel(false, false)){
				addToScopeStackMethods(var.getA(), var.getB(), var.getC());
			}
			//TODO: and lambdas/functions
		}
		Block mainBody = asyncBodyBlock.mainBody;
		boolean atLeastOneOnChangeEvery = false;
		boolean hasEvery = false;
		int n=0;
		for(LineHolder lh : mainBody.lines){
			Line lino = lh.l;
			if(!(lino instanceof OnChange && !(lino instanceof Await))){
				this.raiseError(lino.getLine(), lino.getColumn(), String.format("async may contain only onchange or every instances"));
			}
			else{
				((OnChange)lino).asyncIndex = n++;
				atLeastOneOnChangeEvery=true;
				if(!hasEvery &&  lino instanceof OnEvery){
					hasEvery = true;
				}
			}
		}
		asyncBodyBlock.childrenCount = n;
		asyncBodyBlock.hasEvery = hasEvery;
		
		if(!atLeastOneOnChangeEvery){
			this.raiseError(asyncBodyBlock.getLine(), asyncBodyBlock.getColumn(), String.format("async must contain at least one onchange or every instance"));
		}
		
		if(retExpected){
			mainBody.returnExpectedOfEveryStatement = true;
		}
		
		//TheScopeFrame prev = this.currentScopeFrame;
		//this.currentScopeFrame=this.currentScopeFrame.getParent();
		//Type rtAsRef = null;
		
		this.currentlyInRet.add(retExpected  ? "async":"async-noret");
		
		for(LineHolder lh : mainBody.lines){
			Line lino = lh.l;
			if(lino instanceof OnChange){
				lino.accept(this);
			}
		}
				
		this.currentlyInRet.pop();
		
		if(!asyncBodyBlock.postBlocks.isEmpty()){
			if(!asyncBodyBlock.preBlocks.isEmpty()){
				TheScopeFrame inpresf = this.currentScopeFrame.getChild(asyncBodyBlock.preBlocks.get(0));
				for( VarAtScopeLevel var : inpresf.getAllVariablesAtScopeLevel(false, false, false, false)){
					addToScopeStackVars(var.getVarName(), var.getType(), var.isFinal(), true, var.isShared());
				}
			}
			
			if(null != asyncBodyBlock.stateObjectClassDef){
				Type retType = ((ClassDefStateObject)asyncBodyBlock.stateObjectClassDef).spliceToName.get("ret$");
				addToScopeStackVars("ret$", retType, true, true, false);//ret may be referenced inside the post block if we return here
			}
			
			Block item =asyncBodyBlock.postBlocks.get(0); 
			item.canContainAReturnStmt = true;
			
			
			/*String inretName = "async";
			if(!this.currentlyInRet.isEmpty()){
				String got = this.currentlyInRet.peek();
				if(got.equals("async-noret")){
					inretName += "-noret";
				}
			}
			*/
			this.currentlyInRet.add(retExpected  ? "async":"async-noret");
			this.returnTypeExpected.add(asyncBodyBlock.getTaggedType());
			
			item.accept(this);

			this.currentlyInRet.pop();
			this.returnTypeExpected.pop();
		}
		
		if(null != asyncBodyBlock.stateObjectClassDef){
			this.currentScopeFrame.setClassDef(this.currentScopeFrame, asyncBodyBlock.getFullnameSO(), asyncBodyBlock.stateObjectClassDef, Opcodes.ACC_PUBLIC);
		}
		
		if(null != asyncBodyBlock.cleanUpMethodFuncDef){
			this.forWhileExpectsReturn.push(new Pair<Boolean, String>(asyncBodyBlock.getShouldBePresevedOnStack(), "onchange"));
			asyncBodyBlock.applyMethodFuncDef.accept(this);
			this.forWhileExpectsReturn.pop();
			
			asyncBodyBlock.cleanUpMethodFuncDef.accept(this);
			
			this.level--;
			asyncBodyBlock.initMethodNameFuncDef.accept(this);
			this.level++;
		}
			
		
		Type ret = null;
		
		if(retExpected){
			ArrayList<Type> rtypes = new ArrayList<Type>(mainBody.lines.size());
			ArrayList<OnChange> onchangeVoids = new ArrayList<OnChange>(rtypes.size());
			Map<Type, Pair<Integer,Integer>> offenders = new HashMap<Type, Pair<Integer,Integer>>();
			for(LineHolder lh : mainBody.lines){
				Line lino = lh.l;
				if((lino instanceof OnChange && !(lino instanceof Await))){
					Type tt = lino.getTaggedType();
					rtypes.add(tt);
					offenders.put(tt, new Pair<Integer,Integer>( lino.getLine(), lino.getColumn() ));
					if(!TypeCheckUtils.isValidType(tt)){
						onchangeVoids.add((OnChange)lino);
					}
					else{
						lino.setShouldBePresevedOnStack(true);
					}
				}
			}
			
			for(ArrayList<Block> blks : new ArrayList[]{asyncBodyBlock.preBlocks, asyncBodyBlock.postBlocks}){
				if(null != blks && !blks.isEmpty()){
					Block blk = blks.get(0);
					Type got = getOnChangeTypeOptions(blk);//blk.getTaggedType();
					
					if(null != got && TypeCheckUtils.isValidType(got)){//Weird, block doesnt have returning tag
						got = TypeCheckUtils.boxTypeIfPrimative(got, false);
						NamedType prepostType = new NamedType(blk.getLine(), blk.getColumn(), got);
						prepostType.setLockedAsRef(true);
						got = prepostType;
					}
					else{
						blk.setShouldBePresevedOnStack(false);//optional, so if it doesnt return anything dont foce it to
					}
					
					if(got != null){
						rtypes.add(got);
						offenders.put(got, new Pair<Integer,Integer>( blk.getLine(), blk.getColumn() ));
					}
				}
			}
			
			ArrayList<Type> invalids = new ArrayList<Type>(rtypes.size());
			
			for(Type rt : rtypes){
				if(!TypeCheckUtils.isValidType(rt)){
					invalids.add(rt);
				}
			}
			
			if(!invalids.isEmpty() &&  invalids.size() != rtypes.size()){
				//remove the voids, because we have at least one which is non void - which can be taken as type for async
				for( Type inv : invalids){
					rtypes.remove(inv);
				}
			}
			
			ret= TypeCheckUtils.getMoreGeneric(this, this, asyncBodyBlock.getLine(), asyncBodyBlock.getColumn(), rtypes, offenders);
			//ret = TypeCheckUtils.boxTypeIfPrimativeAndSetUpperBound(ret);
			ret = TypeCheckUtils.boxTypeIfPrimative(ret, false);
			
			
			boolean isNull = !TypeCheckUtils.isValidType(ret) || ret instanceof VarNull;
			
			if(isNull || !TypeCheckUtils.isValidType(ret)){
				if(!rtypes.contains(null)){//if contains null then one of the nested onchange/everys will have thrown an error
					this.raiseError(asyncBodyBlock.getLine(),asyncBodyBlock.getColumn(), "async must return something");
				}
				
				ret=null;
			}
			else{
				//not null but some onchange not return, so tag those as non return
				
				if(onchangeVoids.size() < rtypes.size()){//but only tag if these are in the minority. If all dont return then we have a problem
					for(OnChange vods : onchangeVoids){
						vods.setShouldBePresevedOnStack(rtypes.isEmpty() ? retExpected : false);
					}
				}
				
				
				//invalids
			}
			
			if(null == ret){
				asyncBodyBlock.noReturn = true;
			}
			else{
				ret = TypeCheckUtils.getRefTypeToLocked(ret);
				asyncBodyBlock.noReturn = false;
				((NamedType)ret).setLockedAsRef(true);//xxx=async{ } => xxx:=async{ }//if not done then fails as it attempts to block on extracting value of rhs of xxx for storage since not locked as ref
			}
			
			//must be retunring a ref because that's expected of onchange and every
			
			
			for(LineHolder lh : mainBody.lines){
				Line lino = lh.l;
				if((lino instanceof OnChange && !(lino instanceof Await))){
					if(lino.getShouldBePresevedOnStack()){
						lino.setTaggedType(ret);
					}
				}
			}
			
			
			asyncBodyBlock.setTaggedType(ret);
		}
		
		//admin
		
		
		if(null == asyncBodyBlock.onChangeDets){
			String fullname = this.justPackageName + "$$AsyncBlock" + localLambdaCount;
			String filename = fullname.contains("/")?fullname.substring(fullname.lastIndexOf('/')): fullname;
			asyncBodyBlock.onChangeDets = new Pair<String, String> (fullname, filename);
			
			asyncBodyBlock.applyMethodName = "$$AsyncBlock" + (localLambdaCount) + "$apply";
			asyncBodyBlock.initMethodName = "$$AsyncBlock" + (localLambdaCount) + "$init";
			asyncBodyBlock.cleanupMethodName = "$$AsyncBlock" + (localLambdaCount) + "$cleanup";
		}
		localLambdaCount++;
		
		asyncBodyBlock.isModuleLevel = this.currentlyInClassDef.isEmpty();
		asyncBodyBlock.holderclass = new NamedType(asyncBodyBlock.isModuleLevel?this.moduleLevelNamedType:this.currentlyInClassDef.peek());
		
		for(LineHolder lh : mainBody.lines){
			Line lino = lh.l;
			if((lino instanceof OnChange && !(lino instanceof Await))){//overwrite state object class name
				OnChange asonChange  =(OnChange)lino;
				asonChange.onChangeDets = asyncBodyBlock.onChangeDets;
			}
		}

		this.level--;
		this.level--;
		
		return ret;
	}
	
	
	private class ExtractOnChangeCandidates extends OnChangeNestedVis implements IgnoreASTRepointForReturn{
		private HashSet<Type> candidates  = new HashSet<Type>();
		
		public Type findOnChangeType(Block blk){
			//candidates.add(blk.getTaggedType());
			this.visit(blk);
			ArrayList<Type> types = new ArrayList<Type>();
			for(Type t: candidates){
				if(TypeCheckUtils.isValidType(t)){
					types.add(t);
				}
			}
			if(types.isEmpty()){
				Type ll = blk.getTaggedType();
				if(ll instanceof NamedType && ((NamedType)ll).orignallyfromVarNull){
					//lady
				}
				else{
					types.add(ll);//may end like this: ninset = every(xx) { xx }// i.e. implicit return
				}
			}
			
			Type got = getMostGenericGeneric(types, null, blk.getLine(), blk.getColumn(), false);
			return got;
			
		}
		
		@Override
		public Object visit(ReturnStatement returnStatement) {
			super.visit(returnStatement);
			
			candidates.add(returnStatement.getTaggedType());
			
			return null;
		}
		
		@Override
		public Object visit(ContinueStatement continueStatement) {
			super.visit(continueStatement);
			candidates.add(continueStatement.getTaggedType());
			return null;
		}
		
		@Override
		public Object visit(BreakStatement breakStatement) {
			super.visit(breakStatement);
			candidates.add(breakStatement.getTaggedType());
			return null;
		}
	}
	
	private Type getOnChangeTypeOptions(Block blk){
		ExtractOnChangeCandidates extr = new ExtractOnChangeCandidates();
		return extr.findOnChangeType(blk);
	}
	
	private void addVarsAndMethodsOnEntryTocurrentScope(int line, int col){
		for(Fiveple<String, Type, Boolean, Boolean, Boolean> toAdd : this.varsToAddToScopeOnEntry){
			String name =toAdd.getA();
			this.currentScopeFrame.setVariable(this.currentScopeFrame, name, createTypeAndLocationVarHolder(line, col, (Type)toAdd.getB(), toAdd.getC(), null, false, false, toAdd.getE(), false, true, false, false), toAdd.getD(), this.level, null, false); //no need to check this exists already, becuase it can't!
		}
		
		for(Thruple<String, TypeAndLocation, AccessModifier> toAdd : this.methsToAddToScopeOnEntry){
			String name =toAdd.getA();
			this.currentScopeFrame.setFuncDef(this.currentScopeFrame, name, toAdd.getB(), this.level); //no need to check this exists already, becuase it can't!
		}
	}
	
	
	private static class RefFinder extends AbstractVisitor{
		public ArrayList<String> referencedrefs = new  ArrayList<String>();
		
		@Override
		public Object visit(RefName refName) {
			Type got = refName.getTaggedType();
			if(TypeCheckUtils.hasRefLevels(got)) {
				String name = refName.name;
				if(!containsLocalVar(name) && !referencedrefs.contains(name)) {
					referencedrefs.add(name);
				}
			}
			return null;
		}
		
		private Stack<HashSet<String>> localvars = new Stack<HashSet<String>>();
		{
			localvars.add(new HashSet<String>());
		}
		
		private void addLocalVar(String var) {
			this.localvars.peek().add(var);
		}
		
		private boolean containsLocalVar(String var) {
			for(HashSet<String> level : localvars) {
				if(level.contains(var)) {
					return true;
				}
			}
			return false;
		}
		
		@Override
		public Object visit(FuncDef funcDef) {
			localvars.add(new HashSet<String>());
			funcDef.getParams().params.forEach(a -> addLocalVar(a.name));
			
			super.visit(funcDef);
			localvars.pop();
			return null;
		}
		
		@Override
		public Object visit(LambdaDef lambdaDef) {
			localvars.add(new HashSet<String>());
			lambdaDef.getParams().params.forEach(a -> addLocalVar(a.name));
			
			super.visit(lambdaDef);
			localvars.pop();
			return null;
		}
		
		@Override
		public Object visit(ForBlock forBlock) {
			localvars.add(new HashSet<String>());
			
			addLocalVar(forBlock.localVarName);
			
			super.visit(forBlock);
			localvars.pop();
			return null;
		}
		
		@Override
		public Object visit(ForBlockOld forBlockOld) {
			localvars.add(new HashSet<String>());
			
			addLocalVar(forBlockOld.assignName);
			
			super.visit(forBlockOld);
			localvars.pop();
			return null;
		}
		
		@Override
		public Object visit(ClassDef classDef) {
			localvars.add(new HashSet<String>());
			
			if(classDef.classDefArgs != null) {
				classDef.classDefArgs.aargs.forEach(a -> addLocalVar(a.name));
			}
			
			super.visit(classDef);
			localvars.pop();
			return null;
		}
		
		@Override
		public Object visit(AssignNew assignNew) {
			addLocalVar(assignNew.name);
			return super.visit(assignNew);
		}
		
		@Override
		public Object visit(AssignExisting assignExisting) {
			if(assignExisting.isReallyNew) {
				if(assignExisting.assignee instanceof RefName) {
					addLocalVar(((RefName)assignExisting.assignee).name);
				}
			}

			return super.visit(assignExisting);
		}
		

		@Override
		public Object visit(OnChange onChange){
			return null;//ignore
		}
		
		@Override
		public Object visit(AsyncBlock asyncBlock) {
			return null;//ignore
		}
	}
	
	@Override
	public Object visit(OnChange onChange) {
		if(onChange.exprs.isEmpty() && onChange.body != null) {//nothing being listened to so investiate to see if we can find refs to listen to...
			this.maskErrors();
			onChange.body.accept(this);
			this.maskedErrors();
			
			RefFinder rf = new RefFinder();
			onChange.body.accept(rf);
			rf.referencedrefs.forEach(a -> onChange.exprs.add(new RefName(a)));
		}
		
		if(onChange.exprs.isEmpty() && onChange.body != null) {
			this.raiseError(onChange.getLine(), onChange.getColumn(), "At least one ref to monitor must be specified for " + onChange.getName());
		}
		
		boolean prevWoChange = withinOnChange;
		withinOnChange=true;
		
		boolean isawait = onChange instanceof Await;

		Block dummy = new Block(1,2);
		this.currentScopeFrame=TheScopeFrame.buildTheScopeFrame_Block(this.currentScopeFrame, dummy);
		this.currentScopeFrame.enterScope();
		
		addVarsAndMethodsOnEntryTocurrentScope(onChange.getLine(), onChange.getColumn());
		
		
		HashSet<String> localExprNames = new HashSet<String>();
		for(Node expr: onChange.exprs){
			Type exprType;
			if(expr instanceof AssignNew){
				AssignNew an = (AssignNew)expr;
				if(localExprNames.contains(an.name)){//onchange(f=xs2, f=xs) {} //not allowed
					this.raiseError(onChange.getLine(), onChange.getColumn(), String.format("Variable %s has already been defined in current scope", an.name));
				}
				else{
					localExprNames.add(an.name);
				}
				
				an.accept(this);
				exprType = an.getTaggedType();
				
				addToScopeStackVars(an.name, exprType, an.isFinal, true, an.isShared);//for the next block
				Type rhs = an.expr.getTaggedType();
				if(null != rhs && !rhs.equals(an.type)){
					this.raiseError(onChange.getLine(), onChange.getColumn(), String.format("type specified for variable: %s does not match right hand side of assignment: %s", an.type, rhs));
				}
			}
			else{
				exprType = (Type)expr.accept(this);
			}
			
			if(null != exprType){
				if(!TypeCheckUtils.hasRefLevels(exprType) && !TypeCheckUtils.hasRefLevelsAndIsArray(exprType) 
						&& !TypeCheckUtils.isMap(ers, exprType, true) 
						&& !TypeCheckUtils.isList(ers, exprType, true)
						&& !TypeCheckUtils.isSet(ers, exprType, true)
						&& !TypeCheckUtils.isRegistrationSet(ers, exprType)){
					this.raiseError(onChange.getLine(), onChange.getColumn(), String.format("%s statements can only operate upon either refernces or arrays, lists, maps, sets of references or ReferenceSets, not: %s", onChange.getName(), exprType));
				}
			}
		}
		
		this.currentScopeFrame = this.currentScopeFrame.leaveScope();
		
		addVarsAndMethodsOnEntryTocurrentScope(onChange.getLine(), onChange.getColumn());
		
		if(null == onChange.onChangeDets){
			Pair<String, String> lamDets = createLambdaDetsObject("$$onChange" + localLambdaCount++);
			
			onChange.onChangeDets = lamDets;
			onChange.applyMethodName = "$$onChange" + (localLambdaCount-1) + "$apply";
			onChange.initMethodName = "$$onChange" + (localLambdaCount-1) + "$init";
			onChange.cleanupMethodName = "$$onChange" + (localLambdaCount-1) + "$cleanup";
			//System.err.println("assign lambda dets to: " + asyncBlock);
		}
		else{
			localLambdaCount++;
		}
		onChange.isModuleLevel = this.currentlyInClassDef.isEmpty();
		onChange.holderclass = new NamedType(onChange.isModuleLevel?this.moduleLevelNamedType:this.currentlyInClassDef.peek());
		
		if(null != onChange.stateObjectClassDef){
			this.currentScopeFrame.setClassDef(this.currentScopeFrame, onChange.getFullnameSO(), onChange.stateObjectClassDef, Opcodes.ACC_PUBLIC);
		}

		String inretName = onChange.getName();
		
		if(!this.currentlyInRet.isEmpty()){
			String got = this.currentlyInRet.peek();
			if(got.equals("async-noret")){
				inretName += "-noret";
			}
		}
		
		this.currentlyInRet.add(inretName);
		this.onchangeRetType.add(onChange.getTaggedType());
		this.returnTypeExpected.add(onChange.getTaggedType());
		Type ret;
		if(null == onChange.applyMethodFuncDef){
			if(onChange.body == null){
				ret = null;
			}
			else{
				this.forWhileExpectsReturn.push(new Pair<Boolean, String>(isawait?true:onChange.getShouldBePresevedOnStack(), "onchange"));
				
				onChange.body.canContainAContinueOrBreak = true;
				onChange.body.canContainAReturnStmt = true;
				
				onChange.body.accept(this);
				ret = getOnChangeTypeOptions(onChange.body);
				this.forWhileExpectsReturn.pop();
			}
		}
		else{
			if(null != onChange.body){
				ret = onChange.body.getTaggedType();
			}
			else{
				ret = null;
			}
		}


		this.currentlyInRet.pop();
		this.onchangeRetType.pop();
		this.returnTypeExpected.pop();
		
		if(null != onChange.cleanUpMethodFuncDef){
			this.forWhileExpectsReturn.push(new Pair<Boolean, String>(onChange.getShouldBePresevedOnStack(), "onchange"));
			
			onChange.applyMethodFuncDef.accept(this);
			
			this.forWhileExpectsReturn.pop();
			
			onChange.cleanUpMethodFuncDef.accept(this);
			onChange.initMethodNameFuncDef.accept(this);
		}
		

		if(onChange.getShouldBePresevedOnStack()){
			if(null == ret){
				onChange.noReturn = true;
			}
			
			boolean isNull = !TypeCheckUtils.isValidType(ret);
			
			ret = TypeCheckUtils.boxTypeIfPrimative(ret, false);
			
				//only needed for the likes of ar = for(n=0; n < 50; n++){n*2}
			
			if(isNull || !TypeCheckUtils.isValidType(ret)){
				if(onChange instanceof Await){
					this.raiseError(onChange.getLine(),onChange.getColumn(), "await cannot return anything");
				}
				else if(onChange instanceof OnEvery){
					this.raiseError(onChange.body.getLine(),onChange.body.getColumn(), "every must return something");
				}
				else{
					this.raiseError(onChange.body.getLine(),onChange.body.getColumn(), "onchange must return something");
				}
				//ret=const_void_thrown;
				ret=null;
			}
			else{
				ret = TypeCheckUtils.getRefTypeToLocked(ret);
				
				NamedType asRet = new NamedType(onChange.getLine(), onChange.getColumn(), ret);
				asRet.setLockedAsRef(true);
				ret = asRet;
			}
			
			onChange.setTaggedType(ret);
		}
		
		withinOnChange = prevWoChange;

		if(!onChange.options.isEmpty()) {//TODO: only pocess these once
			TreeSet<String> invalids = new TreeSet<String>(); 
			for(String opt : onChange.options) {
				if(opt.equals("onlyclose")) {
					onChange.onlyClose = true;
				}else {
					invalids.add(opt);
				}
			}
			
			Set<String> dupes;
			{
				Set<String> uniques = new HashSet<String>();
				dupes =  onChange.options.stream().filter(e -> !uniques.add(e)).collect(Collectors.toSet());
			}
			
			if(!invalids.isEmpty()) {
				this.raiseError(onChange.body.getLine(), onChange.body.getColumn(), String.format("invalid options specified: %s - valid options are: \"onlyclose\"", String.join(", ", invalids)));
			}
			
			if(!dupes.isEmpty()) {
				this.raiseError(onChange.body.getLine(), onChange.body.getColumn(), String.format("duplicate options specified: %s", String.join(", ", dupes)));
			}
			
		}
		
		return ret;
	}
	
	private static final NamedType changedType = new NamedType(new ClassDefJava(Transaction.class));
	
	@Override
	public Object visit(Changed changed) {
		if(!withinOnChange){
			this.raiseError(changed.getLine(), changed.getColumn(), "changed variable may only exist within onchange block");
		}
		changed.isModuleLevel = this.currentlyInClassDef.isEmpty();
		changed.setTaggedType(changedType);
		return changedType;
	}
	
	@Override
	public Object visit(AsyncBlock asyncBlock) {
		this.level++;
		asyncBlock.body.staticFuncBlock=true;
		asyncBlock.body.isAsyncBlock=true;
		Type ret = (Type)asyncBlock.body.accept(this);
		
		if(null != asyncBlock.executor)
		{
			this.level--;
			Type exeType = (Type)asyncBlock.executor.accept(this);
			this.level++;
			if(null == TypeCheckUtils.checkSubType(this.ers, ISOExecutor, exeType)) {
				this.raiseError(asyncBlock.getLine(), asyncBlock.getColumn(), "Asynchonous executor must be a subtype of com.concurnas.runtime.cps.ISOExecutor: %s is not", exeType);
			}
			
		}
		
		if(null == ret || !asyncBlock.getShouldBePresevedOnStack()){
			asyncBlock.noReturn = true;
		}
		else if(ret instanceof VarNull )
		{
			//this.raiseError(assignExisting.getLine(),assignExisting.getColumn(), "Ambiguous type declaration of null");
			int levels = ret.getArrayLevels();
			NullStatus ns = ret.getNullStatus();
			ret = new NamedType(asyncBlock.getLine(), asyncBlock.getColumn(), new ClassDefJava(java.lang.Object.class));
			ret.setArrayLevels(levels);
			ret.setNullStatus(ns);
			asyncBlock.body.setTaggedType(ret);
		}
		else{
			if(TypeCheckUtils.isVoid(ret)) {
				ret = const_object;
			}
			
			asyncBlock.noReturn = false;
		}
		
		ret = TypeCheckUtils.boxTypeIfPrimative(ret, false);
		
		int line = asyncBlock.getLine();
		int col = asyncBlock.getColumn();
		
		if(asyncBlock.getShouldBePresevedOnStack() && null == ret ){
			this.raiseError(line, col, "async block must return something");
			ret = const_object;
		}
		ret = TypeCheckUtils.getRefTypeToLocked(ret);
		NamedType asRet = new NamedType(line, col, ret );//
		asRet.setLockedAsRef(true);
	/*	
		if(ns != null) {
			asRet.setNullStatus(nullStatus);
		}
		*/
		asyncBlock.setTaggedType(asRet);
		
				
		FuncRef fakeFuncRef = new FuncRef(line, col);
		fakeFuncRef.superClassName = "com/concurnas/bootstrap/runtime/cps/IsoTask";
		FuncRefArgs eaFLambdaConst =  new FuncRefArgs(line, col);
		//extra ones captured...
		FuncParams lfp = asyncBlock.getExtraCapturedLocalVars();
		if(lfp != null){
			
			//MHA: remove the res which may have got on here by accident by earlier pass
			if(!lfp.params.isEmpty()){
				int last = lfp.params.size()-1;
				FuncParam fp = lfp.params.get(last);
				if(fp.name.equals("ret$")){
					lfp.params.remove(last);
				}
			}
			
			for(FuncParam p : lfp.params){
				Expression e = new RefName(line, col, p.name);
				Type et = (Type)e.accept(this);
				e.setTaggedType(et);
				eaFLambdaConst.addExpr(e );
			}
		}
		
		if(!asyncBlock.noReturn && null!=eaFLambdaConst){
			RefName e = new RefName("ret$");
			asRet.accept(this);
			e.setTaggedType(asRet);
			asRet.accept(this);
			eaFLambdaConst.addExpr(e);//return is added to constructor
		}
		
		fakeFuncRef.extraArgsForLambdaConst = eaFLambdaConst;
		
		asyncBlock.body.staticFuncBlock=false;
		if(this.currentlyInClassDef.isEmpty()){
			//must be module level, thus only case where we can have static methods...
			asyncBlock.body.staticFuncBlock=true;//tag as static function...
		}
		
		if(null == asyncBlock.lamDets){
			///String fullname = this.justPackageName.replace('.', '/') + "$$Lambda" + localLambdaCount++;
			//System.err.println("fullname: " + fullname);
			//String filename = fullname.contains("/")?fullname.substring(fullname.lastIndexOf('/')+1): fullname;
			
			/*String fullname = "$$Lambda" + localLambdaCount++;
			//System.err.println("fullname: " + fullname);
			String filename = this.justPackageName.replace('.', '/') +"$" + fullname;
			Tuple<String, String> lamDets = new Tuple<String, String> (filename, fullname);*/
			Pair<String, String> lamDets = createLambdaDetsObject("$$Lambda" + localLambdaCount++);
			asyncBlock.lamDets = lamDets;
			
			//System.err.println("assign lambda dets to: " + asyncBlock);
		}
		else{
			localLambdaCount++;
		}
		
		fakeFuncRef.setLambdaDetails(asyncBlock.lamDets);
		
		FuncType retFuncType = new FuncType(0,0, new ArrayList<Type>(), const_void);
		
		FuncLocation loc;
		if(!this.currentlyInClassDef.isEmpty()){
			//inclass
			ClassDef holder = this.currentlyInClassDef.peek();
			loc = new ClassFunctionLocation(holder.bcFullName(), new NamedType(line, col, holder));
			fakeFuncRef.operatingOn=new NamedType(line, col, holder);
		}
		else{
			//static module level
			loc = new StaticFuncLocation(new NamedType(line, col, this.moduleLevelNamedType));
		}
		
		loc.setLambdaOwner("com/concurnas/bootstrap/lang/Lambda$Function0");
		
		fakeFuncRef.typeOperatedOn = new TypeAndLocation(retFuncType, loc );
		fakeFuncRef.setTaggedType(retFuncType);
		
		
		ArrayList<Type> consturctorArgs = new ArrayList<Type>();
		if(lfp != null){
			for(FuncParam p : lfp.params){
				Type aot =(Type)p.accept(this);//p.getTaggedType()
				aot = (Type)aot.copy();
				p.setTaggedType(aot);
				consturctorArgs.add(aot);
			}
		}
		
		//add return type lambda
		if(!asyncBlock.noReturn){
			consturctorArgs.add(asRet);//return is added to constructor
		}
		
		fakeFuncRef.argumentsThatDontNeedToBecurriedIn = consturctorArgs;
		
		//args added in constructor
		
		PrintSourceVisitor psv = new PrintSourceVisitor();
		psv.visit(asyncBlock.body);
		
		String contents = psv.toString();
		
		if(null == asyncBlock.methodName){
			asyncBlock.methodName = generateLambdaName(contents);
			//System.err.println("gennerated ab name " + asyncBlock.methodName  );
		}else{
			lambdaNames.add(asyncBlock.methodName);
		}
		
		fakeFuncRef.methodName = asyncBlock.methodName;
		
		asyncBlock.fakeFuncRef = fakeFuncRef;
		
		//method structure
		Block body = (Block)asyncBlock.body.copy();
		
		body.staticFuncBlock=false;//inner body is not static
		
		Block newbody;
		//turn this into a lambda, with approperiate bindings
		if(!asyncBlock.noReturn){
			newbody = Utils.makeAssignToRefFromrhsBlock(body, ret, true); //xxx => ret := {xxx}
		}
		else{
			newbody=body;
		}
		newbody.add(new LineHolder(line, col, new ReturnStatement(0,0)));
		
		body=newbody;
		
		
		//add return type lambda
		if(!asyncBlock.noReturn && null != lfp){// && null != lfp){
			FuncParam res = new FuncParam(0,0,"ret$", asRet, false);
			res.accept(this);
			lfp.add(res);//return is added to constructor
		}
		else if(!asyncBlock.noReturn){
			lfp = new FuncParams(0,0);//hack
			FuncParam res = new FuncParam(0,0,"ret$", asRet, false);
			res.accept(this);
			lfp.add(res);//return is added to constructor
		}
		
		
		
		//if(null == asyncBlock.fakeLambdaDef){
			
			LambdaDef fakeLambdaDef = new LambdaDef(asyncBlock.getLine(), asyncBlock.getColumn(), null, lfp, body, const_void, new ArrayList<Pair<String, NamedType>>());
			fakeLambdaDef.methodName = asyncBlock.methodName;
			fakeLambdaDef.lamDets = asyncBlock.lamDets;
			fakeLambdaDef.setSupressTypeBoxing(true);
			
			asyncBlock.fakeLambdaDef = fakeLambdaDef;
		//}
		this.level--;
		asyncBlock.fakeLambdaDef.accept(this);
		

		if(asyncBlock.noReturn){
			Type retx = (Type)ScopeAndTypeChecker.const_void.copy();
			return asyncBlock.setTaggedType(retx);
		}
		
		return asRet;
	}
	
	
	
	
	
	
	public Object visitReal(LambdaDef lambdaDef) {
		this.level++;
		int line= lambdaDef.getLine();
		int col = lambdaDef.getColumn();
		
		FuncRef fakeFuncRef = new FuncRef(line, col);//JPT: the fact that we regenerate the fakeFuncRef every time causes us some trouble - see if this can be done only once instead
		
		if(null !=  lambdaDef.fakeFuncRef){
			fakeFuncRef.extraArgsForLambdaConst = lambdaDef.fakeFuncRef.extraArgsForLambdaConst;
		}
		
		
		FuncRefArgs argz =  new FuncRefArgs(line, col);
		FuncRefArgs eaFLambdaConst =  new FuncRefArgs(line, col);
		

		this.currentlyInFuncDef.add(lambdaDef);
		
		int argcounts = 0;
		for(FuncParam p : lambdaDef.params.params)
		{
			Type aot =(Type)p.accept(this);
			argz.addType(aot);
			argcounts++;
		}
		//extra ones captured...
		FuncParams lfp = lambdaDef.getExtraCapturedLocalVars();
		if(lfp != null){
			if(null == lambdaDef.forceNestFuncRepoint || null == fakeFuncRef.extraArgsForLambdaConst){
				//do first time only
				for(FuncParam p : lfp.params){
					Expression e = new RefName(line, col, p.name);
					Type et = (Type)e.accept(this);
					e.setTaggedType(et);
					eaFLambdaConst.addExpr(e );
				}	
				if(null == lambdaDef.forceNestFuncRepoint){
					lambdaDef.forceNestFuncRepoint = true; //we have to set this which is a real mess :(
				}
			}
			else{
				for(Expression e : fakeFuncRef.extraArgsForLambdaConst.getBoundArgs()){
					Type et = (Type)e.accept(this);
					e.setTaggedType(et);
				}
				
				eaFLambdaConst = fakeFuncRef.extraArgsForLambdaConst;
			}
			
		}
		
		fakeFuncRef.setArgsForScopeAndTypeCheck( argz);
		fakeFuncRef.argsForNextCompCycle = argz;
		fakeFuncRef.extraArgsForLambdaConst = eaFLambdaConst;
		
		Type retAcc = lambdaDef.returnType!=null?  (Type)lambdaDef.returnType.accept(this): null;
		if(null != retAcc)
		{
			Type tt = (Type)retAcc.copy();
			tt.setOrigonalGenericTypeUpperBound(null);
			lambdaDef.returnType = tt;
		}
		else
		{
			this.raiseError(lambdaDef.getLine(), lambdaDef.getColumn(), String.format("Unable to resolve type: '%s'", lambdaDef.returnType));
		}
		
		this.returnTypeExpected.add(lambdaDef.returnType); 
		this.currentlyInRet.add("lambda");
		
		if(null != lambdaDef.body) {
			if(this.currentlyInClassDef.isEmpty()){
				//must be module level, thus only case where we can have static methods...
				lambdaDef.body.staticFuncBlock=true;//tag as static function...
			}
			
			lambdaDef.body.canContainAReturnStmt = true;
			
			if(!const_void.equals(lambdaDef.returnType)){
				lambdaDef.body.setShouldBePresevedOnStack(true);
			}
		}
		
		typesReturnedCurrentFunc.push(new HashSet<Type>());
		Type got = lambdaDef.body==null?null:(Type)lambdaDef.body.accept(this);
		HashSet<Type> retTypes = typesReturnedCurrentFunc.pop();
		
		if(lambdaDef.getShouldInferFuncType() )
		{//infer ret type! - add the one from the last statement
			retTypes.add(got);
			Type retTypeOption = inferReturnType(lambdaDef.getLine(), lambdaDef.getColumn(),retTypes);
			if(null != retTypeOption){//great, we were able to infer the type
				lambdaDef.returnType = (Type)retTypeOption.accept(this);
			}
		}
		Pair<String, String> lamDets;
		if(lambdaDef.lamDets==null){
			//if not passsed from an asyncblock... create one
			/*String fullname = this.justPackageName + "$$Lambda" + localLambdaCount++;
			fullname = fullname.replace('.', '/');
			//System.err.println("fullname lam: " +  fullname  + ":" + fakeFuncRef.getLine());
			String filename = fullname.contains("/")?fullname.substring(fullname.lastIndexOf('/')+1): fullname;
			lamDets = new Tuple<String, String> (fullname, filename);*/
			
			lamDets = createLambdaDetsObject("$$Lambda" + localLambdaCount++);
			
			lambdaDef.lamDets = lamDets;
			//System.err.println("assign lambda dets to [lam]: " + lambdaDef);
		}
		else{
			lamDets = lambdaDef.lamDets;
			localLambdaCount++;
		}
		
		fakeFuncRef.setLambdaDetails(lamDets);
		//System.err.println("set on lambda details: " +  lamDets + ":" + fakeFuncRef.getLine());
		
		FuncType retFuncType = lambdaDef.getFunctTypeIncExtraArgs();
		
		FuncLocation loc;
		if(!this.currentlyInClassDef.isEmpty()){
			//inclass
			ClassDef holder = this.currentlyInClassDef.peek();
			loc = new ClassFunctionLocation(holder.bcFullName(), new NamedType(line, col, holder));
			fakeFuncRef.operatingOn=new NamedType(line, col, holder);
		}
		else{
			//static module level
			loc = new StaticFuncLocation(new NamedType(line, col, this.moduleLevelNamedType));
		}
		
		
		
		loc.setLambdaOwner("com/concurnas/bootstrap/lang/Lambda$Function" + argcounts + (null != retAcc && retAcc.equals(ScopeAndTypeChecker.const_void)?"v":""));
		
		fakeFuncRef.typeOperatedOn = new TypeAndLocation(retFuncType, loc );
		fakeFuncRef.setTaggedType(retFuncType);
		
		ArrayList<Type> consturctorArgs = new ArrayList<Type>();
		
		//lfp = lambdaDef.getExtraCapturedLocalVars();
		if(lfp != null){
			for(FuncParam p : lfp.params){
				Type aot =(Type)p.accept(this);//p.getTaggedType()
				p.setTaggedType(aot);
				consturctorArgs.add(aot);
			}
		}
		
		fakeFuncRef.argumentsThatDontNeedToBecurriedIn = consturctorArgs;
		
		//args added in constructor
		
 		PrintSourceVisitor psv = new PrintSourceVisitor();
		psv.visit(lambdaDef);
		
		String contents = psv.toString();
		
		//System.err.println(lambdaDef.getLine() + ": contentes: " + contents + "\n----------------\n");
		
		if(null == lambdaDef.methodName){
			lambdaDef.methodName = generateLambdaName(contents);// this.packageAndClassName + "$$LambdaInner" + localLambdaInnerCount++;
		}else{
			lambdaNames.add(lambdaDef.methodName);
		}
			//problems
		
		fakeFuncRef.methodName = lambdaDef.methodName;
		
		lambdaDef.fakeFuncRef = fakeFuncRef;
		this.currentlyInFuncDef.pop();
		this.returnTypeExpected.pop();
		this.currentlyInRet.pop();
		
		FuncType retFuncTypeToReturn = lambdaDef.getFunctType().copyTypeSpecific();//do some stuff to this?
		
		if(retFuncTypeToReturn.retType.getInOutGenModifier() != null){
			retFuncTypeToReturn.retType.setInOutGenModifier(null);
		}
		
		retFuncTypeToReturn.setLambdaDetails(fakeFuncRef.typeOperatedOn);
		
		lambdaDef.setTaggedType(retFuncTypeToReturn);
		this.level--;
		
		if(lambdaDef.implementSAM != null) {
			/*retFuncTypeToReturn.retType= TypeCheckUtils.boxTypeIfPrimative(retFuncTypeToReturn.retType, false);
			retFuncType.retType= TypeCheckUtils.boxTypeIfPrimative(retFuncType.retType, false);
			lambdaDef.returnType = TypeCheckUtils.boxTypeIfPrimative(lambdaDef.returnType, false);*/
			retFuncTypeToReturn.implementSAM = lambdaDef.implementSAM;
		}
		
		if(!lambdaDef.omitAnonLambdaSources && null == retFuncTypeToReturn.anonLambdaSources) {
			retFuncTypeToReturn.anonLambdaSources = new ArrayList<AnonLambdaDefOrLambdaDef>();//bit of a hack
			retFuncTypeToReturn.anonLambdaSources.add(lambdaDef);
		}else {
			retFuncTypeToReturn.anonLambdaSources = null;
		}
		
		return retFuncTypeToReturn;
		
	}
	
	private Stack<HashMap<String, String>> lambContentsInModStack = new Stack<HashMap<String, String>>();
	
	private HashSet<String> lambdaNames = new HashSet<String>();
	private static long lambdaNamescnt = 0;
	
	private String generateLambdaName(String contents){
		HashMap<String, String> lambContentsInMod = lambContentsInModStack.peek();
		String got = lambContentsInMod.get(contents);
		if(null == got){
			got = this.packageName.peek() + "$$LambdaInner" + lambdaNames.size() + "$$" + lambdaNamescnt++;
			got = got.replace('.', '/');
			lambContentsInMod.put(contents, got);			
			lambdaNames.add(got);
		}
		
		return got;
	}
	
/*	private int lambdaNames = 0;
	
	private String generateLambdaName(String contents){
		HashMap<String, String> lambContentsInMod = lambContentsInModStack.peek();
		String got = lambContentsInMod.get(contents);
		if(null == got){
			got = this.packageAndClassName + "$$LambdaInner" + lambdaNames++;//localLambdaInnerCount++;
			lambContentsInMod.put(contents, got);			
			//lambdaNames.add(got);
		}
		
		return got;
	}*/
	
	
	private FuncInvoke canBeAFuncInvoke(int line, int col, Expression leExpression, FuncInvokeArgs args){
		
		/*if(leExpression instanceof RefNamedType){
			ArrayRef astRedirectToArrayRef =  ((RefNamedType)leExpression).astRedirectToArrayRef;
			if(null != astRedirectToArrayRef){
				leExpression = astRedirectToArrayRef;
			}
		}
		*/
		if(leExpression instanceof ArrayRef){

			ArrayRef asAref = (ArrayRef)leExpression;
			
			if(asAref.couldBeGenericMethodParams()){//i.e. only one
				PrintSourceVisitor psv = new PrintSourceVisitor();
				psv.processArrayRefElements(asAref.arrayLevelElements);
				ArrayList<Type> genTypes = Utils.parseGenTypeList(""+psv);
				if(null != genTypes && !genTypes.isEmpty()){//ensure the types are parseable, if so then we might have a match, 
					maskErrors();
					
					//ensure we are considering ourselves not within the dot operator
					dotOperatorLHS.push(null);
					this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
					for(Type g : genTypes){ g.accept(this);}
					dotOperatorLHS.pop();
					this.currentDotOperatorTracker.pop();
					
					if(!maskedErrors()){
						//no errors so this is looking hopefull... Now see if this makes sense translated into a   
						FuncInvoke asFuncInvoke = new FuncInvoke(line, col,  ((RefName)asAref.expr).name, args, genTypes);
						maskErrors();
						
						asFuncInvoke.accept(this);
						
						if(!maskedErrors()){//ok we have a perfect mathc!
							//redirect and process for real
							return asFuncInvoke;
						}
						
					}
				}
			}
			
		}
		return null;
	}
	
	/*private ArrayList<Type> canBeFuncRef(Expression leExpression){//e.g. thing = myGen[String]&("hi there", kid);
		
		if(leExpression instanceof RefNamedType){
			ArrayRef astRedirectToArrayRef =  ((RefNamedType)leExpression).astRedirectToArrayRef;
			if(null != astRedirectToArrayRef){
				leExpression = astRedirectToArrayRef;
			}
		}
		
		if(leExpression instanceof ArrayRef){
			ArrayRef asAref = (ArrayRef)leExpression;
			
			if(asAref.couldBeGenericMethodParams()){//i.e. only one
				PrintSourceVisitor psv = new PrintSourceVisitor();
				psv.processArrayRefElements(asAref);
				ArrayList<Type> genTypes = Utils.parseGenTypeList(""+psv);
				if(null != genTypes && !genTypes.isEmpty()){//ensure the types are parseable, if so then we might have a match, 
					maskErrors();
					
					//ensure we are considering ourselves not within the dot operator
					dotOperatorLHS.push(null);
					for(Type g : genTypes){ g.accept(this);}
					dotOperatorLHS.pop();
					
					if(!maskedErorrs()){
						//no errors so this is looking hopefull... Now see if this makes sense translated into a   
						return genTypes;
					}
				}
			}
			
		}
		return null;
	}*/
	
	public Object visit(NamedConstructorRef namedConstructorRef) {
		//namedConstructorRef.
		if(null == namedConstructorRef.funcRef){
			namedConstructorRef.funcRef = new FuncRef(namedConstructorRef.getLine(), namedConstructorRef.getColumn(), namedConstructorRef.namedConstructor, namedConstructorRef.argz);
		}
		
		if(namedConstructorRef.funcRef.hasVectorizedRedirect()) {
			return namedConstructorRef.funcRef.vectorizedRedirect.accept(this);
		}
		
		return visit(namedConstructorRef.funcRef, true);
		
	}
	
	private boolean firstArgIsHiddenActorClassArray(List<Object> items){
		if(!items.isEmpty()){
			Node first = (Node)items.get(0);
			if(first.notes != null && first.notes.contains("firstArgIsHiddenActorClassArray")){
				return true;
			}
		}
		
		return false;
	}
	
	private boolean isArgFuncion0OrSAM(Type lhsType) {
		Type got = TypeCheckUtils.convertfuncTypetoNamedType(lhsType, null);
		if(got instanceof NamedType) {
			NamedType lhsNT = (NamedType)got;
			if(TypeCheckUtils.isFunction0(ers, lhsNT)) {
				return true;
			}
			
			if(lhsNT.isInterface()) {//perhaps it's a SAM function?
				List<Pair<String, TypeAndLocation>> methods = lhsNT.getAllLocallyDefinedMethods(this, true, false);
				if(methods.size() == 1) {
					return true;
				}
			}
		}
		return false;
	}
	
	@Override
	public Object visit(FuncRef funcRef) {
		return visit(funcRef, false);
	}
	
	private Object visit(FuncRef funcRef, boolean forceConstructor) {//ar.get&(int)
		int line = funcRef.getLine();
		int col =  funcRef.getColumn();
		
		maskErrors();
		funcRef.functo.setPreceedingExpression(funcRef);

		funcRef.astRedirectnewOperatorOverloaded = null;
		if(funcRef.functo instanceof New){
			New asNew = (New)funcRef.functo;
			
			FuncInvokeArgs fia = new FuncInvokeArgs(0,0);
			
			if(funcRef.args != null){
				for(Object exprOrType : funcRef.args.exprOrTypeArgsList){
					if(exprOrType instanceof Type){
						fia.add(new TypeReturningExpression((Type)exprOrType));
					}else{
						fia.add((Expression)exprOrType);
					}
				}
				
				if(funcRef.args.nameMap != null){
					
					ArrayList<Pair<String, Object>> newNameMap = new ArrayList<Pair<String, Object>>();
					
					for(Pair<String, Object> item : funcRef.args.nameMap){
						String key = item.getA();
						Object exprOrType = item.getB();
						if(exprOrType instanceof Type){
							newNameMap.add(new Pair<String, Object>(key, new TypeReturningExpression((Type)exprOrType)));
						}else{
							newNameMap.add(new Pair<String, Object>(key, (Expression)exprOrType));
						}
					}
					
					fia.nameMap = newNameMap;
				}
			}
			
			
			FuncInvokeArgs preFIA = asNew.args;
			asNew.args = fia;
			asNew.calledInFuncRef=true;
			asNew.accept(this);
			asNew.args = preFIA;
			boolean astRedirectToClassloader = asNew.astRedirect != null && asNew.astRedirect instanceof DotOperator;
			if(asNew.newOpOverloaded != null || astRedirectToClassloader){//directed to operator overloader, so redirect this funcRef as well!
				//what = mp.new MyGenClass&("77", _ String) => mp.new&('MyGenClass', "77", _ String)
				
				if(funcRef.args == null){
					maskedErrors();
					this.raiseError(line, col, String.format("Operator overloading of new cannot produce a class reference"));
					return null;
				}else if(asNew.newOpOverloaded != null){
					FuncRefArgs base = (FuncRefArgs)funcRef.args.copy();
					base.exprOrTypeArgsList.add(0, asNew.newOpOverloaded.args.asnames.get(0).copy());
					FuncRef fropov = new FuncRef(line, col, new RefName(line, col,"new"), base);
					fropov.lhsHasNewOPOVerload = true;
					funcRef.astRedirectnewOperatorOverloaded = fropov;
					//FuncRef(int line, int col, Expression functo, FuncRefArgs args)
				}else{
					FuncRefArgs base = (FuncRefArgs)funcRef.args.copy();//PIONTE
					DotOperator asDot = (DotOperator)asNew.astRedirect;
					ArrayList<Expression> elements = asDot.getElements(this);
					ArrayList<Expression> newelements = new ArrayList<Expression>();
					
					newelements.add(elements.get(0));
					newelements.add(elements.get(1));
					newelements.add(new FuncRef(line, col, new RefName(line, col, "newInstance"), base));
					
					DotOperator newDop = new DotOperator(line, col, newelements);
					
					funcRef.astRedirectnewOperatorOverloaded = newDop;
				}
				maskedErrors();
				return funcRef.astRedirectnewOperatorOverloaded.accept(this);
			}
		}
		else{
			funcRef.functo.accept(this);
		}
		
		maskedErrors();
		Node functoThing = (Node)funcRef.functo;//.accept(this);
		/*if(functoThing instanceof RefName && ((RefName) functoThing).astRedirect != null){
			functoThing = ((RefName) functoThing).astRedirect;
		}*/
		ArrayList<Type> genTypes=null;
		//NamedType namedTypeForconstructor = null;F
		if(functoThing == null)
		{
			//this.raiseError(--, --, "Unable to find reference Function Type"); <-must already been reported as error
			return null;
		} 
		else if(functoThing instanceof RefQualifiedGenericNamedType || functoThing instanceof New){
			NamedType ttn=null;
			if(functoThing instanceof RefQualifiedGenericNamedType){
				RefQualifiedGenericNamedType asRefQ = ((RefQualifiedGenericNamedType)functoThing);
				//namedTypeForconstructor = asRefQ.mynamed;
				ttn = asRefQ.mynamed;
				line = asRefQ.getLine();
				col = asRefQ.getColumn();
			}
			else{
				New asNamedCon = (New)functoThing;
				Type tt = asNamedCon.getTaggedType();
				
				if(asNamedCon.vectroizedDegreeAndArgs != null) {
					tt = TypeCheckUtils.extractVectType(tt);
				}
				
				if(tt instanceof NamedType){
					ttn = (NamedType)tt;
				}
				line = asNamedCon.getLine();
				col = asNamedCon.getColumn();
			}
			
			if(null != ttn){
				ClassDef cd = ttn.getSetClassDef();
				functoThing = new RefName(line, col, cd != null && cd.isLocalClass? cd.className: ttn.getNamedTypeStr());
				
				List<Type> defgenTypes = ttn.getGenTypes();// 
				
				genTypes = new ArrayList<Type>(defgenTypes.size());
				for(Type g : defgenTypes){
					this.dotOperatorLHS.push(null);
					this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
					Type j =TypeCheckUtils.boxTypeIfPrimative((Type)g.accept(this), false);
					if(j instanceof GenericType){
						GenericType asGj = ((GenericType) j).copyTypeSpecific();
						asGj.splicedIn=true;
						j=asGj;
					}
					
					genTypes.add(j);
					this.dotOperatorLHS.pop();
					this.currentDotOperatorTracker.pop();
				}
			}
		}
		
		funcRef.functoFoBC = functoThing;
				
		ArrayList<Type> wantedArguments = new ArrayList<Type>();
		
		FuncRefArgs argsForScopeAndTypeCheck = funcRef.getArgsForScopeAndTypeCheck();
		
		boolean noArgs = argsForScopeAndTypeCheck == null;
		boolean orignoArgs = argsForScopeAndTypeCheck == null;
		

		if(!noArgs){
			int n=0;
			HashMap<Integer, Node> replaceArg = new HashMap<Integer, Node>();
			HashMap<Integer, Node> replaceArgMap = new HashMap<Integer, Node>();
			for(Object itema : argsForScopeAndTypeCheck.exprOrTypeArgsList)
			{
				Node item = (Node)itema;
				this.dotOperatorLHS.push(null);
				this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
				Type iType = null;

				item = isNodeReallyAUnderscoreType(item, replaceArg, n);
						
				if(item instanceof Type){
					iType = (Type)item;
					
				}//ignore expressions otherwise...
				else{
					Expression eType = (Expression)item;
					iType = (Type)eType.accept(this);
				}
				//TypeCheckUtils.assertRefIsGettable(this, item.getLine(), item.getColumn(), iType);
				wantedArguments.add(iType);
				this.dotOperatorLHS.pop();
				this.currentDotOperatorTracker.pop();
				n++;
			}
			
			if(!replaceArg.isEmpty()){
				for(Integer argNo : replaceArg.keySet()){
					argsForScopeAndTypeCheck.exprOrTypeArgsList.set(argNo, replaceArg.get(argNo));
				}
			}
			//now check the named params...
			n=0;
			for(Pair<String, Object> entry : argsForScopeAndTypeCheck.nameMap){
				Object resolvesTo = entry.getB();
				if(resolvesTo instanceof Node){
					Node asNode = (Node)resolvesTo;
					this.dotOperatorLHS.push(null);
					this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));

					asNode = isNodeReallyAUnderscoreType(asNode, replaceArgMap, n);

					this.dotOperatorLHS.pop();
					this.currentDotOperatorTracker.pop();
				}
				n++;
			}
			
			if(!replaceArgMap.isEmpty()){
				for(Integer argNo : replaceArgMap.keySet()){
					Pair<String, Object> entry = argsForScopeAndTypeCheck.nameMap.get(argNo);
					argsForScopeAndTypeCheck.nameMap.set(argNo, new Pair<String, Object>(entry.getA(), replaceArgMap.get(argNo)));
				}
			}
			
		}
		
		ArrayList<Pair<String, Type>> namesMapType = getNameMap(/*funcRef.argsForNextCompCycle != null? funcRef.argsForNextCompCycle:*/funcRef.args);
		
		
		
		Set<FuncType> choicesBeingCurreid = new HashSet<FuncType>();
		HashMap<FuncType, NamedType> ftToOrigonalRef = new HashMap<FuncType, NamedType>();
		
		HashMap<FuncType, TypeAndLocation> funcTypeToTAL = new HashMap<FuncType, TypeAndLocation>();
		
		String simpleName = null;
		
		//Map<Type, Type> paramToType = null
		
		List<Object> exprArgs = noArgs?null:new ArrayList<Object>( funcRef.args.exprOrTypeArgsList);
		
		if(functoThing instanceof RefName || functoThing instanceof New){
			RefName funcAlready=null;
			if(functoThing instanceof New){
				simpleName = ((New)functoThing).typeee.toString();
			}
			else{
				funcAlready = (RefName)functoThing;//oh u may already be in dot context!
				simpleName = funcAlready.name;
			}
			
			//Tuple<HashSet<TypeAndLocation>,Boolean> funsAndBool = forceConstructor?null:getMatchingFuncNames(null,this, funcAlready.name, funcRef.functo.getLine(), funcRef.functo.getColumn(), false, false, wantedArguments);

			//visit fellas
			
			FuncInvoke fakeFuncInvoke=null;
			if(!forceConstructor && null != argsForScopeAndTypeCheck){
				FuncInvokeArgs fia = new FuncInvokeArgs(funcRef.getLine(), funcRef.getColumn());
				for(Object itema : argsForScopeAndTypeCheck.exprOrTypeArgsList){
					Node item = (Node)itema;
					if(item instanceof Type){
						fia.add(new TypeReturningExpression( (Type)item));
						
					}//ignore expressions otherwise...
					else{
						fia.add((Expression)item);
					}
				}
				
				fakeFuncInvoke = new FuncInvoke(funcRef.getLine(), funcRef.getColumn(), funcAlready.name, fia, genTypes);
			}
			
			Pair<String, MatchingFunction> findIncActor = forceConstructor?null:findAndRedirectFunctionToActee(funcAlready.name, noArgs?null:new ArrayList<Type>(wantedArguments), namesMapType, fakeFuncInvoke, funcRef.functo.getLine(), funcRef.functo.getColumn(), false, false);
			
			HashSet<TypeAndLocation> theFunc = new HashSet<TypeAndLocation>();
			boolean isConstructor;
			if(null != findIncActor){
				String namRedirect = findIncActor.getA();
				if(namRedirect != null){//redirection occured
					funcAlready.name = namRedirect;
				}
				
				MatchingFunction x = findIncActor.getB();
				TypeAndLocation tal = x.getB();
				if(null != tal){
					theFunc.add(tal);	
				}
				isConstructor = x.getC();
			}
			else{
				isConstructor=true;//forced
			}
			
			if(theFunc.isEmpty()){
				//maybe actor call...
				
				if(!isConstructor){
					
					if(!this.currentlyInClassDef.isEmpty()){
						if(precceededByNothing() && currentlyInClassDef.peek().isActor ){
							//see if we can find the thing as: of.theOrigCall();
							//and not prefixed already
							this.maskErrors();
							
							funcRef.setPreceedingExpression(null);//black this to avoid infinite copy
							funcRef.functo.setPreceedingExpression(null);
							DotOperator prefixedWithFor = DotOperator.buildDotOperator(line, col, new RefOf(line, col), (FuncRef)funcRef.copy());
							
							Type resolves = (Type)prefixedWithFor.accept(this);
									
							if(!this.maskedErrors()){//it worked!
								funcRef.astRedirect = prefixedWithFor;
								return resolves;
							}
							funcRef.functo.setPreceedingExpression(funcRef);//reset this
						}
					}
					//maybe its an invoke call, b&()//where b is a refname having a method: invoke
					
					{
						//see if this resolves to a namedType with invoke overloaded
						//we call this second after conventional look to avoid cases where someone has declared a lambda field called invoke. e.g class X{invoke = def() = "hi";} etc
						this.maskErrors();
						RefName rn = new RefName(0,0, simpleName);
						rn.setPreceedingExpression(funcRef);
						Type nameTo = (Type)rn.accept(this);
						nameTo = TypeCheckUtils.getRefTypeToLocked(nameTo);
						//String findOpErr="";
						if(nameTo instanceof NamedType && rn.resolvesTo != null && rn.resolvesTo.getLocation() != null){//resolves to a field not a constructor type
							//int line = funcRef.getLine();
							int column = funcRef.getColumn();
							//m = MYClass() <- we dont want this, but m(), <- this we want
							//FuncInvokeArgs argsz = new FuncInvokeArgs();
							FuncInvoke overloaded = canBeOperatorOverloaded(nameTo, wantedArguments, funcRef.args, "invoke", new ArrayList<Expression>(), line, column, false, null, false, funcRef.astOverrideOperatorOverload);
							if(null != overloaded){
								FuncRef xx = new FuncRef(line, column, new RefName(0,0, overloaded.funName), funcRef.args);
								funcRef.astOverrideOperatorOverload = DotOperator.buildDotOperator(line, column, rn, xx);
								this.maskedErrors();
								return (Type)funcRef.astOverrideOperatorOverload.accept(this);
							}
							//findOpErr = makeMissingOpOverLoadMessage("invoke", nameTo, wantedArguments, null);
						}
						this.maskedErrors();
					}
					
				}
				
				//maybe constructor...
				maskErrors();
				
				NamedType asNamed = ((forceConstructor || isConstructor ) && (functoThing instanceof New))? (NamedType)((New)functoThing).typeee : new NamedType(0, 0, funcAlready.name);
				asNamed.accept(this);
				ClassDef got = asNamed.getSetClassDef();
				
				if(got != null){
					
					boolean funcRefToActor = false;
					boolean actingonactorCon = (forceConstructor || isConstructor ) && null != TypeCheckUtils.checkSubType(this.ers, const_actor, asNamed, 0, 0, 0, 0);
					if(!noArgs && actingonactorCon){
						funcRefToActor=true;
						
						if(!firstArgIsHiddenActorClassArray(exprArgs)){
							ArrayDef ad = new ArrayDef(line, col, new RefClass(line, col, const_object));
							ad.isArray=true;
							if(ad.notes == null){
								ad.notes = new HashSet<String>();
								ad.notes.add("firstArgIsHiddenActorClassArray");
							}
							//argsForNextCompCycle.exprOrTypeArgsList.add(0,ad);
							exprArgs.add(0,ad);
							wantedArguments.add(0, (Type)ad.accept(this));
						}
					}
					
					HashSet<FuncType> fts = got.getAllConstructors();
					
					if(!fts.isEmpty()){//TODO: could this ever be empty? - object with no constructors?
						HashSet<TypeAndLocation> items = new HashSet<TypeAndLocation>();
						StaticFuncLocation sfl = new StaticFuncLocation(asNamed);
						
						boolean gensDefined = null != genTypes && !genTypes.isEmpty();
						
						Map<Type, Type> paramToType = new HashMap<Type, Type>();
						if(gensDefined){
							asNamed.setGenTypes(genTypes);
							paramToType = TypeCheckUtils.extractGenericBindings(asNamed);
						}
						
						if(funcRefToActor){
							funcRef.replaceFirstArgWithTypeArraOf = asNamed;
						}
						
						
						if(actingonactorCon && noArgs && fts.size() == 1){//sneak in first argument when none specified for xxx = actor Thingy& can only do on one match
							funcRefToActor=true;//copy paste o matic
							
							//argsForNextCompCycle.exprOrTypeArgsList.add(0,ad);
							FuncType ft = fts.iterator().next();
							ArrayList<Type> inputs = ft.getInputs();
							int sz = inputs.size();
							
							exprArgs = new ArrayList<Object>(sz);
							
							if(!firstArgIsHiddenActorClassArray(exprArgs)){
								ArrayDef ad = new ArrayDef(line, col, new RefClass(line, col, const_object));
								ad.isArray=true;
								if(ad.notes == null){
									ad.notes = new HashSet<String>();
									ad.notes.add("firstArgIsHiddenActorClassArray");
								}
								exprArgs.add(ad);
								wantedArguments.add((Type)ad.accept(this));
							}
							
							
							argsForScopeAndTypeCheck = new FuncRefArgs(line, col);
							for(int n=1; n < sz; n++){
								Type tt = inputs.get(n);
								exprArgs.add(tt);
								wantedArguments.add(tt);
							}
							noArgs=false;
							//funcRef.setArgsForScopeAndTypeCheck(argsForScopeAndTypeCheck);
						}

						
						
						
						for(FuncType ft : fts){
							ft = (FuncType)ft.copy();
							ft.retType = asNamed;//const_void;
							if(gensDefined){
								ft = (FuncType) GenericTypeUtils.mapFuncTypeGenericsToOtherGenerics(ft, paramToType, false);
							}
							else{//infer generics with a little help from those already deinfed
								//asNamed.hasGenTypes()
								//extract existing bindings
								Map<Type, Type> paramToTypex = new HashMap<Type, Type>(paramToType);
								
								List<Type> mappedArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, ft, wantedArguments, namesMapType,0, true, false);//mapping is specific to each instance
								
								paramToTypex.putAll(TypeCheckUtils.attemptGenericBinding(this.ers, ft.inputs, TypeCheckUtils.boxTypeIfPrimative(mappedArgs, false) ));
								ft = (FuncType) GenericTypeUtils.mapFuncTypeGenericsToOtherGenerics(ft, paramToTypex, false);
							}
							items.add(new TypeAndLocation(ft, sfl));
						}
						
						theFunc = items;
						isConstructor = true;
						if(funcRef.functo instanceof RefName && got.isLocalClass){
							got.callingfuncRefsAsRefNames.add((RefName)funcRef.functo);
						}
						
					}
				}
				
				maskedErrors();
			}
			
			//we need to find a way to bind the arguments....
			//findMatchingFunction(name,  argsWanted, funcInvoke.getLine(), funcInvoke.getColumn(), funcInvoke.genTypes);
			
			HashSet<TypeAndLocation> matchingNames = theFunc;
			funcRef.isConstructor= isConstructor;

			if(!funcRef.isConstructor && (matchingNames==null || matchingNames.isEmpty() ) ){
				//might be an actor call, so redirect....
				
				NamedType lhsOpOnType = null;
				if(!this.dotOperatorLHS.isEmpty()){
					Type top = this.dotOperatorLHS.peek();
					if(top instanceof NamedType){
						lhsOpOnType = (NamedType)top;
					}
				} 
				
				boolean shouldIgnoreGenerics = noArgs?false:wantedArguments.stream().anyMatch(a -> a instanceof NamedType && ((NamedType)a).requiresGenTypeInference)
						|| namesMapType.stream().anyMatch(a -> a.getB() instanceof NamedType && ((NamedType)a.getB()).requiresGenTypeInference)
						|| (null != lhsOpOnType && lhsOpOnType.requiresGenTypeInference);
				Pair<String, MatchingFunction> mostSpecificTAL = findAndRedirectFunctionToActee(funcAlready.name, noArgs?null:wantedArguments, namesMapType, null, funcRef.functo.getLine(), funcRef.functo.getColumn(), true, shouldIgnoreGenerics);
				
				String namRedirect = mostSpecificTAL.getA();
				if(namRedirect != null){//redirection occured
					MatchingFunction x = mostSpecificTAL.getB();
					matchingNames = matchingNames==null?new HashSet<TypeAndLocation>():matchingNames;
					matchingNames.add(x.getB());//nice, this function will find one for us
					funcAlready.name = namRedirect;
				}else if(shouldIgnoreGenerics) {
					TypeAndLocation nextBest = mostSpecificTAL.getB().getNextBest();
					if(null != nextBest ) {
						//matchingNames = matchingNames==null?new HashSet<TypeAndLocation>():matchingNames;
						//matchingNames.add(nextBest);
						funcRef.typeOperatedOn = nextBest;
						
						if(!namesMapType.isEmpty()) {
							ArrayList<Pair<String, Object>> namessMapExpr = getNameMapObj(funcRef.args);
							FuncType beingC = (FuncType)nextBest.getType();
							List<Object> mappedArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, beingC, exprArgs, namessMapExpr, 0, false, false);//should be false
							//check all mapped
							if(mappedArgs != exprArgs){//changes made?
								exprArgs = mappedArgs;
								funcRef.args.exprOrTypeArgsList=exprArgs;
								funcRef.args.nameMap = new ArrayList<Pair<String, Object>>(); 
							}
						}
					}
				}
			}
			
			//the algorithm in this space needs to be much more clever
			
			boolean hasThingToBeAccepted = false;
			
			if(null != matchingNames){
				for(TypeAndLocation item : matchingNames ){//TODO: generic tests here should not be done for all
					Type tr = item.getType();
					
					FuncType checkGenson;
					
					FuncType ft;
					if(TypeCheckUtils.hasRefLevels(tr)){
						ft = (FuncType)TypeCheckUtils.getRefType(tr);
						checkGenson = ft.copyTypeSpecific();
						//item.setType(ft);
						//item = item.copy();
						//item.setType(ft);
						ft = applyLocalGenerics(line, col, ft, genTypes, wantedArguments);
						ftToOrigonalRef.put(ft, (NamedType)tr);
					}
					else{
						ft = (FuncType)tr;
						checkGenson = ft.copyTypeSpecific();
						/*if(funcRef.isConstructor && null != namedTypeForconstructor){
							ft.retType = namedTypeForconstructor;
						}*/
						
						ft = applyLocalGenerics(line, col, ft, genTypes, wantedArguments);
						tr = applyLocalGenerics(line, col, (FuncType)tr, genTypes, wantedArguments);
					}
					
					if(null != checkGenson.origonatingFuncDef){
						checkGenson = checkGenson.origonatingFuncDef.getFuncType();//swip back in the generic types if there are any...
					}
					else if(checkGenson.getLambdaDetails() != null){
						Type got = checkGenson.getLambdaDetails().getType();
						if(got instanceof FuncType){
							checkGenson = (FuncType)got;
						}
					}
					
					String name = funcAlready==null? "<init>" : funcAlready.name;
					if(!funcRef.isConstructor){//ignore this check for constructors which cannot define local generics
						int genCnt = genTypes==null?0: genTypes.size();
						if(genCnt>0){
							int localGensExpected = checkGenson.getLocalGenerics() != null?checkGenson.getLocalGenerics().size():0;
							if( localGensExpected != genCnt){
								this.raiseError(funcRef.getLine(), funcRef.getColumn(), String.format("Incorrect number of generic types passed for reference: %s. Expected %s got %s", name, localGensExpected, genCnt));
							}
						}
					}

					if(ft==null){
						continue;
					}
					
					//class level generics
					
					List<RefNamedType> refsToQualify = refNamedTypeToQuantify();
					
					if((wantedArguments != null && !wantedArguments.isEmpty()) /*|| !paramToTypex.isEmpty()*/ ){
						//bind any missing generic params to be infered - e.g. those defined on a non local basis	
						Map<Type, Type> paramToType = TypeCheckUtils.attemptGenericBinding(this.ers, ft.inputs, TypeCheckUtils.boxTypeIfPrimative(wantedArguments, false) );
						
						for(Type k : paramToType.keySet()){
							Type v = paramToType.get(k);
							if(v instanceof GenericType){
								//replace the generic type with one containing the clone information we set here
								GenericType asGen = (GenericType)v;
								if(!asGen.splicedIn){//avoid doing this twice
									GenericType cloned = asGen.copyTypeSpecific();
									cloned.splicedIn = true;
									paramToType.put(k, cloned);
								}
							}
						}
						
						tr = (FuncType) GenericTypeUtils.mapFuncTypeGenericsToOtherGenerics(tr, paramToType, false);
						ft = (FuncType) GenericTypeUtils.mapFuncTypeGenericsToOtherGenerics(ft, paramToType, false);
						
						//quantify parent class using the defined map
						if(!refsToQualify.isEmpty()){
							for(RefNamedType refNamedTyppe : refsToQualify){
								NamedType toQuantify = refNamedTyppe.mynamed;
								ClassDef resolvedTo= toQuantify.getSetClassDef();
								if(null != resolvedTo){
									ArrayList<GenericType> requiredGens = resolvedTo.getClassGenricList();
									ArrayList<Type> foundGens = new ArrayList<Type>(requiredGens.size());
									for(GenericType gt : requiredGens){
										Type resolvesTo = paramToType.get(gt);
										if(null != resolvesTo){
											foundGens.add(resolvesTo);
										}
									}
									if(requiredGens.size() == foundGens.size()){//not all items matched -> fail setting
										toQuantify.setGenTypes(foundGens);
									}
								}
							}
						}
					}
						
					//we map generics here? same as other code...
					{
						Location loc = item.getLocation();//set origin here such that bytcecode gen knows to call arg on superclass IF RELEVANT...
						if(loc  instanceof FuncLocation){
							ft.origin = ((NamedType)((FuncLocation)loc).getOwnerType()).getSetClassDef();
						}
						
						if((ft.getLocalGenerics() != null && !ft.getLocalGenerics().isEmpty()) || funcRef.isConstructor){
							//find missing generics - raise error if unqualified, note this only applies for methods with local generics or constructors
							Set<GenericType> unbounded = TypeCheckUtils.findUnboundedGenerics(ft);
							if( !unbounded.isEmpty()){
								for(GenericType u : unbounded.toArray(new GenericType[0])){
									if(u.splicedIn){
										unbounded.remove(u);
									}//break;//at least one not spliced in, so we can abandon this attempt completly - dont do this cos u want all missing ones listed below, no false positives
								}
							}
							
							//filter to only include locally defined
							Set<GenericType> unboundedfilt = new HashSet<GenericType>();
							for(GenericType itemx : unbounded){
								if(ft.getLocalGenerics() == null || ft.getLocalGenerics().contains(itemx)){
									unboundedfilt.add(itemx);
								}
							}
								
							if(!unboundedfilt.isEmpty()){//check to ensure that all generic types are bound
								if(loc instanceof StaticFuncLocation){//all types must be paramerterized, so this is an auto fail
									this.raiseError(funcRef.getLine(), funcRef.getColumn(), String.format("Missing generic binding for: %s on module method: %s", Utils.sortAndJoinSet(unboundedfilt), name));
								}
								else{//should all be defined
									this.raiseError(funcRef.getLine(), funcRef.getColumn(), String.format("Missing generic binding for: %s on method: %s", Utils.sortAndJoinSet(unboundedfilt), name));
								}
								//if on class, then all those defined on class must be defined... - parent ones can be escluded
							}
						}
					}
					
					Type orig = item.getType();
					if(orig instanceof FuncType) {
						FuncType asFT = (FuncType)orig;
						if(asFT.hasBeenVectorized != null) {
							ft.hasBeenVectorized = asFT.hasBeenVectorized;
						}
					}
					
					choicesBeingCurreid.add(ft);
					//funcTypeToTAL.put(ft, item );
					if(null != ft.retType){//JPT: ugly
						ft.retType.setInOutGenModifier(null);
					}
					funcTypeToTAL.put(ft, new TypeAndLocation(tr, item.getLocation()) );
					Location locc = item.getLocation();
					if(!hasThingToBeAccepted  && (locc instanceof LocationStaticField || locc instanceof LocationClassField)){
						hasThingToBeAccepted=true;
					}
					
				}
			}
			
			if(hasThingToBeAccepted){//only accept if this leads to a static field
				functoThing.accept(this);
			}
			
			funcRef.methodName = funcAlready==null? "<init>" : funcAlready.name;
		}
		else
		{//TODO: what about... this.x, //super.x
			Type gota = (Type)functoThing.accept(this);
			
			if(!(gota instanceof FuncType)){
				this.raiseError(funcRef.functo.getLine(), funcRef.functo.getColumn(), "Can only make function reference on function reference not: " + gota);
				return null;
			}
			
			FuncType ft = (FuncType)gota;
			if(null != ft){
				//funcTypeToTAL.put(ft, ((FuncRef)functoThing).typeOperatedOn );
				//TODO: next part of code is wrong/redundant???
				//ft.origin = ((NamedType)((FuncLocation)ft.getLambdaDetails().getLocation()).getOwnerType()).getSetClassDef();
				//ft.origin = new ClassDefJava(Object.class);
				//ft.origin = new 
				TypeAndLocation gotTal = ft.getLambdaDetails();
				if(null != gotTal){
					Location gotLoc = gotTal.getLocation();
					LocationLocalVar loc = new LocationLocalVar(this.currentScopeFrame);
					loc.setLambda(gotLoc.isLambda());
					loc.setLambdaOwner(gotLoc.getLambdaOwner());
					
					//funcTypeToTAL.put(ft, new TypeAndLocation(gotTal.getType(), loc));
					
					if(null != ft.retType){//JPT: ugly
						ft.retType.setInOutGenModifier(null);
					}
					
					funcTypeToTAL.put(ft, new TypeAndLocation(ft, loc));
					

					
					
					choicesBeingCurreid.add(ft);
				}
				
			}
			funcRef.methodName = "apply";
			
		}
		
		if(choicesBeingCurreid.isEmpty())
		{
			this.raiseError(funcRef.functo.getLine(), funcRef.functo.getColumn(), "Unable to find reference function Type for: " + funcRef.methodName);
			//fake one to clear up error reporting a bit
			return new FuncType((Type)const_object.copy());
		}
		else
		{
			Expression origFuncto = funcRef.functo;
			
			if(origFuncto instanceof New){
				Type res = origFuncto.getTaggedType();
				if(res instanceof NamedType){
					NamedType asNamed = (NamedType)res;
					ClassDef cd = asNamed.getSetClassDef();
					if(cd != null && cd.isLocalClass){
						cd.callingConstructors.add((New)funcRef.functo);
					}
				}
				
			}
			
			boolean namedConWthNotExplicitNew = origFuncto instanceof New && !((New)origFuncto).explicitNewKeywordUsed;
			if(orignoArgs && (namedConWthNotExplicitNew || origFuncto instanceof RefQualifiedGenericNamedType || origFuncto instanceof RefName) && funcRef.isConstructor){
				//e.g. xx = MyClass& -> we really want to return a ConstructorRef here not an individual methodref
				boolean atLeastOnePublic=false;
				//ensure at least one public constructor
				for(FuncType ft : choicesBeingCurreid){
					if(ft.getUnderlyingDefAccessMod() == AccessModifier.PUBLIC){
						atLeastOnePublic = true;
						break;
					}
				}
				
				NamedType resolvesTo;
				if(origFuncto instanceof RefQualifiedGenericNamedType){
					resolvesTo = ((RefQualifiedGenericNamedType)origFuncto).mynamed;
				}else if(origFuncto instanceof New){
					resolvesTo = (NamedType)((New)origFuncto).getTaggedType();//TODO: if actor tag this correctly
				}else{
					resolvesTo = (NamedType)functoThing.getTaggedType();
				}
				
				if(null == resolvesTo){
					return null;
				}

				
				if(!atLeastOnePublic){
					this.raiseError(funcRef.getLine(), funcRef.getColumn(), String.format("There musts be at least one public consturctor declared on: %s in order to create a Constructor ref" , resolvesTo  ));
				}
				

				FuncType ft = new FuncType(resolvesTo);
				ft.isClassRefType = true;
				
				Pair<String, String> lambdaDetails = funcRef.getLambdaDetails();
				
				Fourple<FuncType, ArrayList<Type>, ArrayList<Pair<Type, Integer>>, ArrayList<Pair<String, Type>> > uniqueArgs = new Fourple<FuncType, ArrayList<Type>, ArrayList<Pair<Type, Integer>>, ArrayList<Pair<String, Type>> >(ft, null, null, namesMapType);
				
				if(null == lambdaDetails){
					lambdaDetails = getLambdaDetails("", resolvesTo, funcRef.methodName , uniqueArgs);
					funcRef.setLambdaDetails(lambdaDetails);
				}
				else{//run anyway to set state as approperiate
					getLambdaDetails("", resolvesTo, funcRef.methodName , uniqueArgs);
				}
				
				String owwnerelambda = lambdaDetails.getA();//"com/concurnas/bootstrap/lang/Lambda$ClassRef";
				ClassFunctionLocation cflloc = new ClassFunctionLocation(owwnerelambda, resolvesTo, false);
				cflloc.setLambdaOwner(owwnerelambda);
				TypeAndLocation lambdaTal = new TypeAndLocation(resolvesTo, cflloc);//doesnt resolve to anything, dummy value
				
				ft.setLambdaDetails( lambdaTal);
				
				funcRef.setTaggedType(ft);
				funcRef.typeOperatedOn =lambdaTal; 
				
				return ft;
			}
			
			//funcRef.argsForNextCompCycle = argsForNextCompCycle;
			
			FuncType matchingFunctionBeingCurried = TypeCheckUtils.getMostSpecificFunctionForChoicesFT( this, this.ers, choicesBeingCurreid, noArgs?null:wantedArguments, namesMapType, simpleName==null?"Function reference call":simpleName, funcRef.getLine(), funcRef.getColumn(), false, this, false).getA();
			if(null!=matchingFunctionBeingCurried)
			{
				boolean exprArgsPreLaziesorlambda = false;
				if(!noArgs && matchingFunctionBeingCurried.inputs.stream().anyMatch(a -> null != TypeCheckUtils.checkSubType(this.ers, ScopeAndTypeChecker.getLazyNT(), a) || isArgFuncion0OrSAM(a) )) {
					
					exprArgsPreLaziesorlambda = true;
				}
				
				ArrayList<Pair<String, Object>> namessMapExpr = getNameMapObj(funcRef.args);
				List<Object> mappedArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, matchingFunctionBeingCurried, exprArgs, namessMapExpr, 0, false, false);//should be false
				//check all mapped
				if(mappedArgs != exprArgs){//changes made?
					exprArgs = mappedArgs;
					
					if(exprArgsPreLaziesorlambda) {//adjust original input args if input satifies a lazy param
						funcRef.args.exprOrTypeArgsList=exprArgs;
					}
					
				}
				
				CurriedVararg curriedVararg = Utils.tagCurriedVararg(exprArgs, this);
				if(null != curriedVararg){
					exprArgs = curriedVararg.expandedArgsIncVarargCapture;
					funcRef.curriedVararg = curriedVararg;
				}
				
				ArrayList<Type> argumentsThatNeedToBecurriedIn = new ArrayList<Type>();
				ArrayList<Type> argumentsThatDontNeedToBecurriedIn = new ArrayList<Type>();
				ArrayList<Pair<Type, Integer>> argumentsThatNeedToBecurriedInTypeAndPos = new ArrayList<Pair<Type, Integer>>();
				
				int n=0;
				//funcRef.args.accept(this);
				funcRef.argsForNextCompCycle = new FuncRefArgs(noArgs?line:argsForScopeAndTypeCheck.getLine(), noArgs?col:argsForScopeAndTypeCheck.getColumn());
				
				if(noArgs){
					for(Type a : matchingFunctionBeingCurried.inputs){
						argumentsThatNeedToBecurriedIn.add((Type)(a).copy());
						argumentsThatNeedToBecurriedInTypeAndPos.add(new Pair<Type, Integer>(a,n));
						funcRef.argsForNextCompCycle.exprOrTypeArgsList.add(a);
					}
					
				}else{
					HashSet<Integer> argsTocuryInIds = new HashSet<Integer>(argsForScopeAndTypeCheck.exprOrTypeArgsList.size());
					for(Object itema : exprArgs)
					{
						//Type wantedType = ((Node)argsWanted.get(0)).getTaggedType();
						
						Node item = (Node)itema;
						Type iType = null;

						funcRef.argsForNextCompCycle.exprOrTypeArgsList.add(item);
						if(item != null){
							Type obtained = item.getTaggedType();
							boolean isNull = item instanceof VarNull;
							if(item instanceof Type && !isNull){
								iType = (Type)item;
								argumentsThatNeedToBecurriedIn.add(iType == null?null:(Type)(iType).copy());
								argumentsThatNeedToBecurriedInTypeAndPos.add(new Pair<Type, Integer>(iType,n));
								
							}//ignore expressions otherwise...
							else
							{
								if(isNull) {
									Type wanted = matchingFunctionBeingCurried.getInputs().get(n);
									obtained = overrideVarNull(wanted, obtained, item);
								}
								
								iType = obtained;
								argumentsThatDontNeedToBecurriedIn.add(iType);
								argsTocuryInIds.add(n);
							}
							
							if(obtained != null && obtained.getNullStatus() != NullStatus.NONNULL) {
								Type wanted = matchingFunctionBeingCurried.getInputs().get(n);

								if(TypeCheckUtils.isNotNullable(wanted) && TypeCheckUtils.isNullable(obtained)) {//null check:
									this.raiseError(item.getLine(), item.getColumn(), "Argument passed to method reference can be null, but method argument type is not nullable");
								}else if( TypeCheckUtils.isUnknown(obtained)  &&  TypeCheckUtils.isNoNull(wanted) ) {//applies to to be curried in only?
									obtained.setNullStatus(wanted.getNullStatus());//MHA
								}
							}
						}
						
						//TypeCheckUtils.assertRefIsGettable(this, item.getLine(), item.getColumn(), iType);
						n++;
					}
					
					//we found the uc, now ensure that the types to not curry in are correct
					int m=0;
					for(Type a : matchingFunctionBeingCurried.inputs){
						if(argsTocuryInIds.contains(m)){
							if(!TypeCheckUtils.hasRefLevels(a) && TypeCheckUtils.hasRefLevels(argumentsThatDontNeedToBecurriedIn.get(m))){
								argumentsThatDontNeedToBecurriedIn.set(m, a);
							}
							m++;
						}
					}
				}
				
				
								
				//key on:
				//functype, list of tuple<typecurryed in index> 
				FuncType ft = new FuncType(Utils.removeGenericUpperBounds(argumentsThatNeedToBecurriedIn), Utils.removeGenericUpperBounds(matchingFunctionBeingCurried.retType));


				if(matchingFunctionBeingCurried.hasBeenVectorized != null){
					funcRef.vectroizedDegreeAndArgs = matchingFunctionBeingCurried.hasBeenVectorized;
					
					ArrayList<Pair<Boolean, NullStatus>> vectStruct =  matchingFunctionBeingCurried.hasBeenVectorized.getA();
					Type newRetft = TypeCheckUtils.applyVectStruct(vectStruct, ft);
					
					return funcRef.setTaggedType(newRetft);
				}
				
				
				funcRef.typeOperatedOn = funcTypeToTAL.get(matchingFunctionBeingCurried);
				
				if(null != funcRef.typeOperatedOn && funcRef.typeOperatedOn.getType() instanceof FuncType){
					Type funtoType = functoThing.getTaggedType();
					if(funtoType instanceof FuncType && ((FuncType)funtoType).isClassRefType){
						((FuncType)funcRef.typeOperatedOn.getType()).isClassRefType=true;
						matchingFunctionBeingCurried.isClassRefType=true;
					}
				}
				
				
				if(matchingFunctionBeingCurried.defaultFuncArgs != null){
					((FuncType)funcRef.typeOperatedOn.getType()).defaultFuncArgs = matchingFunctionBeingCurried.defaultFuncArgs;
				}
				
				
				//private, public etc
				validateMethodVisibility(matchingFunctionBeingCurried.getUnderlyingDefAccessMod(), funcRef.typeOperatedOn, funcRef.methodName, funcRef, matchingFunctionBeingCurried);
								
				if(matchingFunctionBeingCurried.getLocalGenerics() != null){//uh oh bit parnts
					HashSet<GenericType> unbounded = TypeCheckUtils.findUnboundedGenerics(matchingFunctionBeingCurried);
					
					boolean zeroargs = noArgs || (wantedArguments.isEmpty()  && namesMapType.isEmpty() );
					if(zeroargs || !unbounded.isEmpty()) {
						this.raiseError(funcRef.getLine(), funcRef.getColumn(), String.format("Missing generic binding for: %s on method: %s", Utils.sortAndJoin(matchingFunctionBeingCurried.getLocalGenerics()), funcRef.methodName));
					}
				}
				
				
				funcRef.shouldVisitFunctoInBytcodeGen = this.shouldVisitFunctoBytcodeGen(funcRef);
				
				funcRef.argumentsThatDontNeedToBecurriedIn = argumentsThatDontNeedToBecurriedIn;
				
				if(matchingFunctionBeingCurried.getLambdaDetails() != null){
					//the origon is a lambda not the holding class of the lambda
					//matchingFunctionBeingCurried.lambdaDetails.
					
					if(ftToOrigonalRef.containsKey(matchingFunctionBeingCurried)){
						ft.origin = ftToOrigonalRef.get(matchingFunctionBeingCurried).getSetClassDef();
					}
					else{
						ft.origin = matchingFunctionBeingCurried.getPoshObjectStyleName().getSetClassDef();
					}
				}
				/*else if(funcRef.typeOperatedOn != null && funcRef.typeOperatedOn.getLocation().getOriginatesFromConstructorRef()){//its from a constructor ref
					//e.g. MyClass&; mc&(12) etc
					ft.origin = ScopeAndTypeChecker.const_ClassRef_cls;
				}*/
				else{
					ft.origin = matchingFunctionBeingCurried.origin;
				}
				
				
				
				//TODO: next line shouldnt have null check???
				NamedType originNT = ft.origin ==null?matchingFunctionBeingCurried.getPoshObjectStyleName():new NamedType(funcRef.getLine(), funcRef.getColumn(), ft.origin);
				funcRef.operatingOn = originNT;
				Type ownerType = originNT;
				
				Pair<String, String> lambdaDetails = funcRef.getLambdaDetails();
				Fourple<FuncType, ArrayList<Type>, ArrayList<Pair<Type, Integer>>, ArrayList<Pair<String, Type>> > uniqueArgs = new Fourple<FuncType, ArrayList<Type>, ArrayList<Pair<Type, Integer>>, ArrayList<Pair<String, Type>> >(ft, argumentsThatDontNeedToBecurriedIn, argumentsThatNeedToBecurriedInTypeAndPos, namesMapType);
				if(null == lambdaDetails){
					lambdaDetails = getLambdaDetails(matchingFunctionBeingCurried.definedLocation, ownerType, funcRef.methodName, uniqueArgs);
					funcRef.setLambdaDetails(lambdaDetails);
				}
				else{//run anyway to set state as approperiate
					lambdaDetails = getLambdaDetails(matchingFunctionBeingCurried.definedLocation, ownerType, funcRef.methodName, uniqueArgs);
					funcRef.setLambdaDetails(lambdaDetails);
				}
				
				final String classNameOfLambda = lambdaDetails.getA();
				
				boolean returnsVoid = ft == null? false:ScopeAndTypeChecker.const_void.equals(ft.retType);
				
				String owwnerelambda = "com/concurnas/bootstrap/lang/Lambda$Function" + argumentsThatNeedToBecurriedIn.size() + ( returnsVoid? "v":"");
				ClassFunctionLocation cflloc = new ClassFunctionLocation(owwnerelambda, ownerType, false);
				cflloc.setLambdaOwner(owwnerelambda);
				TypeAndLocation lambdaTal = new TypeAndLocation(funcRef.typeOperatedOn.getType(), cflloc);
				
				ft.setLambdaDetails(lambdaTal);
				if(funcRef.typeOperatedOn.getType() instanceof FuncType && ((FuncType)funcRef.typeOperatedOn.getType()).retType instanceof FuncType)
				{
					((FuncType)((FuncType)funcRef.typeOperatedOn.getType()).retType).setLambdaDetails(lambdaTal);
				}
				
				funcRef.setTaggedType(ft);
				
				
				//gennerate default equals for lambda function
				/*
				 A lambda is equal if:
				 	it's acting upon the same object/module                = StoredAs aField [opon]
				 	with the same state - aka locked in arguments          = Fields [f0,..,fn]
				 	calling the same method signature [name and arguments] = Extra thing to check - add a method to cater for this
				 	
				 	in function, lambda does not check super and lambda does call getSignature and compares - check this works ok for generically qualified types
				 	
				 	signature is method, args and ret type, not class of the thing being called
				 	
				 	//add method to return string: pairMeth (ILjava/lang/Object;I)I
				 	  
				 	 in lamba: add call to create this bytecode, also add call to create getSignatuture method for use by internal equals function
				 */
				
				final ClassDef containingClassFiddle = new ClassDef(line, col, classNameOfLambda, "");//fiddle
				containingClassFiddle.classBlock = new Block(line, col);
				
				TheScopeFrame tsfForLambdaClass = containingClassFiddle.getScopeFrameGenIfMissing(this.moduleLevelFrame, containingClassFiddle);

				ArrayList<Pair<String, Type>> varsToAdd = new ArrayList<Pair<String, Type>>();//only care for first two
				//TheScopeFrame tsfForLambdaClass = TheScopeFrame.buildTheScopeFrame_Class(this.moduleLevelFrame, true, containingClassFiddle);
				
				if(!(funcRef.typeOperatedOn.getLocation() instanceof StaticFuncLocation)){//opon reference doesnt exist on lambdas acting upon 
					varsToAdd.add(new Pair<String, Type>("opon", ownerType));
					tsfForLambdaClass.setVariable(tsfForLambdaClass, "opon", new TypeAndLocation(ownerType, new LocationClassField(classNameOfLambda, const_object)), true, this.level, null, false);
				}
				
				//System.err.println("tt: " + ft);
				
				if(funcRef.replaceFirstArgWithTypeArraOf != null){
					funcRef.replaceFirstArgWithTypeArraOf = (NamedType)ft.retType;
				}
				
				if(noArgs) {
					FuncRefArgs argsforNextTime = new FuncRefArgs(line, col);
					argumentsThatNeedToBecurriedIn.forEach(a -> argsforNextTime.addType(a));
					funcRef.setArgsForScopeAndTypeCheck(argsforNextTime);
				}
				
				
				return ft;
			} else {
				return null;
			}
			
		}
	}
	
	private boolean underscoreType(Node item) {
		if(item instanceof NamedType || item instanceof RefName || item instanceof TypeReturningExpression) {
			return true;
		}
		
		if(item instanceof DotOperator) {
			return ((DotOperator)item).getElements(this).stream().allMatch(a -> underscoreType((Node)a));
		}
		
		return false;
		
	}
	
	private Node isNodeReallyAUnderscoreType(Node item, HashMap<Integer, Node> replaceArg, int n) {
		
		if(underscoreType(item)){
			item = filterMissingOrUnusableNamedTypes(item);
			
			this.maskErrors(true);
			item.accept(this);
			ArrayList<CapMaskedErrs> erorsOnItem = this.getmaskedErrors();
			
			if(!erorsOnItem.isEmpty()){
				//e.g. 'String', this might be a variable or a NamedType 
				PrintSourceVisitor psv = new PrintSourceVisitor();
				item.accept(psv);
				
				Node tryAsNamed = new NamedType(item.getLine(), item.getColumn(), psv.toString());
				tryAsNamed = filterMissingOrUnusableNamedTypes(tryAsNamed);
				this.maskErrors(true);
				Type res = (Type)tryAsNamed.accept(this);
				if(this.maskedErrors() || null == res || res instanceof ModuleType){
					this.applyMaskedErrors(erorsOnItem);
				}else{
					item = tryAsNamed;
					//if(null != replaceArg){
						replaceArg.put(n, item);
						return item;
					//}
				}
			}
			
			if(item instanceof TypeReturningExpression){
				item = (Node) ((TypeReturningExpression) item).type;
				replaceArg.put(n, item);
			}
		}
		
		
		
		return item;
	}

	private Node filterMissingOrUnusableNamedTypes(Node item) {
		//if(!funcRef.args.beenThroughOneCompilationCycleAlready && item instanceof RefName){
		if( item instanceof NamedType){
			String txt = ((NamedType)item).getNamedTypeStr();
			ClassDef resolvedTo = getImportedClassDef(txt);
			
			if(null == resolvedTo || UncallableMethods.UNAVAILABLE_CLASSES.contains(resolvedTo))
			{//fail, try to parse as a variable
				if(null == findgetGenericTypeDeclaration(txt)){
					//oh it's also not a generic type either...
					item = new RefName(((NamedType) item).getLine(), ((NamedType) item).getColumn(), txt);
				}
				
			}
		}
		return item;
	}

	private boolean shouldVisitFunctoBytcodeGen(FuncRef funcRef) {
		Location loc = funcRef.typeOperatedOn.getLocation();
		//refNamedTypeToQuantify().isEmpty() if not empty then that implies that we are doing an unbounded funcref (e.g. MyClass.funcla&() //etc
		return refNamedTypeToQuantify().isEmpty() && (loc instanceof LocationLocalVar || loc instanceof LocationStaticField || loc instanceof LocationClassField); // && functoThing instanceof RefName;
	}
	
	

	@Override
	public Object visit(FuncRefInvoke funcRefInvoke) {
		/*
		 * func b(a int, b int) { a+b}
		 * z = b&(8) <- funcref
		 * zz = z(6); <- funcrefinvoke
		 * 
		 * 
		 */
		
		FuncInvoke asFuncInvoke = canBeAFuncInvoke(funcRefInvoke.getLine(), funcRefInvoke.getColumn(), funcRefInvoke.funcRef, funcRefInvoke.getArgsOrig());
		if(null != asFuncInvoke){
			funcRefInvoke.astredirect = asFuncInvoke;
			return asFuncInvoke.accept(this);
		}
		//a normal funcrefinvoke..

		//TODO: check if the logic in getMatchingFuncNames should be applied here as well...
		funcRefInvoke.getArgsOrig().accept(this);
		
		//this(x); super(x);
		
		
		Type funcRefTypeTT = TypeCheckUtils.getRefType(funcRefInvoke.funcRef==null?null: (Type)funcRefInvoke.funcRef.accept(this));
		
		FuncInvoke unassign = typeHasUnassign(funcRefInvoke.funcRef.getLine(), funcRefInvoke.funcRef.getLine(), TypeCheckUtils.getRefTypeToLocked(funcRefTypeTT), funcRefInvoke.funcRef); 
		if(null != unassign) {
			funcRefInvoke.funcRef = DotOperator.buildDotOperatorOneNonDirect(funcRefInvoke.funcRef.getLine(), funcRefInvoke.funcRef.getLine(), funcRefInvoke.funcRef, unassign);
			
			funcRefTypeTT = TypeCheckUtils.getRefType(funcRefInvoke.funcRef==null?null: (Type)funcRefInvoke.funcRef.accept(this));
		}
		
		
		if(null == funcRefTypeTT || !(funcRefTypeTT instanceof FuncType) || funcRefTypeTT.hasArrayLevels())
		{
			this.raiseError(funcRefInvoke.getLine(), funcRefInvoke.getColumn(), String.format("Expected to invoke a function reference"));
			return null;
		}
		

		FuncType funcRefType = (FuncType)funcRefTypeTT;
		List<Expression> mappedArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, funcRefType, funcRefInvoke.getArgsOrig().asnames, (ArrayList<Pair<String, Expression>>)(Object)funcRefInvoke.getArgsOrig().nameMap, 0, false, false);
		if(!mappedArgs.equals(funcRefInvoke.getArgsOrig().asnames)){
			funcRefInvoke.setMappedArgs(mappedArgs);
		}
		
		//ensure calling args match expected type
		if(funcRefType.isClassRefType){
			//classref so obtain the one most relevant
			if(funcRefType.retType instanceof  NamedType){
				NamedType nt =(NamedType) funcRefType.retType;
				List<FuncType> cons = nt.getAllConstructors(this);
				//get most relevant one...
				HashSet<TypeAndLocation> tals = new HashSet<TypeAndLocation>();
				for(FuncType ft : cons){
					tals.add(new TypeAndLocation(ft, new LocationLocalVar(this.currentScopeFrame)) );
				}
				
				ArrayList<Type> argsWanted = new ArrayList<Type>();

				for(int n=0; n< funcRefInvoke.getArgs().asnames.size(); n++){
					this.dotOperatorLHS.push(null);
					this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
					Type lhs = (Type) funcRefInvoke.getArgs().asnames.get(n).accept(this);
					argsWanted.add(lhs);
					this.dotOperatorLHS.pop();
					this.currentDotOperatorTracker.pop();
				}
				
				
				FuncType nextFuncRef = TypeCheckUtils.getMostSpecificFunctionForChoices(this, ers, tals, argsWanted, null, "index get reference call", funcRefInvoke.getLine(), funcRefInvoke.getColumn(), true, this, false);
				if(null != nextFuncRef){
					nextFuncRef = nextFuncRef.copyTypeSpecific();
					nextFuncRef.retType = nt.copyTypeSpecific();
					funcRefType = nextFuncRef;
					funcRefType.setLambdaDetails( funcRefType.getLambdaDetails());
				}
				
				
			}
			
		}
		
		funcRefInvoke.resolvedInputType = funcRefType;
		
		Type ret = funcRefType.retType;
				
		if( mappedArgs.size() != funcRefType.getInputs().size() )
		{
			this.raiseError(funcRefInvoke.funcRef.getLine(), funcRefInvoke.funcRef.getColumn(), String.format("Call of function reference expected: %s arguments but received: %s", funcRefInvoke.getArgsOrig().asnames.size() , funcRefType.getInputs().size() ));
			return null;
		}
		else
		{
			ArrayList<Integer> fails = new ArrayList<Integer>(mappedArgs.size());
			ArrayList<Pair<Boolean, NullStatus>> vectorized = null;
			for(int n=0; n< mappedArgs.size(); n++)
			{
				this.dotOperatorLHS.push(null);
				this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
				Expression lhsExp = mappedArgs.get(n);
				Type lhs = funcRefType.getInputs().get(n); 
				Type rhs = (Type) lhsExp.accept(this);

				ArrayList<Pair<ArrayList<Pair<Boolean, NullStatus>>, Type>> tryRhs = new ArrayList<Pair<ArrayList<Pair<Boolean, NullStatus>>, Type>>();
				if(rhs != null && rhs.isVectorized()) {
					//Type tempRhs
					Type rootType = TypeCheckUtils.extractVectType(rhs);
					ArrayList<Pair<Boolean, NullStatus>> vectSttruct = TypeCheckUtils.getVectorizedStructure(ers, rhs);
					ArrayList<Pair<Boolean, NullStatus>> vectSttructOrig = (ArrayList<Pair<Boolean, NullStatus>>)vectSttruct.clone();
					
					while(!vectSttruct.isEmpty()) {
						ArrayList<Pair<Boolean, NullStatus>> level = (ArrayList<Pair<Boolean, NullStatus>>)vectSttruct.clone();
						vectSttruct.remove(0);
						tryRhs.add(new Pair<ArrayList<Pair<Boolean, NullStatus>>, Type>(vectSttructOrig, TypeCheckUtils.applyVectStruct(vectSttruct, rootType)));
					}
				}else {
					tryRhs.add(new Pair<ArrayList<Pair<Boolean, NullStatus>>, Type>(null, rhs));
				}
				
				boolean match = false;
				for(Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> potentRhsAndDepth : tryRhs) {
					Type potentRhs = potentRhsAndDepth.getB();
					if(null != TypeCheckUtils.checkSubType(ers, lhs, potentRhs, 0, 0, 0,0)) {
						ArrayList<Pair<Boolean, NullStatus>> depth = potentRhsAndDepth.getA();
						
						if(depth != null) {
							if(vectorized != null) {
								if(depth.size() != vectorized.size()) {
									this.raiseError(funcRefInvoke.funcRef.getLine(), funcRefInvoke.funcRef.getColumn(), "Vectorized arguments must all be to the same degree");
									return null;
								}
							}else {
								vectorized = depth;
							}
						}
						match=true;
						break;
					}
				}
				
				if(!match) {
					fails.add(n);
				}
				
				this.dotOperatorLHS.pop();
				this.currentDotOperatorTracker.pop();
			}
			
			if(vectorized != null) {
				ret = TypeCheckUtils.applyVectStruct(vectorized, ret);
				funcRefInvoke.depth = vectorized;
			}
			
			if(!fails.isEmpty())
			{
				StringBuilder sb = new StringBuilder();
				for(int m=0; m< fails.size(); m++)
				{
					sb.append(fails.get(m));
					if(m!=fails.size()-1)
					{
						sb.append(", ");
					}
				}
				
				String s = fails.isEmpty() ? "" : "s";
				this.raiseError(funcRefInvoke.funcRef.getLine(), funcRefInvoke.funcRef.getColumn(), String.format("Incompatible argument%s found for function reference call at position%s: %s" , s, s, sb   ));
				return null;
			}
			
		}
		
		return funcRefInvoke.setTaggedType(ret);
	}
	

	@Override
	public Object visit(FuncParams funcParams) {
		return null;
	}

	private HashSet<String> declaredGenerics(){
		HashSet<String> ret = new HashSet<String>();
		for(FuncDefI infunc : this.currentlyInFuncDef){
			infunc.methodGenricList.forEach(a -> ret.add(a.getA()));
		}
		
		for(ClassDef incls : this.currentlyInClassDef){
			for(GenericType gt : incls.classGenricList){
				ret.add(gt.name);
			}
		}
		
		return ret;
	}
	
	@Override
	public Object visit(FuncParam funcParam) {
		/*
		 * permits parse of the following: fun funbroken(a :) int{ return 4 }
		 */
		Type type = funcParam.type;
		if(funcParam.name == null && type instanceof NamedType ){
			NamedType asNamed = (NamedType)type;
			if(asNamed.getIsRef()){//oops
				funcParam.name = ((NamedType)asNamed.getGenTypes().get(0)).getNamedTypeStr();   
				asNamed.getGenTypes().set(0, const_object);
			}
		}
		//^that was nasty!
		
		if(funcParam.annotations != null){
			funcParam.annotations.setUsedAt(ElementType.PARAMETER);
			funcParam.annotations.accept(this);
		}
		
		Type res=null;
		if(type != null){
			res = (Type)type.accept(this);
			if(res == null && type instanceof NamedType){
				res = ScopeAndTypeChecker.const_object.copyTypeSpecific();
			}
		}
		
		
		if(funcParam.isVararg && null != res){
			res = (Type)res.copy();
			res.setArrayLevels(res.getArrayLevels()+1);
		}
		
		if(funcParam.isLazy) {
			res = Utils.convertToLazyType(res);	
		}
		

		boolean hasGPUQuali = null != funcParam.gpuVarQualifier || null != funcParam.gpuInOutFuncParamModifier;
		
		if(funcParam.defaultValue != null){
			funcParam.defaultOk = true;

			Utils.inferAnonLambda(this, (Node)funcParam.defaultValue, res);
			
			Type dvType = (Type)funcParam.defaultValue.accept(this);
			
			
			boolean isvalid = TypeCheckUtils.isValidType(dvType);
			int line=funcParam.getLine();
			int column=funcParam.getColumn();
			if(!isvalid){
				this.raiseError(line, column, String.format("Invalid default value type %s", dvType));
				funcParam.defaultOk = false;
				//return null;
				dvType=const_object;//panic
			}
			
			if(dvType instanceof VarNull){
				dvType = ((VarNull) dvType).getTaggedType();
			}
			
			if(type != null){
				
				boolean alreadyTypeChecked = false;
				Type convertRetTo = TypeCheckUtils.canConvertRHSToArgLessLambda(this, this.ers, res, dvType);
				if(null != convertRetTo) {

					int linex = funcParam.getLine();
					int colx = funcParam.getColumn();
					
					Pair<Type, Expression> conv = convertExprToArgLessLambda(linex, colx, convertRetTo, dvType, funcParam.defaultValue);
					dvType = conv.getA();
					funcParam.defaultValue = conv.getB();
					
					alreadyTypeChecked=true;
				}
				
				if(null != TypeCheckUtils.checkSubType(this.ers, ScopeAndTypeChecker.getLazyNT(), res)) {
					//so check rhs value to lazy value needed for type...
					Type llhsT = ((NamedType)res).getGenTypes().get(0);
					if(null != TypeCheckUtils.checkSubType(this.ers, llhsT, dvType )) {
						//now convert to new Lazy...
						
						int linex = funcParam.getLine();
						int colx = funcParam.getColumn();
						
						Pair<Type, Expression> conv = convertExpressionToNewLazy(linex, colx, llhsT, dvType, funcParam.defaultValue, false/*, false*/);
						
						if(null != conv) {
							dvType = conv.getA();
							funcParam.defaultValue = conv.getB();
							alreadyTypeChecked=true;
						}
					}
				}
				
				
				if(TypeCheckUtils.typeContainsAGenericType(type, declaredGenerics()) && !TypeCheckUtils.isVarNull(dvType)){
					this.raiseError(line, column, "default value besides null cannot be used for generic type assignment");
					funcParam.defaultOk = false;
				}
				
				Type subt;
				if(!alreadyTypeChecked) {
					subt = TypeCheckUtils.checkAssignmentCanBeDone(this, AssignStyleEnum.EQUALS, res, dvType, line, column, line, column, "");
					//subt = TypeCheckUtils.checkSubType(this, res, dvType, line, column, line, column);
					
					if(null == subt){
						funcParam.defaultOk = false;
					}else {
						subt=res;
					}
				}else {
					subt = res;
				}
				
				
				res = subt==null?res:subt;
			}
			else{
				res = dvType;
			}
		}
		
		if(hasGPUQuali) {
			
			if(null != funcParam.gpuInOutFuncParamModifier && funcParam.gpuVarQualifier != GPUVarQualifier.GLOBAL) {
				this.raiseError(funcParam.getLine(), funcParam.getColumn(), String.format("gpu parameter may not be qualified with %s as it's not marked global", funcParam.gpuInOutFuncParamModifier));
				funcParam.defaultOk = false;
			}
			
			if(funcParam.defaultValue != null) {
				this.raiseError(funcParam.getLine(), funcParam.getColumn(), String.format("gpu parameter may not have default value"));
				funcParam.defaultOk = false;
			}
			
			if(funcParam.isVararg) {
				this.raiseError(funcParam.getLine(), funcParam.getColumn(), String.format("gpu parameter may not be a vararg"));
				funcParam.defaultOk = false;
			}
		}
		
		boolean isinGPUFunc = !this.currentlyInFuncDef.isEmpty() && this.currentlyInFuncDef.peek().isGPUKernalOrFunction != null;
		
		if(isinGPUFunc ) {
			if(null != res) {
				if(!TypeCheckUtils.isPurePrimative(res)) {
					this.raiseError(funcParam.getLine(), funcParam.getColumn(), "all parameters to gpu functions or kernels must be of primative type");
				}
				
				if(funcParam.annotations != null){
					this.raiseError(funcParam.getLine(), funcParam.getColumn(), "parameters to gpu functions or kernels may not have annotations");
				}
				
			}
		}else if(hasGPUQuali){//  {
			this.raiseError(funcParam.getLine(), funcParam.getColumn(), "gpu qulifier is only applicable to gpu kernels or gpu functions");
		}
		
		if( null != funcParam.gpuVarQualifier) {
			res.setGpuMemSpace(funcParam.gpuVarQualifier);
		}
		
		//funcParam.type == null && funcParam.defaultValue == null - this is not a possible configaration | it is with classdefargs
		
		if(null != funcParam.name){
			Type useableType = res;
			if(isinGPUFunc && useableType.getGpuMemSpace() != null /*&& useableType.getArrayLevels() >= 1*/) {
				useableType = (Type)useableType.copy();
				useableType.setArrayLevels(0);
				useableType.setPointer(1);
			}
			
			this.addToScopeStackVars(funcParam.name, useableType, funcParam.isFinal ,true, funcParam.isShared);
		}
		
		if(null != res){
			//funcParam.type = res;//TODO: what if res from defualt changes after initial cycle? oh that will show up as a bug, ok fine
			funcParam.setTaggedType(res);
			
			if(funcParam.isShared && TypeCheckUtils.isPurePrimativeNonArray(res)) {
				this.raiseError(funcParam.getLine(), funcParam.getColumn(), "shared variables may not be of non array primative type");
			}
		}
		
		return res;//TODO: isFinal is being ignored? i think i fix ed this
		
	}

	@Override
	public Object visit(FuncInvokeArgs funcInvokeArgs) {
		// TODO Auto-generated method stub
		this.dotOperatorLHS.push(null);
		this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
		for(Expression e :funcInvokeArgs.asnames)
		{
			e.accept(this);
		}
		
		getNameMap(funcInvokeArgs);
		
		this.dotOperatorLHS.pop();
		this.currentDotOperatorTracker.pop();
		return null;
	}
	
	private ArrayList<Pair<String, Type>> getNameMap(HasNameMap funcInvokeArgs){
		ArrayList<Thruple<String, Expression, Type>> getNameMapBoth = getNameMapBoth(funcInvokeArgs);
		ArrayList<Pair<String, Type>> ret = new ArrayList<Pair<String, Type>>(getNameMapBoth.size());
		
		for(Thruple<String, Expression, Type> nn : getNameMapBoth){
			ret.add(new Pair<>(nn.getA(), nn.getC()));
		}
		
		return ret;
	}
	
	private ArrayList<Pair<String, Expression>> getNameMapExpr(HasNameMap funcInvokeArgs){
		ArrayList<Thruple<String, Expression, Type>> getNameMapBoth = getNameMapBoth(funcInvokeArgs);
		ArrayList<Pair<String, Expression>> ret = new ArrayList<Pair<String, Expression>>(getNameMapBoth.size());
		
		for(Thruple<String, Expression, Type> nn : getNameMapBoth){
			ret.add(new Pair<>(nn.getA(), nn.getB()));
		}
		
		return ret;
	}
	
	private ArrayList<Pair<String, Object>> getNameMapObj(HasNameMap funcInvokeArgs){
		ArrayList<Thruple<String, Object, Type>> getNameMapBoth = getNameMapBoth(funcInvokeArgs);
		ArrayList<Pair<String, Object>> ret = new ArrayList<Pair<String, Object>>(getNameMapBoth.size());
		
		for(Thruple<String, Object, Type> nn : getNameMapBoth){
			ret.add(new Pair<>(nn.getA(), nn.getB()));
		}
		
		return ret;
	}
	
	
	
	private <XXX> ArrayList<Thruple<String, XXX, Type>> getNameMapBoth(HasNameMap funcInvokeArgs){
		this.dotOperatorLHS.push(null);
		this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
		try{
			if(null == funcInvokeArgs){
				return new ArrayList<Thruple<String, XXX, Type>>( 0);
			}
			List<Pair<String, Object>> nmap = funcInvokeArgs.getNameMap();
			ArrayList<Thruple<String, XXX, Type>> got = new ArrayList<Thruple<String, XXX, Type>>( nmap.size());
			
			HashSet<String> visitedNames = new HashSet<String>();
			if(!nmap.isEmpty()){
				for(Pair<String, Object> name : nmap){
					String paramName = name.getA();
					Node nn=(Node)name.getB();
					if(visitedNames.contains(paramName)){
						int line = nn.getLine();
						int coumn = nn.getColumn();
						this.raiseError(line, coumn, String.format("Duplicate named parameter %s", paramName));
					}
					visitedNames.add(paramName);
					Type t;
					if(nn instanceof Expression){
						Expression expr = (Expression)nn;
						t = (Type)expr.accept(this);
					}
					else{
						t = (Type)nn;
						t.accept(this);
					}
					t = t == null?null:(Type)(t).copy();
					Type originRefType = t;
					
					if(TypeCheckUtils.hasRefLevelsAndNotLocked(t)){//extract ref like this: functo(refThing) //calls non ref version
						t = TypeCheckUtils.getRefType(t);
					}
					if(t != originRefType){
						//((NamedType)t).originRefType = originRefType;
						((AbstractType)t).originRefType = originRefType;
					}
					
					
					got.add(new Thruple<String, XXX, Type>(paramName, (XXX)nn, t));
				}
			}
			return got;
		}
		finally{
			this.dotOperatorLHS.pop();
			this.currentDotOperatorTracker.pop();
		}
	}
	
	private HashMap<String, TypeAndLocation> forLoopVarAndType = null;
	
	@Override
	public Object visit(ForBlockOld forBlockOld) {
		
		String nameOfNewVar = null;
		Type typeOfNewVar   = null;
		
		this.forWhileExpectsReturn.push(new Pair<Boolean, String>(forBlockOld.getShouldBePresevedOnStack(), "for"));
		
		if(forBlockOld.getShouldBePresevedOnStack()){
			adContinueToLastIfStmt(forBlockOld.block);
		}
		
		if(null != forBlockOld.assignExpr)
		{
			forBlockOld.assignExpr.accept(this); //not creating a new var just doing some random op on entry
		}
		else if(null != forBlockOld.assignName)
		{
			nameOfNewVar = forBlockOld.assignName;
			Type assigType = null;
			if(forBlockOld.assigType!= null ) assigType = (Type)forBlockOld.assigType.accept(this);
			Type rhs = (Type)forBlockOld.assigFrom.accept(this);
			
			if(null == assigType)
			{//take type to be rhs dunno what its meant to be
				if(this.currentScopeFrame.hasVariable(this.currentScopeFrame, nameOfNewVar, true, false, false))
				{
					Type lhs = this.currentScopeFrame.getVariable(this.currentScopeFrame, nameOfNewVar, true).getA().getType();
					//JPT: next line the lines and cols are wrong
					TypeCheckUtils.checkAssignmentCanBeDone(this, forBlockOld.assignStyle, lhs, rhs, forBlockOld.assigFrom.getLine(),forBlockOld.assigFrom.getColumn(), forBlockOld.assigFrom.getLine(),forBlockOld.assigFrom.getColumn(), "");
					
					forBlockOld.fiddleIsNew = false;
				}
				else
				{//new!
					if(!forBlockOld.assignStyle.isEquals())
					{
						this.raiseError(forBlockOld.getLine(), forBlockOld.getColumn(), String.format("Assignment type not permitted for new variable '%s'", nameOfNewVar));
						this.forWhileExpectsReturn.pop();
						return null;
					}
					
					forBlockOld.fiddleIsNew = true;
				}
				
				if(rhs instanceof VarNull)
				{
					this.raiseError(forBlockOld.assigFrom.getLine(),forBlockOld.assigFrom.getColumn(), "Ambigous type declaration of null");
					rhs = new NamedType(forBlockOld.getLine(), forBlockOld.getColumn(), new ClassDefJava(java.lang.Object.class));
				}
				
				typeOfNewVar = rhs;
			}
			else
			{//we have stated what the lhs should be
				forBlockOld.fiddleIsNew = true;
				typeOfNewVar = TypeCheckUtils.checkAssignmentCanBeDone(this, AssignStyleEnum.EQUALS, assigType, rhs, forBlockOld.getLine(),forBlockOld.getColumn(), forBlockOld.assigFrom.getLine(), forBlockOld.assigFrom.getColumn(), "");
				if(null == typeOfNewVar)
				{//cannot figure it out take the lhs hard defined type
					typeOfNewVar = assigType ;
				}
			}
			
			forBlockOld.resolvedassigType = typeOfNewVar;
			
		}
		
		if(null != nameOfNewVar && null != typeOfNewVar)
		{//little hack for our getVar function which comes later as new thing may be 'early' referenced in check and increment stmt
			boolean prevforceLocalScope  =forceLocalScope;
			forceLocalScope = true;
			forLoopVarAndType = new HashMap<String, TypeAndLocation>();
			forLoopVarAndType.put(nameOfNewVar, createTypeAndLocationVarHolder(forBlockOld.getLine(), forBlockOld.getColumn(), typeOfNewVar, false, null, false, false, false, false, false, false, false));//non final obvously
			forBlockOld.fiddleNewVarType = typeOfNewVar;
			forceLocalScope=prevforceLocalScope;
		}
		
		
		
		if(null != forBlockOld.check)
		{
			TypeCheckUtils.assertNotVoid((Type)forBlockOld.check.accept(this), this, forBlockOld.check.getLine(), forBlockOld.check.getColumn(), "for");
			//TypeCheckUtils.isBoolean(this, (Type)forBlockOld.check.accept(this), forBlockOld.getLine(), forBlockOld.getColumn());
		}
		
		if(null != forBlockOld.postExpr)
		{
			forBlockOld.postExpr.accept(this);
		}
		
		if(null != nameOfNewVar && null != typeOfNewVar)
		{
			addToScopeStackVars(nameOfNewVar, typeOfNewVar, false, true, false);
		}
		
		forLoopVarAndType = null;
		
		if(forBlockOld.origParFor == null){
			forBlockOld.block.canContainAContinueOrBreak = true;
		}
		forBlockOld.block.canContainAReturnStmt = null;
		
		Type blockType = (Type)forBlockOld.block.accept(this);
		
		Type ret = null;
		
		if(forBlockOld.getHasAttemptedNormalReturn()){
			forBlockOld.setShouldBePresevedOnStack(false);
		}
		
		
		Type elseblockType=null;
		if(null != forBlockOld.elseblock){

			forBlockOld.elseblock.canContainAReturnStmt = null;
			elseblockType = (Type)forBlockOld.elseblock.accept(this);
			
			Type origa = elseblockType;
			elseblockType = TypeCheckUtils.getRefTypeToLocked(elseblockType);
			if(TypeCheckUtils.isValidType(elseblockType)){
				TypeCheckUtils.checkSubType(this, elseblockType, origa, forBlockOld.block.getLine(), forBlockOld.block.getColumn(), forBlockOld.block.getLine(), forBlockOld.block.getColumn(), false);
			}
		}
		
		
		if(forBlockOld.getShouldBePresevedOnStack()){
			//only needed for the likes of ar = for(n=0; n < 50; n++){n*2}
			ArrayList<Type> genTypes = new ArrayList<Type>(1);
			
			if(!TypeCheckUtils.isValidType(blockType, true)){
				this.raiseError(forBlockOld.block.getLine(),forBlockOld.block.getColumn(), "for loop must return something");
				//blockType = const_object;
				ret=null; 
				//TODO: set ret=const_void_thrown
			}
			else{
				
				int line = forBlockOld.getLine();
				int col = forBlockOld.getColumn();
				
				genTypes.add(blockType);
				ret = new NamedType(line, col, new ClassDefJava(line, col, java.util.List.class), genTypes);
				ret = (Type)ret.accept(this);
			}
			
			
			
			if(null != forBlockOld.elseblock){
				if(forBlockOld.origParFor != null){
					this.raiseError(forBlockOld.block.getLine(),forBlockOld.block.getColumn(), "parrallel for loop cannot contain else block");
					ret=const_void_thrown;
				}
				else{
					if(!TypeCheckUtils.isValidType(elseblockType)){
						this.raiseError(forBlockOld.block.getLine(),forBlockOld.block.getColumn(), "for loop else block must return something");
						ret=const_void_thrown;
					}
					else{
						List<Type> stuff = new ArrayList<Type>(2);
						Map<Type, Pair<Integer, Integer>> offenders = new HashMap<Type, Pair<Integer, Integer>>();
						
						stuff.add(ret);
						offenders.put(ret, new Pair<Integer, Integer>( forBlockOld.block.getLine(), forBlockOld.block.getLine()));
						stuff.add(elseblockType);
						offenders.put(elseblockType, new Pair<Integer, Integer>( forBlockOld.elseblock.getLine(), forBlockOld.elseblock.getColumn()));
						
						ret = TypeCheckUtils.getMoreGeneric(this, this,  forBlockOld.getLine(), forBlockOld.getLine(), stuff, offenders);
					}
				}
			}
			
			
			forBlockOld.setTaggedType(ret);
		}
		this.forWhileExpectsReturn.pop();
		return ret;
	}
	
	private static final NamedType const_iter = new NamedType(0, 0, new ClassDefJava(java.lang.Iterable.class));
	private static final NamedType const_map = new NamedType(0, 0, new ClassDefJava(java.util.Map.class));
	//private static final NamedType const_collection = new NamedType(0, 0, new ClassDefJava(java.util.Collection.class));

	private void processIdxVarHaver(IdxVarHaver idxHaver){
		
		RefName idxVariableAssignment = idxHaver.getIdxVariableAssignment();
		
		if(idxVariableAssignment != null){
			//exists already great, else convert it to new one for above
			//ensure that its correct type
			this.maskErrors();
			Type existingVarType = (Type)idxVariableAssignment.accept(this);
			boolean varExists = !this.maskedErrors();
			
			int line = idxVariableAssignment.getLine();
			int column =  idxVariableAssignment.getColumn();
			
			if(varExists){//if it exists already then just assign zero to it
				if(existingVarType!=null && (!TypeCheckUtils.checkNumerical(null, existingVarType, line, column, false))){
					this.raiseError(idxVariableAssignment.getLine(), idxVariableAssignment.getColumn(), "Expected numerical type in block incrementer");
				}
				idxHaver.setIdxVariableCreator(null);//ensure that if didnt exist initially, but later does (iterative compilation) then we remove any idxCreator we may have added accidentally.
				
			}
			else{//create new long
				idxHaver.setIdxVariableCreator(new AssignNew(null, line, column, false, false, idxVariableAssignment.name, new PrimativeType(line, column, PrimativeTypeEnum.INT), AssignStyleEnum.EQUALS, new VarInt(line, column, 0)));
			}
		}

		AssignNew idxVariableCreator = idxHaver.getIdxVariableCreator();
		
		if(idxVariableCreator!= null ){
			Type rhsResovlesTo = (Type)idxVariableCreator.expr.accept(this);
			
			Type idxVariableType;
			if(null == idxVariableCreator.type ) {
				idxVariableCreator.type = rhsResovlesTo;
				idxVariableType = (Type)rhsResovlesTo.copy();
			}else {
				idxVariableType = (Type)idxVariableCreator.type.accept(this);
			}
			
			int line = idxVariableCreator.getLine();
			int col = idxVariableCreator.getColumn();
			
			boolean fail = false;
			if(!TypeCheckUtils.checkNumerical(null, idxVariableType, idxVariableCreator.getLine(), idxVariableCreator.getColumn(), false)){
				this.raiseError(line, col, "Expected numerical type in block incrementer");
				fail=true;
			}
			
			if(!TypeCheckUtils.checkNumerical(null, rhsResovlesTo, idxVariableCreator.expr.getLine(), idxVariableCreator.expr.getColumn(), false)){
				this.raiseError(idxVariableCreator.expr.getLine(), idxVariableCreator.expr.getColumn(), "Expected numerical type in block incrementer initial expression");
				fail=true;
			}
			
			if(!fail){
				TypeCheckUtils.checkSubType(this, idxVariableType, rhsResovlesTo, line, col, line, col);//error if not subtype
			}
				
			addToScopeStackVars(idxVariableCreator.name, idxVariableType, false, true, false);
			
			((AssignNew) idxVariableCreator).isReallyNew = true;
			((AssignNew) idxVariableCreator).isTempVariableAssignment = true;
		}
		
	}
	
	@Override
	public Object visit(ForBlock forBlock) {

		this.forWhileExpectsReturn.push(new Pair<Boolean, String>(forBlock.getShouldBePresevedOnStack(), "for"));
		
		//String idxVariable = null; 
		//Type idxVariableType = null;
		processIdxVarHaver(forBlock);
		//for(a in []; n) {} ; for(a in []; n=0) {} ; for(a in []; n int=1) {} ;//etc
		
		if(forBlock.flagErrorListCompri){
			this.raiseError(forBlock.expr.getLine(), forBlock.expr.getColumn(), String.format("if check can only be used for a 'for' list comprehension statement, not a '%s'", forBlock.origParFor));
		}else if(forBlock.getShouldBePresevedOnStack()){
			adContinueToLastIfStmt(forBlock.block);
		}
		
		String  fname = forBlock.isListcompri?"list comprehension":"for loop";
		
		Type thingActuallBeingIterated = (Type)forBlock.expr.accept(this);
		if(null != thingActuallBeingIterated)
		{
			//forBlock.expr.setTaggedType(thingActuallBeingIterated);
			//can iterate through array or something that compiles with Iteratable interface
			
			Type iteratorType = null;
			
			if(forBlock.elseblock == null) {
				flagNullableForOperation(forBlock.expr.getLine(), forBlock.expr.getColumn(), thingActuallBeingIterated, "iterable for loop expression can be null");
			}
			
			boolean isMap = thingActuallBeingIterated instanceof NamedType && null != TypeCheckUtils.checkSubType(this.ers, const_map, thingActuallBeingIterated, 0, 0, 0, 0);
			
			boolean isLocalArrayu = TypeCheckUtils.isLocalArray(thingActuallBeingIterated);
			
			if(thingActuallBeingIterated.hasArrayLevels()  && !isLocalArrayu )
			{
				if(thingActuallBeingIterated instanceof NamedType || thingActuallBeingIterated instanceof PrimativeType || thingActuallBeingIterated instanceof FuncType || thingActuallBeingIterated instanceof GenericType)
				{
					if(thingActuallBeingIterated instanceof NamedType)
					{
						NamedType asNamed = (NamedType)thingActuallBeingIterated;
						
						iteratorType = new NamedType(forBlock.getLine(), forBlock.getColumn(), ((NamedType)thingActuallBeingIterated).getSetClassDef());
						((NamedType)iteratorType).setFromClassGenericToQualifiedType(((NamedType)thingActuallBeingIterated).getFromClassGenericToQualifiedType());
						
						if(asNamed.getIsRef()){
							NamedType itt = (NamedType)iteratorType;
							itt.setIsRef(true);
							itt.setGenTypes(asNamed.getGenericTypeElements().get(0));
						}else{
							iteratorType = ((NamedType) thingActuallBeingIterated).copyTypeSpecific();
						//	iteratorType.setArrayLevels(iteratorType.getArrayLevels()-1);
						}
						
					}
					else if(thingActuallBeingIterated instanceof PrimativeType)
					{
						iteratorType = new PrimativeType(((PrimativeType)thingActuallBeingIterated).type);
					}
					else if(thingActuallBeingIterated instanceof GenericType){
						iteratorType = (Type)thingActuallBeingIterated.copy();
					}
					else
					{
						iteratorType = ((FuncType)thingActuallBeingIterated).clone();
					}
					
					if(thingActuallBeingIterated.getArrayLevels() >= 1)
					{
						iteratorType.setArrayLevels(thingActuallBeingIterated.getArrayLevels()-1);
					}
				}
				else
				{//VarNull ends up here
					this.raiseError(forBlock.expr.getLine(), forBlock.expr.getColumn(), String.format("%s iteration operation can only be performed on arrays or Objects implementing java.lang.Iterable not: %s", fname, thingActuallBeingIterated));
					this.forWhileExpectsReturn.pop();
					return null;
				}
			}
			else if(thingActuallBeingIterated instanceof NamedType && (isMap || isLocalArrayu || null != TypeCheckUtils.checkSubType(this.ers, const_iter, thingActuallBeingIterated, 0, 0, 0, 0) ))
			{//if it's an iterator
				
				NamedType NretSoFar = (NamedType)thingActuallBeingIterated;
				
				if(isMap){
					forBlock.isMapSetType = new NamedType(NretSoFar.getLine(), NretSoFar.getColumn(), new ClassDefJava(Set.class));
					forBlock.isMapSetType.setGenTypes(NretSoFar.getGenericTypeElements().get(0));
					NretSoFar = forBlock.isMapSetType;
					NretSoFar.accept(this);
				}
				else if(isLocalArrayu){
					NamedType ana = new NamedType(NretSoFar.getLine(), NretSoFar.getColumn(), new ClassDefJava(LocalArray.class));
					NretSoFar = NretSoFar.copyTypeSpecific();
					NretSoFar.setArrayLevels(NretSoFar.getArrayLevels()-1);
					ana.setGenTypes(NretSoFar);
					NretSoFar = ana;
					NretSoFar.accept(this);
				}
				
				HashSet<TypeAndLocation> choices = NretSoFar.getFuncDef(NretSoFar.getLine(), NretSoFar.getColumn(), "iterator", null, null, this);//iterator missing type
						
				FuncType iterFunctionRef = TypeCheckUtils.getMostSpecificFunctionForChoices(this, ers, choices, new ArrayList<Type>(), null, "index get reference call", forBlock.getLine(), forBlock.getColumn(), false, this, false);
				if(null == iterFunctionRef || !(iterFunctionRef.retType instanceof NamedType))
				{//this seems impossibe...
					this.forWhileExpectsReturn.pop();
					return null;
				}
				
				NamedType iteratorCls = (NamedType)iterFunctionRef.retType;
				
				if(null == iteratorCls || !iteratorCls.getNonGenericPrettyName().equals("java.util.Iterator"))
				{
					this.raiseError(forBlock.getLine(), forBlock.getColumn(), String.format("Expected iterator %s return type of: java.util.Iterator not: %s", fname, iteratorCls));
					this.forWhileExpectsReturn.pop();
					return null;
				}
				
				HashSet<TypeAndLocation> nextchoices = iteratorCls.getFuncDef(forBlock.getLine(), forBlock.getColumn(), "next", true, null, null, this);
				FuncType nextFuncRef = TypeCheckUtils.getMostSpecificFunctionForChoices(this, ers, nextchoices, new ArrayList<Type>(), null, "index get reference call", forBlock.getLine(), forBlock.getColumn(), false, this, false);
				
				if(null == nextFuncRef)
				{
					this.raiseError(forBlock.getLine(), forBlock.getColumn(), String.format("Missing expected method on java.util.Iterator for %s", fname));
					this.forWhileExpectsReturn.pop();
					return null;
				}
				
				iteratorType = nextFuncRef.retType;
			}
			else{
				this.raiseError(forBlock.getLine(), forBlock.getColumn(), String.format("Expected Iterable object or array for %s not: %s", fname, thingActuallBeingIterated));
				this.forWhileExpectsReturn.pop();
				return null;
			}
			
			Type actualTypeToAsign = null;
			if(null != forBlock.localVarType)
			{
				Type assignedType = (Type)forBlock.localVarType.accept(this);
				
				actualTypeToAsign = TypeCheckUtils.checkAssignmentCanBeDone(this, AssignStyleEnum.EQUALS, assignedType, iteratorType, forBlock.getLine(), forBlock.getColumn(), forBlock.getLine(), forBlock.getColumn(), ""); 
				if(null == actualTypeToAsign)
				{//ensure that the two dudes are assignable
					this.forWhileExpectsReturn.pop();
					return null;
				}
				
			}
			else
			{
				actualTypeToAsign = (Type)iteratorType.copy();
				actualTypeToAsign.setNullStatus(NullStatus.NONNULL);
			}
			
			actualTypeToAsign = (Type)actualTypeToAsign.copy();//type of variable resulting from list iteration does not need its generic upper bound anymore...
			actualTypeToAsign.setOrigonalGenericTypeUpperBound(null);
			
			forBlock.localVarTypeToAssign = actualTypeToAsign;
			
			
			if(null != forBlock.assignTuple) {
				forBlock.assignTuple.expr = new TypeReturningExpression(forBlock.getLine(), forBlock.getColumn(), actualTypeToAsign);
				forBlock.assignTuple.accept(this);
				
				for(Assign ass : forBlock.assignTuple.lhss) {
					if(null != ass) {
						String name;
						if(ass instanceof AssignNew) {
							AssignNew assNew = (AssignNew)ass;
							name = assNew.name;
						}else {
							AssignExisting assE = (AssignExisting)ass;
							name = ((RefName)assE.assignee).name;
						}

						addToScopeStackVars(name, ass.getTaggedType(), false, true, false);
					}
				}
			}else {
				addToScopeStackVars(forBlock.localVarName, actualTypeToAsign, false, true, false);
			}
			

			if(forBlock.origParFor == null){
				forBlock.block.canContainAContinueOrBreak = true;
			}
			
			forBlock.block.canContainAReturnStmt = null;
			
			Type blockType;
			if(forBlock.flagErrorListCompri){
				this.forWhileExpectsReturn.push(new Pair<Boolean, String>(false, "if-parfor"));//cleans up messy if expression errors
				blockType = (Type)forBlock.block.accept(this);
				this.forWhileExpectsReturn.pop();
			}else {
				blockType = (Type)forBlock.block.accept(this);
			}
			
			Type orig = blockType;
			blockType = TypeCheckUtils.getRefTypeToLocked(blockType);
			if(TypeCheckUtils.isValidType(blockType)){
				TypeCheckUtils.checkSubType(this, blockType, orig, forBlock.block.getLine(), forBlock.block.getColumn(), forBlock.block.getLine(), forBlock.block.getColumn(), false);
			}
			
			Type elseblockType=null;
			if(null != forBlock.elseblock){

				forBlock.elseblock.canContainAReturnStmt = null;
				elseblockType = (Type)forBlock.elseblock.accept(this);
				
				Type origa = elseblockType;
				elseblockType = TypeCheckUtils.getRefTypeToLocked(elseblockType);
				if(TypeCheckUtils.isValidType(elseblockType)){
					TypeCheckUtils.checkSubType(this, elseblockType, origa, forBlock.block.getLine(), forBlock.block.getColumn(), forBlock.block.getLine(), forBlock.block.getColumn(), false);
				}
			}
			
			//FIXME the above returns a thing which does not have its line/col number set
			//then there is the next bug about why type checker things it's weird (doesnt know interfaces maybe?
			
			Type ret = null;
			
			if(forBlock.getHasAttemptedNormalReturn()){
				forBlock.setShouldBePresevedOnStack(false);
			}
			
			
			if(forBlock.getShouldBePresevedOnStack()){
				//only needed for the likes of ar = for(n=0; n < 50; n++){n*2}
				ArrayList<Type> genTypes = new ArrayList<Type>(1);
				
				boolean invalidType = !TypeCheckUtils.isValidType(blockType);
				
				if(invalidType && forBlock.origParFor==null){
					this.raiseError(forBlock.block.getLine(),forBlock.block.getColumn(), String.format("%s must return something", fname));
					ret=const_void_thrown;
				}
				else{
					int line = forBlock.getLine();
					int col = forBlock.getColumn();
					/*
					if(invalidType && null != forBlock.fbv){
						blockType = ScopeAndTypeChecker.const_void_nt;
					}*/
					
					genTypes.add(blockType);
					ret = new NamedType(line, col, new ClassDefJava(line, col, java.util.List.class), genTypes);
				
					ret = (Type)ret.accept(this);
				}
				
				if(null != forBlock.elseblock){
					if(forBlock.origParFor != null){
						this.raiseError(forBlock.block.getLine(),forBlock.block.getColumn(), "parrallel for loop cannot contain else block");
						ret=const_void_thrown;
					}
					else{
						if(!TypeCheckUtils.isValidType(elseblockType)){
							this.raiseError(forBlock.block.getLine(),forBlock.block.getColumn(), "for loop else block must return something");
							ret=const_void_thrown;
						}
						else{
							List<Type> stuff = new ArrayList<Type>(2);
							Map<Type, Pair<Integer, Integer>> offenders = new HashMap<Type, Pair<Integer, Integer>>();
							
							stuff.add(ret);
							offenders.put(ret, new Pair<Integer, Integer>( forBlock.block.getLine(), forBlock.block.getLine()));
							stuff.add(elseblockType);
							offenders.put(elseblockType, new Pair<Integer, Integer>( forBlock.elseblock.getLine(), forBlock.elseblock.getColumn()));
							
							ret = TypeCheckUtils.getMoreGeneric(this, this,  forBlock.getLine(), forBlock.getLine(), stuff, offenders);
						}
					}
				}
				
				forBlock.setTaggedType(ret);
				
			}
			this.forWhileExpectsReturn.pop();
			
			if((forBlock.idxVariableCreator != null || forBlock.idxVariableAssignment != null ) && !forBlock.block.hasDefoBrokenOrContinued){
				int line = forBlock.getLine();
				int col = forBlock.getColumn();
				
				String name = forBlock.idxVariableAssignment!=null?forBlock.idxVariableAssignment.name:forBlock.idxVariableCreator.name;
				
				if(!this.currentScopeFrame.hasVariableAssigned(name)) {
					AssignNew idxVariableCreator = forBlock.getIdxVariableCreator();
					if(null != idxVariableCreator) {//HERE thing
						idxVariableCreator.accept(this);
					}
				}
				
				
				if(null == forBlock.postIdxIncremement) {
					forBlock.postIdxIncremement = new PostfixOp(line, col, FactorPostFixEnum.PLUSPLUS, new RefName(line, col, name));
					forBlock.postIdxIncremement.setShouldBePresevedOnStack(false);
				}
				forBlock.postIdxIncremement.accept(this);
			}
			
			return ret;
			
		}
		this.forWhileExpectsReturn.pop();
		return null;
	}
	
	@Override
	public Object visit(DottedNameList dottedNameList) {
		return null;//nop
	}

	@Override
	public Object visit(DottedAsName dottedAsName) {
		return null; //doesn't need to do anything
	}

	Stack<DotOperatorAndIndex> currentDotOperatorTracker = new Stack<DotOperatorAndIndex>();
	
	static class DotOperatorAndIndex
	{
		public boolean ignore=false;
		private DotOperator dop;
		private int idx = 0;
		public DotOperatorAndIndex(DotOperator dop)
		{
			this.dop = dop;
		}
		
		public DotOperatorAndIndex(boolean ignore)
		{
			this.ignore = ignore;
		}
		
		public Expression getprevious() {
			return this.dop == null? null:this.dop.getElements(null).get(idx-1);
		}
		public Expression getcurrent() {
			return this.dop.getElements(null).get(idx);
		}

		public void inc(){
			idx++;
		}
		
		public boolean isProcesingLastElement()
		{
			if(ignore){
				return true;
			}
			return idx == this.dop.getElements(null).size();
		}
		
		public boolean isLast() {
			return idx == this.dop.getElements(null).size()-1;
		}
		
		public boolean isFirst(){
			return idx == 0;
		}
	}
	
	//private Type dotOperatorLHS = null;
	Stack<Type> dotOperatorLHS = new Stack<Type>();
	Stack<List<NamedType>> traitsForSuper = new Stack<List<NamedType>>();
	//dotOperatorLHS - should be a stack because of this:
	//System.out.println("" + System.out); //when resolving the nested argument the dot operator gets wiped out... :(
	
	private void tagNextExpressionIFAsyncRefRef(int curIdx, ArrayList<Expression> elements){
		int nplus1 = curIdx + 1;
		if(elements.size() > nplus1){
			Expression e = elements.get(curIdx);
			if(e instanceof AsyncRefRef){//tag ayncref ref to check ref levels because they are need by thing on rhs.
				//e.g. a:: //no level checking needed
				//a::get() //level checking is needed
				AsyncRefRef arr = (AsyncRefRef)e;
				arr.checkRefLevels = true;
			}
		}
	}
	
	private Expression potentiallyAnUnboundFuncRef(ArrayList<Expression> elements, int n){
		/*
		 * This: myRef = MyClass[String].getLa&("hi") - naturally is interpreted as an arrayref operation returning something and then a funcRef on that
		 * But we want to interpret this as a single FuncRef operation on a NamedType, with generic bounds
		 */
		
		return null;
	}
	
	private Expression potentiallyAnImplicitRefConstructor(ArrayList<Expression> elements, int n, HashSet<Integer> canReplacewithRefNamedType){
		//Integer:RefArra(12) //this could be either a dot operator: AsyncRefRef(name) . FuncInvoke(args)
		//or it could be an implicit namedConstructor of NamedType(Integer, RefType, args)
		if(elements.size() - n - 2 >= 0){
			Expression e1 = elements.get(n);
			Expression e2 = elements.get(n+1);
			
			if(e1 instanceof AsyncRefRef && ((AsyncRefRef)e1).b instanceof RefName && e2 instanceof FuncInvoke){
				
				//try as normal, no issues, accept
				AsyncRefRef e1c = (AsyncRefRef)e1.copy();
				FuncInvoke e2c = (FuncInvoke)e2.copy();

				maskErrors();
				ArrayList<Expression> parialElements = new ArrayList<Expression>();
				parialElements.add(e1c);
				parialElements.add(e2c);
				processDotOperatorElements(null, null, 0, parialElements, null, canReplacewithRefNamedType, null, null, null);
				
				if(!maskedErrors()){//cool no errors so no adjustment required
					return null;
				}
				else{
					//otherwise, try as a namedConstructor if that works lucky you!
					maskErrors();
					
					RefName namedOn = (RefName)((AsyncRefRef)e1c).b;
					int line = e1c.getLine();
					int column = e1c.getColumn();
					NamedType nt = new NamedType(line, column, namedOn.name);
					int rr = e1c.refCntLevels;
					
					for(int na = 0; na < rr; na++){
						if(na == rr-1){
							nt = new NamedType(line, column, e2c.funName, nt);
						}
						else{
							nt = new NamedType(line, column, nt);
						}
					}
					
					New nc = new New(line, column, nt, e2c.args, true);
					nc.accept(this);
					
					if(!maskedErrors()){
						//great! a match
						return nc;//TODO: should return a copy of the origonal thing, an untouched one?
					}
				}
			}
		}
		//otherwise not a match, continue as normal with above expected failure
		return null;
	}
	
	private Type processDotOperatorElements(Type head, Node prev, int offset, ArrayList<Expression> elements, ArrayList<Boolean> returnCalledOn, HashSet<Integer> canReplacewithRefNamedType, DotOperatorAndIndex tracker,  ArrayList<Boolean> directAccess, ArrayList<Boolean> safeCall){
		
		HashMap<Integer, Expression> slotToRemapping = new HashMap<Integer, Expression>();
		
		for(int n = offset; n < elements.size(); n++){
			boolean isLast = elements.size()-1 == n;
			Expression e = elements.get(n);
			
			boolean returnSelf;
			if(returnCalledOn==null){
				returnSelf=false;
			}
			else{
				returnSelf = returnCalledOn.get(n-1);
			}
			
			boolean safeCallRet = safeCall==null?false:safeCall.get(n-1);
			
			tagNextExpressionIFAsyncRefRef(n, elements);
			
			if(head != null){
				e.setPreceededByDotInDotOperator(true);
			}
			
			//a.f = b[3].k(f.g()).z(49); <- typiucal use case
			//enter scope frame and do doings...
			if(null != prev && !e.isPermissableToGoOnRHSOfADot(prev))
			{
				this.raiseError(e.getLine(), e.getColumn(), "non suitable element detected to right hand side of dot: " + e.getClass().getSimpleName());//TODO: enhance with name of thing which is not suitable
				return null;
			}

			boolean addedTraitsForMethodCalls = false;
			if(head != null){
				if(head instanceof ModuleType && !(e instanceof ArrayRef || e instanceof RefName || e instanceof FuncRef || e instanceof FuncInvoke || e instanceof RefQualifiedGenericNamedType))
				{
					break;//error is triggered below...
				}
				
				dotOperatorLHS.push( head);
				
				if(prev instanceof RefSuper) {//if no qualifier and if in class and class has refs
					 RefSuper asSuper = (RefSuper)prev;
					 if(asSuper.superQuali == null) {
						 if(!this.currentlyInClassDef.isEmpty()) {
							 ClassDef cd = this.currentlyInClassDef.peek();
							 ArrayList<NamedType> traits = cd.getTraitsAsNamedType(0, 0, false);//dont check java interfaces
							 if(!traits.isEmpty()) {
								 traitsForSuper.push(traits);
								 addedTraitsForMethodCalls=true;
							 }
						 }
					 }
				}
			}
			
			if(!addedTraitsForMethodCalls) {
				traitsForSuper.push(null);
			}
			
			if(canReplacewithRefNamedType.contains(n)){
				//try refName, but replace with RefNamedType if it's a namedType
				maskErrors();
				Type tt = (Type)e.accept(this);
				if(maskedErrors() || tt instanceof ModuleType){//uh oh, errors, so try as a RefNamedType
					int line = e.getLine();
					int col = e.getColumn();
					RefNamedType rnt = new RefNamedType(line, col, new NamedType(line, col, ((RefName)e).name));
					maskErrors();
					rnt.accept(this);
					if(!maskedErrors()){
						//no erorrs, nice so this will work, replace e with this
						e = rnt;
						elements.set(n, rnt);//replacement for next iteration of compliation too
					}
				}
			}
			
			
			this.maskErrors(true);
			Type rhsOfDot = (Type)e.accept(this);
			ArrayList<CapMaskedErrs> errors = this.getmaskedErrors();
			if(!isLast) {
				boolean safeCallNext = safeCall==null?false:safeCall.get(n);
				validateSafeDotop(e.getLine(), e.getColumn(), safeCallNext, rhsOfDot);
			}
			
			
			if(!errors.isEmpty() || (rhsOfDot instanceof ModuleType)) {
				//TODO: must be single dot
				 ArrayList<Pair<Boolean, NullStatus>> headvect = TypeCheckUtils.getVectorizedStructure(ers, head);
				 
				 boolean directAcess = directAccess!= null && directAccess.get(n-1);
				 boolean returnSelfx = returnCalledOn!= null && returnCalledOn.get(n-1);
				 boolean safeCallx = safeCall!= null && safeCall.get(n-1);
				 
				 if(!headvect.isEmpty() && !directAcess && !returnSelfx && !safeCallx) {//See if we can auto vectorize the call, e.g. A.field -> A^field; where A is list of objects having field
					 
					 boolean isRefName = e instanceof RefName;
					 boolean isFuncInvoke = !isRefName && e instanceof FuncInvoke;
					 boolean isFuncRef = !isRefName &&  !isFuncInvoke && e instanceof FuncRef;
					 boolean isNew = !isFuncRef && !isRefName &&  !isFuncInvoke && e instanceof New;
					 if(isRefName || isFuncInvoke || isFuncRef || isNew) {
						 Type vectLHSType = TypeCheckUtils.extractVectType(head);
						 
						 boolean pass=false;
						 Type tt;
						 if(!isRefName) {
							 int x = headvect.size()-1;
							 while(!pass) {
								 this.dotOperatorLHS.push(vectLHSType);
								 this.maskErrors();
								 tt = (Type)e.accept(this);
								 this.dotOperatorLHS.pop();
								 pass = !this.maskedErrors() && TypeCheckUtils.isValidType(tt);
								 if(!pass) {//for next iteration
									 if(--x < 0) {
										 break;//fail
									 }
									 ArrayList<Pair<Boolean, NullStatus>> itm = new ArrayList<Pair<Boolean, NullStatus>>(1);
									 itm.add(headvect.get(x));
									 vectLHSType = TypeCheckUtils.applyVectStruct(itm, vectLHSType);
								 }
							 }
							 
						 }else{
							 this.dotOperatorLHS.push(vectLHSType);
							 this.maskErrors();
							 tt = (Type)e.accept(this);
							 this.dotOperatorLHS.pop();
							 pass = !this.maskedErrors() && TypeCheckUtils.isValidType(tt);
						 }
						 
						 
						 if(pass) {
							 Type prevType = this.dotOperatorLHS.pop();
							 
							 Expression vfr;
							 Expression prevEelement = elements.get(n-1);
							 if(isRefName) {
								 vfr = new VectorizedFieldRef(e.getLine(), e.getColumn(), (RefName)e, prevEelement, false, safeCallx);
							 }else if(isFuncInvoke){
								 vfr = new VectorizedFuncInvoke((FuncInvoke)e, prevEelement, false, safeCallx);
							 }else if(isFuncRef){//
								 vfr= new VectorizedFuncRef((FuncRef)e, prevEelement, false, safeCallx);
							 }else {//isNew
								 vfr= new VectorizedNew(e.getLine(), e.getColumn(), prevEelement, (New)e, false, safeCallx);
							 }
							 
							 this.maskErrors();
							 tt = (Type)vfr.accept(this);//shouldnt be any errors here....
							 if(!this.maskedErrors()) {
								 slotToRemapping.put(n-1, vfr);
								 rhsOfDot = tt;
								 errors = new ArrayList<CapMaskedErrs>();
							 }
							 
							 this.dotOperatorLHS.push(prevType);
						 }
					 }
				 }
							
				this.applyMaskedErrors(errors);
			}
			
			if(null != tracker){
				tracker.inc();
			}
			
			if(null != prev && e instanceof FuncRef){
				//special case to detect unounded funcrefs as follows:
				//e.g. MyClassName.method&(12, _ String);//etc
				FuncRef fr = (FuncRef)e;
				
				if(prev instanceof RefName){
					RefName prevRef = (RefName)prev;
					if(prevRef.resolvesTo==null || prevRef.resolvesTo.getLocation() == null){
						fr.unbounded =true;
					}
				}
				else if(prev instanceof RefQualifiedGenericNamedType){
					fr.unbounded =true;
				}
				else if(prev instanceof RefNamedType){
					fr.unbounded =true;
				}
				else if(prev instanceof AsyncRefRef){//least likely case
					AsyncRefRef arr = (AsyncRefRef)prev;
					if(arr.b instanceof RefQualifiedGenericNamedType){
						fr.unbounded =true;
					}
				}
			}
			
			if(head != null){
				if(!dotOperatorLHS.isEmpty()){//JPT: do we need this empty check?
					dotOperatorLHS.pop();
				}
				if(!traitsForSuper.isEmpty()) {
					traitsForSuper.pop();
				}
			}
			
			if(prev instanceof RefName){//denies this: MyClass.getLaTyped("hi")
				RefName rn = (RefName)prev;
				if(rn.resolvesTo !=null && rn.resolvesTo.getLocation() == null){//looks like its a pure namedTypereference, e.g. MyClass.
					if(e instanceof FuncInvoke){
						
						FuncInvoke fi = (FuncInvoke)e;
						if(null != fi.resolvedFuncTypeAndLocation && fi.resolvedFuncTypeAndLocation.getLocation() instanceof ClassFunctionLocation){
							this.raiseError(prev.getLine(), prev.getColumn(), "type cannot be used in this way");//TODO: enhance with name of thing which is not suitable
						}
						
					}
				}
			}
			
			if(prev instanceof RefQualifiedGenericNamedType){//denies this: MyClass<String>.getLaTyped("hi")
				boolean aRefName = e instanceof RefName;
				
				if(!(e instanceof RefQualifiedGenericNamedType || e instanceof RefNamedType || aRefName || e instanceof FuncRef)){
					this.raiseError(prev.getLine(), prev.getColumn(), "type cannot be used in this way");//TODO: enhance with name of thing which is not suitable
				}
				
				if(aRefName){
					RefName asRef = (RefName)e;
					if(null != asRef.resolvesTo && asRef.resolvesTo.getLocation() instanceof LocationClassField){
						this.raiseError(prev.getLine(), prev.getColumn(), "type cannot be used in this way");//TODO: enhance with name of thing which is not suitable
					}	
				}
			}
			
			if(returnSelf){
				if(!(e instanceof FuncInvoke)){//TODO: and what else can .. be used with?
					this.raiseError(e.getLine(), e.getColumn(), ".. can only be used with method calls");//TODO: enhance with name of thing which is not suitable
					returnSelf=false;
				}
			}
			
			if(!returnSelf) {
				if(safeCallRet) {
					if(!TypeCheckUtils.isVoid(rhsOfDot)) {
						rhsOfDot = TypeCheckUtils.boxTypeIfPrimative(rhsOfDot, false);
						if(null != rhsOfDot) {
							rhsOfDot.setNullStatus(NullStatus.NULLABLE);
						}
					}
				}
				
				head = rhsOfDot;
			}
			e.setTaggedType(rhsOfDot);
			
			prev=(Node)e;
		}
		
		if(!slotToRemapping.isEmpty()) {
			int offsetrep = 0;
			for(int slot : slotToRemapping.keySet()) {
				Expression replace = slotToRemapping.get(slot);
				elements.set(slot-offsetrep, replace);
				elements.remove(slot-offsetrep+1);
				offsetrep++;
			}
		}
		
		return head;
	}
	

	private List<RefNamedType> refNamedTypeToQuantify(){
		//Add all the RefNamedType's prior to current FuncRef to list
		List<RefNamedType> ret = new ArrayList<RefNamedType>();
		if(!this.currentDotOperatorTracker.isEmpty()){
			DotOperatorAndIndex dotAndIdx = this.currentDotOperatorTracker.peek();
			
			if(!dotAndIdx.ignore) {
				ArrayList<Expression> elements = dotAndIdx.dop.getElements(this);
				
				for(int n=dotAndIdx.idx-1; n >=0; n--){
					Expression expr =elements.get(n);
					if(expr instanceof RefName || expr instanceof RefQualifiedGenericNamedType || expr instanceof RefNamedType){
						if(expr instanceof RefNamedType){
							ret.add((RefNamedType) expr);
						}
					}
					else{//MyClass.Child.asd&()[1]//etc
						break;
					}
				}
			}
		}
		
		return ret;
	}
	
	private HashSet<Integer> adjustRefNamesToRefNamedType(ArrayList<Expression> elements){
		//Parent<int>.MyClass.getLa&("hi") //will indicate that the 2nd item can be converted: MyClass from RegName to RefNamedType
		//go through in reverse and tag all contigious namedTypes refnamedtype and refqualifiednamedtpye
		boolean containsFuncRef = false;
		for(Expression ele : elements){
			if(ele instanceof FuncRef){
				containsFuncRef=true;
				break;
			}
		}
		
		HashSet<Integer> ret = new HashSet<Integer>();
		
		if(containsFuncRef){//9/10 cases there is no funcRef so this logic is redudant
			int sss = elements.size();
			
			ArrayList<ArrayList<Integer>> regions = new ArrayList<ArrayList<Integer>>();
			
			ArrayList<Integer> replaceRefNameMode = null;
			for(int n=sss-1; n >=0; n--){
				Expression expr =elements.get(n);
				if(expr instanceof FuncRef){
					replaceRefNameMode = new ArrayList<Integer>();
					regions.add(replaceRefNameMode);
				}
				else if(expr instanceof RefName || expr instanceof RefQualifiedGenericNamedType || expr instanceof RefNamedType){
					if(null != replaceRefNameMode){// && expr instanceof RefName){
						//int line = expr.getLine();
						//int col = expr.getColumn();
						//elements.set(n, new RefNamedType(line, col, new NamedType(line, col, ((RefName)expr).name)));//int line, int col, NamedType mynamed
						replaceRefNameMode.add(n);
					}
				}
				else{//MyClass.Child.asd&()[1]//etc
					replaceRefNameMode=null;//reset, we are no longer in a suseptable region
				}
			}
			if(!regions.isEmpty()){
				
				ArrayList<ArrayList<Integer>> regionRelevant = new ArrayList<ArrayList<Integer>>();
				
				for(ArrayList<Integer> region : regions){
					boolean containsRefName = false;
					for(int n : region){
						if(elements.get(n) instanceof RefName){
							containsRefName=true;
							break;
						}
					}
					if(containsRefName){
						regionRelevant.add(region);
					}
				}
				
				if(!regionRelevant.isEmpty()){
					for(ArrayList<Integer> region : regionRelevant){
						int ss = region.size();
						for(int m=0; m<ss; m++){//skip the first one - so can never return 0 too!
							int n= region.get(m);
							Expression expr =elements.get(n);
							if(expr instanceof RefName){
								ret.add(n);
							}
						}
					}
				}
			}
		}
		return ret;
	}
	
	@Override
	public Object visit(NotExpression notExpression) {
		Type exprType = (Type)notExpression.expr.accept(this);
		TypeCheckUtils.assertNotVoid(exprType, this, notExpression.expr.getLine(), notExpression.expr.getColumn(), "not");
		//TypeCheckUtils.isBoolean(this, thing, notExpression.expr.getLine(), notExpression.expr.getColumn());
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(exprType);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = lhsvec.getA();
		if(vectorized  != null) {
			exprType = lhsvec.getB();
			notExpression.depth = vectorized;
		}
		
		Type ret;
		FuncInvoke overloaded = canBeOperatorOverloaded(exprType, new ArrayList<Type>(), null, "not",  new ArrayList<Expression>(), notExpression.expr.getLine(), notExpression.expr.getColumn(), false, null, false, notExpression.astOverrideOperatorOverload);
		if(null != overloaded){
			notExpression.astOverrideOperatorOverload = overloaded;
			this.dotOperatorLHS.push(exprType);
			ret = (Type)notExpression.astOverrideOperatorOverload.accept(this);
			this.dotOperatorLHS.pop();
		}
		else{
			ret = new PrimativeType(PrimativeTypeEnum.BOOLEAN);
		}
		
		if(vectorized != null) {
			if(ret != null) {
				ret = TypeCheckUtils.applyVectStruct(vectorized, ret);
			}
		}
		
		notExpression.setTaggedType(ret);
		return ret;
	}
	
	
	@Override
	public Object visit(ElvisOperator elvisOperator) {
		Type lhsType = (Type)elvisOperator.lhsExpression.accept(this);
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(lhsType);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = lhsvec.getA();
		if(vectorized  != null) {
			lhsType = lhsvec.getB();
			elvisOperator.depth = vectorized;
		}

		if(null != TypeCheckUtils.assertNotVoid(lhsType, this, elvisOperator.lhsExpression.getLine(), elvisOperator.lhsExpression.getColumn(), "elvis operator ?:") && TypeCheckUtils.isValidType(lhsType)) {
			if(vectorized == null && lhsType.getNullStatus() == NullStatus.NONNULL) {
				this.raiseError(elvisOperator.getLine(), elvisOperator.getColumn(), "Elvis operator ?: may only be used on nullable or potentially nullable types");
			}
		}
		
		lhsType = (Type)lhsType.copy();
		lhsType.setNullStatus(NullStatus.NONNULL);
		
		Type rhsType = (Type)elvisOperator.rhsExpression.accept(this);

		TypeCheckUtils.assertNotVoid(rhsType, this, elvisOperator.rhsExpression.getLine(), elvisOperator.rhsExpression.getColumn(), "elvis operator ?:");
		
		List<Type> typeChoices = new ArrayList<Type>(2);
		Map<Type, Pair<Integer, Integer>> typeOffenders = new HashMap<Type, Pair<Integer, Integer>>();
		
		typeChoices.add(lhsType);
		typeChoices.add(rhsType);
		typeOffenders.put(lhsType, new Pair<Integer, Integer>(elvisOperator.lhsExpression.getLine(), elvisOperator.lhsExpression.getColumn()));
		typeOffenders.put(rhsType, new Pair<Integer, Integer>(elvisOperator.rhsExpression.getLine(), elvisOperator.rhsExpression.getColumn()));
		
		Type got = getMostGenericGeneric(typeChoices, typeOffenders, elvisOperator.getLine(), elvisOperator.getColumn(), false);
		
		if(vectorized != null) {
			if(got != null) {
				got = TypeCheckUtils.applyVectStruct(vectorized, got);
			}
		}
		
		return elvisOperator.setTaggedType(got);
	}
	
	
	@Override
	public Object visit(NotNullAssertion notNullAssertion) {
		Type rhs = (Type)notNullAssertion.expr.accept(this);
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(rhs);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = lhsvec.getA();
		if(vectorized  != null) {
			rhs = lhsvec.getB();
			notNullAssertion.depth = vectorized;
		}
		
		/*if(null != TypeCheckUtils.assertNotVoid(rhs, this, notNullAssertion.expr.getLine(), notNullAssertion.expr.getColumn(), "not null assertion ??") && TypeCheckUtils.isValidType(rhs)) {
			if(vectorized == null && rhs.getNullStatus() == NullStatus.NONNULL) {
				this.raiseError(notNullAssertion.getLine(), notNullAssertion.getColumn(), "Non null assertion ?? may only be applied to nullable or potentially nullable types");
			}
		}*/

		if(rhs != null) {
			rhs = (Type)rhs.copy();
			rhs.setNullStatus(NullStatus.NONNULL);
			
			if(vectorized != null) {
				
					rhs = TypeCheckUtils.applyVectStruct(vectorized, rhs);
			}
		}
		
		return notNullAssertion.setTaggedType(rhs);
	}
	
	
	
	
	@Override
	public Object visit(DotOperator dotOperator) {
		
		DotOperatorAndIndex tracker = new DotOperatorAndIndex(dotOperator);
		currentDotOperatorTracker.push(tracker);
		ArrayList<Expression> elements = dotOperator.getElements(this);//expected to return true origonal elements for processing, not adjusted as par below

		/*if(elements.size()==1) {
			Type got = (Type)elements.get(0).accept(this);
			return dotOperator.setTaggedType(got);
		}*/
		
		for(Expression e : elements){//useful for check in RefQualifiedGenericNamedType - since it cannot go on its own
			if(e instanceof RefQualifiedGenericNamedType){
				((RefQualifiedGenericNamedType)e).isInDotOperator=true;
			}
		}
		
		Expression hh = dotOperator.getHead(this);
		
		HashSet<Integer> canReplacewithRefNamedType = adjustRefNamesToRefNamedType(elements);//useful to deted unbounded func ref: xx = Parent.MyClass.getLa&("hi", 12)
		
		Expression replace = potentiallyAnImplicitRefConstructor(elements, 0, canReplacewithRefNamedType);
		//int offset = 1;
		if(null != replace){//going to be on the first one anyway
			//try as normal, then try as a NamedConstructor, first one works, do nothing, second one works, rewrite dotoperator for later stages (should be ok)
			hh = replace;
			
			ArrayList<Expression> elementsOrig = elements;
			ArrayList<Boolean> isDirectOrig = dotOperator.getIsDirectAccess(this);
			ArrayList<Boolean> newisDirectOrig = new ArrayList<Boolean>(isDirectOrig.size()-1);
			
			elements = new ArrayList<Expression>();
			elements.add(replace);
			for(int m = 2; m < elementsOrig.size(); m++){
				elements.add(elementsOrig.get(m));
				newisDirectOrig.add(isDirectOrig.get(m));//TODO: bug? as newisDirectOrig doesnt get set anywhere...?
			}
			dotOperator.adjustedElements = elements;
		}
		else{
			dotOperator.adjustedElements = null;
		}
		
		tagNextExpressionIFAsyncRefRef(0, elements);
		
		if(canReplacewithRefNamedType.contains(0)){//first item may actually be a RefNamedType instead of a RefName
			maskErrors();
			int line = hh.getLine();
			int col = hh.getColumn();
			RefNamedType rnt = new RefNamedType(line, col, new NamedType(line, col, ((RefName)hh).name));
			rnt.accept(this);
			if(!maskedErrors()){
				//no erorrs, nice so this will work, replace e with this
				hh = rnt;
				elements.set(0, hh);//replacement for next iteration of compliation too
			}
		}
		
		Type head = (Type)hh.accept(this);
		
		validateSafeDotop(hh.getLine(), hh.getColumn(), dotOperator.safeCall.get(0), head);
		
		hh.setTaggedType(head);
		tracker.inc();
		//boolean first=true;
		Node prev = (Node)hh;
		
		head = processDotOperatorElements(head, prev, 1, elements, dotOperator.returnCalledOn, canReplacewithRefNamedType, tracker, dotOperator.getIsDirectAccess(this), dotOperator.safeCall);//i think returnCalledOn needs no adjustment
		
		if(head instanceof ModuleType)
		{//...here!
			ModuleType mt = (ModuleType)head;
			this.raiseError(dotOperator.getLine(), dotOperator.getColumn(), String.format("Unable to resolve reference to variable name: " + mt.getNameSoFar()));
		}
		
		dotOperator.setTaggedType(head);
		
		currentDotOperatorTracker.pop();
		
		return head;
	}
	
	private void validateSafeDotop(int line, int col, boolean safeCall, Type head) {
		if(safeCall) {//safe call
			//rhs must be null or nullable
			if(!TypeCheckUtils.isNullable(head) && !TypeCheckUtils.isUnknown(head)) {
				this.raiseError(line, col, "expression before ?. is expected to be nullable");
			}
		}else {
			if(!(head instanceof VarNull) && TypeCheckUtils.isNullable(head)) {
				this.raiseError(line, col, "expression before . might be null");
			}
		}
	}

	private final Stack<NotifyOnError> notifyOnError = new Stack<NotifyOnError>();
	
	private boolean checkContinueBreakInRightPlace(boolean isContinue, int line, int col)
	{
		//search up until u get into a scopeframe that permitts prescence of the continue or break stmt
		//unless you hit a: function, class, asyncblock or normal block (since sep worker) or module, barrier block, or with
		
		TheScopeFrame frame = this.currentScopeFrame;
		while(null != frame)
		{
			if( null == frame.canContainAContinueOrBreak )
			{
				frame = frame.getParent();
				//return true;
				//System.err.println(frame +"" + this.currentScopeFrame.getParent());
			}
			else
			{
				if(true != frame.canContainAContinueOrBreak)
				{
					if(isContinue){
						this.raiseError(line, col, "continue cannot be used outside of a loop or inside a parallel for loop");
					}
					else{
						this.raiseError(line, col, String.format("break cannot be used outside of a loop, onchange, every, await or async block or inside a parallel for loop"));
					}
					
					return false;
				}
				return true;
			}
		}
		return true;
	}
	
	private Stack<Pair<Boolean, String>> forWhileExpectsReturn = new Stack<Pair<Boolean, String>>();
	
	@Override
	public Object visit(ContinueStatement continueStatement) {
		if(continueStatement.isSynthetic || checkContinueBreakInRightPlace(true, continueStatement.getLine(), continueStatement.getColumn())){//skip this check for synthetic continues
			continueStatement.setIsValid(true);
			Pair<Boolean, String> ctxt = forWhileExpectsReturn.peek();
			continueStatement.setIsAsyncEarlyReturn(ctxt.getB().equals("onchange"));
			if(continueStatement.returns != null){
				if(!ctxt.getA()){
					this.raiseError(continueStatement.getLine(), continueStatement.getColumn(), "continue statement cannot return value");
				}
				
				Type got = (Type)continueStatement.returns.accept(this);
				Type orig = got;
				got = TypeCheckUtils.getRefTypeToLocked(got);
				if(TypeCheckUtils.isValidType(got)){
					TypeCheckUtils.checkSubType(this, got, orig, continueStatement.getLine(), continueStatement.getColumn(), continueStatement.getLine(), continueStatement.getColumn(), false);
				}
				
				
				if(!TypeCheckUtils.isValidType(got)){
					this.raiseError(continueStatement.getLine(),continueStatement.getColumn(), "continue statement must return something");
					got = const_void_thrown;
				}
				continueStatement.setTaggedType(got);
				return got;
			}
			/*else if(forWhileExpectsReturn.peek()){
				this.raiseError(continueStatement.getLine(), continueStatement.getColumn(), "continue statement should return a value");
			}*/ //ok we permit this not returning anything
		}
		else{
			continueStatement.setIsValid(false);
		}
		continueStatement.setTaggedType(const_void_thrown);
		return const_void_thrown;
	}

	@Override
	public Object visit(BreakStatement breakStatement) {
		
		
		Type got;
		
		if(checkContinueBreakInRightPlace(false, breakStatement.getLine(), breakStatement.getColumn())){
			breakStatement.setIsValid(true);
			Pair<Boolean, String> ctxt = forWhileExpectsReturn.peek();
			breakStatement.setIsAsyncEarlyReturn(ctxt.getB().equals("onchange"));
			
			if(breakStatement.returns != null){
				if(!ctxt.getA()){
					this.raiseError(breakStatement.getLine(), breakStatement.getColumn(), "break statement cannot return value");
				}
				
				got = (Type)breakStatement.returns.accept(this);
				Type orig = got;
				got = TypeCheckUtils.getRefTypeToLocked(got);
				
				if(TypeCheckUtils.isValidType(got)){
					TypeCheckUtils.checkSubType(this, got, orig, breakStatement.getLine(), breakStatement.getColumn(), breakStatement.getLine(), breakStatement.getColumn(), false);
				}
				
				if(!TypeCheckUtils.isValidType(got)){
					this.raiseError(breakStatement.getLine(),breakStatement.getColumn(), "break statement must return something");
					got = const_void_thrown;
				}
			}
			else{
				got = const_void_thrown;
			}
			/*else if(forWhileExpectsReturn.peek()){
				this.raiseError(breakStatement.getLine(), breakStatement.getColumn(), "break statement should return a value");
			} //ok we permit this not returning anything
*/			
		}
		else{
			breakStatement.setIsValid(false);
			got = const_void_thrown;
		}
		
		breakStatement.setTaggedType(got);
		return got;
	}

	
	@Override
	public Object visit(ClassDefArgs classDefArgs) {
		for(ClassDefArg cda : classDefArgs.aargs)
		{
			cda.accept(this);
		}
		return null;
	}

	@Override
	public Object visit(ClassDefArg classDefArg) {
		//unused
		classDefArg.type = (Type) classDefArg.type.accept(this);
		return null;
	}
	
	private GenericType fromNamedTypeToGenericType(Type tt){
		if(tt instanceof NamedType){
			NamedType asNamed =(NamedType)tt;
			if(!asNamed.isGeneric()){
				//on nice its generic use it as that
				GenericType ret = new GenericType(asNamed.getNamedTypeStr(),0); 
				ret.splicedIn = true;
				return ret; 
			}
		}
		return null;
	}
	
	
	
	private ClassDef processTraits(String ifaceItem, List<Type> interfaceGenricList, Map<Type, Type> iffaceTypeToClsGeneric , ClassDef classDef, TheScopeFrame classSF, TheScopeFrame parentDF, Type typedActorResolvesTo, boolean parentIsClosedErr, boolean supressConstructors, LinkedHashMap<Pair<String, TypeAndLocation>, Pair<String, TypeAndLocation>> superClassAbstractMethodsToFulfill, List<Fiveple<String, ClassDef, Type, Boolean, AccessModifier>> traitAbstractFieldsToFulfill){
		Thruple<ClassDef, Boolean, Boolean> got = processSuperOrTraitClass(true, ifaceItem, classDef, interfaceGenricList, iffaceTypeToClsGeneric, classSF, parentDF, typedActorResolvesTo, parentIsClosedErr, supressConstructors, superClassAbstractMethodsToFulfill, traitAbstractFieldsToFulfill);
		
		return got.getA();
	}
	
	
	private Thruple<ClassDef, Boolean, Boolean> processSuperOrTraitClass(boolean isTrait, String superOrMixinClass, ClassDef classDef, List<Type> declaredGenericTypesForThing, Map<Type, Type> supOrIfaceTypeToClsGeneric, TheScopeFrame classSF, TheScopeFrame parentDF, Type typedActorResolvesTo, boolean parentIsClosedErr, boolean supressConstructors, LinkedHashMap<Pair<String, TypeAndLocation>, Pair<String, TypeAndLocation>> superClassAbstractMethodsToFulfill, List<Fiveple<String, ClassDef, Type, Boolean, AccessModifier>> traitFields){
		String classNameforError = classDef.isAnonClass ? "Anonymous Class" : classDef.className;
		
		String whatme = isTrait?"trait":"superclass";
		String whatmeExt = isTrait?"implement":"extend";
		String whatmeExted = isTrait?"implemented":"extended";
		
		ClassDef superOrMixinClassDef = parentDF.getClassDef(classSF, superOrMixinClass, true, false);
		
		if(null == superOrMixinClassDef){ //try to look globally...
			superOrMixinClassDef = getImportedClassDef(superOrMixinClass);
		}
		
		ClassDef retClassDef = null;
		
		if(null == superOrMixinClassDef){
			this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("%s cannot resolve reference to %s: %s", classNameforError, whatme, superOrMixinClass));
		}
		else if(classDef.getPrettyName().equals(superOrMixinClassDef.getPrettyName())){
			this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Cycle detected: the class %s cannot %s itself", classDef.getPrettyName(), whatmeExt));
		}
		else
		{
			if(!isTrait){
				if(superOrMixinClassDef.isNestedAndNonStatic())
				{
					AccessModifier am = superOrMixinClassDef.accessModifier;
					ClassDef parNestor = classDef.getParentNestor();
					
					ClassDef supParent = superOrMixinClassDef.getParentNestor();
					
					if(null == parNestor){
						this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Class: %s cannot be the subclass of nested class: %s - it must be nested within a subclass of: %s", classNameforError, classDef.superclass, supParent.className));
					}
					else{
						if(am != AccessModifier.PRIVATE){//thing extending must be protected or public
							
							if(!parNestor.isBeingBeingPastTheParentOfMe(supParent)){
								//and class in which your nested must extend thing in which it's nested too
								this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Nested class: %s cannot be the subclass of: %s - parent nestor must be subclass of: %s", classNameforError, classDef.superclass, supParent.className));
							}
							
						}
						else{
							this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Nested class: %s cannot be the subclass of private nested class: %s", classNameforError, classDef.superclass));
						}
					}
				}
				
				if(superOrMixinClassDef.isEnum){
					this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("%s cannot extend class: %s as it is an enum", classNameforError, superOrMixinClass));
					parentIsClosedErr = true;//supress hashcode etc genneration
				}
			}
			
			
			if( superOrMixinClassDef.isfinal() )
			{
				parentIsClosedErr = true;
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("%s cannot %s: %s as it is closed", classNameforError, whatmeExt, superOrMixinClass));
			}
			else{
				if(!isTrait){
					if(superOrMixinClassDef.isInterface()){
						if(classDef.isAnonClass && classDef.traits.isEmpty()) {//move the superclass ref to be an iface
							classDef.traits.add(new ImpliInstance(classDef.getLine(), classDef.getColumn(), classDef.superclass, classDef.superClassGenricList));
							classDef.superclass = null;
							classDef.superClassGenricList = null;
							
						}else {
							parentIsClosedErr = true;
							this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("%s cannot %s: %s as it is a trait", classNameforError, whatmeExt, superOrMixinClass));
						}
					}
				}
			}
			
			if(UncallableMethods.UNAVAILABLE_CLASSES.contains(superOrMixinClassDef)){//this is now mostly redundant as java system classes cannot be extended
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Class %s cannot be %s", superOrMixinClassDef, whatmeExted));
			}
			
			if(!classDef.isGennerated && !classDef.isActor && UncallableMethods.UNEXTENDABLE_ACTOR_CLASSES.contains(superOrMixinClassDef)){//this is now mostly redundant as java system classes cannot be extended
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Class %s cannot be %s", superOrMixinClassDef, whatmeExted));
			}
			
			if(!isTrait){
				boolean superClassActor = TypeCheckUtils.isTypedOrUntypedActor(this.getErrorRaiseableSupression(),  new NamedType(0, 0, superOrMixinClassDef));
				boolean superClassTypedActor = TypeCheckUtils.isTypedActor(this.getErrorRaiseableSupression(),  new NamedType(0, 0, superOrMixinClassDef));
				
				boolean meTyped = classDef.istypedActor && typedActorResolvesTo!=null;
				
				if(classDef.isActor && !superClassActor){
					String what = (meTyped?"typed":"untyped");
					this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("%s actors can only extend %s actors, not class: %s", what, what, superOrMixinClassDef));
					
					superOrMixinClassDef=meTyped?const_typed_actor_class:const_actor_class;
					supressConstructors=true;
				}
				
				if(!classDef.isActor && superClassActor){
					String what = superClassTypedActor?"typed":"untyped";
					this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("classes can only extend classes, not %s actor: %s", what, superOrMixinClassDef));
					supressConstructors=true;
				}
				
				if(classDef.isActor && superClassActor){
					if(meTyped && meTyped != superClassTypedActor){
						String whatmex = meTyped?"typed":"untyped";
						String whatsup = superClassTypedActor?"typed":"untyped";
						this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("%s actor cannot extend %s actor: %s", whatmex, whatsup, superOrMixinClassDef));
						supressConstructors=true;
					}
				}
			}
			
			//map to right index
			
			//isInterface
			ArrayList<GenericType> neededGenericTypes = superOrMixinClassDef.getClassGenricList();
			
			if(neededGenericTypes != null && !neededGenericTypes.isEmpty())
			{//if actually has generic nonsense...
				if(declaredGenericTypesForThing == null || neededGenericTypes.size() != declaredGenericTypesForThing.size())
				{
					this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Expected %s %s generic params but there are: %s", neededGenericTypes.size(), whatme, classDef.superClassGenricList.size() ));
				}
				else
				{
					ArrayList<Type> newSuperGenericListWithGensColoredIn = new ArrayList<Type>();
					int hh = 0;
					for(int nn = 0; nn < neededGenericTypes.size(); nn++)
					{
						GenericType superClassGenType = neededGenericTypes.get(nn);
						Type tryToFit = declaredGenericTypesForThing.get(nn);
						
						if(tryToFit instanceof NamedType)
						{//JPT: refactor this
							String name = ((NamedType)tryToFit).getNamedTypeStr();
							//chekc to see if name is in generic type list defined
							GenericType matchInclas = GenericTypeUtils.isGenTypeInList(name, classDef.classGenricList);
							if(null != matchInclas)
							{//oh so the thing gets bound by the childclass, lovely
								/*if(((NamedType) tryToFit).getSetClassDef()==null){
									newSuperGenericListWithGensColoredIn = null;//give up
									break;//uh oh!
								}*/
								
								if(((NamedType) tryToFit).isGeneric())
								{
									this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("The type %s is not generic; it cannot be parameterized with arguments", name ));
									newSuperGenericListWithGensColoredIn = null;//give up
									break;
								}
								GenericType supClassThingAsGeneric = new GenericType(classDef.getLine(), classDef.getColumn(), name, hh);
								supClassThingAsGeneric.upperBound = matchInclas.upperBound.copyTypeSpecific();
								
								if(!supOrIfaceTypeToClsGeneric.containsKey(superClassGenType)){
									matchInclas = matchInclas.copyTypeSpecific();
									matchInclas.upperBound = superClassGenType.upperBound;
									
									supOrIfaceTypeToClsGeneric.put(superClassGenType, matchInclas);
								}
								newSuperGenericListWithGensColoredIn.add(supClassThingAsGeneric);
							}
							else
							{
								tryToFit = (Type)tryToFit.accept(this);
								if(!supOrIfaceTypeToClsGeneric.containsKey(superClassGenType) && null != tryToFit)
								{
									supOrIfaceTypeToClsGeneric.put(superClassGenType, tryToFit);
								}
								newSuperGenericListWithGensColoredIn.add(tryToFit);
							}
						}
						else
						{
							tryToFit = null==tryToFit?null:(Type)tryToFit.accept(this);
							if(!supOrIfaceTypeToClsGeneric.containsKey(superClassGenType) && null != tryToFit)
							{
								supOrIfaceTypeToClsGeneric.put(superClassGenType, tryToFit);
							}
							newSuperGenericListWithGensColoredIn.add(superClassGenType);
						}
						
						Type got = TypeCheckUtils.checkSubType(this.ers, superClassGenType, tryToFit, 0,0,0,0);
						if(got == null)
						{//ensure that generic declaration is of the correct type
							this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Generic type refernce at index: %s is not compatible with %s definiton. %s is not equal to or a subtype of %s", nn, whatme, superClassGenType, tryToFit));
							if(!(tryToFit instanceof NamedType)) {//alow progress in convertion to generic type, but if generic type and still failing (e..g incompatable upper bound etc), the wipe this element out
								newSuperGenericListWithGensColoredIn.remove(newSuperGenericListWithGensColoredIn.size()-1);
								newSuperGenericListWithGensColoredIn.add(null);
							}
						}
						
						hh++;
					}
					if(null != newSuperGenericListWithGensColoredIn && !newSuperGenericListWithGensColoredIn.contains(null)){
						declaredGenericTypesForThing.clear();
						declaredGenericTypesForThing.addAll(newSuperGenericListWithGensColoredIn);
					}
					
				}
			}else if(!declaredGenericTypesForThing.isEmpty()) {
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("%s %s does not expect generic type arguments", superOrMixinClassDef.isTrait?"trait":"class", superOrMixinClassDef));
			}
			
			if(classDef.isGeneric() && null !=  TypeCheckUtils.checkSubType(this.ers, throwableNT, new NamedType(classDef.getLine(), classDef.getColumn(), superOrMixinClassDef), classDef.getLine(), classDef.getColumn(), classDef.getLine(), classDef.getColumn())  ){
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("The generic class %s cannot %s %s", classDef, whatme, throwableNT ));
			}
			
			retClassDef = superOrMixinClassDef;
			//classDef.setResolvedSuperType(this, superClassDef);
			
			if(superOrMixinClassDef.isBeingBeingPastTheParentOfMe(classDef))
			{//check that A extends B, B extends A. type ref is not circular
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Circular inheritance reference detected for: %s", classDef.getPrettyName()));
			}
			
			superOrMixinClassDef.getAbstractMethods(supOrIfaceTypeToClsGeneric/*classDef.superclassTypeToClsGeneric*/).stream().forEach(x -> superClassAbstractMethodsToFulfill.put(x,  x));
			
			//superClassAbstractMethodsToFulfill.addAll(superOrMixinClassDef.getAbstractMethods(supOrIfaceTypeToClsGeneric/*classDef.superclassTypeToClsGeneric*/));
			
			traitFields.addAll(superOrMixinClassDef.getTraitFields(supOrIfaceTypeToClsGeneric));
		}
		
		return new Thruple<ClassDef, Boolean, Boolean>(retClassDef, parentIsClosedErr, supressConstructors);
	}
	
	@Override
	public Object visit(ClassDef classDef)
	{
		String className = classDef.className;
		String classNameForErrors = classDef.isAnonClass?"Anonymous Class" : classDef.className;

		if(this.currentScopeFrame.isAnnotation){
			this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("class: %s cannot be defined within annotation", classNameForErrors));
		}
		
		if(!this.currentlyInClassDef.isEmpty()){
			if(this.currentlyInClassDef.peek().isEnumSubClass){
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("%s cannot be defined inside enum elements", classDef.isActor?"actors": "classes"));
				return null;
			}
		}
		
		Annotations annotationsForConstructor=null;
		HashSet<WarningVariant> toSupressWarnings=null;
		if(classDef.annotations != null){
			for(Annotation annot : classDef.annotations.annotations){
				annot.location = Annotation.AnnotationLocation.CLASS;
			}
			classDef.annotations.setUsedAt(ElementType.TYPE);
			classDef.annotations.accept(this);
			annotationsForConstructor = extractAnnotationsForElement(classDef.annotations, "this", false);//only this ones, default applies to class level
			
			if(null != annotationsForConstructor && (classDef.classDefArgs == null || classDef.classDefArgs.aargs.isEmpty())){
				this.raiseError(classDef.annotations.getLine(), classDef.annotations.getColumn(), "class level arguments must be provided in order to use 'this' annnotation location");
			}
			
			toSupressWarnings = Utils.extractSuppressedWarningsFromAnnotations(classDef.annotations, this);
		}
		
		if(classDef.isTransient || classDef.isShared) {
			//JPT: can only be one or the other, not both...
			boolean addTrans = classDef.isTransient;
			boolean adShared = classDef.isShared;
			if(classDef.annotations == null) {
				classDef.annotations = new Annotations(classDef.getLine(), classDef.getColumn(), new ArrayList<Annotation>(1));
			}else {//see if annotation exists already
				for(Annotation annot : classDef.annotations.annotations) {
					if(annot.getTaggedType().equals(const_transientAnnot)) {
						addTrans = false;
					}
					
					if(annot.getTaggedType().equals(const_sharedAnnot)) {
						adShared = false;
					}
					
					if(!addTrans && !adShared) {
						break;
					}
					
				}
			}
			
			if(addTrans) {
				Annotation annot = new Annotation(classDef.getLine(), classDef.getColumn(),"com.concurnas.lang.Transient" , null, null, new ArrayList<String>(0));
				classDef.annotations.annotations.add(annot);
				annot.accept(this);
			}
			
			if(adShared) {
				Annotation annot = new Annotation(classDef.getLine(), classDef.getColumn(), const_SharedStr , null, null, new ArrayList<String>(0));
				classDef.annotations.annotations.add(annot);
				annot.accept(this);
			}
		}
		
		Annotation traitAnnotation = null;
		/*if(classDef.injectClassDefArgsConstructor && (classDef.classDefArgs == null || classDef.classDefArgs.aargs.isEmpty())) {
			this.raiseError(classDef.getLine(), classDef.getColumn(), "class required class definition level arguments in or oder to be injected");
		}*/
		
		if(classDef.isTrait) {
			boolean addTrait = true;
			if(classDef.annotations == null) {
				classDef.annotations = new Annotations(classDef.getLine(), classDef.getColumn(), new ArrayList<Annotation>(1));
			}else {//see if annotation exists already
				for(Annotation annot : classDef.annotations.annotations) {
					//Type tt = annot.getTaggedType();
					//boolean isTrait = tt != null ? tt.equals(const_transientTrait) : annot.className.equals("com.concurnas.lang.Trait");
					
					if(annot.className.equals("com.concurnas.lang.Trait")) {
						addTrait = false;
						traitAnnotation = annot;
					}
				}
			}
			
			if(addTrait) {
				Annotation annot = new Annotation(classDef.getLine(), classDef.getColumn(),"com.concurnas.lang.Trait" , null, null, new ArrayList<String>(0));
				classDef.annotations.annotations.add(annot);
				annot.accept(this);
				traitAnnotation = annot;
			}
		}
		
		
		boolean parentIsClosedErr=false;
		
		TheScopeFrame parentDF = this.currentScopeFrame;
		if(!(parentDF.isClass() || parentDF.paThisIsModule))
		{
			//this.raiseError(classDef.getLine(), classDef.getColumn(), "Classes can only be defined within modules or nested within classes, local classes are not supported");
			//return null;
		}
		
		if(parentDF.isClass()){//note in the parent, it's got kids!
			parentDF.getClassDef().hasNestedChildren= true; 
		}
		
		
		classDef.packageName = getFullyDottedPackage();
		TheScopeFrame classSF = classDef.getScopeFrameGenIfMissing(this.currentScopeFrame, classDef);
		this.currentScopeFrame = classSF;
		this.currentScopeFrame.enterScope();
		if(null != toSupressWarnings){
			this.currentScopeFrame.setSuppressedWarnings(toSupressWarnings);
		}
		
		currentConstructorCallGraph.push(new HashMap<ConstLocationAndType, Type>());
		
		boolean currentlyInIsolatedBlock = !this.currentlyInBlock.isEmpty() && this.currentlyInBlock.peek().isolated;
		
		{
			boolean islocal = !this.currentlyInRet.isEmpty() || currentlyInIsolatedBlock;
			if(islocal){
				if(!this.currentlyInBlock.isEmpty() && this.currentlyInBlock.peek().isClass){
					islocal=false;//not local class if nested within a local class at the top level (like a normal local class)
				}
			}
			classDef.setIsLocalClass(islocal);
		}
		
		
		if(classDef.isLocalClass && classDef.toString().equals("Local2")){
			classDef.isLocalClass=false;
		}
		
		if(classDef.isLocalClass){
			/*if(!this.currentlyInBlock.isEmpty() && this.currentlyInBlock.peek().isClass){
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("local class: '%s' cannnot be nested" , className));
			}*/
			
			if(null != classDef.accessModifier && classDef.accessModifier != AccessModifier.PRIVATE){
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("local class: '%s' can only be declared private" , classNameForErrors));
			}
			
			this.level++;
		}
		
		if(null != parentDF)
		{
			if(parentDF.hasClassDef(parentDF, className, false, true))
			{
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Class name has already been declared in current scope: '%s'" , classNameForErrors));
			}
			else if(getImportOrUsingBeenRegisteredRaw(className) || scopedshortNameToLongNameaa.get(0).containsKey(className) /* hasImportBeenRegistered(className, false)*/ ){
				//top level has basic imports like Enum etc
				this.raiseWarning(classDef.getLine(), classDef.getColumn(), "Class name overwrites imported class: " + classNameForErrors, WarningVariant.REDEFINE_IMPORT);
			}
			
			//if(null != this.currentScopeFrame.getParent() && parentDF.hasClassDef(this.currentScopeFrame.getParent(), className, true))
			if( parentDF.hasClassDef(parentDF, className, true, true))
			{
				/*boolean isNestedInParentSameName=false;
				for(ClassDef cd : this.currentlyInClassDef){
					if(cd.getClassName().equals(className)){
						isNestedInParentSameName=true;
						break;
					}
				}*/
				
				if(!classDef.isLocalClass){
					this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("The nested type: '%s' cannot hide an enclosing type: '%s'" , classNameForErrors, classNameForErrors));
				}
				
				/*if(isNestedInParentSameName){
				}*/
			}
		}
		
		parentDF.setClassDef(classSF, className, classDef, Modifier.PUBLIC);
		
		if(!this.currentlyInClassDef.isEmpty() && !classDef.isLocalClass)
		{//if inner, then mark parent
			classDef.setParentNestor(this.currentlyInClassDef.lastElement());

			if(classDef.isTrait) {
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("traits cannot be nested"));
			}
			
			if(this.currentlyInClassDef.peek().isTrait) {
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("traits cannot nest classes, actors or traits"));
			}
						
			if(classDef.isActor){
				//technicall they can
				//JPT: version 2 permit this
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("actor classes cannot be nested"));
			}
		}
		

		Type typedActorResolvesTo = null;
		boolean isUnqualifiedTypedActor = false;
		boolean supressErrorsInClass = false;
		//Actor
		if(classDef.typedActorOn != null){
			this.maskErrors(true);
			Type resolvesTo = (Type)classDef.typedActorOn.accept(this);
			ArrayList<CapMaskedErrs> errs = this.getmaskedErrors();
			
			
			if(resolvesTo instanceof NamedType) {
				ClassDef accd = ((NamedType)resolvesTo).getSetClassDef();
				if(accd.isTrait) {
					this.raiseError(classDef.getLine(), classDef.getColumn(), accd + " is a trait. Actors cannot act on traits.");
				}
			}
			
			if(null != errs && !errs.isEmpty() ){//there were erorrs so try it as a generic type
				
				if(!classDef.permitGenericInterOfTypedArg) {
					this.raiseError(classDef.getLine(), classDef.getColumn(), "Cannot create actor on non type entity");
				}else {
					typedActorResolvesTo = fromNamedTypeToGenericType(classDef.typedActorOn);
					if(null != typedActorResolvesTo){//its generic!
						typedActorResolvesTo.accept(this);
						isUnqualifiedTypedActor=true;
						if(!classDef.acteeClassExpressions.isEmpty()){//actor AbstractActor of XMan(12) //no
							this.raiseError(classDef.getLine(), classDef.getColumn(), "abstract typed actors cannot have actee arguments");
						}
					}
					else{//cannot be used as a generic, so treat as named type and report errors
						applyMaskedErrors(errs);
					}
				}
			}
			else{
				typedActorResolvesTo = resolvesTo;
			}
			
			if(null != typedActorResolvesTo){
				if(!(typedActorResolvesTo instanceof NamedType) && !(typedActorResolvesTo instanceof GenericType)){
					this.raiseError(classDef.typedActorOn.getLine(), classDef.typedActorOn.getColumn(), "actors can only be created for classes");
				}
				else if((typedActorResolvesTo instanceof NamedType) && ((NamedType)typedActorResolvesTo).getSetClassDef() != null && ((NamedType)typedActorResolvesTo).getSetClassDef().isEnum ){
					this.raiseError(classDef.typedActorOn.getLine(), classDef.typedActorOn.getColumn(), "actors can only be created for classes not enums");
					parentIsClosedErr = true;//hack to supress hashcode etc genneration
				}
				else if(typedActorResolvesTo instanceof NamedType && TypeCheckUtils.isTypedActor(this, (NamedType)typedActorResolvesTo)){//TODO: when generics can have upper bounds, ensure upper bound is non actor in this check
					this.raiseError(classDef.typedActorOn.getLine(), classDef.typedActorOn.getColumn(), String.format("actors cannot have actors as actees. %s is already an actor", resolvesTo));
					supressErrorsInClass=true;
				}
				/*else if(typedActorResolvesTo instanceof NamedType){
					ClassDef taCd = ((NamedType)typedActorResolvesTo).getSetClassDef();
					if(null == taCd || taCd.isLocalClass){
						this.raiseError(classDef.typedActorOn.getLine(), classDef.typedActorOn.getColumn(), String.format("%s is a local class. Actors cannot operate on local classes.", resolvesTo));
					}
				}*/
			}
		}
		
		if(classDef.istypedActor && !classDef.isActor){
			String on = classDef.typedActorOn==null?" something": ": " + classDef.typedActorOn.toString();
			this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("%s must be declared as an actor to act on%s", classNameForErrors, on));
		}
		
		
		if(classDef.isTrait) {
			if(null == classDef.isFinalDefined) {
				classDef.isFinalDefined = "open";
			}else if(classDef.isFinalDefined.equals("closed")) {
				this.raiseError(classDef.getLine(), classDef.getColumn(), "traits cannot be closed");
			}
		}
		
		if(classDef.istypedActor && isUnqualifiedTypedActor){
			if(null != classDef.isFinalDefined && classDef.isFinalDefined.equals("closed")){
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("closed actor %s of %s cannot be closed as it is abstract", classNameForErrors, ((GenericType)typedActorResolvesTo).name ));
			}
			classDef.isFinal=false;
			classDef.setIsAbstract(true);
		}
		
		if(classDef.isActor){
			if(classDef.istypedActor){
				if(null == classDef.superclass){
					classDef.superclass = "com.concurnas.lang.TypedActor";
					classDef.superClassGenricList = new  ArrayList<Type>();
				}
			
				if(isUnqualifiedTypedActor){
					//add generic parameter that needs to be defined by subtype
					GenericType actegen = (GenericType)typedActorResolvesTo;
					String acteegname = actegen.name;
					NamedType acteName = new NamedType(0,0, acteegname);
					//boolean inlistAlready = false;
					for(GenericType genericParamGT : classDef.classGenricList){
						if(!genericParamGT.splicedIn){//ignore the one we added ourselves
							if(genericParamGT.name.equals(acteegname)){
								this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("generic qualifier for actee '%s' has already been declared in generic parameter list for abstract typed actor", acteegname));
							}
						}
					}
					
					if(classDef.superClassGenricList.isEmpty() || (!classDef.superClassGenricList.get(0).equals(acteName) )){
						if(!classDef.superclassTypeToClsGeneric.values().contains(actegen)){
							classDef.superClassGenricList.add(0,acteName);
						}
					}
	
					if(classDef.classGenricList.isEmpty() || !classDef.classGenricList.get(0).equals(actegen)){
						classDef.classGenricList.add(0,actegen);
					}
					
					classDef.nameToGenericMap.put(acteegname, actegen);
					
				}
				else if(typedActorResolvesTo != null){
					if(typedActorResolvesTo instanceof NamedType){//possibly was added as generic type to things above prevoiusly if we were slow to resolve as NamedType
						//so clean up this mess
						GenericType actegen = fromNamedTypeToGenericType(typedActorResolvesTo);
						if(null != actegen){
							String acteegname = actegen.name;
							NamedType acteName = new NamedType(0,0, acteegname);
							
							if(!classDef.superClassGenricList.isEmpty()){
								Type first = classDef.superClassGenricList.get(0);
								if(first instanceof GenericType && ((GenericType)first).splicedIn && first.equals(acteName)){
									classDef.superClassGenricList.remove(0);
								}
							}
							
							if(!classDef.classGenricList.isEmpty()){
								GenericType first = classDef.classGenricList.get(0);
								if(first.splicedIn && first.equals(actegen)){
									classDef.classGenricList.remove(0);
								}
							}
		
							GenericType got = classDef.nameToGenericMap.get(acteegname);
							if(null != got && got.splicedIn){
								classDef.nameToGenericMap.remove(acteegname);
							}
						}
						
					}
					
					
					if(classDef.superClassGenricList.isEmpty() || !classDef.superClassGenricList.get(0).equals(classDef.typedActorOn)){
						classDef.superClassGenricList.add(0,classDef.typedActorOn);
					}
				}
			}
			else{

				if(null == classDef.superclass){//actor MyActorXXX{}
					classDef.superclass = "com.concurnas.lang.Actor";
				}
			}
		}
		
		
		int n = 0;
		Set<String> uniquecgl = new HashSet<String>();
		ArrayList<GenericType> genericParameters = new ArrayList<GenericType>();
		for(GenericType genericParamGT : classDef.classGenricList)
		{
			String genericParam = genericParamGT.name;
			//don't allow public class A<X, L> extends ArrayList<X<L>>
			if(uniquecgl.contains(genericParam))
			{
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("generic qualifier '%s' identifier has already been declared in generic parameter list", genericParam));
			}
			uniquecgl.add((String) genericParam);
			//if you do class A[String](a String) // then your just an idiot for override a existing type...
			
			if(this.hasImportBeenRegistered((String) genericParam) || ((String) genericParam).equals(className) )
			{
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("generic qualifier '%s' identifier overrides an existing type - this is confusing", genericParam));
			}
			
			if(GenericTypeUtils.getAllGenericTypesDeclInHierarchy(classDef).contains(genericParam))
			{
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("generic qualifier '%s' has been defined already further up hierarchy", genericParam));
			}
			
			GenericType toADd = new GenericType(classDef.getLine(), classDef.getColumn(), (String) genericParam, n++);
			toADd.upperBound = genericParamGT.upperBound == null? null :genericParamGT.upperBound.copyTypeSpecific();
			toADd.setNullStatus(toADd.upperBound.getNullStatus());
			
			toADd.accept(this);
			
			genericParameters.add(toADd);
			if(genericParamGT.splicedIn){
				toADd.splicedIn = true;
			}
			//.e.g. class A[x extends Map]
			//class ChildBadGeneric[X, Y] extends Sup[Y] {} 
		}
		if(!classDef.classGenricList.isEmpty()) 
		{
			classDef.classGenricList = genericParameters;
		}
		
		LinkedHashMap<Pair<String, TypeAndLocation>, Pair<String, TypeAndLocation>> superClassAbstractMethodsToFulfill = new LinkedHashMap<Pair<String, TypeAndLocation>, Pair<String, TypeAndLocation>>();

		boolean supressConstructors = false;

		if(classDef.isLocalClass && classDef.accessModifier == null){
			classDef.accessModifier = AccessModifier.PRIVATE;
		}else if(classDef.accessModifier == null ){//unset, default to....
			if(!this.currentlyInClassDef.isEmpty()){
				//nested
				classDef.accessModifier = AccessModifier.PRIVATE;
			}
			else{
				classDef.accessModifier = AccessModifier.PUBLIC;
			}
		}
		

		List<Fiveple<String, ClassDef, Type, Boolean, AccessModifier>> traitVariables = new ArrayList<Fiveple<String, ClassDef, Type, Boolean, AccessModifier>>(0);
		
		if(null != classDef.superclass){
			classDef.superClassGenricList = classDef.superClassGenricList.stream().map(a -> TypeCheckUtils.boxTypeIfPrimative(a, false)).collect(Collectors.toList());
			
			Thruple<ClassDef, Boolean, Boolean> got = processSuperOrTraitClass(classDef.isTrait, classDef.superclass, classDef, classDef.superClassGenricList, classDef.superclassTypeToClsGeneric, classSF, parentDF, typedActorResolvesTo, parentIsClosedErr, supressConstructors, superClassAbstractMethodsToFulfill, traitVariables);
			
			if(null != classDef.superclass) {
				ClassDef resolvedSuperClass = got.getA();
				if(null != resolvedSuperClass && resolvedSuperClass.isLocalClass){
					resolvedSuperClass.classesHavingMeAsTheSuperClass.add(classDef);
				}
				//just set superclass to Object if we cannot figure out what it should be
				classDef.setResolvedSuperType(this, resolvedSuperClass!=null?resolvedSuperClass:ScopeAndTypeChecker.const_object_CD);
				parentIsClosedErr = got.getB();
				supressConstructors = got.getC();
				//
				if(classDef.isTrait && null != resolvedSuperClass && !resolvedSuperClass.isTrait && null != traitAnnotation) {
					//adjust annotation since this trait extends a non trait/interface class
					
					if(traitAnnotation.manyArgs == null) {
						traitAnnotation.manyArgs = new ArrayList<Pair<String, Expression>>();
					}else {
						traitAnnotation.manyArgs = traitAnnotation.manyArgs.stream().filter(a -> !a.getA().equals("nonTraitSuperclass")).collect(Collectors.toList());
					}
					
					
					traitAnnotation.manyArgs.add(new Pair<String, Expression>("nonTraitSuperclass", new RefClass(classDef.getLine(), classDef.getColumn(), new NamedType(resolvedSuperClass))));
					traitAnnotation.accept(this);
				}
			}
		}
		
	
		
		//traits:
		if(classDef.isTrait || !classDef.traits.isEmpty()){
			HashSet<String> notTraits = null; 
			List<ClassDef> resolved = new ArrayList<ClassDef>(); 
			boolean traitMatchSupertype = false;
			for(ImpliInstance inst : classDef.traits) {
				inst.traitGenricList = inst.traitGenricList==null?null:inst.traitGenricList.stream().map(a -> TypeCheckUtils.boxTypeIfPrimative(a, false)).collect(Collectors.toList());
				ClassDef resolvedIface = processTraits(inst.traitName, inst.traitGenricList, inst.iffaceTypeToClsGeneric, classDef, classSF, parentDF, typedActorResolvesTo, parentIsClosedErr, supressConstructors, superClassAbstractMethodsToFulfill, traitVariables);

				if(classDef.resolvedSuperType.equals(resolvedIface)) {
					traitMatchSupertype=true;
				}
				
				if(resolvedIface != null) {
					resolved.add(resolvedIface);
					if(!resolvedIface.isTrait) {
						if(null == notTraits) {
							notTraits = new HashSet<String>();
						}
						notTraits.add(resolvedIface.getClassName());
					}
				}
				
				inst.resolvedIface = resolvedIface;
			}
			
			if(traitMatchSupertype) {
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("%s %s contains duplicate trait and supertype refernce: %s", classDef.isTrait?"trait":"class", classNameForErrors, classDef.superclass));
			}

			for(ClassDef toRemove : new HashSet<ClassDef>(resolved)) {
				resolved.remove(toRemove);
			}
			
			if(!resolved.isEmpty()) {
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("%s %s contains duplicate trait references: %s", classDef.isTrait?"trait":"class",classNameForErrors, String.join(", ", resolved.stream().map(a -> "" + a).sorted().collect(Collectors.toList()) ) ) );
			}
			
			if(notTraits != null) {
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("%s %s cannot be composed with: %s as %s", classDef.isTrait?"trait":"class",classNameForErrors, String.join(", ", notTraits.stream().sorted().collect(Collectors.toList())), notTraits.size() > 1? "they are not traits":"it is not a trait"));
			}
			
			if(classDef.typedActorOn != null) {
				ClassDef cd = classDef.typedActorOn.getSetClassDef();
				if(cd != null) {
					checkInferfaceHierarchy(classDef.getLine(), classDef.getColumn(), true, classDef, cd);
				}
			}else {
				checkInferfaceHierarchy(classDef.getLine(), classDef.getColumn(), true, classDef);
			}
			
			
			//SATC: two traits having same field name, but different types - complain, remove dupes below?
		}
		
		if(!classDef.isTrait /*&& !classDef.traits.isEmpty()*/) {
			NamedType asNamed = new NamedType(classDef);
			List<NamedType> traitsAndClasses = asNamed.getResolvedTraitsAsNamed();

			//classDef.linearizedTraitsInitCalls=null;
			//classDef.traitSuperRefsImpls = new ArrayList<Fourple<String, String, Boolean, TypeAndLocation>>(0); 
			Pair<List<NamedType>, ArrayList<Fourple<String, String, Boolean, TypeAndLocation>>> res = createTraitSuperRefImpls(this, classDef.getLine(), classDef.getColumn(), traitsAndClasses, asNamed.getResolvedSuperTypeAsNamed());
			
			classDef.linearizedTraitsInitCalls=res.getA();
			classDef.traitSuperRefsImpls = res.getB();
		}
		

		if(classDef.typedActorOn != null) {
			ClassDef cd = classDef.typedActorOn.getSetClassDef();
			if(cd != null) {
				ArrayList<NamedType> ifaces = checkInferfaceHierarchy(classDef.getLine(), classDef.getColumn(), false, cd);
				Set<NamedType> implicitIfaces = ifaces.stream().filter(a -> a.getSetClassDef() != null).collect(Collectors.toSet());
				
				classDef.typedActorOnImplicitIfaces = implicitIfaces;
			}
		}
		
		if(!classDef.traits.isEmpty()) {
			//check traits for method clashes, with C ~ A,B: if A and B both define a default implementation for a method, then it must be differentiated in C assuming !(A < B or B > A)
			List<Thruple<String, FuncType, List<String>>> traitMethodsNeedDisamig = traitMethodClashes(classDef);
			if(!traitMethodsNeedDisamig.isEmpty()) {
				if(classDef.getIsAbstract()) {
					//add abstract methods
					for(Thruple<String, FuncType, List<String>> inst : traitMethodsNeedDisamig) {
						FunctionGenneratorUtils.addAbstractMethod(classDef.getLine(), classDef.getColumn(), this, inst.getA(), classDef, inst.getB());
					}
					
				}else {
					ArrayList<String> items = new ArrayList<String>();
					for(Thruple<String, FuncType, List<String>> item : traitMethodsNeedDisamig) {
						items.add(String.format("%s of type: %s is from: %s", item.getA(), item.getB(), String.join(", ", item.getC())));
					}
					String resolves = String.format("It must be added to: %s (either as an abstract or concrete method) or %s declared abstract", classDef, classDef);
					this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("class %s has ambiguous methods from traits. %s. %s", classDef, String.join(". ", items), resolves));
				}
			}
			
			//check traits for any implicit superclasses required
			NamedType cdAsNamed = new NamedType(classDef);
			NamedType implicitTraitSuper = checkTraitSuperClasses(classDef.getLine(), classDef.getColumn(), cdAsNamed);
			if(null != implicitTraitSuper) {
				if(classDef.superclass == null) {
					classDef.resolvedSuperType = implicitTraitSuper.getSetClassDef();
					classDef.superClassGenricList = new ArrayList<Type>(implicitTraitSuper.getGenTypes());
				}else {//one defined already, check equality
					NamedType supAsNamed = classDef.getSuperAsNamedType(0, 0);
					if(!implicitTraitSuper.equals(supAsNamed)) {
						if(null == TypeCheckUtils.checkSubType(this.ers, supAsNamed, implicitTraitSuper) && null == TypeCheckUtils.checkSubType(this.ers, implicitTraitSuper, supAsNamed)) {
							String traitMsg = String.join(", ", cdAsNamed.getResolvedTraitsAsNamed().stream().map(a -> "" + a).sorted().collect(Collectors.toList()));
							this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Traits: %s implicity extend: %s which is not compatable with defined supertype of: %s", traitMsg, implicitTraitSuper, supAsNamed));
						}
					}
				}
				
			}
		}
		
		boolean shouldMakeConstructor = !supressConstructors;
		
		/*
		 - get, + set, ~ get and set,  none
		if(null != classDef.classDefArgs){
			classDef.classDefArgs.accept(this);
		}*/
		
		//auto gennerate code...
		ArrayList<ConstArg> constructorArgs = new ArrayList<ConstArg>();
		ArrayList<Expression> superConstrThings = new ArrayList<Expression>();
		HashSet<String> superClassReferencedVariableNames; // class AA(x int, g int, h double) extends DD(1*x,2+g, 5.6f, h) //h, x and g all get referenced!
		if(!classDef.superClassExpressions.isEmpty())
		{
			RefNameTrackerVisitor refNameVis = new RefNameTrackerVisitor();
			for(Expression e : classDef.superClassExpressions)
			{
				refNameVis.visit(e);
				superConstrThings.add(e);
			}
			superClassReferencedVariableNames = refNameVis.namesReferencedInTree;
		}
		else{
			superClassReferencedVariableNames = new HashSet<String>();
		}
		
		HashSet<String> actorClassReferencedVariableNames; // class AA(x int, g int, h double) extends DD(1*x,2+g, 5.6f, h) //h, x and g all get referenced!
		if(!classDef.acteeClassExpressions.isEmpty()){
			RefNameTrackerVisitor refNameVis = new RefNameTrackerVisitor();
			for(Expression e : classDef.acteeClassExpressions){
				refNameVis.visit(e);
			}
			actorClassReferencedVariableNames = refNameVis.namesReferencedInTree;
		}
		else{
			actorClassReferencedVariableNames = new HashSet<String>();
		}
		
		currentlyInClassDef.add(classDef);
		
		ArrayList<Type> defConArgs = new ArrayList<Type>();
		shouldMakeConstructor = validateClassDefArgs(classDef, classSF,  superClassReferencedVariableNames, actorClassReferencedVariableNames,  defConArgs, constructorArgs);
				
		if(!classDef.isActor /*&& !classDef.constructorsAlreadyAdded*/){
			HashSet<FuncType> consExistAlready = classDef.getAllConstructors();
			FuncType signature = null;
			if(shouldMakeConstructor){//if constructor has been added already, dont do it again! user def or otherwise
				signature = new FuncType(defConArgs, null);
				shouldMakeConstructor = !consExistAlready.contains(signature);
			}
			
			if(shouldMakeConstructor && (!constructorArgs.isEmpty() || !superConstrThings.isEmpty()))
			{//rewrite ast -iif either the superconstructor or the this consturcor has elements to instantiate
				FunctionGenneratorUtils.addConstructor(this.ers, this, classDef, constructorArgs, superConstrThings, superClassReferencedVariableNames, classDef.getLine(), classDef.getColumn(), classDef.isActor, false, annotationsForConstructor, false, classDef.injectClassDefArgsConstructor);
				//classDef.classDefArgs = null;//and wipe them out so on repeat visits we dont gennerate even more constructors
				//mark as autogened!
				//classDef.constructorsAlreadyAdded=true;
			}
		}
		
		//JPT: do not allow extends Thread
		nestorParens.push(className);
		
		classDef.setCcFullName(getfullClassName());
		
		packageName.push(className);
		if(!classDef.isLocalClass){
			this.addImport(className, getFullyDottedPackage(), false); //add C -> a.b.C to local ref table 
		}
		
		
		classDef.classBlock.isClass = true;
		
		if(supressErrorsInClass){
			this.maskErrors();
		}
		
		classDef.classBlock.accept(this);
		
		if(supressErrorsInClass){
			this.maskedErrors();
		}

		boolean toAddZeroArg = true;
		
		if(shouldMakeConstructor && classDef.injectClassDefArgsConstructor && constructorArgs.isEmpty() && superConstrThings.isEmpty()) {//add zero arg constructor
			
			if(classDef.isActor && null == classDef.typedActorOn){
				//ignore if actor
			}else {
				boolean zeroArgArleady=false;
				for(FuncType ft : classDef.getAllConstructors()) {
					if(ft.inputs.isEmpty()) {
						FuncDef origin = ft.origonatingFuncDef;
						if(!origin.isInjected) {
							origin.isInjected = true;
						}
						zeroArgArleady=true;
						break;
					}
					
				}
				
				if(!zeroArgArleady) {
					//and not already defined
					FunctionGenneratorUtils.addConstructor(this.ers, this, classDef, constructorArgs, superConstrThings, superClassReferencedVariableNames, classDef.getLine(), classDef.getColumn(), classDef.isActor, false, annotationsForConstructor, false, classDef.injectClassDefArgsConstructor);
					toAddZeroArg=false;
				}
			}
		}
		
		validateInjections(classDef);
		
		if(classDef.hasAbstractMethods())
		{//implicitly abstract and not declared as such
			classDef.setIsAbstract(true);
			if("closed".equals(classDef.isFinalDefined)){
				this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("class %s is implictly abstract and cannot be closed", classNameForErrors));
			}
			classDef.isFinal = false;
		}
		else if(!classDef.getIsAbstract()){
			classDef.isFinal = null == classDef.isFinalDefined || "closed".equals(classDef.isFinalDefined);//if nothing specified then closed
		}
		
		classDef.bridgeMethodsToAdd = new ArrayList<Pair<FuncDef, FuncDef>>(0);
		if(!superClassAbstractMethodsToFulfill.isEmpty()) {
			for(Pair<String, TypeAndLocation> cand : classDef.getAllLocallyDefinedMethods())
			{
				if(superClassAbstractMethodsToFulfill.containsKey(cand)) {
					//Tuple<String, TypeAndLocation> orig = superClassAbstractMethodsToFulfill.remove(superClassAbstractMethodsToFulfill.indexOf(cand));
					Pair<String, TypeAndLocation> orig = superClassAbstractMethodsToFulfill.remove(cand);
					FuncDef originFD = ((FuncType)orig.getB().getType()).origonatingFuncDef;
					FuncDef definedFD = ((FuncType)cand.getB().getType()).origonatingFuncDef;
					
					Pair<FuncDef, FuncDef> toAddBridge = funcDefNeedsBridgeMethod(originFD, definedFD);
					if(null != toAddBridge) {
						classDef.bridgeMethodsToAdd.add(toAddBridge);
					}
						
				}
			}
			
			HashMap<Pair<String, TypeAndLocation>, Pair<String, TypeAndLocation>> retArgLessToArged = new HashMap<Pair<String, TypeAndLocation>, Pair<String, TypeAndLocation>>();
			
			for(Pair<String, TypeAndLocation> item : superClassAbstractMethodsToFulfill.keySet()) {
				Pair<String, TypeAndLocation> retarglessitem = getArgLessNameAndTal(item);
				
				retArgLessToArged.put(retarglessitem, item);
			}
			
			HashSet<Pair<String, TypeAndLocation>> toremove = new HashSet<Pair<String, TypeAndLocation>>();
			
			for(NamedType trait : classDef.getTraitsAsNamedType(0, 0)) {
				for(Pair<String, TypeAndLocation> locM : trait.getAllLocallyDefinedMethods(this, false, true)) {
					locM = getArgLessNameAndTal(locM);
					if(retArgLessToArged.containsKey(locM)) {
						toremove.add(retArgLessToArged.get(locM));
					}
				}
			}
		
			for(Pair<String, TypeAndLocation> nonAbstracts : classDef.getAllMethods(true)) {
				nonAbstracts = getArgLessNameAndTal(nonAbstracts);
				if(retArgLessToArged.containsKey(nonAbstracts)) {
					toremove.add(retArgLessToArged.get(nonAbstracts));
				}
			}
			
			toremove.forEach(x -> superClassAbstractMethodsToFulfill.remove(x));
			//superClassAbstractMethodsToFulfill.removeAll(toremove);
		}
		
		if(!superClassAbstractMethodsToFulfill.isEmpty())
		{
			HashMap<String, ArrayList<String>> classtoMissings = new HashMap<String, ArrayList<String>>();

			for(Pair<String, TypeAndLocation> oops : superClassAbstractMethodsToFulfill.keySet()) {
			//for(int na = 0; na < superClassAbstractMethodsToFulfill.size(); na++){
				//Tuple<String, TypeAndLocation> oops = superClassAbstractMethodsToFulfill.get(na);
				Location ona = oops.getB().getLocation();
				String prefix;
				if(ona != null && ona instanceof ClassFunctionLocation) {
					ClassFunctionLocation cfl = (ClassFunctionLocation)ona;
					prefix = cfl.ownerType.toString();
				}else {
					prefix = "";
				}
				
				ArrayList<String> item;
				if(!classtoMissings.containsKey(prefix)) {
					item = new ArrayList<String>();
					classtoMissings.put(prefix, item);
				}else {
					item = classtoMissings.get(prefix);
				}
				
				item.add(String.format(((FuncType)oops.getB().getType()).getFormatStringWithPalceholderforMethName(), oops.getA()) );
			}
			
			ArrayList<String> classtoMissingStrings = new ArrayList<String>();
			ArrayList<String> keyz = new ArrayList<String>(classtoMissings.keySet());
			Collections.sort(keyz);
			
			for(String key : keyz) {
				ArrayList<String> presort = classtoMissings.get(key);
				Collections.sort(presort);
				classtoMissingStrings.add(key +":{" + String.join(", ", presort) + "}");
			}
			
			String sb = String.join(", ", classtoMissingStrings);
			
			if(!classDef.getIsAbstract() )
			{
				if(classDef.isLocalClass) {
					this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Local class is missing implementations of abstract method definitions inherited: %s", sb ));
				}else {
					this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Class '%s' is missing implementations of abstract method definitions inherited: %s", classDef, sb ));
				}
			}
		}
		
		classDef.traitVarsNeedingImpl = null;
		//trait abstract variables
		if(!classDef.isTrait && !classDef.getIsAbstract() && !traitVariables.isEmpty()) {
			List<Thruple<String, Type, Type>> traitVarsNeedingImpl = null;
			
			HashMap<String, HashMap<Type, HashSet<Pair<ClassDef, Boolean>>>> traitVarToClassDef = calctraitVarToClassDef(traitVariables);
			
			//HashMap<String, HashMap<Type, HashSet<Tuple<ClassDef, Boolean>>>> traitVarToClassDef = new HashMap<String, HashMap<Type, HashSet<Tuple<ClassDef, Boolean>>>>();
			/*for(Fiveple<String, ClassDef, Type, Boolean, AccessModifier> item :  traitVariables) {
				String fname = item.getA();
				HashMap<Type, HashSet<Tuple<ClassDef, Boolean>>> store = traitVarToClassDef.get(fname);
				if(store == null) {
					store = new HashMap<Type, HashSet<Tuple<ClassDef, Boolean>>>();
					traitVarToClassDef.put(fname, store);
				}
				Type tt = item.getC();
				
				HashSet<Tuple<ClassDef, Boolean>> cds = store.get(tt);// new Tuple<ClassDef, Type>(, item.getC()));
				if(null == cds) {
					cds = new HashSet<Tuple<ClassDef, Boolean>>();
					store.put(tt,  cds);
				}
				cds.add(new Tuple<ClassDef, Boolean>(item.getB(), item.getD()));
			}*/
			
			ArrayList<Sixple<String, Type, Boolean, AccessModifier, Boolean, String>> fdefined = classDef.getAllFieldsDefined();
			for(Sixple<String, Type, Boolean, AccessModifier, Boolean, String> inst : fdefined) {
				String definedName = inst.getA();
				
				HashMap<Type, HashSet<Pair<ClassDef, Boolean>>> hases = traitVarToClassDef.get(definedName);
				if(null != hases) {
					HashSet<Type> removeFromHases = null;
					for(Type expectedType : hases.keySet()) {
						Type definedType = inst.getB();
						if(null != TypeCheckUtils.checkSubType(this.ers, expectedType, definedType)) {
							//match, remove
							if(traitVarsNeedingImpl == null) {
								traitVarsNeedingImpl = new ArrayList<Thruple<String, Type, Type>>();
							}
							traitVarsNeedingImpl.add(new Thruple<String, Type, Type>(definedName, expectedType, definedType) );
							

							if(removeFromHases == null) {
								removeFromHases = new HashSet<Type>();
							}
							removeFromHases.add(expectedType);
						}else if(inst.getC()) {
							//been defined but type does not match
							//TODO: override a field from trait that's already been defined with mismatching type
							
						}
					}
					if(null != removeFromHases) {
						for(Type tt : removeFromHases) {
							hases.remove(tt);
						}
						
						if(hases.isEmpty()) {
							traitVarToClassDef.remove(definedName);
						}
					}
					
				}
			}
			
			if(!traitVarToClassDef.isEmpty()) {
				
				HashSet<String> traitVarToClassDefrm = new HashSet<String>();
				for(String itm : traitVarToClassDef.keySet()) {
					HashMap<Type, HashSet<Pair<ClassDef, Boolean>>> hases = traitVarToClassDef.get(itm);
					//find variables which are instantiated inside trait, and so require initilization
					
					HashSet<Type> hasesremove = new HashSet<Type>();
					
					for(Type tt : hases.keySet()) {
						HashSet<Pair<ClassDef, Boolean>> items = hases.get(tt);
						
						HashSet<Pair<ClassDef, Boolean>> removeFromItems = new HashSet<Pair<ClassDef, Boolean>>();
						for(Pair<ClassDef, Boolean> item : items) {
							if(item.getB()) {//been assigned initial value
								Thruple<String, Type, Type> toAdd = new Thruple<String, Type, Type>(itm, tt, tt) ;
								Pair<String, Type> toAddfield = new Pair<String, Type>(itm, tt) ;
								if(traitVarsNeedingImpl == null) {
									traitVarsNeedingImpl = new ArrayList<Thruple<String, Type, Type>>();
								}else {
									traitVarsNeedingImpl.remove(toAdd);
								}
								traitVarsNeedingImpl.add(toAdd);
								
								if(item.getA().isTrait) {
									if(classDef.traitVarsNeedingFieldDef == null) {
										classDef.traitVarsNeedingFieldDef = new ArrayList<Pair<String, Type>>();
									}
									else {
										classDef.traitVarsNeedingFieldDef.remove(toAddfield);
									}
									classDef.traitVarsNeedingFieldDef.add(toAddfield);
								}
								
								removeFromItems.add(item);
							}
						}
						
						items.removeAll(removeFromItems);
						if(items.isEmpty()) {
							hasesremove.add(tt);
						}
					}
					
					for(Type key : hasesremove) {
						hases.remove(key);
					}
					
					if(hases.isEmpty()) {
						traitVarToClassDefrm.add(itm);
					}
				}
				
				for(String key : traitVarToClassDefrm) {
					traitVarToClassDef.remove(key);
				}
				
				if(!traitVarToClassDef.isEmpty()) {

					Set<String> offenders = traitVarToClassDef.keySet();
					List<String> ostredOff = offenders.stream().sorted().collect(Collectors.toList());
					
					ArrayList<String> items = new ArrayList<String>();
					for(String itm : ostredOff) {
						HashMap<Type, HashSet<Pair<ClassDef, Boolean>>> hases = traitVarToClassDef.get(itm);
						items.addAll(hases.keySet().stream().map(has -> String.format("%s of type %s from %s", itm, has, String.join(", ", hases.get(has).stream().map(a -> a.getA().toString()).sorted().collect(Collectors.toList())))).sorted().collect(Collectors.toList()));
					}
					
					if(!items.isEmpty()) {
						this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Class '%s' is missing implementations of trait fields: %s", classDef, String.join(", ", items) ));
					}
				}
			}
			
			if(null != traitVarsNeedingImpl) {
				classDef.traitVarsNeedingImpl = traitVarsNeedingImpl;
			}
			
		}
		
		if(null != traitAnnotation) {//populate traitAnnotation with local trait variables
			ArrayList<Sixple<String, Type, Boolean, AccessModifier, Boolean, String>> fields = classDef.getAllFieldsDefined();
			
			if(!fields.isEmpty()) {//if there are any
				ArrayList<Expression> annots = new ArrayList<Expression>(fields.size());
				
				for(Sixple<String, Type, Boolean, AccessModifier, Boolean, String> inst : fields) {
					ArrayList<Pair<String, Expression>> manyArgs = new ArrayList<Pair<String, Expression>>(3);
					
					manyArgs.add(new Pair<String, Expression>("fieldName", new VarString(0,0,inst.getA() ) ));
					manyArgs.add(new Pair<String, Expression>("fieldType", new VarString(0,0, TraitFieldEncoderDecoder.encode(inst.getB())) ));
					manyArgs.add(new Pair<String, Expression>("isAbstract", new RefBoolean(0,0, !inst.getC() ) ));
					manyArgs.add(new Pair<String, Expression>("accessModifier", new VarString(0,0, inst.getD().toString() ) ));
					
					annots.add(new Annotation(0, 0, "com.concurnas.lang.TraitField", null, manyArgs, new ArrayList<String>(0)));
				}
				
				if(traitAnnotation.manyArgs == null) {
					traitAnnotation.manyArgs = new ArrayList<Pair<String, Expression>>();
				}else {
					traitAnnotation.manyArgs = traitAnnotation.manyArgs.stream().filter(a -> !a.getA().equals("traitFields")).collect(Collectors.toList());
				}
				ArrayDef ad = new ArrayDef(0, 0, annots);
				ad.isArray=true;
				
				traitAnnotation.manyArgs.add(new Pair<String, Expression>("traitFields", ad));
				traitAnnotation.accept(this);
			}
		}
		
		if(classDef.isActor){
			//if(classDef.getConstructorCount() == 0)
			//{
				if(null != classDef.typedActorOn){
					//if no constructors defined then we add those from the class being acted on, we only define the public oens
					NamedType actingOnType = classDef.typedActorOn==null?null:(NamedType)classDef.typedActorOn.getTaggedType();
					if(null != actingOnType){//here
						int line = classDef.getLine();
						int col = classDef.getColumn();
						
						if((classDef.classDefArgs != null && !classDef.classDefArgs.aargs.isEmpty() ) || !superConstrThings.isEmpty()){
							//we want to create only one constructor in this case
							
							if(isUnqualifiedTypedActor){
								if(classDef.acteeClassExpressions.isEmpty()){//can only do this if no args are attempted to be passed to the unqualified actor generic
									ArrayList<ClassDefArg> cdaa = new ArrayList<ClassDefArg>(classDef.classDefArgs.aargs);
									cdaa.add(0, new ClassDefArg(line, col, null, true, null, "$acteeArg", new FuncType(new ArrayList<Type>(), typedActorResolvesTo)) );
									
									this.maskErrors();
									for(ClassDefArg cda : cdaa) {
										Type at = (Type)cda.type.accept(this);
										if(null != at) {
											cda.type = at;
										}
									}
									this.maskedErrors();
									
									ClassDefArgs cda = new ClassDefArgs(classDef.classDefArgs.getLine(), classDef.classDefArgs.getColumn(), cdaa);
									
									FuncType defConst = FunctionGenneratorUtils.addActorConstructorWithArgs(this.ers, this, classDef, null, cda, classDef.acteeClassExpressions, superConstrThings, superClassReferencedVariableNames, actorClassReferencedVariableNames, line, col, annotationsForConstructor, classDef.injectClassDefArgsConstructor);
									currentScopeFrame.setConstructor(defConst);
									
									if(Utils.funcParamsHaveDefaults(defConst.origonatingFuncDef.params)){
										FunctionGenneratorUtils.addwithDefaultsMethod(this.ers, this, defConst.origonatingFuncDef, this.currentScopeFrame, classDef.classBlock);
									}
									
								}
							}
							else{
								FuncType defConst = FunctionGenneratorUtils.addActorConstructorWithArgs(this.ers, this, classDef, actingOnType, classDef.classDefArgs, classDef.acteeClassExpressions, superConstrThings, superClassReferencedVariableNames, actorClassReferencedVariableNames, line, col, annotationsForConstructor, classDef.injectClassDefArgsConstructor);
								//defConst.accept(this);
								currentScopeFrame.setConstructor(defConst);

								if(Utils.funcParamsHaveDefaults(defConst.origonatingFuncDef.params)){
									FunctionGenneratorUtils.addwithDefaultsMethod(this.ers, this, defConst.origonatingFuncDef, this.currentScopeFrame, classDef.classBlock);
								}
								
							}
						}
						else{
							if(!classDef.acteeClassExpressions.isEmpty()){//JPT: could be refactored with the block above
								//no classdef args, so still possible, though weird, still we want only one here
								if(!isUnqualifiedTypedActor){//cannot have actee args for unqualifiedTypedActor
									FuncType defConst = FunctionGenneratorUtils.addActorConstructorWithArgs(this.ers, this, classDef, actingOnType, null, classDef.acteeClassExpressions, superConstrThings, superClassReferencedVariableNames, actorClassReferencedVariableNames, line, col, annotationsForConstructor, classDef.injectClassDefArgsConstructor);
									currentScopeFrame.setConstructor(defConst);
									
									if(Utils.funcParamsHaveDefaults(defConst.origonatingFuncDef.params)){
										FunctionGenneratorUtils.addwithDefaultsMethod(this.ers, this, defConst.origonatingFuncDef, this.currentScopeFrame, classDef.classBlock);
									}
								}
							}
							else{
								if(isUnqualifiedTypedActor){
									ArrayList<Type> inputs = new ArrayList<Type>();
									inputs.add(new FuncType(new ArrayList<Type>(), typedActorResolvesTo));
									FuncType sig = new FuncType(inputs);
									
									FuncType defConst = FunctionGenneratorUtils.addActorConstructor(this.ers, this, classDef, actingOnType, sig, line, col, true, annotationsForConstructor, classDef.injectClassDefArgsConstructor);
									currentScopeFrame.setConstructor(defConst);
								}
								else{
									List<FuncType> cons = actingOnType.getAllConstructors(this);
									for(FuncType sig : cons){
										if(areAllArgsCallable(sig)){
											if(sig.origonatingFuncDef.accessModifier == AccessModifier.PUBLIC){
												
												FuncDef fd = sig.origonatingFuncDef;
												/*if(null != fd) {
													//fd.isInjected;
													if(null != fd.annotations && null != fd.annotations.annotations && !fd.annotations.annotations.isEmpty() ) {
														for(Annotation annot : fd.annotations.annotations) {
															if(annot.className.equals(const_InjectAnnotationStr)) {
																if(annotationsForConstructor == null) {
																	annotationsForConstructor = new Annotations();
																}
																annotationsForConstructor.annotations.add((Annotation)annot.copy());	
																fd.isInjected=true;
																break;
															}
														}
													}
												}*/
												
												FuncType defConst = FunctionGenneratorUtils.addActorConstructor(this.ers, this, classDef, actingOnType, sig, line, col, false, annotationsForConstructor, fd.isInjected);
												currentScopeFrame.setConstructor(defConst);
											}
										}
									}
								}
							}
						}
					}
					else{
						//actor CYS < Somethingelse
						if(null != classDef.resolvedSuperType){
							NamedType superT = new NamedType(0,0,classDef.resolvedSuperType);
							if(TypeCheckUtils.isTypedOrUntypedActor(this.ers, superT)){//subtype of actor
								if(!classDef.resolvedSuperType.equals(const_actor_class) && !classDef.resolvedSuperType.equals(const_typed_actor_class)){
									//and not actor itself, then we can inherit all the constructors from the superclass

									int line = classDef.getLine();
									int col = classDef.getColumn();
									
									if((classDef.classDefArgs != null && !classDef.classDefArgs.aargs.isEmpty() ) || !superConstrThings.isEmpty()){
										//we want to create only one constructor in this case
										if(shouldMakeConstructor){
											FunctionGenneratorUtils.addConstructor(this.ers, this, classDef, constructorArgs, superConstrThings, superClassReferencedVariableNames, classDef.getLine(), classDef.getColumn(), classDef.isActor, false, annotationsForConstructor, false, classDef.injectClassDefArgsConstructor);
										}
									}
									else{//actor MyActor2 < MyActor {} //copy all the super type constructors
										List<FuncType> cons = superT.getAllConstructors(this);
										for(FuncType sig : cons){
											if(sig.origonatingFuncDef.accessModifier == AccessModifier.PUBLIC){
												if(shouldMakeConstructor){
													ArrayList<Type> inputs = sig.getInputs();	
													
													ArrayList<ConstArg> constructorThingsAC = new ArrayList<ConstArg>(inputs.size());
													ArrayList<Expression> superConstrThingsAC = new ArrayList<Expression>(inputs.size());
													HashSet<String> superClassReferencedVariableNamesAC = new HashSet<String>();
													
													superConstrThingsAC.add(new RefName(line, col, TypesForActor));
													
													int nn=0;
													for(Type tt: inputs){
														if(nn++==0){
															continue;
														}
														boolean isLast = inputs.size() == nn;
														String name = "a" + (nn-1);
														constructorThingsAC.add(new ConstArg(name, tt, true, null, null, tt.hasArrayLevels() && isLast, false, false));
														superConstrThingsAC.add(new RefName(line, col, name));
														superClassReferencedVariableNamesAC.add(name);
													}
																								
													
													FuncType defConst = FunctionGenneratorUtils.addConstructor(this.ers, this, classDef, constructorThingsAC, superConstrThingsAC, superClassReferencedVariableNamesAC, classDef.getLine(), classDef.getColumn(), classDef.isActor, false, annotationsForConstructor, false, classDef.injectClassDefArgsConstructor);
													currentScopeFrame.setConstructor(defConst);
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else{
					//untyped actor, add default constructor
					HashSet<FuncType> consExistAlready = classDef.getAllConstructors();
					ArrayList<Type> defConArgsact = new ArrayList<Type>(defConArgs);
					defConArgsact.add(0, ScopeAndTypeChecker.const_classArray_nt_array);
					FuncType defaultConstArgs = new FuncType(defConArgsact, null);
					
					if(shouldMakeConstructor && !consExistAlready.contains(defaultConstArgs)){//if error already no need for another one...
						FuncType defConst = FunctionGenneratorUtils.addConstructor(this.ers, this, classDef, constructorArgs, superConstrThings, superClassReferencedVariableNames, classDef.getLine(), classDef.getColumn(), classDef.isActor, false, annotationsForConstructor, false, classDef.injectClassDefArgsConstructor);
						
						if(Utils.funcParamsHaveDefaults(defConst.origonatingFuncDef.params)){
							FunctionGenneratorUtils.addwithDefaultsMethod(this.ers, this, defConst.origonatingFuncDef, this.currentScopeFrame, classDef.classBlock);
						}
						
						currentScopeFrame.setConstructor(defConst);
					}
				}
			//}
		}
		else if(toAddZeroArg && !classDef.isTrait && shouldMakeConstructor ){
			toAddZeroArg = false;
			if(classDef.getConstructorCount() == 0) {
				toAddZeroArg = true;
			} else	if(classDef.isAnonClass) {
				toAddZeroArg = classDef.getAllConstructors().stream().allMatch(a -> !a.inputs.isEmpty());//all not empty, this will fail so we need to add one
			}
			
			if(toAddZeroArg) {
				FuncType defConst = FunctionGenneratorUtils.addConstructor(this.ers, this, classDef, constructorArgs, superConstrThings, superClassReferencedVariableNames, classDef.getLine(), classDef.getColumn(), classDef.isActor, false, annotationsForConstructor, false, false);
				currentScopeFrame.setConstructor(defConst);
			}
		}
		
		if(supressConstructors){//remove from previous runs if these were added previously if we shouldnt be adding them
			ArrayList<LineHolder> newholders = new ArrayList<LineHolder> (classDef.classBlock.lines.size());
			for(LineHolder lh : classDef.classBlock.lines){
				if(lh.l instanceof ConstructorDef && ((ConstructorDef)lh.l).isAutoGennerated){
					continue;
				}
				newholders.add(lh);
			}
			
			classDef.classBlock.lines=newholders;
		}
		
		if(classDef.isActor && null != typedActorResolvesTo){
			NamedType actingOnType = (NamedType)classDef.typedActorOn.getTaggedType();
			if(null != actingOnType){
				boolean everyFieldHasGetter = everyFieldHasGetter();//show no warning, that would get annoying
				int line = classDef.getLine();
				int col = classDef.getColumn();
				
				if( classDef.needsActorFunctionsTobeAdded && !parentIsClosedErr){
					if(!isUnqualifiedTypedActor){
						
						//+ own declared setters and getters?
						List<Pair<String, TypeAndLocation>> methds = actingOnType.getAllMethods(this);
						methds = new ArrayList<>(new HashSet<>(methds));
						
						for(Pair<String, TypeAndLocation> method : methds){
							String name = method.getA();
							if(!name.equals("defaultFieldInit$")){
								Type tt = method.getB().getType();
								if(tt instanceof FuncType){
									FuncType asFunc = (FuncType)tt;
									FuncDef origonatingFuncDef = asFunc.origonatingFuncDef;
									if(origonatingFuncDef != null && origonatingFuncDef.accessModifier == AccessModifier.PUBLIC){
										ArrayList<Type> inputs = asFunc.getInputs();
										
										if(!excludeFromActorMethodGen(name, inputs)){
											Type retType = asFunc.retType;
											
											FunctionGenneratorUtils.addActorMethod(this.getErrorRaiseableSupression(), this, name+"$ActorCall", name, classDef, actingOnType, asFunc, inputs, retType, line, col, false, false);
										}
									}
								}
							}
						}
					}
					
					{
						ArrayList<Type> inputs = new ArrayList<Type>();
						Type retType = (Type)const_class_nt.copyTypeSpecific();
						FuncType getClass = new FuncType(inputs, retType);
						FunctionGenneratorUtils.addActorMethod(this.getErrorRaiseableSupression(), this, "getClass$ActorCall", "getClass", classDef, actingOnType, getClass, inputs, retType, line, col, false, false);
					}
					
					
					{
						ArrayList<Type> inputs = new ArrayList<Type>();
						Type retType = (Type)const_boolean.copyTypeSpecific();
						FuncType getClass = new FuncType(inputs, retType);
						FunctionGenneratorUtils.addActorCallerMethod(this.getErrorRaiseableSupression(), this, "toBoolean", classDef, actingOnType, getClass, inputs, retType, line, col);
					}
					
					
					{
						ArrayList<Type> inputs = new ArrayList<Type>();
						Type retType = (Type)const_string.copyTypeSpecific();
						FuncType getClass = new FuncType(inputs, retType);
						FunctionGenneratorUtils.addActorMethod(this.getErrorRaiseableSupression(), this, "toString$ActorCall", "toString", classDef, actingOnType, getClass, inputs, retType, line, col, false, false);
						FunctionGenneratorUtils.addActorCallerMethod(this.getErrorRaiseableSupression(), this, "toString", classDef, actingOnType, getClass, inputs, retType, line, col);
					}
					//TODO: are the above calls really needed? Doesnt Actor provide these already? - i.e. direct toString etc - i think they are needed for java libs
					
					//the below need to be auto gennerated...
					{
						ArrayList<Type> inputs = new ArrayList<Type>();
						Type retType = (Type)const_int.copyTypeSpecific();
						FuncType getClass = new FuncType(inputs, retType);
						
						FunctionGenneratorUtils.addActorMethod(this.getErrorRaiseableSupression(), this, "hashCode$ActorCall", "hashCode", classDef, actingOnType, getClass, inputs, retType, line, col, false, false);
						FunctionGenneratorUtils.addActorCallerMethod(this.getErrorRaiseableSupression(), this, "hashCode", classDef, actingOnType, getClass, inputs, retType, line, col);
					}
					
					{
						ArrayList<Type> inputs = new ArrayList<Type>();
						inputs.add(const_object.copyTypeSpecific());
						Type retType = (Type)const_boolean.copyTypeSpecific();
						FuncType getClass = new FuncType(inputs, retType);
						
						FunctionGenneratorUtils.addActorMethod(this.getErrorRaiseableSupression(), this, "equals$ActorCall", "equals", classDef, actingOnType, getClass, inputs, retType, line, col, false, true);
						FunctionGenneratorUtils.addActorCallerMethod(this.getErrorRaiseableSupression(), this, "equals", classDef, actingOnType, getClass, inputs, retType, line, col);
						
					}
					
					classDef.needsActorFunctionsTobeAdded=false;
				}
				
				if(!hasfuncDefDefinedInClassAlready("hashCode$ActorSuperCallObjM", hashCodeSig) && this.getErrors().isEmpty()){
					FunctionGenneratorUtils.addDefaultHashCode(classDef.getLine(), classDef.getColumn(), classDef, this, false, true);
					FunctionGenneratorUtils.addActorMethod(this.getErrorRaiseableSupression(), this, "hashCode$ActorSuperCall", "hashCode$ActorSuperCallObjM", classDef, actingOnType, hashCodeSig, hashCodeSig.getInputs(), hashCodeSig.retType, line, col, true, false);								
				}
				
				//always attempt to gennerate these, do outside of the needsActorFunctionsTobeAdded check because the conditionality of the below adds extra fail case
				if(everyFieldHasGetter  && this.getErrors().isEmpty()){//only gennerate default hashcode if all fields have accessors (since we cannot access them directly)
					if(!hasfuncDefDefinedInClassAlready("equals$ActorSuperCallObjM", eqSignature)){
						FunctionGenneratorUtils.addDefaultEquals(classDef.getLine(), classDef.getColumn(), classDef, this, false, true);
						FunctionGenneratorUtils.addActorMethod(this.getErrorRaiseableSupression(), this, "equals$ActorSuperCall", "equals$ActorSuperCallObjM", classDef, actingOnType, eqSignature, eqSignature.getInputs(), eqSignature.retType, line, col, true, false);								
					}
				}
				
				
				
			}
		}
		else if(!parentIsClosedErr){//dont auto gennerate code for imposible classes that have already errored for this sort of unrecoverable problem - i.e. closed parent
			
			if(classDef.isActor ){
				if(this.getErrors().isEmpty()) {
					if(classDef.getSuperclass() == null || !TypeCheckUtils.isTypedActor(this.getErrorRaiseableSupression(),  new NamedType(0, 0, classDef.getSuperclass()) )){
						//untyped actor and superclass is untyped as well
						int line = classDef.getLine();
						int col = classDef.getColumn();
						
						boolean everyFieldHasGetter = everyFieldHasGetter();//show no warning, that would get annoying
						
						if(everyFieldHasGetter){//only gennerate default hashcode if all fields have accessors (since we cannot access them directly)
							if(!hasfuncDefDefinedInClassAlready("equals$ActorSuperCallObjM", eqSignature)){
								FunctionGenneratorUtils.addDefaultEquals(classDef.getLine(), classDef.getColumn(), classDef, this, false, true);
							}
							
							if(!hasfuncDefDefinedInClassAlready("equals", eqSignature)){
								FunctionGenneratorUtils.addActorMethod(this.getErrorRaiseableSupression(), this, "equals$ActorSuperCall", "equals$ActorSuperCallObjM", classDef, null, eqSignature, eqSignature.getInputs(), eqSignature.retType, line, col, true, false);
								FunctionGenneratorUtils.addActorMethod(this.getErrorRaiseableSupression(), this, "equals", "equals$ActorSuperCallObjM", classDef, null, eqSignature, eqSignature.getInputs(), eqSignature.retType, line, col, true, false);
							}
							
						}
						
						if(!hasfuncDefDefinedInClassAlready("hashCode$ActorSuperCallObjM", hashCodeSig)){
							FunctionGenneratorUtils.addDefaultHashCode(classDef.getLine(), classDef.getColumn(), classDef, this, false, true);
						}
						
						if(!hasfuncDefDefinedInClassAlready("hashCode", hashCodeSig)){
							FunctionGenneratorUtils.addActorMethod(this.getErrorRaiseableSupression(), this, "hashCode$ActorSuperCall", "hashCode$ActorSuperCallObjM", classDef, null, hashCodeSig, hashCodeSig.getInputs(), hashCodeSig.retType, line, col, true, false);								
							FunctionGenneratorUtils.addActorMethod(this.getErrorRaiseableSupression(), this, "hashCode", "hashCode$ActorSuperCallObjM", classDef, null, hashCodeSig, hashCodeSig.getInputs(), hashCodeSig.retType, line, col, true, false);								
						}
						
						FuncType toStringsig = new FuncType( new ArrayList<Type>(), (Type)const_string.copyTypeSpecific());
						if(!hasfuncDefDefinedInClassAlready("toString", toStringsig)){
							FunctionGenneratorUtils.addActorMethod(this.getErrorRaiseableSupression(), this, "toString$ActorSuperCall", "toString$ActorSuperCallObjM", classDef, null, toStringsig, toStringsig.getInputs(), toStringsig.retType, line, col, true, false);
							FunctionGenneratorUtils.addActorMethod(this.getErrorRaiseableSupression(), this, "toString", "toString$ActorSuperCallObjM", classDef, null, toStringsig, toStringsig.getInputs(), toStringsig.retType, line, col, true, false);
						}
						
						if(!hasfuncDefDefinedInClassAlready("toString$ActorSuperCallObjM", toStringsig)){
							FunctionGenneratorUtils.addCallSuperMethod(this.getErrorRaiseableSupression(), this, "toString$ActorSuperCallObjM", "toString", classDef, toStringsig, line, col);
						}					
						
					}
				}
			}
			else if(!classDef.isTrait && null == classDef.isParentNestorEQOrSUperClass(ScopeAndTypeChecker.const_classLoader_cls) ){//normal class
				if(!classDef.isBeingBeingPastTheParentOfMe(const_ref) && classDef.allTraitClassesResolved() && this.getErrors().isEmpty()) {
					if(!hasfuncDefDefinedInClassAlready("equals", eqSignature) && !hasfuncDefDefinedInClassAlready("equals$ActorSuperCallObjM", eqSignature)){
						FunctionGenneratorUtils.addDefaultEquals(classDef.getLine(), classDef.getColumn(), classDef, this, false, classDef.isActor);
					}
					
					if(!hasfuncDefDefinedInClassAlready("hashCode", hashCodeSig) && !hasfuncDefDefinedInClassAlready("hashCode$ActorSuperCallObjM", hashCodeSig) ){
						FunctionGenneratorUtils.addDefaultHashCode(classDef.getLine(), classDef.getColumn(), classDef, this, false, classDef.isActor);
					}
				}
			}
		}
		
		
		HashMap<ConstLocationAndType, Type> constructorInvokeGraph = currentConstructorCallGraph.pop();
		checkConstrutorInvokeGraphForLoops(constructorInvokeGraph);
		
		checkToFromBinaryBothDefined(classDef.getLine(), classDef.getColumn());
		
		this.currentScopeFrame = this.currentScopeFrame.leaveScope();
		
		if(classDef.isLocalClass){
			this.level--;
		}
		
		//add to local dictionary of names?
		this.currentScopeFrame.setClassDef(classSF, className, classDef, Modifier.PUBLIC);
		
		typeDirectory.put(classDef.bcFullName().replace("$","."), classDef);
		
		packageName.pop();
		nestorParens.pop();
		
		//initblocks.pop();
		currentlyInClassDef.pop();
		
		ensureAllSuperConstCalled(classDef);//check constructor chain is ok
		addTraitMethodsToClass(classDef);//if we implement traits then add default methods

		//we need to create bridge methods for any public methods of a non public superclass
		classDef.bridgeMethodsForNonpublicClassSuperMethods = new ArrayList<FuncDef>(0);
		if(classDef.resolvedSuperType != null) {
			if(classDef.resolvedSuperType.accessModifier != AccessModifier.PUBLIC) {
				NamedType superAsNamed = classDef.getSuperAsNamedType(0, 0);
				String superFullName = superAsNamed.getCheckCastType();
				
				HashMap<String, HashSet<FuncType>> locallyDefined = null;
				
				for(Pair<String, TypeAndLocation> superMethod : superAsNamed.getAllMethods(this)) {
					TypeAndLocation tal = superMethod.getB();
					Location loc = tal.getLocation();
					if(loc instanceof ClassFunctionLocation) {
						ClassFunctionLocation cfl = (ClassFunctionLocation)loc;
						if(cfl.owner.equals(superFullName)) {
							Type tt = tal.getType();
							if(tt instanceof FuncType) {
								FuncType asFT = (FuncType)tt;
								if(asFT.getUnderlyingDefAccessMod() == AccessModifier.PUBLIC) {//declared in the class and public
									
									if(locallyDefined == null) {
										locallyDefined = new HashMap<String, HashSet<FuncType>>();
										for(Pair<String, TypeAndLocation> nametoTal : classDef.getAllLocallyDefinedMethods()) {
											String tname = nametoTal.getA();
											HashSet<FuncType> fset = locallyDefined.get(tname);
											if(fset == null) {
												fset = new HashSet<FuncType>();
												locallyDefined.put(tname, fset);
											}
											
											Type ta = nametoTal.getB().getType();
											if(ta instanceof FuncType) {
												fset.add(((FuncType)ta).copyIgnoreReturnType());
											}
										}
									}
									
									String fname = superMethod.getA();
									
									if(locallyDefined.containsKey(fname)) {
										if(locallyDefined.get(fname).contains(asFT.copyIgnoreReturnType())) {
											continue;//ignore as this method is locally defined
										}
									}
									
									classDef.bridgeMethodsForNonpublicClassSuperMethods.add(asFT.origonatingFuncDef);
								}
							}
						}
					}
				}
				//classDef.resolvedSuperType.getAllLocallyDefinedMethods()
			}
		}
		
		NamedType ret = new NamedType(classDef.getLine(), classDef.getColumn(), classDef);
		classDef.setTaggedType(ret);
		return classDef.isLocalClass?null:ret;//ret;
	}
	
	
	private Pair<String, TypeAndLocation> getArgLessNameAndTal(Pair<String, TypeAndLocation> item) {
		TypeAndLocation tal = item.getB();
		Pair<String, TypeAndLocation> retarglessitem = item;
		Type tt = tal.getType();
		if(tt instanceof FuncType) {
			FuncType retLessFT = ((FuncType)tt).copyIgnoreReturnType();
			retarglessitem = new Pair<String, TypeAndLocation>(item.getA(), new TypeAndLocation(retLessFT, tal.getLocation()));
		}
		return retarglessitem;
	}
	public static HashMap<String, HashMap<Type, HashSet<Pair<ClassDef, Boolean>>>> calctraitVarToClassDef(List<Fiveple<String, ClassDef, Type, Boolean, AccessModifier>> traitVariables) {
		HashMap<String, HashMap<Type, HashSet<Pair<ClassDef, Boolean>>>> traitVarToClassDef = new HashMap<String, HashMap<Type, HashSet<Pair<ClassDef, Boolean>>>>();
			
		for(Fiveple<String, ClassDef, Type, Boolean, AccessModifier> item :  traitVariables) {
			String fname = item.getA();
			HashMap<Type, HashSet<Pair<ClassDef, Boolean>>> store = traitVarToClassDef.get(fname);
			if(store == null) {
				store = new HashMap<Type, HashSet<Pair<ClassDef, Boolean>>>();
				traitVarToClassDef.put(fname, store);
			}
			Type tt = item.getC();
			
			HashSet<Pair<ClassDef, Boolean>> cds = store.get(tt);// new Tuple<ClassDef, Type>(, item.getC()));
			if(null == cds) {
				cds = new HashSet<Pair<ClassDef, Boolean>>();
				store.put(tt,  cds);
			}
			cds.add(new Pair<ClassDef, Boolean>(item.getB(), item.getD()));
		}
		return traitVarToClassDef;
	}
	
	private void validateInjections(ClassDef classDef) {
		boolean hasInjectedFieldsOrMethods = false;
		boolean hasZeroArgInjectedConstructor = false;
		int injectedConstructorCnt = 0;
		for(LineHolder lh : classDef.classBlock.lines) {
			Line lin = lh.l;
			if(lin instanceof Assign) {
				if(!hasInjectedFieldsOrMethods) {
					if(((Assign)lin).isInjected) {
						hasInjectedFieldsOrMethods=true;
					}
				}
			}
			else if(lin instanceof ConstructorDef) {
				ConstructorDef cd = (ConstructorDef)lin;
				if(cd.isInjected) {
					//if(cd.params.isEmpty()) {
						hasZeroArgInjectedConstructor = true;
					//}
					injectedConstructorCnt++;
				}else if(cd.params.isEmpty()) {//zero arg constructor
					hasZeroArgInjectedConstructor = true;
				}
			}else if(lin instanceof FuncDef) {
				FuncDef fd = (FuncDef)lin;
				if(fd.isInjected) {
					hasInjectedFieldsOrMethods=true;
				}
			}
		}
		
		if(hasInjectedFieldsOrMethods && !hasZeroArgInjectedConstructor && (!classDef.isTrait & !classDef.getIsAbstract())) {
			String classNameForErrors = classDef.isAnonClass?"Anonymous Class" : classDef.className;
			this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Class: %s cannot have injectable fields or methods without an injectable constructor", classNameForErrors));
		}
		
		if(injectedConstructorCnt > 1) {
			String classNameForErrors = classDef.isAnonClass?"Anonymous Class" : classDef.className;
			this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("Class: %s may have only one injectable constructor, it has: %s", classNameForErrors, injectedConstructorCnt));
		}
	}
	
	public static Pair<List<NamedType>, ArrayList<Fourple<String, String, Boolean, TypeAndLocation>>> createTraitSuperRefImpls(ScopeAndTypeChecker satc, int line, int col, List<NamedType> traitsAndClasses, NamedType superType) {
		//create methods like: traitSuper$com$myorg$code2$MyTrait$$aMethod - to link trait hierarhcy
		List<NamedType> linearizedTraitsInitCalls = null;
		ArrayList<Fourple<String, String, Boolean, TypeAndLocation>> traitSuperRefsImpls = new ArrayList<Fourple<String, String, Boolean, TypeAndLocation>>(0);
		
		traitsAndClasses.add(superType);
		List<NamedType> linearInst = new ArrayList<NamedType>();
		
		while(!traitsAndClasses.isEmpty()) {//ordered from right to left
			NamedType item = traitsAndClasses.remove(0);
			if(null != item) {
				linearInst.add(item);
				traitsAndClasses.add(0, item.getResolvedSuperTypeAsNamed());
				traitsAndClasses.addAll(0, item.getResolvedTraitsAsNamed());
			}
		}
		
		if(!linearInst.isEmpty()) {
			Collections.reverse(linearInst);
			HashSet<NamedType> already = new HashSet<NamedType>();
			
			List<NamedType> newlinearInst = new ArrayList<NamedType>();
			for(NamedType item : linearInst) {
				if(already.contains(item)) {
					continue;
				}else {
					already.add(item);
					newlinearInst.add(item);
				}
			}

			Collections.reverse(newlinearInst);
			linearInst = newlinearInst;
			
			linearizedTraitsInitCalls = new ArrayList<NamedType>();
			for(NamedType inst : linearInst) {
				ClassDef cd = inst.getSetClassDef();
				if(!cd.isTrait) {
					break;
				}else if(cd.getAllFieldsDefined().stream().anyMatch(ax -> ax.getC())) {
					linearizedTraitsInitCalls.add(inst);
				}
			}
						
			//classDef.linearizedTraitsInitCalls = linearInst.stream().filter(a -> a.getSetClassDef().isTrait && a.getSetClassDef().getAllFieldsDefined().stream().anyMatch(ax -> ax.getC())).collect(Collectors.toList());
			
			//if thing is non trait then ignore rhs
			
			//now we see if there are any SuperRefs needing colouring
			if(linearInst.stream().anyMatch(a -> !a.getSetClassDef().traitSuperRefs.isEmpty())) {
				int linstSz = linearInst.size();
				for(int n = 0; n < linstSz; n++) {
					NamedType inst = linearInst.get(n);
					ClassDef cCD = inst.getSetClassDef();
					int cPrefixLen = ("traitSuper$" + cCD.bcFullName().replace("/", "$") + "$$").length();
					
					HashSet<Pair<String, FuncType>> traitSuperRefs = cCD.traitSuperRefs;
					if(!traitSuperRefs.isEmpty()) {
						for(Pair<String, FuncType> tocolor : traitSuperRefs) {
							String methodNameFull = tocolor.getA();
							String methodName = methodNameFull.substring(cPrefixLen);
							
							FuncType ftWanted = tocolor.getB();
							
							boolean found = false;
							for(int m = n+1; m < linstSz; m++) {//search rhs for definition approperiate for super
								NamedType toTry = linearInst.get(m);
								if((toTry.getSetClassDef() != null && !toTry.getSetClassDef().isTrait) || ClassDef.classHasTraitAnnotation(toTry.getSetClassDef())) {//must be a trait
									List<Pair<String, TypeAndLocation>> allmethods = toTry.getAllLocallyDefinedMethods(null, false, true);
									for(Pair<String, TypeAndLocation> meth : allmethods) {
										if(meth.getA().equals(methodName)) {
											Type tt = meth.getB().getType();
											if(ftWanted.equals(tt) && !((FuncType)tt).isAbstarct() ) {//found mapping!
												Fourple<String, String, Boolean, TypeAndLocation> mapTo = new Fourple<String, String, Boolean, TypeAndLocation>(methodNameFull, methodName, !toTry.isInterface(), meth.getB());
												traitSuperRefsImpls.add(mapTo);
												found=true;
												break;
											}
										}
									}
								}
								
								if(found) {
									break;
								}
							}
							
							if(!found && null != satc) {
								satc.raiseError(line, col, String.format("Unable to resolve non abstract super reference for method: %s of trait: %s", methodName, cCD));
							}
							
						}
					}
				}
			}
		}
		
		return new Pair<List<NamedType>, ArrayList<Fourple<String, String, Boolean, TypeAndLocation>>>(linearizedTraitsInitCalls, traitSuperRefsImpls);
	}
	
	private NamedType checkTraitSuperClasses(int line, int column, NamedType cd) {
		List<NamedType> traits = cd.getResolvedTraitsAsNamed();
		List<NamedType> toCheck = new ArrayList<NamedType>(traits); 
		Set<NamedType> foundSuper = new HashSet<NamedType>();
		
		while(!toCheck.isEmpty()) {
			NamedType trait = toCheck.remove(0);
			if(null != trait) {
				NamedType resolved = trait.getResolvedSuperTypeAsNamed();
				if(null != resolved && !resolved.equals(ScopeAndTypeChecker.const_object)) {
					ClassDef rcd = resolved.getSetClassDef();
					if(rcd == null) {
						continue;
					}
					
					if(rcd.isTrait) {
						toCheck.add(resolved);
					}else {//must be concrete type
						foundSuper.add(resolved);
					}
				}
				
			}
		}
		
		int sz = foundSuper.size();
		
		if(sz == 0) {
			return null;
		} else if(sz == 1) {
			return foundSuper.iterator().next();
		}
		else {

			Map<Type, Pair<Integer, Integer>> offenders = new HashMap<Type, Pair<Integer, Integer>>();
			foundSuper.forEach(a -> offenders.put(a, new Pair<Integer, Integer>(line, column)));
			
			NamedType mostgen = (NamedType)TypeCheckUtils.getMoreGeneric(this, this, line, column, new ArrayList<Type>(foundSuper), offenders, false);
			
			if(!foundSuper.contains(mostgen)) {
				String traitMsg = String.join(", ", traits.stream().map(a -> "" + a).sorted().collect(Collectors.toList()));
				String supMsg = String.join(", ", foundSuper.stream().map(a -> "" + a).sorted().collect(Collectors.toList()));
				this.raiseError(line, column, String.format("Traits: %s extend differing non related non trait supertypes: %s - they cannot be used together in concrete classes", traitMsg, supMsg));
			}
						
			return mostgen;
		}
	}
	
	
	/**
	 * Find the origon of the method in question, if two or more are defined in different trait classes then we have a clash which needs resolving
	 * @param traitInstances
	 * @return
	 */
	private List<Thruple<String, FuncType, List<String>>> traitMethodClashes(ClassDef cd) {
		List<Thruple<String, FuncType, List<String>>> ret = new ArrayList<Thruple<String, FuncType, List<String>>>(0);
		
		HashMap<Pair<String, TypeAndLocation>, HashSet<NamedType>> itemToLocations = new NamedType(cd).getAllMethodOrigins(this);
		
		for(Pair<String, TypeAndLocation> methodx : itemToLocations.keySet()) {//find those with more than one origin
			HashSet<NamedType> sources = itemToLocations.get(methodx);
			if(sources.size() > 1) {//an offender! This needs a definition in the concrete class
				//filter out instances having the locations being heirachically related to one another
				LowestCommonAncestor lca = new LowestCommonAncestor(sources, false, new HashSet<Type>());
				NamedType found = lca.go();
				if(!sources.contains(found)) {//at least one not hierarhcually related
					ret.add(new Thruple<String, FuncType, List<String>>(methodx.getA(), (FuncType)methodx.getB().getType(), sources.stream().map(a -> a.toString()).sorted().collect(Collectors.toList())));
				}
			}
		}
		
		return ret;
	}
	
	private void addTraitMethodsToClass(ClassDef cd) {
		if(!cd.isTrait) {
			cd.addMethodsToTraits = null;
			
			HashSet<Pair<String, TypeAndLocation>> traitMethods = new HashSet<Pair<String, TypeAndLocation>>();
			for(NamedType trait : cd.getTraitsAsNamedType(0, 0, false)) {
				List<Pair<String, TypeAndLocation>> traitCollec = trait.getAllLocallyDefinedMethods(this, false, false);//right most definitions first
				traitCollec.removeAll(trait.getAllLocallyDefinedMethods(this, true, false));//remove abstract
				traitMethods.addAll(traitCollec);
			}
			traitMethods.removeAll(cd.getAllLocallyDefinedMethods());//remove things overriden in class here
			
			cd.addMethodsToTraits = traitMethods.stream().map(a -> a.getB()).collect(Collectors.toList());
		}
	}
	
	
	private ArrayList<NamedType> checkInferfaceHierarchy(int line, int col, boolean checkForErrors, ClassDef... classDefs) {
		//check to see that there is no conflict in generic type heirarchy, as more than one element in the hierarchy may qualify a trait A < B ~T, but B also ~ T in hierarchy

		ArrayList<NamedType> ifaces = new ArrayList<NamedType>();
		
		for(ClassDef classDef : classDefs) {
			HashSet<ClassDef> visitAlready = new  HashSet<ClassDef>();
			visitAlready.add(classDef);
			
			NamedType sup = classDef.getFullyqualifiedSuperClassRef(line, col);
			while(sup != null) {
				ifaces.addAll(sup.getResolvedTraitsAsNamed());
				
				ClassDef thingCD = sup.getSetClassDef();
				if(thingCD == null) {
					sup = null;
				}else {
					if(visitAlready.contains(thingCD)) {
						classDef.resolvedSuperType = null;
						return new ArrayList<NamedType>();
					}else {
						visitAlready.add(thingCD);
						sup = sup.getSetClassDef().getFullyqualifiedSuperClassRef(line, col);
					}
				}
			}

			ifaces.addAll(classDef.getTraitsAsNamedType(line, col));
		}
		
		
		ArrayList<NamedType> ret = new ArrayList<NamedType>(ifaces);
		
		HashMap<ClassDef, HashSet<NamedType>> templateTogenericImpl = new HashMap<ClassDef, HashSet<NamedType>>();
		while(!ifaces.isEmpty()) {
			NamedType ifaceInst = ifaces.remove(0);
			if(null != ifaceInst) {
				ClassDef template = ifaceInst.getSetClassDef();
				if(template != null && ifaceInst.hasGenTypes()) {//only consider generic traits
					HashSet<NamedType> inst = templateTogenericImpl.getOrDefault(template, new HashSet<NamedType>());
					inst.add(ifaceInst);
					templateTogenericImpl.put(template, inst);
				}
				
				ifaces.addAll(ifaceInst.getResolvedTraitsAsNamed());
			}
			
		}
		
		//now check for conflicting qualifications of generic types
		StringBuilder sb = null;
		if(checkForErrors) {
			for(ClassDef templ : templateTogenericImpl.keySet()) {
				HashSet<NamedType> insts = templateTogenericImpl.get(templ);
				if(insts.size() > 1) {//differing impls
					if(sb == null) {
						sb = new StringBuilder();
					}
					sb.append(String.format("The generic trait %s cannot be qualified more than once with different arguments in the hierarchy for class: %s. Incompatible definitions: %s", templ, classDefs[0], String.join(", ", insts.stream().map(Object::toString).sorted().collect(Collectors.toList()))));//JPT: grammar could be better here
				}
			}
		}
		
		if(sb != null) {
			this.raiseError(line, col, sb.toString());
		}
		
		return ret;
	}
	
	private Pair<FuncDef, FuncDef> funcDefNeedsBridgeMethod(FuncDef originFD, FuncDef definedFD) {
		FuncType originFT = originFD.getFuncType();
		FuncType definedFT = definedFD.getFuncType();
		
		boolean differs = false;
		int n=0;
		for(Type origParam : originFT.inputs) {
			if(origParam instanceof GenericType) {
				Type compTo = definedFT.inputs.get(n);
				if(compTo instanceof GenericType) {
					compTo = ((GenericType)compTo).upperBound;
				}
				
				if(!((GenericType)origParam).upperBound.equals(compTo)) {
					differs=true;
					break;
				}
			}
			n++;
		}
		
		if(!differs) {
			if(originFT.retType instanceof GenericType) {
				Type compTo = definedFT.retType;
				if(compTo instanceof GenericType) {
					compTo = ((GenericType)compTo).upperBound;
				}
				
				if(!((GenericType)originFT.retType).upperBound.equals(definedFT.retType)) {
					differs=true;
				}
			}
		}
		
		if(differs) {
			return new Pair<FuncDef, FuncDef>(originFD, definedFD);
		}
		
		return null;
	}
	
	

	private boolean areAllArgsCallable(FuncType sig) {
		for(Type inpuut : sig.inputs){
			if(inpuut instanceof NamedType){
				NamedType nt = ((NamedType)inpuut);
				if( const_cls_initUncreatable.equals(nt.getSetClassDef())){
					return false;
				}
			}
		}
		return true;
	}

	public static final ClassDef const_cls_initUncreatable = new ClassDefJava(InitUncreatable.class); 
	public static final NamedType const_initUncreatable = new NamedType(new ClassDefJava(InitUncreatable.class, true)); 
	public static final NamedType const_cls_Decoder_nt = new NamedType(new ClassDefJava(Decoder.class, true)); 
	public static final NamedType const_cls_Encoder_nt = new NamedType(new ClassDefJava(Encoder.class, true)); 
	
	private boolean findOneArgFunction(HashSet<TypeAndLocation> tals, NamedType theArg){
		for(TypeAndLocation tal : tals){
			Type ttal = tal.getType();
			if(ttal instanceof FuncType){
				FuncType ft = (FuncType)ttal;
				if(ft.retType.equals(const_void)){
					ArrayList<Type> inputs = ft.getInputs();
					if(inputs.size() == 1 && inputs.get(0).equals(theArg)){
						return true;
					}
				}
			}
		}
		return false;
	}
	
	private void checkToFromBinaryBothDefined(int line, int column){//for dma
		boolean toBinaryDMA = false;
		boolean fromBinaryDMA = false;
		
		Map<String, HashSet<TypeAndLocation>> funcs = this.currentScopeFrame.getAllFunctions();
		for(String fname : funcs.keySet()){
			if(fname.equals("toBinary")){
				toBinaryDMA = findOneArgFunction(funcs.get(fname), const_cls_Encoder_nt);
			} else if(fname.equals("fromBinary")){
				fromBinaryDMA = findOneArgFunction(funcs.get(fname), const_cls_Decoder_nt);
			}
		}
		
		if(toBinaryDMA != fromBinaryDMA){//so one but not the other was defined
			this.raiseError(line, column, String.format("If public %s is defined then public %s must also be defined", toBinaryDMA?"toBinary(Encoder)":"fromBinary(Decoder)", toBinaryDMA?"fromBinary(Decoder)":"toBinary(Encoder)" ));
		}
	}
	
	private boolean validateClassDefArgs(ClassDef classDef, TheScopeFrame classSF, HashSet<String> superClassReferencedVariableNames, HashSet<String> actorClassReferencedVariableNames, ArrayList<Type> defConArgs, ArrayList<ConstArg> constructorArgs){
		boolean shouldMakeConstructor=true;
		if( classDef.classDefArgs != null &&  classDef.classDefArgs.aargs != null && !classDef.classDefArgs.aargs.isEmpty())
		{
			//if variable is referenced in superconsturor list then dont define it as a local variable...
			//classDef.superClassExpressions
			
			HashSet<String> alreadyDefined = new HashSet<String>();
			ClassDefArg prevP=null;
			//now we have some defualt fields to make and a constructor
			for(ClassDefArg arg : classDef.classDefArgs.aargs){
				String name = arg.name; 
				Type argType = arg.type;
				//boolean isFinal = arg.isFinal; 
				String prefix = arg.prefix;
				Expression defaultValue = arg.defaultValue;
				
				int line = arg.getLine();
				int column = arg.getColumn();
				
				if(null != defaultValue){
					Type dvType = (Type)defaultValue.accept(this);
					boolean isvalid = TypeCheckUtils.isValidType(dvType);
					
					if(dvType instanceof VarNull && argType == null){
						//dvType = argType!=null?argType:((VarNull) dvType).getTaggedType();
						argType = const_object.copyTypeSpecific();
					}
					
					if(!isvalid){
						this.raiseError(line, column, String.format("Invalid default value type %s", dvType));
						//return null;
						dvType=const_object;//panic
					}
					
					if(argType != null){
						if(TypeCheckUtils.typeContainsAGenericType(argType, declaredGenerics()) && !(defaultValue instanceof VarNull)){
							this.raiseError(line, column, "default value besides null cannot be used for generic type assignment");
						}
						
						Type subt = argType==dvType?dvType:TypeCheckUtils.checkSubType(this, argType, dvType, line, column, line, column);
						argType = subt==null?argType:subt;
					}
					else{
						argType = dvType;
						arg.type = argType;
					}
				}
				else if(argType == null){
					this.raiseError(line, column, String.format("Either a type or default value must be specified for parameter %s", name));
					argType = const_object;
				}
				
				boolean annotationnamesValid=true;
				if(arg.annotations != null){
					if(currentScopeFrame.isClass()){
						for(Annotation annot : arg.annotations.annotations){
							annot.location = Annotation.AnnotationLocation.CLASSDEFPARAM;
						}
					}
					//check getter/setter valid if defined
					validateAnnotaionLocationVsPrefix(arg.annotations, prefix);
					
					this.maskErrors(true);
					arg.annotations.setUsedAt(ElementType.PARAMETER);
					arg.annotations.accept(this);
					if(applyMaskedErrors()){//supress double reporting of error
						annotationnamesValid=false;
					}
				}
				
				
				
				if(arg.isVararg && null != argType){
					argType = (Type)argType.copy();
					argType.setArrayLevels(argType.getArrayLevels()+1);
				}
				arg.setTaggedType(argType);

				
				if(arg.defaultValue != null && prevP != null && prevP.isVararg ){//JPT: below is dirty copy paste, refactor? - from below yuck!
					//check type is not compatible with the prevous thing
					Type withDefault = arg.getTaggedType();
					Type theVararg = prevP.getTaggedType();
					if(null != theVararg && null != withDefault && theVararg.hasArrayLevels()){
						theVararg = (Type)theVararg.copy();
						theVararg.setArrayLevels(theVararg.getArrayLevels()-1);
						
						if(null != TypeCheckUtils.checkSubType(this.ers, theVararg, withDefault, 0, 0, 0, 0)){
							this.raiseError(arg.getLine(), arg.getColumn(), String.format("Parameter %s with default value may not immediately follow vararg parameter: %s having type of: %s which can be included in the vararg", arg.name, prevP.name, withDefault ));
						}
					}
				}
				
				if(arg.isVararg  && prevP != null && prevP.defaultValue != null){
					//check type is not compatible with the prevous thing
					Type withDefault = prevP.getTaggedType();
					Type theVararg = arg.getTaggedType();
					if(null != theVararg && null != withDefault && theVararg.hasArrayLevels()){
						theVararg = (Type)theVararg.copy();
						theVararg.setArrayLevels(theVararg.getArrayLevels()-1);
						
						if(null != TypeCheckUtils.checkSubType(this.ers, theVararg, withDefault, 0, 0, 0, 0)){
							this.raiseError(arg.getLine(), arg.getColumn(), String.format("Vararg parameter %s may not immediately follow parameter with default value: %s having type of: %s which can be included in the vararg", arg.name, prevP.name, withDefault ));
						}
					}
				}
				
				
				
				if(classSF.hasVariable(classSF, name, false, true, false) || alreadyDefined.contains(name))
				{
					shouldMakeConstructor = false;
					this.raiseError(arg.getLine(), arg.getColumn(), String.format("Cannot define variable: %s more than once", name));
				}
				else if(arg.isFinal && ("~".equals(prefix) || "+".equals(prefix) ) ){
					//shouldMakeConstructor = false;//we can still gennerate a constructor
					this.raiseError(arg.getLine(), arg.getColumn(), String.format("Cannot autodefine setter for field %s that has been declared val", name));
				}
				else
				{
					this.maskErrors(true);
					/*Type got = (Type)*/argType.accept(this);
					//argType.setOrigonalGenericTypeUpperBound(got.getOrigonalGenericTypeUpperBound());
					boolean wereerrors = this.maskedErrors();
					
					
					boolean toAddfield = false;
					
					if(!superClassReferencedVariableNames.contains(name) && !actorClassReferencedVariableNames.contains(name)) {//don't add the class variable if it gets passed directly on to the superclass
						toAddfield=true;
						//mark as autogennerated
					}else if(superClassReferencedVariableNames.contains(name) && prefix != null) {
						ClassDef sueperCls = classDef.getSuperclass();
						if(null != sueperCls) {
							TypeAndLocation varinSuper = sueperCls.getVariable(null, name);
							if(null == varinSuper) {
								toAddfield=true;
								superClassReferencedVariableNames.remove(name);//will need to set field in constructor
							}else{//see if superclass has the field, if so add getter setter if prefix
								//toAddfield=true;
								Location loc = varinSuper.getLocation();
								if(loc != null && loc instanceof LocationClassField) {
									LocationClassField lcf = (LocationClassField)loc;
									if(lcf.getAccessModifier() != AccessModifier.PRIVATE) {
										addGetterSetter(prefix, name, argType, arg.annotations, arg.getLine(), arg.getColumn(), true);
									}
								}
								
							}
						}
					}
					
					if(/*!classDef.constructorsAlreadyAdded &&*/ toAddfield) {
						Annotations annotationsForField = !annotationnamesValid?null:extractAnnotationsForElement(arg.annotations, "param"); 
						Type varType = argType;
						if(wereerrors){
							varType = ScopeAndTypeChecker.const_object;
						}
						
						varType = (Type)varType.copy();
						varType.setAutoGenenrated(true);
						
						FunctionGenneratorUtils.addClassVariable(ers, this, classDef, name, prefix, varType, classDef.getLine(), classDef.getColumn(), arg.isFinal, arg.am, annotationsForField, arg.isTransient, arg.isShared, arg.isOverride, arg.isLazy);
					}
					
					defConArgs.add(argType);
					Annotations annotationsForConstructor = !annotationnamesValid?null:extractAnnotationsForElement(arg.annotations, "param", true);//param or just the thing by itself
					
					if(arg.isVararg){
						//we temp added a level, so now remove it
						argType = (Type)argType.copy();//dirty programming sin, reusing same arg name
						argType.setArrayLevels(argType.getArrayLevels()-1);
					}
					
					constructorArgs.add(new ConstArg(name, argType, arg.isFinal, annotationsForConstructor, defaultValue, arg.isVararg, arg.isLazy, arg.isShared));
				}
				
				alreadyDefined.add(name);
				prevP = arg;
			}
		}
		return shouldMakeConstructor;
	}
	
	
	private String getfullClassName(){
		StringBuilder sbam = new StringBuilder(this.truePackageName + "$");
		for(int no=0; no < nestorParens.size(); no++)
		{
			String cls = nestorParens.get(no);
			sbam.append(cls);
			if(no != nestorParens.size()-1){
				sbam.append("$");
			}
		}
		return sbam.toString();
	}
	
	/**
	 * Return if function exists aleady, also consdiering functions to which we have not yet infered return type
	 */
	private boolean hasfuncDefDefinedInClassAlready(String name, FuncType sig){
		return hasfuncDefDefinedInClassAlready(name, sig, false);
	}
	
	private boolean hasfuncDefDefinedInClassAlready(String name, FuncType sig, boolean ignoreAutoGen){
		if(ExisitsAlready.FALSE != currentScopeFrame.hasFuncDef(currentScopeFrame, name, sig, false, ignoreAutoGen, true, false, false)){
			return true;
		}
		
		//and no ret type determined yet...
		FuncType sigNoRet = sig.copyTypeSpecific();
		sigNoRet.retType=null;
		if(ExisitsAlready.FALSE != currentScopeFrame.hasFuncDef(currentScopeFrame, name, sigNoRet, false, ignoreAutoGen, true, false, false)){
			return true;
		}
		
		ClassDef cdIn = this.currentlyInClassDef.peek();
		for(NamedType nt : cdIn.getTraitsAsNamedType(0, 0, false)) {
			if(null != nt) {
				List<Pair<String, TypeAndLocation>> items = nt.getAllMethods(this);
				for(Pair<String, TypeAndLocation> item : items) {
					if(item.getA().equals(name) && item.getB().getType().equals(sig)) {
						
						Location loc = item.getB().getLocation();
						if(loc instanceof ClassFunctionLocation) {
							ClassFunctionLocation cfl = (ClassFunctionLocation)loc;
							if(cfl.ownerType.equals(ScopeAndTypeChecker.const_object)) {
								continue;
							}
						}
						
						return true;
					}
				}
			}
		}
		
		return false;
		
	}
	
	private boolean everyFieldHasGetter(){
		for(VarAtScopeLevel item  : currentScopeFrame.getAllVariablesAtScopeLevel(false, true, false, false)){
			String getterName = FunctionGenneratorUtils.getGetterName(item.getVarName(), this.getErrorRaiseableSupression(), item.getType(), 0,0);
			if(!currentScopeFrame.hasFuncDef(currentScopeFrame, getterName, false, false, false)){
				return false;
			}
		}
		return true;
	}
	
	private boolean excludeFromActorMethodGen(String name, ArrayList<Type> args){
		if(name.equals("getClass") && args.isEmpty()){
			return true;
		}
		else if(name.equals("toString") && args.isEmpty()){
			return true;
		}
		else if(name.equals("hashCode") && args.isEmpty()){
			return true;
		}
		else if(name.equals("equals") && args.size()==1 && args.get(0).equals(const_object)){
			return true;
		}
		
		return false;
	}
	
	private static final FuncType eqSignature;
	static{
		ArrayList<Type> sInputs = new ArrayList<Type>(); sInputs.add(const_object);
		eqSignature = new FuncType(sInputs, new PrimativeType(PrimativeTypeEnum.BOOLEAN));
	}
	
	private static final FuncType hashCodeSig;
	static{
		ArrayList<Type> hcsInputs = new ArrayList<Type>();
		hashCodeSig = new FuncType(hcsInputs, new PrimativeType(PrimativeTypeEnum.INT));
	}
	
/*	private static final FuncType toStringSig;
	static{
		ArrayList<Type> hcsInputs = new ArrayList<Type>();
		toStringSig = new FuncType(hcsInputs, const_string);
	}*/
	
	
	
	
	public boolean equals(Object other){
		if(other instanceof ScopeAndTypeChecker){
			ScopeAndTypeChecker theOther = (ScopeAndTypeChecker)other;
			if(theOther.isFirstStmtInBlock == this.isFirstStmtInBlock && theOther.localLambdaCount == this.localLambdaCount){
				//etc
				return true;
			}
		}
		return false;
	}
	
	private boolean isRecursive(Type currentPoint, HashMap<Type, Type> typeToType, HashSet<Type> seenSoFar)
	{
		Type nextHop = typeToType.get(currentPoint);
		if(null != nextHop)
		{
			seenSoFar.add(currentPoint);
			if(seenSoFar.contains(nextHop))
			{
				return true;
			}
			else
			{
				return isRecursive(nextHop, typeToType, seenSoFar);
			}
		}
		return false;
	}
	
	private void checkConstrutorInvokeGraphForLoops(HashMap<ConstLocationAndType, Type> constructorInvokeGraph )
	{
		//this() -> this(); fail
		//this(double) -> this(int), this(int) -> this(double); fail etc
		
		HashMap<Type, ConstLocationAndType> lhsToOffender = new HashMap<Type, ConstLocationAndType>();
		HashMap<Type, Type> lhsToRhs = new HashMap<Type, Type>();
		for(ConstLocationAndType ct : constructorInvokeGraph.keySet())
		{
			lhsToOffender.put(ct.type, ct);
			lhsToRhs.put(ct.type, constructorInvokeGraph.get(ct));
		}
		
		for(Type startPoint : lhsToRhs.keySet())
		{
			HashSet<Type> seenSoFar = new HashSet<Type>();
			if(isRecursive(startPoint, lhsToRhs, seenSoFar))
			{
				ConstLocationAndType clat = lhsToOffender.get(startPoint);
				int line = clat.line;
				int col = clat.col;
				this.raiseError(line, col, String.format("Recursive constructor invocation is not permitted"));
			}
		}
		
//		if(null != this.currentConstructorDef && !this.currentConstructorDef.isEmpty())
//		{
//			FuncType currentFT = this.currentConstructorDef.peek().getFuncType();
//			if(currentFT.equals(mostSpec))
//			{
//				
//			}//currentConstructorCallGraph = new Stack<ArrayList<Tuple<Type, Type>>>();
//		}
		
	}
	
	
	private void ensureAllSuperConstCalled(ClassDef clsDef)
	{
		HashSet<FuncType> theConstructors = clsDef.getAllConstructors();
		
		String clsErrName = clsDef.isAnonClass?"Anonymous Class" : clsDef.toString();
		
		
		// if(theConstructors.isEmpty()) {} else... - on can never be empty! because we define default noarg as a hack...
		ClassDef sup = clsDef.getSuperclass(); 
		for(FuncType constru : theConstructors){
			FuncDef origonalconstructor = constru.origonatingFuncDef;
			if(null != origonalconstructor)
			{
				if(!origonalconstructor.doithCallsAnotherConstructor())
				{//exclude the dudes who call super or self from the analyss...
					//if there is no default super constructor, then problem
					
					if(!sup.hasNoArgConstructor(this))
					{
						//oh no, class needs to call superconstructor
						this.raiseError(origonalconstructor.getLine(), origonalconstructor.getColumn(), String.format("Implicit super constructor for superclass %s of %s is undefined. Must explicitly invoke another constructor or invoke superconstructor", sup, clsErrName));
					}

					boolean found = false;
					
					if(TypeCheckUtils.isActor(this, new NamedType(sup))){
						//actor MyActor < ....?, so call super(types) if exists
						HashSet<FuncType> oneargcons = sup.getConstructor(1, null);
						if(!oneargcons.isEmpty()){
							for(FuncType con : oneargcons){
								if(con.inputs.get(0).equals(ScopeAndTypeChecker.const_classArray_nt_array)){
									if(con.getUnderlyingDefAccessMod() != AccessModifier.PRIVATE){
										found = true;
										break;
									}
								}
							}
						}
					}
					else{
						HashSet<FuncType> supCons = sup.getConstructor(0, null);
						for(FuncType supC : supCons){
							if(supC.getUnderlyingDefAccessMod() != AccessModifier.PRIVATE){
								found = true;
								break;
							}
						}
					}
					
					if(!found){
						this.raiseError(origonalconstructor.getLine(), origonalconstructor.getColumn(), String.format("Implicit super constructor for superclass %s of %s is private. Must explicitly invoke another non private (e.g. public or protected) constructor in supertype", sup, clsErrName));
					}
					
				}
			}
			else
			{
				if(!sup.hasNoArgConstructor(this))
				{
					//oh no, class needs to call superconstructor
					this.raiseError(clsDef.getLine(), clsDef.getColumn(), String.format("Implicit super constructor for superclass %s of %s is undefined. Must explicitly invoke another constructor or invoke superconstructor", sup, clsErrName));
				}
			}
		}
	}
	
	public String getFullyDottedPackage()
	{
		StringBuilder sb = new StringBuilder();
		
		for(int na = 0; na < packageName.size(); na++)
		{
			sb.append(packageName.get(na));
			if(na != packageName.size()-1)
			{
				sb.append(".");
			}
		}
		return sb.toString();
	}
	
	private boolean currentlyInActorDef(){
		return !this.currentlyInClassDef.isEmpty() && this.currentlyInClassDef.peek().isActor;
	}
	
	private boolean currentlyInTypedActor(){
		if(!this.currentlyInClassDef.isEmpty()) {
			ClassDef cd = this.currentlyInClassDef.peek();
			if(cd.isActor && cd.istypedActor) {
				return true;
			}
		}
		return false;  
	}
	
	private boolean currentlyInTraitDef(){
		return !this.currentlyInClassDef.isEmpty() && this.currentlyInClassDef.peek().isTrait;
	}
	
	private boolean notInActorUnlessItsATypedActor(){
		if(currentlyInActorDef()){
			return  this.currentlyInClassDef.peek().istypedActor;
		}
		return true;
	}
	
	private NamedType currentlyActingOnNestedClass(){
		//assumes in actor already
		ClassDef curCls = this.currentlyInClassDef.peek();
		/*ClassDef pnest = curCls.getParentNestor();
		if(null != pnest){
			return new NamedType(0,0,pnest);
		}*/
		
		NamedType typedActorOn = curCls.typedActorOn;
		if(null != typedActorOn){
			Type actingOn = typedActorOn.getTaggedType();
			if(null != actingOn && actingOn instanceof NamedType){
				return ((NamedType) actingOn).getparentNestorFakeNamedType();
			}
		}
		
		return null;
	}
	
	private boolean inConstructor = false; //this.x = 7 does not get overriten with this.setX(7); etc inConstructor
	public final static String TypesForActor = "types$forActor";
	public final static String NestedTypeRefForActor = "parnest$forActor";//bit OTT!
	
	
	public Object visitReal(ConstructorDef conDef) {
		conDef.funcblock.isConstructor=true;
		conDef.funcblock.isFuncDefBlock=true;
		conDef.funcblock.funcDef = conDef;
		
		HashSet<String> funcArgNames = new HashSet<String>();
		if(null != conDef.params)//TODO: remove null check as can never be null
		{
			for(FuncParam p : conDef.params.params)
			{
				if(funcArgNames.contains(p.name)){
					String anem=p.name;
					//if(!anem.equals(TypesForActor)){//if clause hack to avoid for actors of actors, complaint about double 
						this.raiseError(p.getLine(), p.getColumn(), String.format("Duplicate parameter: %s", anem));
					//}
				}
				else
				{
					funcArgNames.add(p.name);
				}
				p.accept(this);
			}
		}
		
		if(!this.currentlyInClassDef.isEmpty()){
			conDef.origin = this.currentlyInClassDef.peek();
		}
		else{
			//static in module itself
			conDef.origin = this.moduleLevelNamedType;
		}
		
		if(conDef.origin.isTrait) {
			this.raiseError(conDef.getLine(), conDef.getColumn(), "Constructors cannot be defined within traits");
		}
		
		if(conDef.isInjected) {
			if(conDef.annotations == null){
				conDef.annotations = new Annotations();
			}else {
				if(!conDef.annotations.hasAnnotation(const_InjectAnnotationStr)) {
					conDef.annotations.annotations.add((Annotation)const_InjectAnnotation.copy());
				}
			}
			
			/*if(!this.currentlyInClassDef.isEmpty()) {
				ClassDef cd = this.currentlyInClassDef.peek();
				if(cd.isLocalClass || cd.isAnonClass) {
					this.raiseError(conDef.getLine(), conDef.getColumn(), "local and anonymous classes may not have constructors marked with inject");
				}
			}*/
		}
		
		if(conDef.annotations!= null){
			conDef.annotations.setUsedAt(ElementType.CONSTRUCTOR);
			conDef.annotations.accept(this);
			if(null != conDef.funcblock){
				HashSet<WarningVariant> toSupress = Utils.extractSuppressedWarningsFromAnnotations(conDef.annotations, this);
				if(!toSupress.isEmpty()){
					conDef.funcblock.suppressedWarnings.addAll(toSupress);
				}
			}
		}
		
		boolean currentInActor = currentlyInActorDef();
		if(currentInActor){
			
			if(!funcArgNames.contains(TypesForActor)){
				FuncParam p = new FuncParam(conDef.getLine(),conDef.getColumn(), TypesForActor, const_classArray_nt_array, true);
				conDef.params.params.add(0, p);
				p.accept(this);	
			}
			
			NamedType nestee = currentlyActingOnNestedClass();
			if(!funcArgNames.contains(NestedTypeRefForActor) && null != nestee){
				FuncParam p = new FuncParam(conDef.getLine(),conDef.getColumn(), NestedTypeRefForActor, nestee, true);
				conDef.params.params.add(1, p);
				p.accept(this);	
			}
			
		}
		
		
		
		if(!this.currentScopeFrame.isClass()){
			this.raiseError(conDef.getLine(), conDef.getColumn(), "Constructors can only be defined within class definitions");
			if(conDef.accessModifier == null){
				conDef.accessModifier = AccessModifier.PUBLIC;//default public
			}
		}
		else
		{
			ClassDef curClass = this.currentlyInClassDef.peek();
			
			if(curClass.isAnonClass && !curClass.isActor) {
				if(conDef.params != null && conDef.params.params.size() > 0) {
					if(!conDef.params.params.stream().allMatch(a -> a.name.contains("$"))) {//unless synthetic nested params
						this.raiseError(conDef.getLine(), conDef.getColumn(), "Anonymous classes may only define zero arg constructors (if any)");
					}
				}
			}
			
			conDef.isEnumconstru = curClass.isEnum;//add extra arguments
			if(conDef.isEnumconstru){
				conDef.isEnumconstruSubClass = this.currentlyInClassDef.peek().isEnumSubClass;
				if(conDef.accessModifier == null){
					conDef.accessModifier = conDef.isEnumconstruSubClass?AccessModifier.PUBLIC:AccessModifier.PRIVATE;//default public
				}
				else if(conDef.accessModifier != AccessModifier.PRIVATE && !conDef.isEnumconstruSubClass){
					this.raiseError(conDef.getLine(), conDef.getColumn(), "enum constructors can only be private");
				}
			}
			else{
				if(conDef.accessModifier == null){
					conDef.accessModifier = AccessModifier.PUBLIC;//default public
				}
			}
			
			if(conDef.isEnumconstruSubClass && !conDef.isAutoGennerated){
				//ensure first line is super or this call
				boolean firstLineIsCon = true;
				if(null == conDef.funcblock || conDef.funcblock.lines == null || conDef.funcblock.lines.isEmpty()){
					firstLineIsCon=false;
				}
				else{
					LineHolder lh = conDef.funcblock.lines.get(0);
					if(lh.l instanceof DuffAssign){
						DuffAssign da = (DuffAssign)lh.l;
						firstLineIsCon = da.e instanceof SuperOrThisConstructorInvoke;
					}
				}
				
				if(!firstLineIsCon){
					this.raiseError(conDef.getLine(), conDef.getColumn(), "First line of constructor for enum element must be a this or super call");
				}
				
			}
			
			currentConstructorDef.push(conDef);
			
			
			boolean prev = inConstructor;//TODO: refactor out inConstructor because there is a stack for it
			this.inConstructor = true;
			
			FuncType sigCheck = conDef.getFuncType();
			
			ExisitsAlready hasConst = this.currentScopeFrame.hasConstructor(this.currentScopeFrame, sigCheck, sigCheck.getAutoGennerated(), false);
			if(hasConst == ExisitsAlready.TRUE)
			{
				this.raiseError(true, conDef.getLine(), conDef.getColumn(), "Constructor with matching argument definition exists already in current Scope");
			}
			else if(hasConst == ExisitsAlready.TRUE_GT_ERASED)
			{
				this.raiseError(true, conDef.getLine(), conDef.getColumn(), "Constructor with matching argument definition exists already in current Scope - generic types are erased at runtime");
			}
			else
			{
				//check to see if exists with default arguments ignored
				ExisitsAlready existAlreadyMinSet = this.currentScopeFrame.hasConstructor(this.currentScopeFrame, sigCheck, sigCheck.getAutoGennerated(), true);
				
				if(ExisitsAlready.TRUE == existAlreadyMinSet){
					this.raiseError(true, conDef.getLine(), conDef.getColumn(), "Constructor with matching argument definition exists already in current Scope when default arguments are ignored");
				}
				else if(ExisitsAlready.TRUE_GT_ERASED == existAlreadyMinSet){
					this.raiseError(true, conDef.getLine(), conDef.getColumn(),"Constructor with matching argument definition exists already in current Scope - generic types are erased at runtime when default arguments are ignored");
				}
				
				this.currentScopeFrame.setConstructor(sigCheck);
			}
			
			if(needToAddActorOnInitCall(conDef.funcblock)){//we add some code here... remove once init bug fixed
				int line = conDef.funcblock.getLine();
				int col = conDef.funcblock.getColumn();
				conDef.funcblock.add(new LineHolder(line, col, new DuffAssign(line, col, DotOperator.buildDotOperatorOne(line, col, new RefSuper(line, col), new FuncInvoke(line, col,"onInit")))));
			}
			
			this.level++;
			
			//this.dotOperatorLHS.push(null);//fresh scope
			//this.currentDotOperatorTracker.push(new DotOperatorAndIndex(false));
			conDef.funcblock.accept(this);
			//this.dotOperatorLHS.pop();
			//this.currentDotOperatorTracker.pop();
			
			this.level--;
			
			this.inConstructor = prev;
			currentConstructorDef.pop();
		}
		
		
		
		
		if(Utils.funcParamsHaveDefaults(conDef.params) && !currentlyInTypedActor() /*!currentlyInActorDef()*/   ){// && notInActorUnlessItsATypedActor()){
			//(satc, ScopeAndTypeChecker satc, FuncDef funcDef, TheScopeFrame myScopeFrame, Block currentBlock)
			FunctionGenneratorUtils.addwithDefaultsMethod(this.ers, this, conDef, this.currentScopeFrame, this.currentlyInBlock.peek());
		}
		
		return null;
	}
	
	private boolean needToAddActorOnInitCall(Block body){
		//has super.onInit(); been added to last line of body already?
		if(!this.currentlyInClassDef.peek().isActor){
			return false;
		}
		
		if(body.isEmpty()){
			return true;
		}
		
		Line lastLine = body.getLast().l;
		if(lastLine instanceof DuffAssign){
			DuffAssign da = (DuffAssign)lastLine;
			if(da.e instanceof DotOperator){
				DotOperator dotOp = (DotOperator)da.e;
				List<Expression> elms = dotOp.getElements(this);
				if(elms.size() == 2 && elms.get(0) instanceof RefSuper){
					Expression e2 = elms.get(1);
					if(e2 instanceof FuncInvoke){
						FuncInvoke fi = (FuncInvoke)e2;
						if((fi.funName.equals("onInit") || fi.funName.equals("onInit$ActorSuperCall")) && fi.args.getArgumentsWNPs().isEmpty()){
							return false;
						}
					}
				}
			}
		}
		
		//also ensure that calls a superconstructor
		/*Line firstLine = body.getFirst().l;
		if(firstLine instanceof DuffAssign){
			DuffAssign asDA = (DuffAssign)firstLine;
			if(asDA.e instanceof SuperConstructorInvoke){
				return true;
			}
		}*/
		
		return true;
		
	}
	
	private ArrayList<Fiveple<String, Type, Boolean, Boolean, Boolean>> varsToAddToScopeOnEntry = new ArrayList<Fiveple<String, Type, Boolean, Boolean, Boolean>>(); 
	private ArrayList<Thruple<String, TypeAndLocation, AccessModifier>> methsToAddToScopeOnEntry = new ArrayList<Thruple<String, TypeAndLocation, AccessModifier>>(); 
	
	
	private void addToScopeStackVars(String varname, Type vartype, Boolean isFinal, Boolean hasBeenAssigned, Boolean isShared)
	{
		this.varsToAddToScopeOnEntry.add(new Fiveple<String, Type, Boolean, Boolean, Boolean>(varname, vartype, isFinal, hasBeenAssigned, isShared));
	}
	
	private void addToScopeStackMethods(String varname, TypeAndLocation vartype, AccessModifier am)
	{
		this.methsToAddToScopeOnEntry.add(new Thruple<String, TypeAndLocation, AccessModifier>(varname, vartype, am));
	}
	
	@Override
	public Object visit(CatchBlocks catchBlocks) {
		HashSet<Type> caughtAlready = new HashSet<Type>();
		boolean allok =true;
		Map<Type, Pair<Integer,Integer>> offenders = new HashMap<Type, Pair<Integer,Integer>>();
		for(Type ca: catchBlocks.caughtTypes){
			Type catchType = (Type)ca.accept(this);
			int line = ((Node)ca).getLine();
			int column = ((Node)ca).getColumn();
			
			if(!TypeCheckUtils.isValidType(this, catchType, line, column)){
				allok = false;
			}
			else{
				boolean ok = TypeCheckUtils.isClassInstanceOfJavaCompiledClass(this, catchType, THROWABLE_NAMEDTYPE , ((Node)ca).getLine(), ((Node)ca).getColumn() );
				
				if(!ok){
					allok=false;
					this.raiseError(line, column, String.format("Attempted to catch Type: %s which is not a subtype of throwable", catchType));
				}
				
				if(caughtAlready.contains(catchType)){
					allok=false;
					this.raiseError(line, column, String.format("Attempted to catch Type: %s more than once in same catch block", catchType));
				}
				caughtAlready.add(catchType);
				offenders.put(catchType, new Pair<>(line, column));
			}
		}
		
		Type mostSpec = TypeCheckUtils.getMoreGeneric(this, this, catchBlocks.getLine(), catchBlocks.getColumn(), new ArrayList<Type>(caughtAlready), offenders );
		if( null == mostSpec){
			return null;
		}
		if(mostSpec instanceof NamedTypeMany){
			mostSpec = mostSpec.getSelf();
		}
		
		addToScopeStackVars(catchBlocks.var, mostSpec, false, true, false);
		catchBlocks.catchBlock.canContainAContinueOrBreak = null;
		catchBlocks.catchBlock.canContainAReturnStmt = null;
		catchBlocks.blockType = (Type)catchBlocks.catchBlock.accept(this);
		catchBlocks.setTaggedType(mostSpec);
		return allok ? mostSpec : null;
	}

	private boolean isFirstStmtInBlock = true;
	private Stack<Boolean> lastThingBlockReturns = new Stack<Boolean>(); 
	private int level;//JPT: this level var can be removed, and stored internally within the currentScopeFrame
	public Stack<Block> currentlyInBlock = new Stack<Block>();
	
	@Override
	public Object visit(Block block) {
		nullableOverwriteType.push(new HashMap<Pair<String, Boolean>, NullStatus>());
		currentlyInBlock.add(block);
		boolean prevIsFirst = isFirstStmtInBlock;
		isFirstStmtInBlock = true;
		
		lambContentsInModStack.push(new HashMap<String, String>());
		
		if(block.isolated){//isolated blocks can have break in them
			block.canContainAContinueOrBreak=null;
		}
		
		if(block.isModuleLevel){
			privateStaticAccessRedirectOverrideCnter=0;
		}
		
		if(!block.isClass)
		{
			if(block.isModuleLevel && this.isREPL != null) {
				enterScopedNameMapREPL();
				this.currentScopeFrame.replAssignedthisIteration.clear();
			}else {
				enterScopedNameMap();
			}
			
			if(block.isDirectParentABlock && this.currentScopeFrame.isClass()/*&& block.isolated*/)
			{
				this.raiseError(block.getLine(), block.getColumn(), "blocks cannot be nested directly within classes");
				currentlyInBlock.pop();
				return null;
			}
			if(!block.isModuleLevel)
			{
				block.canNestModuleLevelFuncDefs=false;
				//mark block if it
				int csize =  currentlyInBlock.size();
				
				for(int n = csize-1; n >=0; n--) {
					Block par = currentlyInBlock.get(n);
					if(par.isFuncDefBlock || par.isClass || par.canNestModuleLevelFuncDefs || par.staticFuncBlock) {
						break;
					}
					if(par.isModuleLevel) {
						block.canNestModuleLevelFuncDefs = true;
						break;
					}
				}
				
				//preserver classes and functions
				this.currentScopeFrame = TheScopeFrame.buildTheScopeFrame_Block(this.currentScopeFrame, block);
				this.currentScopeFrame.staticFunc = block.staticFuncBlock;
				if(block.isFuncDefBlock) {
					this.currentScopeFrame.isFuncDefBlock=true;
					this.currentScopeFrame.funcDef = block.funcDef;
				}
				
				this.currentScopeFrame.enterScope();
			}
			
			addVarsAndMethodsOnEntryTocurrentScope(block.getLine(), block.getColumn());
			
			this.varsToAddToScopeOnEntry = new ArrayList<Fiveple<String, Type, Boolean, Boolean, Boolean>>(); 
			this.methsToAddToScopeOnEntry = new ArrayList<Thruple<String, TypeAndLocation, AccessModifier>>(); 
			
		}

		this.currentScopeFrame.canContainAContinueOrBreak = block.canContainAContinueOrBreak;
		this.currentScopeFrame.canContainAReturnStmt = block.canContainAReturnStmt;
		this.currentScopeFrame.isconstructor = block.isConstructor;
		this.currentScopeFrame.isExtFunc = block.isExtFunc;
		
		Type lastproceded = null;
		
		LineHolder lh = block.startItr();
		
		this.lastThingBlockReturns.push(block.getShouldBePresevedOnStack());
		//boolean expectedRet = block.getShouldBePresevedOnStack();
		
		if(!block.returnExpectedOfEveryStatement){//not on all, just one last...
			ArrayList<LineHolder> linesNoSynth = block.getLinesExcludeSynthetics();
			int upToLine = block.isModuleLevel?linesNoSynth.size():linesNoSynth.size()-1;
			for(int n=0; n < upToLine; n++){
				//set all but last to not return anything, and avoid the stupid synthetic stuff | except if module leve, then tag all of them
				linesNoSynth.get(n).l.setShouldBePresevedOnStack(false);
			}
		}
		boolean leveladjustor = block.isClassFieldBlock|| block.canNestModuleLevelFuncDefs;
		if(leveladjustor){
			this.level++;
		}
		LineHolder lastProcLH=null;
		while(lh != null)
		{
			if(block.isClass) {
				if(!lh.l.getIsValidAtClassLevel())
				{
					this.raiseError(lh.l.getLine(), lh.l.getColumn(), "line cannot be present within class definition");
				}
			}
			if(lh.l instanceof Block){
				((Block)lh.l).isDirectParentABlock = true;
			}
			Type got = (Type)lh.accept(this);
			
			if(!(lh.l instanceof ContinueStatement && ((ContinueStatement)lh.l).isSynthetic)){
				lastproceded = got;
			}
			lastProcLH = lh;
			lh = block.getNext();
			isFirstStmtInBlock=false;
		}
		this.lastThingBlockReturns.pop();
		
		if(block.isModuleLevel) {
			if(this.isREPL != null && /*TypeCheckUtils.isValidType(lastproceded) &&*/ lastProcLH != null) {
				Line ll = lastProcLH.l;
				Expression expr = null;
				boolean fromDA = false;
				if(ll instanceof Expression) {
					expr = (Expression)ll;
				}else if(ll instanceof DuffAssign) {
					fromDA=true;
					expr = ((DuffAssign)ll).e;
				}
				
				if(expr instanceof FuncDef) {
					expr = null;
				}
				if(expr instanceof ClassDef) {
					expr = null;
				}
				
				if(expr != null) {
					boolean canmap = true;
					if(!fromDA && !((Node)expr).getShouldBePresevedOnStack()) {
						this.maskErrors();
						((Node)expr).setShouldBePresevedOnStack(true);
						Type tt = (Type)expr.accept(this);
						canmap = !this.maskedErrors() && TypeCheckUtils.isValidType(tt);
						if(!canmap) {
							((Node)expr).setShouldBePresevedOnStack(false);
						}
					}else {
						canmap = TypeCheckUtils.isValidType(expr.getTaggedType());
						
						((Node)expr).setShouldBePresevedOnStack(true);
					}
					
					if(canmap) {
						String tmpVarName;
						if(expr instanceof RefName) {//hack ans assign to self
							RefName asrn = (RefName)expr;
							tmpVarName = asrn.name;
						}else {
							tmpVarName = this.isREPL.getTmpVarName();
						}
						
						Block blk = new Block(lastProcLH.getLine(), lastProcLH.getColumn());
						blk.add(new DuffAssign(expr));
						blk.isolated = true;
						blk.setShouldBePresevedOnStack(true);
						
						AssignNew an = new AssignNew(null, lastProcLH.getLine(), lastProcLH.getColumn(), tmpVarName, lastproceded, AssignStyleEnum.EQUALS, blk);
						an.isautogenerated=true;
						block.replaceLast(new LineHolder(an));
						
						lastproceded = (Type)an.accept(this);
					}
					
				}
			}
		}
		
		if(leveladjustor){
			this.level--;
		}
		
		if(!block.isClass)
		{
			
			if(block.isModuleLevel) {
				boolean iisrep = this.isREPL != null;
				
				if(iisrep) {
					leaveScopedNameMapREPL();
				}else {
					leaveScopedNameMap();
				}
				
				if(iisrep) {
					this.currentScopeFrame  = this.currentScopeFrame.leaveScopeREPL(iisrep);
				}else {
					this.currentScopeFrame  = this.currentScopeFrame.leaveScope();
				}
			}else {
				leaveScopedNameMap();
				this.currentScopeFrame  = this.currentScopeFrame.leaveScope();
			}
			
		}
		lambContentsInModStack.pop();
		isFirstStmtInBlock = prevIsFirst;
		block.setTaggedType(lastproceded);
		if(block.getShouldBePresevedOnStack() && null == lastproceded && block.isolated){
			this.raiseError(block.getLine(),block.getColumn(), "block must return something");
			//lastproceded = const_object;
		}
		
		currentlyInBlock.pop();
		HashMap<Pair<String, Boolean>, NullStatus> infered = nullableOverwriteType.pop();
		
		if(block.isolated && !block.isAsyncBlock && !block.isAsyncBody) {
			nullableOverwriteType.peek().putAll(infered);
		}else {
			block.inferedNullability = infered;
		}
		
		return lastproceded; //TODO: should return type of last thing in the block, actually must do this for this: a = {5+5}! yes. must, what about if() {} else() {} - must choose most generical
	}

	private static final NamedType THROWABLE_NAMEDTYPE = new NamedType(new ClassDefJava(Throwable.class));
	
	private int withCount = 0;
	
	@Override
	public Object visit(WithBlock withBlock) {
		withCount++;
		String tmpVarName = "withTmpVar$" + withCount;
		
		int line = withBlock.getLine();
		int col = withBlock.getColumn();
		boolean exprError = false;
		Expression forTempVar = withBlock.expr;
		Type eType = (Type)withBlock.expr.accept(this);
		if(!TypeCheckUtils.isValidType(eType) ||!( eType instanceof NamedType)) {
			this.raiseError(withBlock.expr.getLine(), withBlock.expr.getColumn(), "with expression must be an Object type");
			exprError=true;
			eType = null;
		}else {
			if(TypeCheckUtils.isNullable(eType)) {
				this.raiseError(line, col, "with expression may be null");
				eType = (Type)eType.copy();
				eType.setNullStatus(NullStatus.NONNULL);
				forTempVar = new NotNullAssertion(withBlock.expr.getLine(), withBlock.expr.getColumn(), forTempVar);
			}
		}
		
		if(withBlock.astOverride != null) {
			Block astOv = (Block)withBlock.astOverride;
			LineHolder lh = astOv.lines.remove(0);
			AssignNew assnew = (AssignNew)lh.l;
			assnew.accept(this);
			currentlyInWithStatement.push(new Pair<String, NamedType>(tmpVarName, (NamedType)eType));
			Type ret = withBlock.setTaggedType((Type)astOv.accept(this));
			currentlyInWithStatement.pop();
			astOv.lines.add(0, lh);
			return ret;
		}
		
		
		this.maskErrors(true);
		AssignNew assnew = new AssignNew(null, line, col, tmpVarName, eType, AssignStyleEnum.EQUALS, forTempVar);
		assnew.accept(this);
		
		currentlyInWithStatement.push(new Pair<String, NamedType>(tmpVarName, (NamedType)eType));
		
		Type retType = (Type)withBlock.blk.accept(this);
		
		currentlyInWithStatement.pop();
		ArrayList<CapMaskedErrs> errs = this.getmaskedErrors();
		
		if(!errs.isEmpty()) {
			this.applyMaskedErrors(errs);
		}else if(!exprError) {
			//all good, reroute to block with tmp var form
			//astRedirect
			
			Block astOverride = new Block(line, col);
			
			astOverride.add(assnew);
			astOverride.add(withBlock.blk);

			astOverride.setShouldBePresevedOnStack(withBlock.blk.getShouldBePresevedOnStack());
			withBlock.astOverride = astOverride;
			return withBlock.setTaggedType((Type)withBlock.astOverride.accept(this));
			
		}
		
		return withBlock.setTaggedType(retType);
	}
	
	private void adContinueToLastIfStmt(Block blk){
		LineHolder lh = blk.getLast();
		
		if(null != lh){
			Line lastLine = lh.l;
			if(lastLine instanceof IfStatement){
				IfStatement ifStatement = (IfStatement)lastLine;
				if(ifStatement.getShouldBePresevedOnStack() && !ifStatement.getHasAttemptedNormalReturn() && ifStatement.elseb == null){
					//its ok to have this: aa = while(a++<10) {if(a <= 7) { 99 } }
					//translates to: while(a++<10) {if(a <= 7) { 99 } else{continue } }
					
					int line = ifStatement.getLine();
					int col = ifStatement.getColumn();
					
					ifStatement.elseb = new Block(line, col);
					ifStatement.elseb.isSynthetic = true;
					ifStatement.elseb.add(new LineHolder(line, col, new ContinueStatement(line, col)));
					//ifStatement.elseb.accept(this);
				}
			}
		}
		
	}

	@Override
	public Object visit(WhileBlock whileBlock) {
		this.forWhileExpectsReturn.push(new Pair<Boolean, String>(whileBlock.getShouldBePresevedOnStack(), "while"));
		
		processIdxVarHaver(whileBlock);
		
		nullableOverwriteType.push(new HashMap<Pair<String, Boolean>, NullStatus>());

		TypeCheckUtils.assertNotVoid((Type)whileBlock.cond.accept(this), this, whileBlock.cond.getLine(), whileBlock.cond.getColumn(), "while");
		TestedNonNullAndNull testNullables = nullableTypeLogic.processTest(whileBlock.cond);
		nullableOverwriteType.pop();
		
		
		//TypeCheckUtils.isBoolean(this, (Type)whileBlock.cond.accept(this), whileBlock.getLine(), whileBlock.getColumn());
		whileBlock.block.canContainAContinueOrBreak = !whileBlock.isTransWhileBlock;
		whileBlock.block.canContainAReturnStmt = null;
		
		if(whileBlock.getShouldBePresevedOnStack()){
			adContinueToLastIfStmt(whileBlock.block);
		}
		
		HashMap<Pair<String, Boolean>, NullStatus> inFitBlock = new HashMap<Pair<String, Boolean>, NullStatus>();
		nullableOverwriteType.push(inFitBlock);

		testNullables.addAllNonNullToContainer(inFitBlock);
		Type blockType = (Type)whileBlock.block.accept(this);
		nullableOverwriteType.pop();
		
		
		Type ret = null;		
		
		if(whileBlock.getHasAttemptedNormalReturn()){
			whileBlock.setShouldBePresevedOnStack(false);
		}
		
		Type elseblockType=null;
		if(null != whileBlock.elseblock){

			whileBlock.elseblock.canContainAReturnStmt = null;
			elseblockType = (Type)whileBlock.elseblock.accept(this);
			
			Type origa = elseblockType;
			elseblockType = TypeCheckUtils.getRefTypeToLocked(elseblockType);
			if(TypeCheckUtils.isValidType(elseblockType)){
				TypeCheckUtils.checkSubType(this, elseblockType, origa, whileBlock.block.getLine(), whileBlock.block.getColumn(), whileBlock.block.getLine(), whileBlock.block.getColumn(), false);
			}
		}
		
		
		if(whileBlock.getShouldBePresevedOnStack()){
			//only needed for the likes of ar = for(n=0; n < 50; n++){n*2}
			ArrayList<Type> genTypes = new ArrayList<Type>(1);
			if(!TypeCheckUtils.isValidType(blockType)){
				this.raiseError(whileBlock.block.getLine(),whileBlock.block.getColumn(), "while loop must return something");//TODO: remove this line as covered by defoRet

				ret=null;
			}
			else{
				Type orig = blockType;
				blockType = TypeCheckUtils.getRefTypeToLocked(blockType);
				if(TypeCheckUtils.isValidType(blockType)){
					TypeCheckUtils.checkSubType(this, blockType, orig, whileBlock.getLine(), whileBlock.getColumn(), whileBlock.getLine(), whileBlock.getColumn(), false);
				}
				
				
				genTypes.add(blockType);
				
				int line = whileBlock.getLine();
				int col = whileBlock.getColumn();
				ret = new NamedType(line, col, new ClassDefJava(line, col, java.util.List.class), genTypes);
				ret = (Type)ret.accept(this);
			}
			
			
			
			if(null != whileBlock.elseblock){
				if(!TypeCheckUtils.isValidType(elseblockType)){
					this.raiseError(whileBlock.block.getLine(),whileBlock.block.getColumn(), "while loop else block must return something");
					ret=const_void_thrown;
				}
				else{
					List<Type> stuff = new ArrayList<Type>(2);
					Map<Type, Pair<Integer, Integer>> offenders = new HashMap<Type, Pair<Integer, Integer>>();
					
					stuff.add(ret);
					offenders.put(ret, new Pair<Integer, Integer>( whileBlock.block.getLine(), whileBlock.block.getLine()));
					stuff.add(elseblockType);
					offenders.put(elseblockType, new Pair<Integer, Integer>( whileBlock.elseblock.getLine(), whileBlock.elseblock.getColumn()));
					
					ret = TypeCheckUtils.getMoreGeneric(this, this,  whileBlock.getLine(), whileBlock.getLine(), stuff, offenders);
				}
			}
			
			whileBlock.setTaggedType(ret);
			
		}
		this.forWhileExpectsReturn.pop();
		
		PostfixOp postIdxIncremement=null;
		if(whileBlock.idxVariableCreator != null || whileBlock.idxVariableAssignment != null){
			String name = whileBlock.idxVariableAssignment!=null?whileBlock.idxVariableAssignment.name:whileBlock.idxVariableCreator.name;
			
			if(!this.currentScopeFrame.hasVariableAssigned(name)) {
				AssignNew idxVariableCreator = whileBlock.getIdxVariableCreator();
				if(null != idxVariableCreator) {//HERE thing
					idxVariableCreator.accept(this);
				}
			}
			
			if(whileBlock.postIdxIncremement == null) {
				int line = whileBlock.getLine();
				int col = whileBlock.getColumn();
				postIdxIncremement = new PostfixOp(line, col, FactorPostFixEnum.PLUSPLUS, new RefName(line, col, name));
				postIdxIncremement.setShouldBePresevedOnStack(false);
				whileBlock.postIdxIncremement = postIdxIncremement;
			}
			whileBlock.postIdxIncremement.accept(this);
		}
		
		
		{
			HashMap<Pair<String, Boolean>, NullStatus> nsMap = this.nullableOverwriteType.peek();
			
			for(Pair<String, Boolean> notNullKey : testNullables.testedNotNull.keySet()) {
				nsMap.put(notNullKey, NullStatus.NULLABLE);
			}
			for(Pair<String, Boolean> nullkey : testNullables.testedNull.keySet()) {
				nsMap.put(nullkey, NullStatus.NONNULL);
			}
		}
		
		return ret;
	}
	private static final String ExprString = "(?<!\\\\)\\{.*?\\}";
	private static final Pattern ExprStringPattern = Pattern.compile(ExprString);//lazy
	
	private boolean disableStringSubExprs = false;
	
	
	public ArrayList<Expression> breakupString(int line, int col, String varString){
		ArrayList<Expression> found = new ArrayList<Expression>();
		int sz = varString.length();
		int lparam = 0;
		int fromStrPoint = 0;
		for(int n = 0; n < sz; n++) {
			char x = varString.charAt(n);
			switch(x) {
				case '{':{
					if(lparam == 0) {
						found.add(new VarString(line, col+fromStrPoint+1, varString.substring(fromStrPoint, n)));
						fromStrPoint = n+1;
					}
					lparam++;
				}
				break;
				
				case '}':{
					if( 0 == --lparam) {
						Expression expr = Utils.parseExpression(varString.substring(fromStrPoint, n), this.fullPathFileName, line, col+n+1, this);
						if(null != expr){
							((Node)expr).setLine(line);
							((Node)expr).setColumn(col+n+1);
							found.add(expr);
						}
						fromStrPoint = n+1;
					}
					if(lparam <0) {
						lparam = 0;
					}
				}
				break;
				case '\\':{//skip next its escaped
					n++;
				}
				break;
					
			}
		}
		
		String lastportion = varString.substring(fromStrPoint, sz);
		if(lparam > 0) {
			//merge remainder into previous
			VarString last = (VarString)found.get(found.size()-1);
			last.str = last.str + lastportion;
		}else {
			//add remainder
			found.add(new VarString(line, col+fromStrPoint+1, lastportion));
		}
		
		return found;
	}
	
	@Override
	public Object visit(VarString varString) {
		String message = varString.str;//the \{one}:{one}   
		                               //the \{one}:{one}

		int line = varString.getLine();
		int column = varString.getColumn();
		
		if(!varString.foundSubs) {
			if(!disableStringSubExprs){
				ArrayList<Expression> components = breakupString(line, column, message);
				if(components.size() > 1) {
					varString.subExpressions = components;
				}
			}
			
			varString.foundSubs = true;
		}
		
		if(null != varString.subExpressions){
			for(Expression expr : varString.subExpressions){//more efficient to do this above?
				expr.accept(this);
			}
		}
		
		Type type = new NamedType(line, column, const_cls_String);
		varString.setTaggedType(type);
		return type;
	}
	
	@Override
	public Object visit(VarRegexPattern varString) {
		try{
			Pattern.compile(varString.str);
		}
		catch(PatternSyntaxException pse){//lol
			this.raiseError(varString.getLine(), varString.getColumn(), "Invalid regex: " + pse.getDescription());
		}
		
		Type type = new NamedType(varString.getLine(), varString.getColumn(), const_cls_Pattern);
		varString.setTaggedType(type);
		return type;
	}

	@Override
	public Object visit(VarNull varNull) {
		if(varNull.getTaggedType() == null){
			NamedType laObj = const_object.copyTypeSpecific();
			laObj.orignallyfromVarNull = true;
			laObj.setLine(varNull.getLine());
			laObj.setColumn(varNull.getColumn());
			laObj.setNullStatus(NullStatus.NULLABLE);
			varNull.setTaggedType(laObj);//guess, dont overwrite otherwise, other parts of code sometimes override the tagged type
		}
		Type ret = varNull.getTaggedTypeRaw();
		if(null == ret) {
			ret = varNull.getTaggedType();
		}
		
		return ret;
		//return varNull.getTaggedType();
	}

	@Override
	public Object visit(VarInt varInt) {
		Type type = new PrimativeType(PrimativeTypeEnum.INT);
		varInt.setTaggedType(type);
		return type;
	}
	
	@Override
	public Object visit(VarShort varInt) {
		Type type = new PrimativeType(PrimativeTypeEnum.SHORT);
		varInt.setTaggedType(type);
		return type;
	}
	
	@Override
	public Object visit(VarLong varLong) {
		Type type = new PrimativeType(PrimativeTypeEnum.LONG);
		varLong.setTaggedType(type);
		return type;
	}
	
	@Override
	public Object visit(VarChar varChar) {
		Type type = new PrimativeType(PrimativeTypeEnum.CHAR);
		varChar.setTaggedType(type);
		return type; 
	}

	@Override
	public Object visit(VarFloat varFloat) {
		Type type = new PrimativeType(PrimativeTypeEnum.FLOAT);
		varFloat.setTaggedType(type);
		return type; 

	}

	@Override
	public Object visit(VarDouble varDouble) {
		Type type = new PrimativeType(PrimativeTypeEnum.DOUBLE);
		varDouble.setTaggedType(type);
		return type; 
	}

	@Override
	public Object visit(UsingStatement usingStatement) {
		return null; //TODO: remove this

	}

	@Override
	public Object visit(TryCatch tryCatch) {
		if(tryCatch.astRepoint != null){
			Type tt = (Type)tryCatch.astRepoint.accept(this);
			tryCatch.setTaggedType(tt);
			return tt;
		}
		
		if(!tryCatch.tryWithResources.isEmpty()){//see if we can transform the try with resources into try finally form
			
			boolean okToTransform = true;
			
			this.currentScopeFrame = TheScopeFrame.buildTheScopeFrame_Block(this.currentScopeFrame, new Block(0,0));
			this.currentScopeFrame.enterScope();
			
			ArrayList<Sevenple<String, NamedType, Integer, Integer, Node, Boolean, Boolean>> names = new ArrayList<Sevenple<String, NamedType, Integer, Integer, Node, Boolean, Boolean>>(tryCatch.tryWithResources.size());
			int n=0;
			for(Line ln : tryCatch.tryWithResources){
				n++;
				String name;
				Node rhs;// = null;
				boolean shouldNullExisting = true;
				boolean isFinal = false;
				
				if(ln instanceof Assign && !(ln instanceof DuffAssign)){
					if(ln instanceof AssignNew){
						AssignNew asnew = (AssignNew)ln;
						name = asnew.name;
						isFinal = asnew.isFinal;
						rhs = (Node)asnew.expr;//maybe null
					}
					else{// if(ln instanceof AssignExisting){
						AssignExisting asnew = (AssignExisting)ln;
						rhs = (Node)asnew.expr;
						if(asnew.assignee instanceof RefName){
							name =  ((RefName)asnew.assignee).name;
						}
						else{
							PrintSourceVisitor psv = new PrintSourceVisitor();
							asnew.assignee.accept(psv);
							this.raiseError(ln.getLine(), ln.getColumn(), String.format("assignment specified in try with resource block must resolve to a variable, '%s' is not a variable", psv));
							okToTransform=false;
							name = "error";
						}
						shouldNullExisting=asnew.isReallyNew || !this.currentScopeFrame.hasVariableAssigned(name) ;//assign existing
					}
				}
				else{
					rhs = (Node)ln;
					//tempvar name
					name = "tempVar" + n;//temp value
				}
				this.maskErrors(true);
				ln.accept(this);
				if(this.applyMaskedErrors()){
					okToTransform=false;
				}
				Type resolvedTo = ln.getTaggedType();
				
				if( resolvedTo==null || resolvedTo instanceof VarNull || !(resolvedTo instanceof NamedType)){
					PrintSourceVisitor psv = new PrintSourceVisitor();
					rhs.accept(psv);
					this.raiseError(ln.getLine(), ln.getColumn(), String.format("Resource specified in try with resource block must implement close method, '%s' does not", psv.toString()));
					okToTransform=false;
					resolvedTo=ScopeAndTypeChecker.const_object.copyTypeSpecific();
				}
				else if(!TypeCheckUtils.hasMethod(tryCatch.getLine(), tryCatch.getColumn(), resolvedTo, "close", this)){
					this.raiseError(ln.getLine(), ln.getColumn(), String.format("Resource specified in try with resource block must implement close method, type: %s does not", resolvedTo));
					okToTransform=false;
				}
				
				names.add(new Sevenple<String, NamedType, Integer, Integer, Node, Boolean, Boolean>(name, (NamedType)resolvedTo, ln.getLine(), ln.getColumn(), rhs, shouldNullExisting, isFinal));
			}
			
			this.currentScopeFrame = this.currentScopeFrame.leaveScope();
			
			if(okToTransform){//just do first one for now
				//try{ a = null; a = thing above; normaltrycatch finally { le thing } - special variant on bc gen
				
				Block wrapperBlock = new Block(tryCatch.blockToTry.getLine(), tryCatch.blockToTry.getColumn());
				wrapperBlock.isolated=true;
				//wrapperBlock.setShouldBePresevedOnStack(true);

				Block toWriteThisLayerTo = wrapperBlock;
				for(Sevenple<String, NamedType, Integer, Integer, Node, Boolean, Boolean> nn : names){
					String name = nn.getA();
					if(nn.getF()  ){//only null if not already existing or not already assigned
						int line = nn.getC();
						int col =  nn.getD();
						//create initial null items in wrapper
						NamedType nt = nn.getB().copyTypeSpecific();
						TypeCheckUtils.unlockAllNestedRefs(nt);
						AssignNew an = new AssignNew(null, line, col, name, nt, AssignStyleEnum.EQUALS, new VarNull(line, col));
						an.isFinal = nn.getG();
						an.skipNullableCheck = true;
						toWriteThisLayerTo.add(new LineHolder(line, col, an));
					}
				}
				
				n=0;
				for(Sevenple<String, NamedType, Integer, Integer, Node, Boolean, Boolean> nn : names){
					boolean isLast = ++n == names.size();
					Block tryBlock = new Block(tryCatch.blockToTry.getLine(), tryCatch.blockToTry.getColumn());
					
					{//a = closeablething()
						int line = nn.getC();
						int col =  nn.getD();
						//create initial null items in wrapper
						Block rhsStuff = new Block(line, col);
						rhsStuff.isolated=false;
						
						Expression resolvesTo;
						
						Node rhs = nn.getE();
						if(rhs instanceof  Expression){
							resolvesTo = (Expression)rhs;
						}
						else{
							Block rhsBlock = new Block(line, col);
							rhsBlock.isolated=true;
							rhsBlock.setShouldBePresevedOnStack(true);
							rhsBlock.add(new LineHolder((Statement)rhs));
							resolvesTo = rhsBlock;
						}
						
						
						
						String name = nn.getA();
						AssignExisting an = new AssignExisting(line, col, new RefName(name), AssignStyleEnum.EQUALS_STRICT, resolvesTo);
						an.ignoreFinalCheck = nn.getG();
						an.refCnt = TypeCheckUtils.getRefLevels(nn.getB());
						tryBlock.add(new LineHolder(line, col, an));
					}
					
					if(isLast){//now add normal code
						if( tryCatch.cbs.isEmpty() && null == tryCatch.finalBlock)
						{
							tryBlock.addAll(tryCatch.blockToTry.lines);
						}
						else{//doubt this works...
							
							TryCatch normal = (TryCatch)tryCatch.copy();
							
							if(normal.finalBlock != null){
								normal.finalBlock.originId = normal.finalBlock;
							}
							
							normal.tryWithResources = new ArrayList<Line>();//clear this out
							tryBlock.add(new LineHolder(normal));
							
						}
					}

					Block finBlock = new Block(tryCatch.blockToTry.getLine(), tryCatch.blockToTry.getColumn());
					{
						int line = nn.getC();
						int col =  nn.getD();
						String name = nn.getA();
						
						Block notNullBlock = new Block(line, col);
						//do null check
						ArrayList<GrandLogicalElement> inotnullthigs = new ArrayList<GrandLogicalElement>();
						inotnullthigs.add(new GrandLogicalElement(line, col, GrandLogicalOperatorEnum.REFNE, new RefName(line, col, name)));
						EqReExpression isNotNullTest = new EqReExpression(line, col, new VarNull(line, col), inotnullthigs);
						IfStatement nullcheck = new IfStatement(line, col, isNotNullTest, notNullBlock, null);
						//call close
						DotOperator closeFunc = DotOperator.buildDotOperatorOne(line, col, new RefName(line, col, name), new FuncInvoke(line, col, "close"));
						
						notNullBlock.add(new LineHolder(line, col, new DuffAssign(closeFunc)));
						
						finBlock.add(new LineHolder(line, col, nullcheck));
					}
					
					TryCatch closingTryCatch = new TryCatch(tryCatch.blockToTry.getLine(), tryCatch.blockToTry.getColumn(), tryBlock, finBlock);
					closingTryCatch.setShouldBePresevedOnStack(tryCatch.getShouldBePresevedOnStack());
					closingTryCatch.supressFinnallyException = new Thruple<Label, Label, Label>(new Label(), new Label(), new Label());
					toWriteThisLayerTo.add(new LineHolder(closingTryCatch));
					toWriteThisLayerTo = tryBlock;
				}
				
				wrapperBlock.setShouldBePresevedOnStack(tryCatch.getShouldBePresevedOnStack());
				wrapperBlock.setIfReturnsExpectImmediateUse(false);
				tryCatch.tryWithResourcesastRepoint = wrapperBlock;
				
				Type tt = (Type)wrapperBlock.accept(this);
				tryCatch.setTaggedType(tt);
				return tt;
			}
		}
		
		List<Type> typeChoices = new ArrayList<Type>(2);
		Map<Type, Pair<Integer, Integer>> typeOffenders = new HashMap<Type, Pair<Integer, Integer>>();
		
		
		tryCatch.blockToTry.canContainAContinueOrBreak = null;
		tryCatch.blockToTry.canContainAReturnStmt = null;
		Type blkToTry = (Type)tryCatch.blockToTry.accept(this);
		
		typeChoices.add(blkToTry);
		typeOffenders.put(blkToTry, new Pair<Integer, Integer>(tryCatch.blockToTry.getLine(), tryCatch.blockToTry.getColumn()));
		
		
		if(tryCatch.blockToTry.isEmpty()){
			this.raiseError(tryCatch.blockToTry.getLine(), tryCatch.blockToTry.getColumn(), "Use of try catch finally is inappropriate - try block is empty");
		}
		else if(tryCatch.blockToTry.containsSingleVoidReturn()){
			this.raiseError(tryCatch.blockToTry.getLine(), tryCatch.blockToTry.getColumn(), "Use of try catch finally is inappropriate - just use return");
		}
		
		ArrayList<Type> catchParents = new ArrayList<Type>(tryCatch.cbs.size()); 
		ArrayList<Pair<Integer, Integer>> catchBlockLineCols = new ArrayList<Pair<Integer, Integer>>(tryCatch.cbs.size()); 
		
		if( tryCatch.cbs.isEmpty() && null == tryCatch.finalBlock)
		{
			if(tryCatch.tryWithResources.isEmpty()){
				this.raiseError(tryCatch.getLine(), tryCatch.getColumn(), "Try catch finnally block must consist of at least one catch block and/or one finnally block");
			}
			
		}
		else
		{
			for(CatchBlocks c : tryCatch.cbs)
			{
				Type excepType = (Type)c.accept(this);
				
				if(!TypeCheckUtils.isValidType(c.blockType)){
					catchBlockLineCols.add(new Pair<Integer, Integer>(c.getLine(), c.getColumn()));
				}
				
				if(null != excepType)
				{
					for(Type caughtBefore : catchParents)
					{
						if(null != TypeCheckUtils.checkSubType(this.ers, caughtBefore, excepType, c.getLine(), c.getColumn(), c.getLine(), c.getColumn()))
						{//if subtype of a thing already caught then it can never actually get caught in this block
							this.raiseError(c.getLine(), c.getColumn(), String.format("Unreachable catch block for %s. It is already handled by the catch block for %s " , excepType, caughtBefore) );
							break;
						}
					}
					
					catchParents.add(excepType);
				}
				
				if(c.blockType == null && c.catchBlock.hasDefoReturned) {
					continue;//if catch(e){ ... return }//then we ignore the type returned
				}
				
				typeChoices.add(c.blockType);
				typeOffenders.put(c.blockType, new Pair<Integer, Integer>(c.getLine(), c.getColumn()));
			}
			
			Type typeToReturnSoFar = getMostGenericGeneric(typeChoices, typeOffenders, tryCatch.getLine(), tryCatch.getColumn(), false);
			
			if(null != tryCatch.finalBlock)
			{
				tryCatch.finalBlock.canContainAContinueOrBreak = null;
				tryCatch.finalBlock.canContainAReturnStmt = null;
				//tryCatch.finalBlock.accept(this);
				
				//Stack<Tuple<Boolean, String>> prevforWhileExpectsReturn = forWhileExpectsReturn;
				//forWhileExpectsReturn = new Stack<Tuple<Boolean, String>>();
				
				Type fType = (Type)tryCatch.finalBlock.accept(this);
				
				//forWhileExpectsReturn = prevforWhileExpectsReturn;
				
				if(tryCatch.finalBlock.isEmpty() || fType==null){
					fType = const_void_thrown;
				}
				
				tryCatch.finalBlockRetrunsVoid = !TypeCheckUtils.isValidType(fType, false);
				
				
				if(tryCatch.isReallyA == null && tryCatch.getShouldBePresevedOnStack() && !tryCatch.hasEcapedNormally()  && !TypeCheckUtils.isValidType(typeToReturnSoFar, false) && tryCatch.finalBlockRetrunsVoid ){
					this.raiseError(tryCatch.getLine(),tryCatch.getColumn(), "final block must return something since try catch blocks do not");
				}
				
				if(tryCatch.finalBlockRetrunsVoid){
					tryCatch.setShouldBePresevedOnStack(tryCatch.getShouldBePresevedOnStack());
				}
				/*else{
					typeChoices = new ArrayList<Type>(1);
					typeChoices.add(fType);
					typeOffenders.put(fType, new Tuple<Integer, Integer>(tryCatch.finalBlock.getLine(), tryCatch.finalBlock.getColumn()));
				}*/
			}
		}

		//tryCatch.setShouldBePresevedOnStack(tryCatch.getShouldBePresevedOnStack());
		
		if(tryCatch.getHasAttemptedNormalReturn()){
			tryCatch.setShouldBePresevedOnStack(false);
		}
		
		
		
		if(tryCatch.hasFinal()) {
			this.nullableOverwriteType.peek().putAll(tryCatch.finalBlock.inferedNullability);
		}else  {
			boolean fail=false;
			
			List<HashMap<Pair<String, Boolean>, NullStatus>> inferedNullinBlocks = new ArrayList<HashMap<Pair<String, Boolean>, NullStatus>>();
			if(tryCatch.blockToTry.inferedNullability != null && !tryCatch.blockToTry.inferedNullability.isEmpty()) {
				inferedNullinBlocks.add(tryCatch.blockToTry.inferedNullability);
			}else {
				fail=true;
			}
			
			for(CatchBlocks cbs : tryCatch.cbs) {
				if(cbs.catchBlock.inferedNullability != null && !cbs.catchBlock.inferedNullability.isEmpty()) {
					inferedNullinBlocks.add(cbs.catchBlock.inferedNullability);
				}else {
					fail=true;
					break;
				}
			}
			if(!inferedNullinBlocks.isEmpty()) {
				Pair<List<Pair<String, Boolean>>, List<Pair<String, Boolean>>> nonnullAndNullable = Utils.filterNullInferMap(inferedNullinBlocks);
				
				HashMap<Pair<String, Boolean>, NullStatus> addto = this.nullableOverwriteType.peek();
				
				if(!fail) {
					for(Pair<String, Boolean> nonNull : nonnullAndNullable.getA()) {
						addto.put(nonNull, NullStatus.NONNULL);
					}
				}
				
				for(Pair<String, Boolean> nullableNull : nonnullAndNullable.getB()) {
					addto.put(nullableNull, NullStatus.NULLABLE);
				}
			}
		}
		
		
		
		
		
		if(tryCatch.getShouldBePresevedOnStack() && !tryCatch.gethasDefoReturnedConventionally()){
			Type got = getMostGenericGeneric(typeChoices, typeOffenders, tryCatch.getLine(), tryCatch.getColumn(), false);
			
			if(!TypeCheckUtils.isValidType(got, true)){
				if(!tryCatch.hasDefoThrownException){
					boolean tBlockFail = !TypeCheckUtils.isValidType(blkToTry);
					
					if(tBlockFail && !catchBlockLineCols.isEmpty()){
						this.raiseError(tryCatch.getLine(), tryCatch.getColumn(), "try catch must return something");
					}
					else{
						if(tBlockFail){
							if(null != tryCatch.isReallyA){
								this.raiseError(tryCatch.blockToTry.getLine(), tryCatch.blockToTry.getColumn(), "sync block must return something");
							}
							else{
								this.raiseError(tryCatch.blockToTry.getLine(), tryCatch.blockToTry.getColumn(), "try block of try catch must return something");
							}
						}
						else if(!catchBlockLineCols.isEmpty()){
							for( Pair<Integer, Integer> ci :  catchBlockLineCols){
								this.raiseError(ci.getA(), ci.getB(), "catch block of try catch must return something");
							}
						}
					}
					
				}
				got=const_void_thrown;
				//got = getMostGenericGeneric(typeChoices, typeOffenders, tryCatch.getLine(), tryCatch.getColumn(), true);
			}
			tryCatch.setTaggedType(got);
			return got;
		}
		else{
			
			return const_void_thrown;
		}
	}

	private static final NamedType throwableNT = new  NamedType(new ClassDefJava(Throwable.class));
	
	@Override
	public Object visit(ThrowStatement throwStatement) {
		//Ensure that this is an objet that extends uncatchable
		//TODO: write runtime logic to convert ALL exceptions to be RunTimeException ??
		/*
		ClassDef runtimeExcep = this.getImportedOrDeclaredClassDef("java.lang.RuntimeException");
		
		Type toThrow = (Type)throwStatement.thingTothrow.accept(this);
		if(null == TypeCheckUtils.checkSubType(this.errorRaisableSupression, runtimeExcep, toThrow, --,--,--,--))
		{
			this.raiseError(--,--, String.format("Exception thrown must be a RuntimeException. Found: %s", expected, iType ));
		}
		*/
		
		Type trown = (Type)throwStatement.thingTothrow.accept(this);
		
		NamedType namedThrownType = null;
		if(trown instanceof NamedType)
		{
			namedThrownType = (NamedType)trown;
		}
		else if(trown instanceof GenericType)
		{
			namedThrownType = ((GenericType)trown).upperBound;
		}
		
		if(null == namedThrownType)
		{
			this.raiseError(throwStatement.getLine(), throwStatement.getColumn(), "Exception type thrown must be a subtype of Throwable not: " + trown);
		}
		else
		{
			if(null == TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), throwableNT, namedThrownType, throwStatement.getLine(), throwStatement.getColumn(), throwStatement.getLine(), throwStatement.getColumn()))
			{
				if(trown instanceof GenericType)
				{
					this.raiseError(throwStatement.getLine(), throwStatement.getColumn(), String.format("Generic Exception type upper bound must be of type or subtype of Throwable: %s is not" , namedThrownType) );
				}
				else
				{
					this.raiseError(throwStatement.getLine(), throwStatement.getColumn(), String.format("Exception type thrown must be a subtype of Throwable: %s is not" , trown) );
				}
			}
		}
		
		return const_void_thrown;
		//return null;
	}
	
	public final static PrimativeType const_void_thrown = new PrimativeType(PrimativeTypeEnum.VOID);
	static{
		const_void_thrown.thrown=true;
	}
	private final static PrimativeType const_void_errored = new PrimativeType(PrimativeTypeEnum.VOID);
	static{
		const_void_errored.errored=true;
	}

	private boolean currentlyInMethodLambda(){
		String got = this.currentlyInRet.peek();
		return got.equals("method") || got.equals("lambda");
	}
	
	@Override
	public Object visit(ReturnStatement returnStatement) {
		Type retTupe = const_void;
		if(null != returnStatement.ret)
		{
			retTupe = (Type)returnStatement.ret.accept(this);
			
			if(!this.currentlyInRet.isEmpty()){
				String currentlyIn = this.currentlyInRet.peek();
				if(currentlyIn.endsWith("-noret")){
					this.raiseError(returnStatement.getLine(), returnStatement.getColumn(), String.format("return statement within %s cannot return a value", currentlyIn.substring(0, currentlyIn.length()-6)));
				}
			}
		}
		else{
			if(!this.currentlyInRet.isEmpty()){
				String currentlyIn = this.currentlyInRet.peek();
				if("await".equals(currentlyIn)){
					this.raiseError(returnStatement.getLine(), returnStatement.getColumn(), "return statement must define something to return");
				}
			}
			
		}

		TheScopeFrame frame = this.currentScopeFrame;
		while(null != frame)
		{
			if( null == frame.canContainAReturnStmt )
			{
				frame = frame.getParent();
			}
			else
			{
				if(false == frame.canContainAReturnStmt)
				{
					this.raiseError(returnStatement.getLine(), returnStatement.getColumn(), "return statement is not valid here");
					returnStatement.isAllowedHere = false;
					return null;
				}
				//its fine
				frame = null;
			}
		}
		
		boolean inMethodLambda = currentlyInMethodLambda();
		
		if(inMethodLambda){
			this.typesReturnedCurrentFunc.peek().add(retTupe);
		}
		
		//Type wanted = returnStatement.withinOnChange ? onchangeRetType.peek():currentlyInFuncDef.peek().getRetuType();
		//Type wanted = returnStatement.withinOnChange && !onchangeRetType.isEmpty() ? onchangeRetType.peek():returnTypeExpected.peek();
		
		Type wanted;
		if(!inMethodLambda && !onchangeRetType.isEmpty()){
			wanted = onchangeRetType.peek();
		}
		else{
			wanted = returnTypeExpected.peek();
			if(wanted ==null){
				FuncDefI fd = currentlyInFuncDef.peek();
				if(!(fd instanceof FuncDefI && ((FuncDefI)fd).getShouldInferFuncType())){//only if type is actually defined, otherwise we must infer it fresh every time
					wanted=fd.getRetuType();
				}
			}
		}
		
		if(null != wanted)
		{
			if(!inMethodLambda && returnStatement.ret == null){
				//return is not manditory for returns within onchange
				return null;
			}
			
			//TODO: this is ugly: retTupe.equals(const_void), what if it's the lambda VOID type being returned, eek!
			if(retTupe==null ||  ( !wanted.equals(const_void) &&  (retTupe.equals(const_void)||retTupe.equals(const_void_thrown)) )){
				String method = !this.currentlyInFuncDef.isEmpty() && this.currentlyInFuncDef.peek() instanceof LambdaDef?"lambda":"method";
				this.raiseError(returnStatement.getLine(), returnStatement.getColumn(), String.format("Return statement in %s must return type of %s", method, wanted));//JPT: if RETURN - 'currently it returns nothing'
				returnStatement.setTaggedType(const_void);
				return const_void;
			}
			else if( (wanted.equals(const_void) && !(retTupe.equals(const_void)||retTupe.equals(const_void_thrown)) )){
				this.raiseError(returnStatement.getLine(), returnStatement.getColumn(), "void methods cannot return a value");
				returnStatement.setTaggedType(const_void);
				return const_void;
			}
			else
			{
				if(wanted.equals(retTupe))
				{
					//retTupe = TypeCheckUtils.convertFromGenericToNamedType(retTupe);
					
					returnStatement.setTaggedType(retTupe);
					return retTupe;
				}
				else
				{
					//MHA:why was it locked to begin with?
					wanted = (Type)wanted.copy();
					TypeCheckUtils.unlockAllNestedRefs(wanted);
					
					Type ret = TypeCheckUtils.checkSubType(this, wanted, retTupe, returnStatement.getLine(), returnStatement.getColumn(), returnStatement.getLine(), returnStatement.getColumn() );
					if(null == ret){
						this.raiseError(returnStatement.getLine(), returnStatement.getColumn(), String.format("Type mismatch: cannot convert from %s to %s", retTupe, wanted));
					}
					
					//ret = TypeCheckUtils.convertFromGenericToNamedType(ret);
					
					returnStatement.setTaggedType(ret);
					return ret;
				}
			}
			//return retTupe;
		}
		else
		{
			return returnStatement.ret == null?null:returnStatement.ret.getTaggedType();
		}
	}
	
	private Type currentlyInExtensionFunction(){
		if(this.currentlyInFuncDef.isEmpty()){
			return null;
		}else{
			for(int n = this.currentlyInFuncDef.size()-1; n >= 0; n--){
				FuncDefI fd = this.currentlyInFuncDef.get(n);
				if(fd instanceof FuncDef){
					if(((FuncDef)fd).extFunOn != null){
						Type ret = ((FuncDef)fd).extFunOn;
						if(ret != null) {
							TheScopeFrame cf = this.currentScopeFrame;
							while(cf != null) {
								if(cf.isExtFunc) {
									break;
								}else if(cf.isClass()) {
									ret=null;
									break;
								}
								cf = cf.getParent();
							}
						}
						return ret;
					}
				}
			}
		}
		return null;
	}
	
	private Object thisOrSuper(boolean isSuper, String txt, int line, int col, String qualifier, RefThis refThis)
	{
		Type inExtFunction = currentlyInExtensionFunction();
		
		boolean ingppufunc = !this.currentlyInFuncDef.isEmpty() && this.currentlyInFuncDef.peek().isGPUKernalOrFunction != null;
		
		if(currentlyInClassDef.isEmpty() && inExtFunction == null)
		{
			if(!ingppufunc) {
				this.raiseError(line, col, String.format("%s references can only be made within a class or extension function", txt));
				return null;
			}else if(isSuper){
				this.raiseError(line, col, String.format("%s references can only be made within a class or extension function not gpu functions or kernels", txt));
				return null;
			}
		}
		else if(isInSuperConstructorCall())
		{
			this.raiseError(line, col, String.format("%s references cannot be whilst invoking this or super constructors", txt));
			return null;
		}
		
		
		
		if(isSuper)
		{//supertype resolution
			
			if(qualifier != null){
				if(ingppufunc) {
					this.raiseError(line, col, "qualified super references can only be made within a class or extension function not gpu functions or kernels");
				}
				
				ClassDef qualiTo;
				if(PrimativeTypeEnum.nameToEnum.containsKey(qualifier)){
					qualiTo = com.concurnas.compiler.bytecode.Utils.primToBoxedType((PrimativeTypeEnum.nameToEnum.get(qualifier))).getSetClassDef();
				}else{
					qualiTo = this.getImportedClassDef(qualifier);
				}
				
				ClassDef cd;
				if(null == qualiTo){
					this.raiseError(line, col, String.format("qualifier for super does not exist: %s", qualifier));
					return null;
				}else{
					cd = qualiTo;
				}
				
				if(inExtFunction != null){
					this.raiseError(line, col, "qualifier for super cannot be defined inside extension function");
					return null;
				}
				
				ClassDef curCd = this.currentlyInClassDef.peek();
				ClassDef supClass = curCd.getSuperclass();
				
				NamedType ret = new NamedType(line, col, cd);
				
				if(!cd.equals(supClass)) {
					HashSet<ClassDef> traits = curCd.getTraits();
					if(traits.isEmpty()) {
						this.raiseError(line, col, String.format("qualifier for super must be either the super class: %s or any traits the current class is composed of", curCd));
						return null;
					}
					
					if(!traits.contains(cd)) {
						this.raiseError(line, col, String.format("qualifier for super must be either the super class: %s or any traits: %s", curCd, String.join( ", ", traits.stream().map(a -> a.toString()).sorted().collect(Collectors.toList()) )));
						return null;
					}else {
						ArrayList<NamedType> nts = curCd.getTraitsAsNamedType(line, col);
						for(NamedType nt : nts) {
							ClassDef cdx = nt == null? null: nt.getSetClassDef();
							if(cdx != null && cdx.equals(cd)) {
								if(!ClassDef.classHasTraitAnnotation(cd)) {
									this.raiseError(line, col, String.format("Only Concurnas traits may be explicity referenced: %s is not a trait, it's an interface", cd));
								}
								return nt;
							}
						}
					}
				}else {
					ArrayList<Type> genTypes = new ArrayList<Type>(cd.superClassGenricList.size());
					for(Type gt : cd.superClassGenricList){
						genTypes.add(gt);
					}
					ret.setGenTypes(genTypes);
				}
				
				return ret;
				
			}else {
				if(null != inExtFunction) {//super.call <- refers to the object called on, not the ext function version
					return inExtFunction;
				}
				
				return currentlyInClassDef.peek().getSuperAsNamedType(line, col);
			}
		}
		else
		{
			ClassDef cd;
			
			if(inExtFunction != null){
				if(inExtFunction instanceof PrimativeType){
					cd = com.concurnas.compiler.bytecode.Utils.primToBoxedType(((PrimativeType)inExtFunction).type).getSetClassDef();
				}else{
					cd = ((NamedType)inExtFunction).getSetClassDef();
				}
			}else{
				cd = currentlyInClassDef.isEmpty()?null:currentlyInClassDef.peek();
			}
			
			
			ClassDef origCD = cd;
			if(null == cd){//soemthing went wrong, would have been reported elsewhere
				return  (NamedType)const_object.copy();
			}

			if(qualifier != null){
				
				if(ingppufunc) {
					this.raiseError(line, col, String.format("qualified %s references can only be made within a class or extension function not gpu functions or kernels", txt));
				}
				
				ClassDef qualiTo;
				if(PrimativeTypeEnum.nameToEnum.containsKey(qualifier)){
					qualiTo = com.concurnas.compiler.bytecode.Utils.primToBoxedType((PrimativeTypeEnum.nameToEnum.get(qualifier))).getSetClassDef();
				}else{
					qualiTo = this.getImportedClassDef(qualifier);
				}
								
				if(null == qualiTo){
					this.raiseError(line, col, String.format("qualifier for this does not exist: %s", qualifier));
				}else{
					cd = qualiTo;
				}
				if(inExtFunction == null){
					if(!currentlyInClassDef.contains(qualiTo)){
						this.raiseError(line, col, String.format("qualifier for this must be either current class or parent nestor: %s resolves to: %s which is not", qualifier, qualiTo));
					}
				}else{
					if(!currentlyInClassDef.contains(qualiTo) && !qualiTo.equals(cd)){
						this.raiseError(line, col, String.format("qualifier for this within extension function must be either current class, the extended type: % or parent nestor: %s resolves to: %s which is not", cd, qualifier, qualiTo));
					}
				}
			
			}
			
			if(inExtFunction != null && !currentlyInClassDef.isEmpty() && null != refThis){//ext function in class, repoint this...
				if(origCD.equals(cd)){
					refThis.astRedirect = null;
					refThis.astRedirect = new RefName("this$extFunc");
					return refThis.astRedirect.accept(this);
				}
			}
			
			
			if(inExtFunction != null && origCD.equals(cd)){
				return (Type)inExtFunction.copy();
			}else{
				NamedType ret = new NamedType(line, col, cd);
				ArrayList<Type> genTypes = new ArrayList<Type>(cd.classGenricList.size());
				
				for(GenericType gt : cd.classGenricList){
					genTypes.add(gt);
				}
				
				ret.setGenTypes(genTypes);
				return ret;
			}
		}
	}

	@Override
	public Object visit(RefOf refOf) {
		thisOrSuper(false, "of", refOf.getLine(), refOf.getColumn(), null, null);
		//refOf.setTaggedType(ret);
		
		if(refOf.resolveToOf == null){
			int line = refOf.getLine();
			int col = refOf.getColumn();
			refOf.resolveToOf = DotOperator.buildDotOperator(refOf.getLine(), refOf.getColumn(), new RefSuper(line, col), new RefName(line, col, "of"));
		}
		
		Type ret = (Type)refOf.resolveToOf.accept(this);
		
		//refOf.setTaggedType(ret);
		return ret;
	}
	
	@Override
	public Object visit(RefThis refThis) {
		Type ret =  (Type)thisOrSuper(false, "this", refThis.getLine(), refThis.getColumn(), refThis.qualifier, refThis);
		refThis.setTaggedType(ret);
		return ret;
	}
	
	@Override
	public Object visit(RefClass refClass) {
		refClass.lhsType.setIsLHSClass(true);
		Type lhsType = (Type)refClass.lhsType.accept(this);
		
		lhsType = TypeCheckUtils.boxTypeIfPrimative(lhsType, false);
		/*if(!(lhsType instanceof NamedType)){
			this.raiseError(refClass.getLine(), refClass.getColumn(), "class cannot be obtained for: " + lhsType);
			return null;
		}*/
		
		if(null == lhsType){
			this.raiseError(refClass.getLine(), refClass.getColumn(), "cannot determine type for class reference");
			return null;
		}
		
		ArrayList<Type> genTypes = new ArrayList<Type>();
		genTypes.add(lhsType);
		
		//refClass.lhsType = lhsType;
		
		NamedType ret = new NamedType(refClass.getLine(), refClass.getColumn(), const_class, genTypes);
		refClass.setTaggedType(ret);
		
		return ret;
	}

	@Override
	public Object visit(RefSuper refSuper) {
		Type ret =  (Type) thisOrSuper(true, "super", refSuper.getLine(), refSuper.getColumn(), refSuper.superQuali, null);
		refSuper.setTaggedType(ret);
		return ret;
	}
	/*
	private Set<FuncType> findFuncDefs(Type from, String functionName)//from type: array or classdef
	{
		if(from instanceof ClassDef)
		{
			return ((ClassDef)from).getFuncDef(functionName);
		}
		else if(from instanceof NamedType)
		{
			return ((NamedType)from).getFuncDef(functionName);
			//return ((ClassDef)from).getFuncDef(functionName);
		}
		else if(from.hasArrayLevels())
		{//it's an array - so treat as object + length variable
			if(functionName.equals("clone"))
			{//BECAUSE: The class Object does not itself implement the interface Cloneable, so calling the clone method on an object whose class is Object will result in throwing an exception at run time.
				HashSet<FuncType> ret = new HashSet<FuncType>();
				ret.add( new FuncType(new ArrayList<Type>(), from));
				return ret;
			}
			else
			{
				return (new ClassDefJava(java.lang.Object.class)).getFuncDef(functionName);
			}
		}
		
		return null;
	}
	*/
	
	private TypeAndLocation findFuncDefs(int line, int col, Type from, String name)//from type: array or classdef
	{
		if(from instanceof NamedType) {
			from = TypeCheckUtils.getRefTypeToLocked((NamedType)from);
		}
		
		if(from.hasArrayLevels())
		{//it's an array - so treat as object + length variable
			if(name.equals("length")) {
				return new TypeAndLocation(new PrimativeType(PrimativeTypeEnum.INT), new LocationClassField("", from, true, false, false));
			}else {
				return null;//arrays have no fields other than length covered above
			}
		}else if(from instanceof NamedType){
			NamedType asNamed = ((NamedType)from);
			
			if(TypeCheckUtils.isTypedActor(this.getErrorRaiseableSupression(), asNamed) && !asNamed.isLockedAsActor){
				//check actee first, unless locked as actor
				
				//unless call itself originates from inside the actor itself, then we check actor first
				if(!this.currentlyInClassDef.isEmpty()){
					ClassDef cd =  this.currentlyInClassDef.peek();
					ClassDef set = asNamed.getSetClassDef();
					if(cd.isActor && set != null){
						if(cd.equals(set)){
							//check actor first
							TypeAndLocation tal = asNamed.getVariable(name);
							if(null != tal){
								return tal;
							}
							
						}
					}
				}
				
				Type got = TypeCheckUtils.extractTypedActorType(this.getErrorRaiseableSupression(), asNamed);
				if(got instanceof NamedType){
					NamedType actee = (NamedType)got;
					TypeAndLocation tal = actee==null?null:actee.getVariable(name);
					if(null != tal){
						if(!asNamed.equals(got)){//if the variable is via an actor, then we make it private, all actor vars are private
							Location loc = tal.getLocation().copy();
							loc.setAccessModifier(AccessModifier.PRIVATE);
							tal = tal.copy();
							tal.setLocation(loc);//copy so we dont corrupt the origonal location definition
						}
						
						return tal;
					}
				}
				
				//uh oh check the actor itself next...
			}
			
			//check enum field access
			TypeAndLocation tal = asNamed.getVariable(name);
			if(null != tal){
				ClassDef where = asNamed.getSetClassDef();
				if(where != null && where.isEnum){
					Location loc = tal.getLocation();
					if(loc instanceof LocationStaticField){
						Type got = tal.getType();
						if(asNamed.equals(got)){
							if(!asNamed.isEnumParent){
								return null;//-> MyEnum.ONE.ONE //not ok
							}
							
							//((NamedType)got).isEnumElement=true;
						}else if(TypeCheckUtils.isEnum(got)){//thing.enum.ONE
							((NamedType)got).isEnumParent=true;
						}
					}
					else if(loc instanceof LocationClassField){
						LocationClassField lcf = (LocationClassField)loc;
						if(lcf.ownerType.equals(asNamed) && asNamed.isEnumParent){
							//!enumelement -> MyEnum.d //not ok
							return null;
						}
					}
				}else{//thing.enum.ONE
					Location loc = tal.getLocation();
					if(loc instanceof LocationStaticField){
						Type got = tal.getType();
						if(TypeCheckUtils.isEnum(got)){
							((NamedType)got).isEnumParent=true;
						}
					}
				}
			}
			
			if(tal != null && from.getNullStatus() == NullStatus.NULLABLE) {
				Type ret = tal.getType();
				ret = (Type)ret.copy();
				ret.setNullStatus(NullStatus.NULLABLE);
				tal = tal.cloneWithRetFuncType(ret);
			}
			
			return tal;
		}
		else if(from instanceof ModuleType)
		{
			ModuleType currentMod = (ModuleType)from;
			
			String dottedNameToResolve = currentMod.getNameSoFar() +"." + name;
			ClassDef ret = this.mainLoop.getClassDefFromPath(dottedNameToResolve, mc, false);
			if(null != ret)
			{
				NamedType nt = new NamedType(line, col, ret);
				if(ret.isEnum){
					nt.isEnumParent=true;
				}
				
				return new TypeAndLocation(nt, null);
			}else{
				
				return this.mainLoop.getVariableFromPath(dottedNameToResolve, mc, false);
				//HashSet<TypeAndLocation> fd = this.mainLoop.getFunctionFromPath(dottedNameToResolve, mc, false);
			}
		}
		
		
		return null;
	}
	
	private Pair<String, TypeAndLocation> getVariable(String name, int line, int col, boolean dontSerachGlobals)
	{
		if(!dotOperatorLHS.isEmpty() && dotOperatorLHS.peek() != null)
		{//in dot op scope, e.g. a.b = 99
			return new Pair<>(name, findFuncDefs(line, col, dotOperatorLHS.peek(), name));
		}
		else
		{//not in a dot operator,  e.g. a = 99
			//check locl scpes, but stop when u get to the class level, then check the class leve, then check the level above the class..
			//nested classes
			
			//call made in with statement
			
			if(!this.currentlyInWithStatement.isEmpty()) {
				for(int n = currentlyInWithStatement.size()-1; n>=0; n--){
					Pair<String, NamedType> nameAndType = currentlyInWithStatement.get(n);
					NamedType toTry = nameAndType.getB();
					if(null != toTry) {
						TypeAndLocation tal = findFuncDefs(line, col, toTry, name);
						if(null != tal){
							Location loc = tal.getLocation().copy();
							loc.redirectExtFuncOrWithExpr = nameAndType.getA();//i.e. repoint to: "withTmpVar$2. xxx ()..."
							return new Pair<>(name, new TypeAndLocation(tal.getType(), loc));
						}
					}
				}
			}
			
			
			//if call made in extension function, 
			if( !this.currentlyInFuncDef.isEmpty()){
				for(int n = currentlyInFuncDef.size()-1; n>=0; n--){
					FuncDefI fd = currentlyInFuncDef.get(n);
					if(fd instanceof FuncDef){
						if(((FuncDef)fd).extFunOn != null){
							Type extFuncOn = ((FuncDef)fd).extFunOn;
							
							TypeAndLocation tal = findFuncDefs(line, col, extFuncOn, name);
							if(null != tal){
								Location loc = tal.getLocation().copy();
								loc.redirectExtFuncOrWithExpr = "this$extFunc";//i.e. repoint to: "this$extFunc. xxx ()..."
								return new Pair<>(name, new TypeAndLocation(tal.getType(), loc));
								
							}else{//give up dont search higher
								break;
							}
						}
					}
				}
			}
			
			
			//oh but first check we're not in a for loop nonesens bit
			if (null != forLoopVarAndType && forLoopVarAndType.containsKey(name))
			{
				return new Pair<>(name, tagNestedParent(forLoopVarAndType.get(name)));
			}
			
			TheScopeFrame search = this.currentScopeFrame;
			while(search!=null)
			{//check 'local' scopes until we get to class level
				if(search.isClass())
				{//when u hit a class stop!
					break;
				}
				else
				{//variable could have been imported in whcih case...
					if(search.hasVariable(this.currentScopeFrame, name, true, false, false))
					{
						Pair<TypeAndLocation, Boolean> gotVar = search.getVariable(this.currentScopeFrame, name, true);
						if(this.isInSuperConstructorCall() && gotVar.getB()) {
							this.raiseError(line, col, String.format("Cannot refer to instance variable %s while explicitly invoking a constructor", name)); 
						}
						TypeAndLocation tal = gotVar.getA();
						//((NamedType)tal.getType()).getEnumVars(satc)
						return new Pair<>(name, tal);//tagNestedParent(tal);
					}
				}
				search = search.getParent();
			}
			
			if(!this.currentlyInClassDef.isEmpty())
			{// now search nested class heirachy if any
				Object[] classHeriarch = this.currentlyInClassDef.toArray();
				for(int n = classHeriarch.length-1; n>=0; n--){
					ClassDef topCls = (ClassDef)classHeriarch[n];
					if(topCls.hasVariable(this.currentScopeFrame, name) )
					{//class, superclass and also check parent scope...
						if(this.isInSuperConstructorCall()) {
							this.raiseError(line, col, "Cannot refer to an instance variable while explicitly invoking a constructor");
						}
						return new Pair<>(name, tagNestedParent(topCls.getVariable(this.currentScopeFrame, name)));
					}
				}
			}
			if(!dontSerachGlobals){
				while(search != null)
				{//now search globals
					if(!search.isClass())
					{
						//we've reached the top level
						if(search.hasVariable(this.currentScopeFrame, name, true, false, false))
						{
							if(this.isInSuperConstructorCall()){
								this.raiseError(line, col, "Cannot refer to an instance variable while explicitly invoking a constructor");
							}
							return new Pair<>(name, tagNestedParent(search.getVariable(this.currentScopeFrame, name, true).getA()));
						}
					}
					search = search.getParent();
				}			
				//check to see if it's a thing that's been imported or like var = ClassStatic.d
				boolean nameRepointed = false;
				String origname = name;
				if(hasImportBeenRegistered(name))
				{//and finnaly search top level imports for the name
					nameRepointed=true;
					name = getImportBeenRegistered(name);
				}
				
				/*TypeAndLocation got = this.mainLoop.getVariableFromPath(name, this.mc, false);//TODO: this at time resolves to a null location
				if(got == null)
				{
					ClassDef cls = this.mainLoop.getClassDefFromPath(name, this.mc, false);
					if(cls != null)
					{
						got = new TypeAndLocation(new NamedType(line, col, cls), null);
					}
				}*/
				
				//still not found, try prepending current path and looking around there...
				
				TypeAndLocation got = getNameOrClassFromPath(line, col, name);
				if(null == got){//e.g. annotation X{c=Thing.ONE; public enum Thing{ONE, TWO}}
					name =  getFullyDottedPackage() + "." + name;
					got = getNameOrClassFromPath(line, col, name);
				}else{
					Type tg = got.getType();
					if(TypeCheckUtils.isEnum(tg)){
						((NamedType)tg).isEnumParent=true;
					}
				}
				
				if(nameRepointed){
					if(got == null){
						return null;
					}
					
					Location loc = got.getLocation();
					if(loc instanceof LocationStaticField){
						LocationStaticField asStat = (LocationStaticField)loc;
						origname = name.substring(asStat.owner.length()+1);
					}
				}
				
				return new Pair<>(origname, tagNestedParent(got));
			}
			
			return null;
		}
	}
	
	
	
	private TypeAndLocation tagNestedParent(TypeAndLocation tal){
		if(tal != null){
			Type tt = tal.getType();
			if(tt instanceof NamedType){
				NamedType nt = (NamedType)tt;
				ClassDef cd = nt.getSetClassDef();
				if(cd != null && cd.isEnum ){
					nt.isEnumParent=true;
				}
			}
		}
		
		return tal;
	}
	
	private TypeAndLocation getNameOrClassFromPath(int line, int col, String name){
		TypeAndLocation got = this.mainLoop.getVariableFromPath(name, this.mc, false);//TODO: this at time resolves to a null location
		if(got == null)
		{
			ClassDef cls = this.mainLoop.getClassDefFromPath(name, this.mc, false);
			if(null == cls){
				cls = getImportedClassDef(name);
			}
			
			if(cls != null)
			{
				got = new TypeAndLocation(new NamedType(line, col, cls), null);
			}
		}
		return got;
	}
	
	private Thruple<NamedType, FuncType, Boolean> rhsDotOfMap(int line, int col){
		if((!this.dotOperatorLHS.isEmpty() && this.dotOperatorLHS.peek() != null) ){
			Type left = dotOperatorLHS.peek();
			if(left instanceof NamedType){
				NamedType asNamed= (NamedType)left;
				Type toLocked = TypeCheckUtils.getRefTypeToLocked(asNamed);
				if(toLocked instanceof NamedType) {
					asNamed = (NamedType)toLocked;
					if(null != TypeCheckUtils.checkSubType(this.ers, const_map, asNamed, 0, 0, 0, 0)){
						List<Type> gens = asNamed.getGenTypes();
						if(gens.size() == 2 ){//&& gens.get(0).equals(const_string)
							Type keyType = gens.get(0);
							
							if(null != TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), const_string, keyType, 0, 0, 0, 0)){
								return new Thruple<NamedType, FuncType, Boolean>((NamedType)left, new FuncType(asNamed.getGenTypes().get(1)), true);
							}
						}
					}
					else{
						ArrayList<Type> argsWanted = new ArrayList<Type>();
						argsWanted.add(const_string);
						HashSet<TypeAndLocation> items = asNamed.getFuncDef(line, col, "get", argsWanted, null, this);
						//TODO: varargs may cause a problem here...
						for(TypeAndLocation tal : items){
							Type tt = tal.getType();
							if(tt != null && tt instanceof FuncType){
								FuncType ft = (FuncType)tt;
								ArrayList<Type> inputs = ft.getInputs();
								if(inputs.size() == 1 && inputs.get(0).equals(const_string)){
									return new Thruple<NamedType, FuncType, Boolean>((NamedType)left, ft, false);
								}
							}
						}
						
						//might have a putter instead but of course this cannot be used 
						
						items = asNamed.getFuncDef(line, col, "put", argsWanted, null, this);
						//TODO: varargs may cause a problem here...
						for(TypeAndLocation tal : items){
							Type tt = tal.getType();
							if(tt != null && tt instanceof FuncType){
								FuncType ft = (FuncType)tt;
								ArrayList<Type> inputs = ft.getInputs();
								if(inputs.size() >= 1 && inputs.get(0).equals(const_string)){
									return new Thruple<NamedType, FuncType, Boolean>((NamedType)left, ft, false);
								}
							}
						}
						
					}
				}
				
			}
			
		}
		return null;
	}
	
	@Override
	public Object visit(RefName refName) {
		if(refName.astRedirectforOnChangeNesting != null){
			return refName.astRedirectforOnChangeNesting.accept(this);
		}
		
		String name = refName.name;
		
		if(null  == name){
			return null;
		}
		
		Pair<String, TypeAndLocation> reta = getVariable(name, refName.getLine(), refName.getColumn(), false);
		
		if(name.equals("stateObject$") && reta==null){
			reta = getVariable(name, refName.getLine(), refName.getColumn(), false);
		}
		
		TypeAndLocation ret;
		if(null != reta){
			if(!refName.name.equals(reta.getA())){
				refName.bytecodename = reta.getA();
			}
			ret = reta.getB();
		}else{
			ret = null;
		}
		
		
		if(null == ret)
		{//oh no, but maybe if we look globally we can find something...
			//so for now assume that it's a module, i.e. System.out.println("")
			
			if(null != refName.astRedirect) {
				return refName.astRedirect.accept(this);
			}
				
			
			Thruple<NamedType, FuncType, Boolean> appliedtoMap = rhsDotOfMap(refName.getLine(), refName.getColumn());
			if(null != appliedtoMap){
				NamedType appliedTo = appliedtoMap.getA();
				refName.isMapGetter = new Fourple<Boolean, NamedType, String, FuncType>(appliedtoMap.getC(), appliedTo, name, appliedtoMap.getB());
				Type tt = appliedtoMap.getB().retType;
				tt = removeInOUTGens(tt);
				refName.setTaggedType(tt);
				return tt;
				
			}else{
				Expression previousExpr = refName.getPreceedingExpression();
				//boolean dotLast = false;//(!this.dotOperatorLHS.isEmpty() && this.dotOperatorLHS.peek() == null);
				boolean procLast = currentDotOperatorTracker.isEmpty() ||  currentDotOperatorTracker.peek().isProcesingLastElement();
				if((refName.astRedirect != null && refName.astRedirect instanceof FuncRef) /*|| (dotLast && !procLast) */||  procLast  ){
					//see if we can treat the RefName as a FuncRef, e.g. def foo() { def fong() { 12} return fong }
					if(null == previousExpr || !(previousExpr instanceof FuncRef || previousExpr instanceof FuncInvoke)){
						//reuse prevoius one if there was one declared
						FuncRef tryFuncRef = refName.astRedirect!=null && refName.astRedirect instanceof FuncRef ?(FuncRef)refName.astRedirect:new FuncRef(refName.getLine(), refName.getColumn(), (RefName)refName.copy(), null);
						maskErrors();//mask errors because we report below if needs be
						Type got = (Type)tryFuncRef.accept(this);
						if(!maskedErrors()){//yippe! a match, do ast redirect for subsequent calls
							refName.astRedirect = tryFuncRef;
							return got;
						}
					}
					
					//fail as normal
					this.raiseError(refName.getLine(), refName.getColumn(), String.format("%s cannot be resolved to a variable", name));
				}
				else if(previousExpr instanceof FuncRef && !currentDotOperatorTracker.isEmpty()){
					//cater for this case: oo = OuterCls(99); oo.MyClass&
					NamedType tryNamed = new NamedType(refName.getLine(), refName.getColumn(), name);
					maskErrors();//mask errors because we report below if needs be
					Type got = (Type)tryNamed.accept(this);
					if(!maskedErrors()){//yippe! a match, do ast redirect for subsequent calls
						refName.astRedirect = tryNamed;
						refName.setTaggedType(got);
						return got;
					}
					
				}

				String modTypeName = name;
				
				if((!this.dotOperatorLHS.isEmpty() && this.dotOperatorLHS.peek() != null) && dotOperatorLHS.peek() instanceof ModuleType){
					modTypeName = ((ModuleType)dotOperatorLHS.peek()).getNameSoFar() + "."  + modTypeName;
				}
				else{
					if(hasImportBeenRegistered(modTypeName)){//and finnaly search top level imports for the name
						modTypeName = getImportBeenRegistered(modTypeName);
					}
				}
				
				refName.ignoreWhenGenByteCode=true;
				
				/*boolean inDop = !currentDotOperatorTracker.isEmpty();
				if(!inDop || !(inDop && currentDotOperatorTracker.peek().isProcesingLastElement()))
				{
					this.raiseError(refName.getLine(), refName.getColumn(), String.format("%s cannot be resolved to a variable", name));
				}*/
				
				return new ModuleType(refName.getLine(), refName.getColumn(), modTypeName);
			}
		}
		else if(ret.getLocation() == null)
		{
			refName.ignoreWhenGenByteCode=true;
			//TODO: this nexy check is ugly, fixes this erorr: System.identityHashCode(MyEnum) // where MyEnum is an Enum class def
			boolean inDop = !currentDotOperatorTracker.isEmpty();
			if(!inDop || currentDotOperatorTracker.peek().isProcesingLastElement())
			{
				this.raiseError(refName.getLine(), refName.getColumn(), String.format("%s cannot be resolved to a variable", name));
			}else if(inDop  && (currentDotOperatorTracker.peek().isLast() || currentDotOperatorTracker.peek().getcurrent() != refName)){
				this.raiseError(refName.getLine(), refName.getColumn(), String.format("%s cannot be resolved to a variable", name));
			}
		}
		else
		{//normal case
			/*
			 * { Type tt = ret.getType(); if(tt != null){ if(null != tt.getGpuMemSpace()) {
			 * if(this.currentlyInFuncDef.empty() ||
			 * this.currentlyInFuncDef.peek().isGPUKernalOrFunction == null) {
			 * this.raiseError(refName.getLine(), refName.getColumn(),
			 * String.format("%s cannot be referenced outside of a gpu kernel or function",
			 * name)); } } } }
			 */
			
			Location loc = ret.getLocation();
			
			if(loc.redirectExtFuncOrWithExpr != null){
				//refName.astRedirect = null;
				
				if(refName.astRedirect ==null) {
					refName.astRedirect = DotOperator.buildDotOperatorOneNonDirect(refName.getLine(), refName.getColumn(), new RefName(loc.redirectExtFuncOrWithExpr), (RefName)refName.copy());
				}
				
				return refName.astRedirect.accept(this);
				//refName.astRedirect
			}
			
			AccessModifier am = loc.getAccessModifier();
			
			if(am == AccessModifier.PRIVATE || am == AccessModifier.PROTECTED || am == AccessModifier.PACKAGE){ 
				if(loc instanceof LocationClassField){
					LocationClassField lcf = (LocationClassField)loc;
					NamedType creator =  (NamedType)lcf.ownerType;
					if(protectedAndNotInPackage(am, loc)  && (creator != null &&( this.currentlyInClassDef.isEmpty() || !isAccesible(am, creator, this.currentlyInClassDef.peek(), name.equals("<init>"), this.justPackageName)))){
						this.raiseError(refName.getLine(), refName.getColumn(), String.format("The variable %s is not visible" , name));
					}
					else{//need to mark owner varaible for redirection.
						if(null==loc.getPrivateStaticAccessorRedirectFuncGetter()  && !this.currentlyInClassDef.isEmpty() ){
							ClassDef topCls = this.currentlyInClassDef.peek();
							ClassDef creatorClasDef = creator.getSetClassDef();
							if(topCls.isParentNestor(creatorClasDef) || creatorClasDef.isParentNestor(topCls)){//if declard in parent nestor... or the other way around 
								
								if(topCls.isEnumSubClass){//enum subclasses are not really nested, rather they are subclasses of whatever
									if(am == AccessModifier.PRIVATE){//thus private is invalid
										this.raiseError(refName.getLine(), refName.getColumn(), String.format("private variable %s is not visible to enum item", name));
									}
								}
								else{//ok its a real nested class
									loc.setPrivateStaticAccessorRedirectFuncGetter(this.getNextPrivateStaticAccessorRedirectFuncName(), name);
									if(refName.shouldAddsetterAccessorIfGetterAdded){
										loc.setPrivateStaticAccessorRedirectFuncSetter(this.getNextPrivateStaticAccessorRedirectFuncName(), name, ret.getType() );
									}
								}
							}
						}
					}
				}
				else if(loc instanceof LocationStaticField){
					//hmm
					String owner = ((LocationStaticField) loc).owner;
					String moi = this.justPackageName.replace('.', '/');
					if(protectedAndNotInPackage(am, loc)  && !moi.equals(owner)){
						this.raiseError(refName.getLine(), refName.getColumn(), String.format("The variable %s is not visible" , name));
					}
					else{//need to mark owner varaible for redirection.
						if(null==loc.getPrivateStaticAccessorRedirectFuncGetter()  && !this.currentlyInClassDef.isEmpty() ){
							loc.setPrivateStaticAccessorRedirectFuncGetter(this.getNextPrivateStaticAccessorRedirectFuncName(), name);
							
							if(refName.shouldAddsetterAccessorIfGetterAdded){
								loc.setPrivateStaticAccessorRedirectFuncSetter(this.getNextPrivateStaticAccessorRedirectFuncName(), name, ret.getType() );
							}
						}
					}
				}
			}
			if(loc instanceof LocationClassField){
				LocationClassField lcf = (LocationClassField)loc;
				if(lcf.ownerType instanceof NamedType){
					NamedType creator =  (NamedType)lcf.ownerType;
					
					if(!(creator.hasArrayLevels() && refName.name.equals("length"))){//ignore for thing.length
						if(creator != null &&( !this.currentlyInClassDef.isEmpty() && !isAccesible(am, creator, this.currentlyInClassDef.peek(), name.equals("<init>"), this.justPackageName))){
							this.raiseError(refName.getLine(), refName.getColumn(), String.format("The variable %s is not visible" , name));
						}
					}
					
					
					
					if(inThisOrSuperConstructorInvokation){//if location resolves to self type
						if(!this.currentlyInClassDef.isEmpty() && this.currentlyInClassDef.peek().toString().equals(creator.toString())){
							this.raiseError(refName.getLine(), refName.getColumn(), String.format("Cannot refer to instance variable %s while explicitly invoking a constructor", name));
						}
					}
					
					if(TypeCheckUtils.isActor(this.ers, creator) && !this.precceededByThisSuperOrNothing()){
						//actor and not preceeded by anything...
						if(!this.dotOperatorLHS.isEmpty() && this.dotOperatorLHS.peek() != null){
							this.raiseError(refName.getLine(), refName.getColumn(), String.format("Cannot access actor field: %s", name));
						}
					}
										
					if( this.dotOperatorLHS.isEmpty()){
						//steo up classdefs to ensure we are not inside a local class trying to call a method of a 'nestor' class
						ClassDef callsiteCls = ((NamedType)((LocationClassField)loc).ownerType).getSetClassDef();
						boolean inLocal = false;
						for(int n = this.currentlyInClassDef.size()-1; n >= 0; n--){
							ClassDef cd = this.currentlyInClassDef.get(n);
							if(cd.equals(callsiteCls)){
								if(inLocal){
									ClassDef currentCls = this.currentlyInClassDef.isEmpty()?null: this.currentlyInClassDef.peek();
									this.raiseError(refName.getLine(), refName.getColumn(), String.format("Field %s in: %s cannot be called from within local class: %s (local classes are not nested)", name, callsiteCls, currentCls ));
								}
							}
							if(cd.isLocalClass){
								inLocal = true;
							}
						}
						//in local class trying to access method which is in fake parent nestor class
					}
					
				}
			}
			else if(loc instanceof LocationStaticField){
				tagIgnorePreviousDopElement(refName);
			}
			
			if(!refName.inCastExpr && !this.asisOverwriteType.isEmpty()){
				Pair<String, Boolean> key = makeRefNameTypeOverrideKey(refName);
				if(key != null) {
					for(int n = this.asisOverwriteType.size() - 1;  n >=0; n--){
						HashMap<Pair<String, Boolean>, Type> level = this.asisOverwriteType.get(n);
						if(null != level && level.containsKey(key)){
							refName.castTo = removeInOUTGens(level.get(key));
							break;
						}
					}
				}
			}
			
			refName.ignoreWhenGenByteCode=false;
		}
					
		refName.resolvesTo = ret;
		
		if(null != ret){
			Type tt = ret.getType();
			refName.sourceOfNameGeneric =  null != tt &&  tt instanceof NamedType && null != ((NamedType)tt).getOrigonalGenericTypeUpperBoundRaw();//oh its from a generic source
		}
		
		Type returnType = null;
		if(refName.castTo != null){
			returnType = refName.castTo;
			refName.castFrom = removeInOUTGens(ret.getType());
		}else if(ret!=null){
			returnType = removeInOUTGens(ret.getType());
		}
		
		NullStatus inferedAs = null;
		
		if(refName.inferNonNullable) {
			inferedAs = NullStatus.NONNULL;
			Pair<String, Boolean> key = makeRefNameTypeOverrideKey(refName);
			nullableOverwriteType.peek().put(key, inferedAs);
		}else {
			if(!this.nullableOverwriteType.isEmpty()){
				Pair<String, Boolean> key = makeRefNameTypeOverrideKey(refName);
				inferedAs = inferredAs(key);
			}
		}
		
		if(null != inferedAs) {
			Object constf = ((Node)returnType).getFoldedConstant();
			returnType = (Type)returnType.copy();
			((Node)returnType).setFoldedConstant(constf);
			returnType.setNullStatus(inferedAs);
		}
		
		if(returnType instanceof NamedType){
			checkTypeDefAccessiableNT((NamedType) returnType, refName.getLine(), refName.getLine());
		}
		
		
		if(!refName.supressUnassign) {
			FuncInvoke unassign = typeHasUnassign(refName.getLine(), refName.getLine(), TypeCheckUtils.getRefTypeToLocked(returnType), (Expression)refName.astRedirect); 
			if(null != unassign ) {
				RefName rn = new RefName(refName.name);
				rn.supressUnassign = true;//else inf loop
				refName.astRedirect = DotOperator.buildDotOperatorOneNonDirect(refName.getLine(), refName.getLine(), rn, unassign);
				
				return refName.astRedirect.accept(this);
			}
		}
		
		return returnType==null?null:refName.setTaggedType(returnType);
	}
	
	public FuncInvoke typeHasUnassign(int line, int col, Type lhs, Expression existingRedirect) {
		return canBeOperatorOverloaded(lhs, new ArrayList<Type>(), null, "unassign", new ArrayList<Expression>(), line, col, false, null, true, (Node)existingRedirect);
	}
	
	
	private void checkTypeDefAccessiableNT(NamedType returnType, int line, int col){
		ClassDef clu = ((NamedType)returnType).getSetClassDef();
		if(clu != null){
			checkTypeDefAccessiableCD(clu, line, col);
		}
	}
	
	private void checkTypeDefAccessiableCD(ClassDef clu, int line, int col){
		AccessModifier am = clu.accessModifier;
		String bcname = clu.bcFullName();
		if(bcname != null){
			String location = bcname.replace('/', '.');//
			
			if(location.contains("$")){
				location = location.substring(0, location.indexOf('$'));
			}
			
			checkTypeDefAccessiable(line, col, clu.className, am, location);
		}
		
	}
	
	
	private boolean protectedAndNotInPackage(AccessModifier am, Location loc){
		if(am.equals(AccessModifier.PROTECTED) || am.equals(AccessModifier.PACKAGE)){
			String owner = null;
			if(loc instanceof LocationClassField){
				owner = ((LocationClassField) loc).getOwner();
			}else if(loc instanceof LocationStaticField){
				owner = ((LocationStaticField) loc).owner;
			}else if(loc instanceof StaticFuncLocation){
				owner = ((NamedType)((StaticFuncLocation)loc).getOwnerType()).getSetClassDef().getPrettyName();
			}else if(loc instanceof ClassFunctionLocation){
				owner = ((ClassFunctionLocation)loc).owner;
			}
			
			if(owner == null){
				return false;
			}
			
			String currentPackage = this.justPackageName;
			
			String definedPackage = owner.replace('/', '.');//
			
			if(definedPackage.contains("$")){
				definedPackage = definedPackage.substring(0, owner.indexOf('$'));
			}
			
			currentPackage = currentPackage.contains(".")?currentPackage.substring(0, currentPackage.lastIndexOf('.')):currentPackage;
			definedPackage = definedPackage.contains(".")?definedPackage.substring(0, definedPackage.lastIndexOf('.')):definedPackage;
			
			return !currentPackage.equals(definedPackage);
		}
		
		return true;
	}
	
	private Type removeInOUTGens(Type tt){
		if(null != tt){
			
			if(tt.getInOutGenModifier() == InoutGenericModifier.IN){
				tt = ScopeAndTypeChecker.const_object.copyTypeSpecific();
			}
		}
		return tt;
	}

	private int privateStaticAccessRedirectOverrideCnter = 0;
	private String getNextPrivateStaticAccessorRedirectFuncName(){
		//Used for cases where you have a private static module level variable or function being access within a nested class - here we must call an accessor method to access it
		//since we cannot directly reference the private static varaible (even from a nested static clas... weird)
		return "psar$" + privateStaticAccessRedirectOverrideCnter++;
	}
	
	@Override
	public Object visit(RefBoolean refBoolean) {
		Type x = new PrimativeType(PrimativeTypeEnum.BOOLEAN);
		refBoolean.setTaggedType(x);
		return x;
	}

	private Type checkNumericalInFixPostFix(Type ret, int line, int col, String postfixErr, boolean restrictInfix) {
		if (null != ret && ret.hasArrayLevels()) {
			this.raiseError(line, col, String.format("pre and postifx operations cannot be performed on arrays (not yet): %s%s", ret, postfixErr));
		} else {
			if (TypeCheckUtils.checkNumerical(this, ret, line, col, restrictInfix)) {
				
				if(restrictInfix){
					Type unboxed = TypeCheckUtils.unboxTypeIfBoxed(ret);
					boolean needsBoxing = !ret.equals(unboxed);
					
					if(((PrimativeType)unboxed).type == PrimativeTypeEnum.LONG){
						ret = ScopeAndTypeChecker.const_long;
					}else{
						ret = ScopeAndTypeChecker.const_int;
					}
					
					if(needsBoxing){
						ret = TypeCheckUtils.boxTypeIfPrimative(ret, false);
					}
				}
				
				return ret;
			} else {
				this.raiseError(line, col, String.format("Expected type %s not: %s%s", restrictInfix ? "integral" : "numerical", ret, postfixErr));
			}
		}
		return null;
	}
	
	public static final PrimativeType const_int = new PrimativeType(PrimativeTypeEnum.INT);
	public static final PrimativeType const_double = new PrimativeType(PrimativeTypeEnum.DOUBLE);
	public static final PrimativeType const_float = new PrimativeType(PrimativeTypeEnum.FLOAT);
	public static final PrimativeType const_long = new PrimativeType(PrimativeTypeEnum.LONG);
	
	//((ArrayRef)LHS).getLastArrayRefElement().liToMap = LISTorMAPType.PUT;
	
	private void tagArrayRefWithGetAndPut(Expression LHS)
	{//e.g. on xxx[3]++; if this were a map operation it gets tagged
		/*if(LHS instanceof RefNamedType){
			ArrayRef astRedirectToArrayRef =  ((RefNamedType)LHS).astRedirectToArrayRef;
			if(null != astRedirectToArrayRef){
				LHS = astRedirectToArrayRef;
			}
		}*/
		
		if(LHS instanceof ArrayRef)
		{
			((ArrayRef)LHS).getLastArrayRefElement().liToMap = LISTorMAPType.GETANDPUT;
		}
		else if(LHS instanceof DotOperator)
		{
			tagArrayRefWithGetAndPut(((DotOperator)LHS).getLastElement());
		}
		return;
	}
	
	@Override
	public Object visit(PrefixOp prefixOp) {
		
		boolean plusplusorminsminus = (prefixOp.prefix != FactorPrefixEnum.NEG && prefixOp.prefix != FactorPrefixEnum.PLUS && prefixOp.prefix != FactorPrefixEnum.COMP );
		
		if(plusplusorminsminus)
		{
			Node eee = (Node)TypeCheckUtils.checkCanBePrePostfiexed(this, this, prefixOp.p1, prefixOp.p1.getLine(), prefixOp.p1.getColumn());
			eee.shouldAddsetterAccessorIfGetterAdded=true;
		}
		rhsPendingAssignmeng.push(const_int);
		tagArrayRefWithGetAndPut(prefixOp.p1);

		ArrayList<Type> elementTypes = vectorizeElementsIfApproperiate(prefixOp);
		
		Type leType = elementTypes.get(0);//(Type)prefixOp.p1.accept(this);

		if(elibableForNameMapConverstion(prefixOp.p1)){
			prefixOp.p1 = convertDotOpMapThingToArrayRef((DotOperator)prefixOp.p1);
			leType = (Type)prefixOp.p1.accept(this);
		}

		flagNullableForOperation(prefixOp.p1.getLine(), prefixOp.p1.getColumn(), leType);
		
		TypeCheckUtils.assertRefIsGettable(this, prefixOp.p1.getLine(), prefixOp.p1.getColumn(), leType, -1);//get
		TypeCheckUtils.assertRefIsAssignable(this, prefixOp.p1.getLine(), prefixOp.p1.getColumn(), leType, -1);//set
		
		leType = leType == null?null:(Type)leType.copy();
		TypeCheckUtils.unlockAllNestedRefs(leType);
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(leType);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = lhsvec.getA();

		if(vectorized != null) {
			leType = lhsvec.getB();
			prefixOp.depth = vectorized;
		}
				
		
		Type ret;
		Type oponleType= TypeCheckUtils.getRefTypeToLocked(leType);
		
		
		
		FuncInvoke overloaded = canBeOperatorOverloaded(oponleType, new ArrayList<Type>(), null, prefixOp.prefix.asMethod,  new ArrayList<Expression>(), prefixOp.getLine(), prefixOp.getColumn(), plusplusorminsminus, null, false, prefixOp.astOverrideOperatorOverload);
		if(null != overloaded){
			prefixOp.astOverrideOperatorOverload = overloaded;
			this.dotOperatorLHS.push(leType);
			Type got = (Type)prefixOp.astOverrideOperatorOverload.accept(this);
			if(!plusplusorminsminus){
				ret = got;
			}
			else{
				ret = leType;
			}
				
			this.dotOperatorLHS.pop();
		}
		else{
			ret = checkNumericalInFixPostFix(leType, prefixOp.getLine(), prefixOp.getColumn(), makeMissingOpOverLoadMessage(prefixOp.prefix.asMethod, leType, new ArrayList<Type>(0), leType), prefixOp.prefix == FactorPrefixEnum.COMP);
		}
		
		rhsPendingAssignmeng.pop();
		
		if(vectorized != null) {
			ret = (Type)ret.copy();
			ret = TypeCheckUtils.applyVectStruct(vectorized, ret);
		}
		
		if(ret != null && ret.getPointer() > 0 && !prefixOp.prefix.isDoubleThing) {
			this.raiseError(prefixOp.getLine(), prefixOp.getColumn(), String.format("Invalid operator: %s in expression involving pointer", prefixOp.prefix) );
		}
		
		if(plusplusorminsminus)
		{
			TypeCheckUtils.checkCanBePrePostfiexed(this, this, prefixOp.p1, prefixOp.p1.getLine(), prefixOp.p1.getColumn());
		}
		
		prefixOp.setTaggedType(ret);
		return ret;
	}
	
	private boolean elibableForNameMapConverstion(Expression p2){
		if(p2 instanceof DotOperator){
			DotOperator asDot = (DotOperator)p2;
			Expression last = asDot.getLastElement();
			return last instanceof RefName && ((RefName)last).isMapGetter!=null;
		}
		
		return false;
	}

	@Override
	public Object visit(PostfixOp postfixOp) {
		Node eee = (Node)TypeCheckUtils.checkCanBePrePostfiexed(this, this, postfixOp.p2, postfixOp.p2.getLine(), postfixOp.p2.getColumn());//ugly needs to be called again
		eee.shouldAddsetterAccessorIfGetterAdded=true;
		rhsPendingAssignmeng.push(const_int);
		tagArrayRefWithGetAndPut(postfixOp.p2);

		ArrayList<Type> elementTypes = vectorizeElementsIfApproperiate(postfixOp);
		
		Type leType = elementTypes.get(0);//(Type)postfixOp.p2.accept(this);
		
		if(elibableForNameMapConverstion(postfixOp.p2)){
			postfixOp.p2 = convertDotOpMapThingToArrayRef((DotOperator)postfixOp.p2);
			leType = (Type)postfixOp.p2.accept(this);
		}
		
		flagNullableForOperation(postfixOp.p2.getLine(), postfixOp.p2.getColumn(), leType);

		TypeCheckUtils.assertRefIsGettable(this, postfixOp.p2.getLine(), postfixOp.p2.getColumn(), leType, -1);//get
		TypeCheckUtils.assertRefIsAssignable(this, postfixOp.p2.getLine(), postfixOp.p2.getColumn(), leType, -1);//set
		
		leType = leType == null?null:(Type)leType.copy();
		TypeCheckUtils.unlockAllNestedRefs(leType);//probably wrong
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(leType);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = lhsvec.getA();

		if(vectorized != null) {
			leType = lhsvec.getB();
			postfixOp.depth = vectorized;
		}
		
		Type ret;
		Type oponleType= TypeCheckUtils.getRefTypeToLocked(leType);
		FuncInvoke overloaded = canBeOperatorOverloaded(oponleType, new ArrayList<Type>(), null, postfixOp.postfix.asMethod,  new ArrayList<Expression>(), postfixOp.getLine(), postfixOp.getColumn(), true, null, false, postfixOp.astOverrideOperatorOverload);
		if(null != overloaded){
			postfixOp.astOverrideOperatorOverload = overloaded;
			this.dotOperatorLHS.push(oponleType);
			postfixOp.astOverrideOperatorOverload.accept(this);
			ret=leType;
			this.dotOperatorLHS.pop();
		}
		else{
			ret = checkNumericalInFixPostFix(leType, postfixOp.getLine(), postfixOp.getColumn(), makeMissingOpOverLoadMessage(postfixOp.postfix.asMethod, oponleType, new ArrayList<Type>(0), oponleType), false);
			
		}
		
		rhsPendingAssignmeng.pop();
		
		if(vectorized != null) {
			ret = TypeCheckUtils.applyVectStruct(vectorized, ret);
		}
		TypeCheckUtils.checkCanBePrePostfiexed(this, this, postfixOp.p2, postfixOp.p2.getLine(), postfixOp.p2.getColumn());
		postfixOp.setTaggedType(ret);
		return ret;
	}
	
	@Override
	public Object visit(PowOperator powOperator) {
		ArrayList<Type> elementTypes = vectorizeElementsIfApproperiate(powOperator);
		
		Type a = elementTypes.get(0);//(Type) powOperator.expr.accept(this);
		a = a == null?null:(Type)a.copy();
		a = TypeCheckUtils.extractRawRefType(a);
		flagNullableForOperation(powOperator.expr.getLine(), powOperator.expr.getColumn(), a);
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(a);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = lhsvec.getA();
		if(vectorized != null) {
			a = lhsvec.getB();
		}
		
		Type b = elementTypes.get(1);//(Type) powOperator.raiseTo.accept(this);
		b = b == null?null:(Type)b.copy();
		b = TypeCheckUtils.extractRawRefType(b);
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> rhsvec = vectorizedOperator(b);
		ArrayList<Pair<Boolean, NullStatus>> instVect = rhsvec.getA();
		if(instVect != null) {
			b = rhsvec.getB();
			vectorized = instVect;
		}	
		

		boolean lastWasOpOverload=false;
		
		Type ret;
		FuncInvoke overloaded = canBeOperatorOverloaded(a, b, "pow", powOperator.raiseTo, powOperator.getLine(), powOperator.getColumn(), powOperator.astOverrideOperatorOverload);
		if(null != overloaded){
			powOperator.astOverrideOperatorOverload = DotOperator.buildDotOperator(powOperator.expr.getLine(), powOperator.expr.getColumn(), powOperator.expr, overloaded); 
			ret = (Type)powOperator.astOverrideOperatorOverload.accept(this);
			lastWasOpOverload=overloaded.vectroizedDegreeAndArgs != null;
		}
		else{
			flagNullableForOperation(powOperator.raiseTo.getLine(), powOperator.raiseTo.getColumn(), b);
			ret = TypeCheckUtils.checkNumericalInfix(this.ers, a, b, powOperator.expr.getLine(), powOperator.expr.getColumn(), powOperator.raiseTo.getLine(), powOperator.raiseTo.getColumn(), makeMissingOpOverLoadMessage("pow", a, b, null));
			ret = TypeCheckUtils.unboxTypeIfBoxed(ret);
		}
		
		if(vectorized != null) {
			powOperator.depth = vectorized;
			if(null != ret && !lastWasOpOverload) {
				ret = TypeCheckUtils.applyVectStruct(vectorized, ret);
			}
		}else {
			ret = validateAndReturnPointerType(powOperator.getLine(),powOperator.getColumn(), elementTypes, ret, false);
		}
		
		powOperator.setTaggedType(ret);
		return ret;
		
		//return new PrimativeType(PrimativeTypeEnum.DOUBLE);
	}

	private HashSet<String> processCopyExpressionItems(int line, int col, Type thing, List<CopyExprItem> copyItems, boolean unchecked){
		if(thing instanceof NamedType) {
			HashSet<String> overridenFeilds = new HashSet<String>();
			
			NamedType asNamed = (NamedType)thing;
			Map<String, Sixple<String, Type, Boolean, AccessModifier, Boolean, String>> fieldSpec = new HashMap<String, Sixple<String, Type, Boolean, AccessModifier, Boolean, String>>();
			asNamed.getAllFields(false).forEach(a -> fieldSpec.put(a.getA(), a));

			boolean exclAlready = false;
			HashSet<String> incdupes = new HashSet<String>();
			HashSet<String> mustInclude = new HashSet<String>();
			HashSet<String> mustExclude = new HashSet<String>();
			boolean alreadyHasSuperCopier = false;
			for( CopyExprItem cei : copyItems) {
				if(cei instanceof CopyExprAssign) {
					CopyExprAssign asAssign = (CopyExprAssign)cei;
					String fieldName = asAssign.field;
					if(overridenFeilds.contains(fieldName) && !unchecked) {
						this.raiseError(asAssign.assignment.getLine(), asAssign.assignment.getColumn(), String.format("field: %s may be copied only once in copier", fieldName));
					}
					overridenFeilds.add(fieldName);
					
					if(mustExclude.contains(fieldName)) {
						this.raiseError(line, col, String.format("Field: %s declared in exclude specification of copier cannot also have an override or copier defined", fieldName));
					}
					
					Type got = (Type)asAssign.assignment.accept(this);
					if(!TypeCheckUtils.isValidType(got)) {
						this.raiseError(asAssign.assignment.getLine(), asAssign.assignment.getColumn(), String.format("Type: %s is not valid in copier", got));
					}
					
					
					if(fieldSpec.containsKey(fieldName)) {
						Sixple<String, Type, Boolean, AccessModifier, Boolean, String> spec = fieldSpec.get(fieldName);
						if(null == TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), spec.getB(), got)) {
							this.raiseError(asAssign.assignment.getLine(), asAssign.assignment.getColumn(), String.format("cannot assign value of type: %s to override field: %s of type: %s", got, fieldName, spec.getB()));
						}
						
					}else if(!unchecked) {
						this.raiseError(asAssign.assignment.getLine(), asAssign.assignment.getColumn(), String.format("attempting to override field: %s which does not exist", fieldName));
					}
					
				}
				else if(cei instanceof CopyExprIncOnly) {
					CopyExprIncOnly asceio = (CopyExprIncOnly)cei;
					String fname = asceio.incOnly;
					
					if(mustInclude.contains(fname)) {
						incdupes.add(fname);
					}else {
						mustInclude.add(fname);
					}
					
					if(!fieldSpec.containsKey(fname) && !unchecked) {
						this.raiseError(line, col, String.format("Field: %s declared in include specification of copier does not exist", fname));
					}
					
				}else if(cei instanceof CopyExprExclOnly) {
					
					if(exclAlready) {
						this.raiseError(line, col, "only one exclude specification may be included in a copier");
					}
					exclAlready=true;
					CopyExprExclOnly asceio = (CopyExprExclOnly)cei;

					HashSet<String> dupes = new HashSet<String>();
					for(String fname : asceio.excludeOnly) {
						if(mustExclude.contains(fname)) {
							dupes.add(fname);
						}else {
							mustExclude.add(fname);
						}
						
						if(!fieldSpec.containsKey(fname) && !unchecked) {
							this.raiseError(line, col, String.format("Field: %s declared in exclude specification of copier does not exist", fname));
						}
						
						if(overridenFeilds.contains(fname)) {
							this.raiseError(line, col, String.format("Field: %s declared in exclude specification of copier cannot also have an override or copier defined", fname));
						}
					}
					
					if(!dupes.isEmpty()) {
						this.raiseError(line, col, String.format("Duplicate field names: %s declared in exclude specification of copier", String.join(", ", dupes.stream().sorted().collect(Collectors.toList()) )));
					}
				}else if(cei instanceof CopyExprNested) {
					CopyExprNested asNested = (CopyExprNested)cei;
					String fname = asNested.fname;
					
					if(mustExclude.contains(fname)) {
						this.raiseError(line, col, String.format("Field: %s declared in exclude specification of copier cannot also have an override or copier defined", fname));
					}
					
					if(overridenFeilds.contains(fname)) {
						this.raiseError(line, col, String.format("field: %s may be copied only once in copier", fname));
					}else {
						overridenFeilds.add(fname);
					}
					
					if(!fieldSpec.containsKey(fname) && !unchecked) {
						this.raiseError(line, col, String.format("Field: %s with copier does not exist", fname));
					}else {
						Pair<Boolean, Boolean> uncheckedandNoDefaut = isUncheckedValid(asNested.line, asNested.col, asNested.modifiers);
						boolean uncheckedx = uncheckedandNoDefaut.getA();
						asNested.nodefault = uncheckedandNoDefaut.getB();
						
						asNested.incItems = processCopyExpressionItems(asNested.line, asNested.col, fieldSpec.get(fname).getB(), asNested.copyItems, uncheckedx);
					}
				}else if(cei instanceof CopyExprSuper) {
					CopyExprSuper asSuper = (CopyExprSuper)cei;
					
					/*
					 * if(thing.equals(ScopeAndTypeChecker.const_object)) { this.raiseError(line,
					 * col, "Only one super copier may be defined"); }
					 */
					
					if(alreadyHasSuperCopier) {
						this.raiseError(line, col, "Only one super copier may be defined");
					}
					alreadyHasSuperCopier=true;
					
					NamedType supType = asNamed.getResolvedSuperTypeAsNamed();
					
					if(supType == null && unchecked) {
						supType = ScopeAndTypeChecker.const_object;
					}
					
					if(supType != null) {
						Pair<Boolean, Boolean> uncheckedandNoDefaut = isUncheckedValid(asSuper.line, asSuper.col, asSuper.modifiers);
						boolean uncheckedx = uncheckedandNoDefaut.getA();
						asSuper.nodefault = uncheckedandNoDefaut.getB();
						
						asSuper.incItems = processCopyExpressionItems(asSuper.line, asSuper.col, supType, asSuper.copyItems, uncheckedx);
					}else {
						this.raiseError(line, col, String.format("Cannot apply copier to super type"));
					}
				}
			}
			
			if(!incdupes.isEmpty()) {
				this.raiseError(line, col, String.format("Duplicate field names: %s declared in include specification of copier", String.join(", ", incdupes.stream().sorted().collect(Collectors.toList()) )));
			}
			
			List<String> incAndExcl = mustExclude.stream().filter(mustInclude::contains).sorted().collect(Collectors.toList());
			if(!incAndExcl.isEmpty()) {
				this.raiseError(line, col, String.format("Fields in copier cannot be present for both inclusion and exclusion: %s", String.join(", ",  incAndExcl)));
			}
			
			return mustInclude.isEmpty() && !alreadyHasSuperCopier && !copyItems.isEmpty()? null:mustInclude;
		}else {
			this.raiseError(line, col, "copier specification can only be applied to object types");
		}
		return null;
	}
	
	private Pair<Boolean, Boolean> isUncheckedValid(int line, int col, List<String> modifiers) {
		boolean unchecked = false;
		boolean nodefaut = false;
		
		if(modifiers != null) {
			ArrayList<String> unknownkw = new ArrayList<String>(0); 
			for(String item : modifiers) {
				if(item.equals("unchecked")) {
					if(unchecked) {
						this.raiseError(line, col, "unchecked may not be repeated");
					}
					unchecked = true;
				}else if(item.equals("nodefault")) {
					if(nodefaut) {
						this.raiseError(line, col, "nodefault may not be repeated");
					}
					nodefaut = true;
				}
				else {
					unknownkw.add(item);
				}
			}
			
			if(!unknownkw.isEmpty()) {
				this.raiseError(line, col, "unknown keyword in copier: " + String.join(", ", unknownkw));
			}
		}
		
		return new Pair<Boolean, Boolean>(unchecked, nodefaut);
	}
	
	@Override
	public Object visit(CopyExpression copyExpression) {
		Type thing = (Type)copyExpression.expr.accept(this);
		//ensure that it's an object
		if(!(thing instanceof ModuleType)){// || thing instanceof FuncType){
			if(thing instanceof VarNull ||  ((thing instanceof PrimativeType && ((PrimativeType)thing).type != PrimativeTypeEnum.LAMBDA) ) && !thing.hasArrayLevels()){
				this.raiseError(copyExpression.getLine(), copyExpression.getColumn(), "Copies can only be made of Object types not: " + thing);
			}
			else{
				copyExpression.setTaggedType(thing);
				
				if(copyExpression.copyItems != null) {
					Pair<Boolean, Boolean> uncheckedandNoDefaut = isUncheckedValid(copyExpression.getLine(), copyExpression.getColumn(), copyExpression.modifiers);
					boolean unchecked = uncheckedandNoDefaut.getA();
					copyExpression.nodefault = uncheckedandNoDefaut.getB();
					copyExpression.copySpecMustInclude = processCopyExpressionItems(copyExpression.getLine(), copyExpression.getColumn(), thing, copyExpression.copyItems, unchecked);
				}
				
				
				if(thing instanceof NamedType) {
					NamedType asNamed = (NamedType)thing;
					if(ClassDef.classHasAnnotation(asNamed.getSetClassDef(), const_SharedStr, true)) {
						this.raiseError(copyExpression.getLine(), copyExpression.getColumn(), "Cannot copy object as its class or superclass has been marked shared");
					}
				}
				
			}
		}
		
		return thing;
	}
	
	
	private ClassDef findClassDef(Type from, String className)//from type: array or classdef
	{
		if(from instanceof NamedType)
		{//only classes can have nested classes
			return ((NamedType)from).getClassDef(className);
		}
		
		else if(from instanceof ModuleType)
		{
			ModuleType currentMod = (ModuleType)from;
			
			String dottedNameToResolve = currentMod.getNameSoFar() +"." + className;
			ClassDef ret = this.mainLoop.getClassDefFromPath(dottedNameToResolve, mc, false);
			return ret;
		}
		
		return null;
	}
	
	private ArrayList<ClassDef> revcurrIn()
	{
		int size = this.currentlyInClassDef.size();
		ArrayList<ClassDef> ret = new ArrayList<ClassDef>(size);
		for(int n=1; n <= size; n++)
		{
			ret.add(this.currentlyInClassDef.get(size-n));
		}
		return ret;
	}
	
	private ArrayList<FuncDefI> revcurrInFuncDef()
	{//TODO: inline this code as its only used below
		int size = this.currentlyInFuncDef.size();
		ArrayList<FuncDefI> ret = new ArrayList<FuncDefI>(size);
		for(int n=1; n <= size; n++)
		{
			ret.add(this.currentlyInFuncDef.get(size-n));
		}
		return ret;
	}
	
	
	private GenericType findgetGenericTypeDeclaration(String name)
	{
	
		
		if(this.currentlyInClassDef.isEmpty() && this.currentlyInFuncDef.isEmpty() && this.currentlyInFuncTypeDecl.isEmpty())
		{
			return null;
		}
		
		if(!this.currentlyInFuncTypeDecl.isEmpty()){
			int size = this.currentlyInFuncTypeDecl.size();
			GenericType asGen = new GenericType(name, 0);
			for(int n=1; n <= size; n++)
			{
				FuncType ft = this.currentlyInFuncTypeDecl.get(size-n);
				if(null != ft.getLocalGenerics() && !ft.getLocalGenerics().isEmpty()){
					if(ft.getLocalGenerics().contains(asGen)){//horray!
						return asGen;
					}
				}
			}
		}
		
		//first we search the local function generic map, since this overrides the class
		for(FuncDefI fd : revcurrInFuncDef()){
			HashMap<String, GenericType> getStringToGenerics = fd.getStringToGenerics();
			GenericType got = getStringToGenerics.get(name);
			if(got != null){
				return got;
			}
		}
		
		//now class may have it
		for(ClassDef cls : revcurrIn())//process from the top of the stack
		{
			GenericType got = cls.nameToGenericMap.get(name);
			if(got != null )
			{
				return got;
			}
			
		}
		
		return null;
	}
	
	@Override
	public ClassDef getImportedClassDef(String namereftoresolve) {
		return getImportedClassDef(namereftoresolve, false);
	}
	
	@Override
	public ClassDef getImportedClassDef(String namereftoresolve, boolean ingoreDotOp) {
		// TODO Auto-generated method stub
		
		if(namereftoresolve == null) {
			return null;
		}
		
		namereftoresolve = namereftoresolve.replaceAll(" ", "");
		
		ClassDef resolvedTo = null;
		
		if(namereftoresolve.equals("com.concurnas.lang.TypedActor")){//hack for when called on nested types
			resolvedTo = this.mainLoop.getClassDefFromPath(namereftoresolve, this.mc, false);
		}
		else{
			if(!ingoreDotOp && !dotOperatorLHS.isEmpty() && dotOperatorLHS.peek() != null)
			{//in dot op scope, e.g. a.b = 99
				resolvedTo = findClassDef(dotOperatorLHS.peek(), namereftoresolve);
			}
			else
			{//not in a dot operator,  e.g. a = 99
				//check locl scpes, but stop when u get to the class level, then check the class leve, then check the level above the class..
				//nested classes
				TheScopeFrame search = this.currentScopeFrame;
				while(search!=null)
				{//check 'local' scopes until we get to class level
					if(search.isClass())
					{//when u hit a class stop!
						break;
					}
					else
					{
						if(search.hasClassDef(this.currentScopeFrame, namereftoresolve, true, false))
						{
							return search.getClassDef(this.currentScopeFrame, namereftoresolve, true, false);
						}
					}
					search = search.getParent();
				}
				
				if(!this.currentlyInClassDef.isEmpty())
				{// now search nested class heirachy if any
					Object[] items = this.currentlyInClassDef.toArray();
					ClassDef[] classHeriarch = new ClassDef[items.length];
					for(int n = 0; n < items.length; n++ )
					{
						classHeriarch[n] = (ClassDef)items[n];
					}
					
					for(int n = classHeriarch.length; n>0; n--){
						ClassDef topCls = classHeriarch[n-1];
						if(topCls.hasClassDef(namereftoresolve) )
						{//class, superclass and also check parent scope...
							resolvedTo =  topCls.getClassDef(namereftoresolve);
							break;
						}/*else if(topCls.toString().equals(namereftoresolve)){
							resolvedTo = topCls;
							break;
						}*/
					}
				}
				if(resolvedTo == null)
				{
					while(search != null)
					{//now search globals
						if(!search.isClass())
						{
							//we've reached the top level
							if(search.hasClassDef(this.currentScopeFrame, namereftoresolve, true, false))
							{
								return search.getClassDef(this.currentScopeFrame, namereftoresolve, true, false);
							}
						}
						search = search.getParent();
					}
					
					namereftoresolve = importRemapBeforeSub(namereftoresolve);
					
					resolvedTo = this.mainLoop.getClassDefFromPath(namereftoresolve, this.mc, false);
				}
			}
		}
		
		typeDirectory.put(namereftoresolve, resolvedTo);
		
		return resolvedTo;
	}
	
	private String importRemapBeforeSub(String input)
	{
		int pos = input.indexOf('.');
		if(pos > -1)
		{
			String sube = input.substring(0, pos);
			if(hasImportBeenRegistered(sube))
			{//and finnaly search top level imports for the name
				sube = getImportBeenRegistered(sube);
			}
			
			input =  sube + input.substring(pos);
		}
		else if(hasImportBeenRegistered(input))
		{//and finnaly search top level imports for the name
			input = getImportBeenRegistered(input);
		}
		return input;
	}
	
	
	private ArrayList<Type> resolveGenericTypeQualifciation(int line, int col, ArrayList<Type> elements)
	{
		ArrayList<Type> resolvedTypes = new ArrayList<Type>();
		for(Type t : elements)
		{
			Type orig = t;
			String name = ""+t;
			this.dotOperatorLHS.push(null);
			this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
			if(t instanceof PrimativeType && !t.hasArrayLevels() ){
				switch(((PrimativeType)t).type){
					case INT: t = new NamedType( line, col, "Integer"); break;
					case BOOLEAN: t = new NamedType( line, col, "Boolean"); break;
					case LONG: t = new NamedType( line, col, "Long"); break;
					case FLOAT: t = new NamedType( line, col, "Float"); break;
					case DOUBLE: t = new NamedType( line, col, "Double"); break;
					case SHORT: t = new NamedType( line, col, "Short"); break;
					case BYTE: t = new NamedType( line, col, "Byte"); break;
					case CHAR: t = new NamedType( line, col, "Character"); break;
					case LAMBDA: t = new NamedType( line, col, "Lambda"); break;//com/concurnas/bootstrap/lang/Lambda
				}
			}
			if(null == t){
				this.dotOperatorLHS.pop();
				this.currentDotOperatorTracker.pop();
				continue;
			}
			
			t.setInOutGenModifier(orig.getInOutGenModifier());
			
			Type got = null;
			maskErrors(true);//mask errors because we report below if needs be
			got = (Type)t.accept(this);
			ArrayList<CapMaskedErrs> masterr = getmaskedErrors();
			this.dotOperatorLHS.pop();
			this.currentDotOperatorTracker.pop();
			if(null != got)
			{
				if(masterr != null && !masterr.isEmpty()){
					this.applyMaskedErrors(masterr);
				}
				
				resolvedTypes.add(got);
			}
			else
			{
				//maybe a nested superclass generic type reference which got qualified in subclass definition: class B[AAA] extends A[Z[AAA]]
				boolean gotMatch = false;
				
				if(!this.currentTypedefQaulifiers.isEmpty()){//if rhs of typedef statement
					HashMap<String, GenericType> topLevel = this.currentTypedefQaulifiers.peek();
					if(topLevel.containsKey(name)){
						t = topLevel.get(name);
						gotMatch = true;
					}
				}
				
				if(!gotMatch && this.currentScopeFrame.isClass())
				{
					ClassDef holdingClass = this.currentScopeFrame.getClassDef();
					for(GenericType maybematch : holdingClass.classGenricList)
					{
						if(maybematch.name.equals(name))
						{
							t = maybematch;
							gotMatch = true;
							break;
						}
					}
				}
				if(!gotMatch)
				{
					this.raiseError(line, col, String.format("Unable to resolve type corresponding to name: %s", name));
				}
				
				resolvedTypes.add(t);
			}
		}
		return resolvedTypes;
	}
	
	private Stack<Pair<List<Type>, ArrayList<Pair<String, Type>>>> inNamedConstructor = new Stack<Pair<List<Type>, ArrayList<Pair<String, Type>>>>();

/*	@Override
	public Object visit(RefNamedType refNamedType) {
		//note, MySomething[n].method() //MySomething[n] - could either be a method refernce, or a arrayref 
		//try this as a NamedType, if thats ok, great, otherwise try it as a arraydef - if that works then set it and proceed
		
		maskErrors();
		refNamedType.mynamed.accept(this);
		if(maskedErorrs()){
			
			if(refNamedType.astRedirectToArrayRef != null){//cool, just refer to previous mapping...
				return refNamedType.astRedirectToArrayRef.accept(this);
			}
			
			//it might not be a named, type so try as arradef
			PrintSourceVisitor psv = new PrintSourceVisitor();
			psv.visit(refNamedType);
			String strToTry = psv.toString();
			try{
				ArrayRef couldbe = Utils.parseArrayRefJustName(strToTry, "tryArrayRef", refNamedType.getLine());
				if(null != couldbe){
					//we have something, see if its refarray
					maskErrors();
					couldbe.accept(this);
					if(!maskedErorrs()){
						//ok it's an arrayref
						refNamedType.astRedirectToArrayRef = couldbe;
						return couldbe.accept(this);
					}
				}
			}
			catch(Exception e){
				//nope!
			}
			
		}
		else{//oh it parses to a namedtype now
			//clear out any previous redirects if any
			refNamedType.astRedirectToArrayRef = null;
		}
		
		//accept as normal
		return refNamedType.mynamed.accept(this);
	}*/
	
/*
	private void validateGenerics(ArrayList<Type> gens, int line, int col){//pointless
		for(Type gen : gens){
			if(gen instanceof PrimativeType && gen.getInOutGenModifier() != null){
				this.raiseError(line, col, "Generic types qualified with primative types may not be tagged as in our out");
			}
		}
	}*/
	
	@Override
	public Object visit(NamedType namedType) {
		String namereftoresolve = namedType.getNamedTypeStr();
		
		
		
		ArrayList<Type> gens = namedType.getGenericTypeElements();
				
		//validateGenerics(gens, namedType.getLine(), namedType.getColumn());
		
		//add preiouvs dot operator path
		if(!this.dotOperatorLHS.isEmpty() ){
			Type x = this.dotOperatorLHS.peek();
			if(x != null){
				namereftoresolve = x.getPrettyName() + "." + namereftoresolve;
			}
		}
		
		
		//Tuple<String, Integer> key = new Tuple<String, Integer>(namereftoresolve, gens.size());
		TypeDefTypeProvider typedefProvider = this.currentScopeFrame.getTypeDef(namereftoresolve);
		int gsize = gens.size();
		typedefProvider = typedefProvider==null?null:typedefProvider.hasArgs(gsize);
		
		if(null == typedefProvider){//imported?
			if(hasImportBeenRegistered(namereftoresolve)){//and finnaly search top level imports for the name
				namereftoresolve = getImportBeenRegistered(namereftoresolve);
			}
			
			typedefProvider = this.mainLoop.getTypeProviderFromPath(namereftoresolve, this.mc, false);
								
			typedefProvider = typedefProvider==null?null:typedefProvider.hasArgs(gsize);
		}
		
		if(null != typedefProvider){
			Thruple<Type, AccessModifier, String>  tpp = typedefProvider.qualifyType(gens);
			
			checkTypeDefAccessiable(namedType.getLine(), namedType.getColumn(), "typedef", tpp.getB(), tpp.getC());
			
			Type got = tpp.getA();//TypeCheckUtils.boxTypeIfPrimative(tpp.getA(), true);//int=>Integer
			
			if(namedType.getArrayLevelsRefOVerride() > 0){
				got = (Type)got.copy();
				got.setArrayLevels(got.getArrayLevels() + namedType.getArrayLevels());
			}else {
				got = (Type)got.copy();
			}
			got.setNullStatus(namedType.getNullStatus());
			
			if(got instanceof NamedType) {
				((NamedType)got).ignoreNonQualificationfGenerics=false;
			}

			got.setLine(namedType.getLine());
			got.setColumn(namedType.getColumn());
			
			
			if(namedType.astredirect != null && namedType.astredirect instanceof MultiType && got instanceof MultiType) {
				((MultiType)got).astOverride = ((MultiType)namedType.astredirect).astOverride;
			}
			
			Type ret = null;
			boolean visitAlready=false;
			if(namedType.astredirect != null && namedType.astredirect  instanceof NamedType && got instanceof NamedType) {
				NamedType astRDNT = (NamedType)namedType.astredirect;
				NamedType gotNT = (NamedType)got;
				
				ClassDef cd = astRDNT.getSetClassDef();
				
				if(cd != null) {
					ArrayList<GenericType> expectedGens = cd.getClassGenricList();
					if(!expectedGens.isEmpty()) {
						ArrayList<Type> currentlySetGenerics = astRDNT.getGenericTypeElements();
						if(currentlySetGenerics.size() == expectedGens.size()) {
							
							this.maskErrors();
							Stack<Type> prevLHS = this.dotOperatorLHS;
							try{
								this.dotOperatorLHS = new Stack<Type>();
								ret = (Type)got.accept(this);
								visitAlready = true;
							}
							finally{
								this.dotOperatorLHS=prevLHS;
							}
							this.maskedErrors();
							
							if(cd.equals(gotNT.getSetClassDef())){
								if(gotNT.getGenericTypeElements().isEmpty()) {
									got = namedType.astredirect;//nullify, sitck with old version
									visitAlready = false;
								}
							}
						}
					}
				}
			}
			
			namedType.astredirect = got;
			
			if(!visitAlready) {
				Stack<Type> prevLHS = this.dotOperatorLHS;
				try{
					this.dotOperatorLHS = new Stack<Type>();
					ret = (Type)namedType.astredirect.accept(this);
				}
				finally{
					this.dotOperatorLHS=prevLHS;
				}
			}
			
			
			
			
			return namedType.setTaggedType(ret);
		}

		// typedefs.peek().put(name, got);
		Type got = (Type)visit(namedType, false);
		
		if(got != null && !namedType.ignorePPPCheck){
			checkTypeDefAccessiableNT(namedType, namedType.getLine(), namedType.getLine());
		}
		
		return got;
	}
	
	private void checkTypeDefAccessiable(int line, int col, String thing, AccessModifier am, String location){
		String here = this.justPackageName;//String.join(".", this.packageName);
		
		
		if(am == AccessModifier.PRIVATE && !here.startsWith(location)){
			this.raiseError(line, col, String.format("%s has been marked private", thing));
		}
		else if(am == AccessModifier.PROTECTED && !startswithPackage(here, location)){
			this.raiseError(line, col, String.format("%s has been marked protected", thing));
		}
		else if(am == AccessModifier.PACKAGE && !samePackage(here, location)){
			this.raiseError(line, col, String.format("%s has been marked package", thing));
		}
	}
	
	private boolean samePackage(String currentPackage, String definedPackage){
		
		if(currentPackage.contains("$")){
			currentPackage = currentPackage.substring(0, currentPackage.indexOf('$'));
		}
		
		currentPackage = currentPackage.contains(".")?currentPackage.substring(0, currentPackage.lastIndexOf('.')):currentPackage;
		definedPackage = definedPackage.contains(".")?definedPackage.substring(0, definedPackage.lastIndexOf('.')):definedPackage;
		return currentPackage.equals(definedPackage);
	}
	
	private boolean startswithPackage(String currentPackage, String definedPackage){
		currentPackage = currentPackage.contains(".")?currentPackage.substring(0, currentPackage.lastIndexOf('.')):currentPackage;
		definedPackage = definedPackage.contains(".")?definedPackage.substring(0, definedPackage.lastIndexOf('.')):definedPackage;
		return currentPackage.startsWith(definedPackage);
	}
	
	
		
	public Object visit(NamedType namedType, boolean ignoreGenericTypeCheck) {
		String namereftoresolve = namedType.getNamedTypeStr();
			
		NamedType upperBound = namedType.getOrigonalGenericTypeUpperBound();
		if(null != upperBound){
			upperBound.accept(this);
		}
		
		namedType.printNameInBytecodeRepresentation = false;
		//check gentypes - resolve as approeriate, e.g. call setclass etc
		ArrayList<Type> resolvedTypes = resolveGenericTypeQualifciation(namedType.getLine(), namedType.getColumn(), namedType.getGenericTypeElements());
		namedType.setGenTypes(resolvedTypes);//TODO: for cases where the type is qualified, at classdef level, we need to ensre that this is respected. i.e. class MyClass[X :< List](); item = new MyClass[String](); (also for the nestor case below...)
		
		ClassDef resolvedTo = namedType.getSetClassDef();
		if(null == resolvedTo){
			resolvedTo = getImportedClassDef(namereftoresolve);
			//namedType.namedType = resolvedTo.toString();
		}
		
		if(null != resolvedTo){
			ClassDef setAlready = namedType.getSetClassDef();
			if(null != setAlready && !setAlready.equals(resolvedTo)){//strange, prehaps we have overriden the definition which was prevoiuly imported and on the previons
				//generic argument binding we did it incorrectly, in this case we re-set the generic types to what they were origonally, prior to inference
				if(null != namedType.origGenericBinding){
					namedType.fromClassGenericToQualifiedType = new HashMap<GenericType, Type>();
					namedType.setGenTypes(new ArrayList<Type>(namedType.origGenericBinding));
				}
			}
			
			//isNamedTypeAccessable(new NamedType(namedType.getLine(), namedType.getColumn(), resolvedTo), true);
		}
		
		
		if(null != resolvedTo && UncallableMethods.UNAVAILABLE_CLASSES.contains(resolvedTo)&& !namedType.okToReferenceEvenIfUncreatable && !namedType.getIsLHSClass())
		{//null check needed?
			this.raiseError(namedType.getLine(), namedType.getColumn(), String.format("Instances of %s cannot be created", resolvedTo));
		}
		
		if(null == resolvedTo){
			GenericType foundGenType = findgetGenericTypeDeclaration(namereftoresolve);
			if( foundGenType != null  )
			{
				if(namedType.getGenTypes() != null && !namedType.getGenTypes().isEmpty() )
				{//public class A<X, L> extends ArrayList<X<L>> this is not allowed
					this.raiseError(namedType.getLine(), namedType.getColumn(), "Generic type refernces cannot have generic qualifications themselves");
					return null;
				}
				else
				{
					GenericType retGen = (GenericType)foundGenType.clone();
					retGen.setArrayLevels(namedType.getArrayLevels());
					retGen.accept(this);
					if(retGen.getNullStatus() != NullStatus.NULLABLE) {//once its null its staying null!
						retGen.setNullStatus(namedType.getNullStatus());
					}
					
					//namedType.setOrigonalGenericTypeUpperBound(((GenericType)foundGenType).upperBound.copyTypeSpecific());
					return retGen;
				}
			}
			else// if(!namedType.unresolveableLocalType)
			{
				/*it could be an actor on a nested type...
					out = new Outer<int>()
					rawActor = out.actor Inner<double>() <- actor on Inner
				*/
				ClassDef resolvedTox = getImportedClassDef(namereftoresolve, true);
				if(null != resolvedTox){
					NamedType namedTypex = namedType.copyTypeSpecific();
					namedTypex.setClassDef(resolvedTox);
					
					if(TypeCheckUtils.isTypedActor(this, namedTypex)){//its creating an actor
						namedTypex = TypeCheckUtils.extractRootActor(namedTypex);
						Type genOne = namedTypex.getGenTypes().get(0);
						if(genOne instanceof NamedType){
							NamedType asNamed= (NamedType)genOne;
							ClassDef cls = asNamed.getSetClassDef();
							if(cls != null){
								if(cls.isNestedAndNonStatic()){
									//finally, we have determined that the actor is acting on a nested inner class, so we are allowed to import the 
									//getImportedClassDef by bypassing the dot operater on the left hand side. 
									resolvedTo = resolvedTox;
								}
							}
						}
					}
				}
				
				if(null == resolvedTo){
					
					if(/*resolvedTypes.isEmpty() &&*/ !currentlyInTypedefStatement.isEmpty()){
						if(currentlyInTypedefStatement.peek().typedefargs.contains(namereftoresolve)){
							namedType.printNameInBytecodeRepresentation = true;
							return namedType;
						}
					}
					
					
					this.raiseError(namedType.getLine(), namedType.getColumn(), "Unable to resolve type corresponding to name: " + namereftoresolve);
					return null;//must return null else everything breaks lol
				}
			}
		}


		if(null != resolvedTo)
		{

			if(resolvedTo.equals(const_typed_actor_class)  && !this.dotOperatorLHS.isEmpty()){
				//if we are doing this: out.actor Inner<double>() - then we need to go into the definition of namedType and tweak the types of the parent nestor as these got lost previously
				Type potentialParent = this.dotOperatorLHS.peek();
				if(potentialParent instanceof NamedType)
				{
					NamedType nestorLHSDot = (NamedType)potentialParent;
					HashMap<GenericType, Type> parentNestorQualified = nestorLHSDot.getFromClassGenericToQualifiedType();
					
					if(!namedType.getGenTypes().isEmpty()){
						Type got = namedType.getGenTypes().get(0);
						if(null != got){
							((NamedType)got).augmentfromClassGenericToQualifiedType(parentNestorQualified);
						}
					}
				}
			}
			
			
			List<GenericType> requiredGens = resolvedTo.getClassGenricList();
			
			
			if(namedType.expectedToBeAbstractTypedActor){
				if(!(resolvedTo.getIsAbstract() && TypeCheckUtils.isTypedActor(this, namedType))){
					this.raiseError(namedType.getLine(), namedType.getColumn(), String.format("expected abstract typed actor not class: %s", resolvedTo));
					ignoreGenericTypeCheck=true;//already error above
				}
			}
			
			int requiredGensCnt = requiredGens.size();
			int declGenericTypes = namedType.getGenericTypeElements().size();
			String noraw=null;
			if (requiredGensCnt>0 && !ignoreGenericTypeCheck){
				namedType.requiresGenTypeInference = false;
				boolean inferedArgs = false;
				if((namedType.errorOnPrevoiusGenTypeQualification || declGenericTypes==0) && null != inNamedConstructor && !inNamedConstructor.isEmpty() && null != inNamedConstructor.peek() && ((inNamedConstructor.peek().getA() != null &&  !inNamedConstructor.peek().getA().isEmpty()) || (inNamedConstructor.peek().getB() != null &&  !inNamedConstructor.peek().getB().isEmpty()) )){
					//infer generic types type from types of args passed, i.e. new MyClass("") -> MyClass[String]
					//this fails still of course aaa = MyClass()//if there is a zero arg constructor
					inferedArgs=true;
					if(namedType.errorOnPrevoiusGenTypeQualification){//reset qualification
						namedType.setGenTypes(new ArrayList<Type>(0));
						namedType.fromClassGenericToQualifiedType = new HashMap<GenericType, Type>();
					}
					
					
					ArrayList<Type> argsWanted = new ArrayList<Type>(inNamedConstructor.peek().getA());
					ArrayList<Pair<String, Type>> namessMap = inNamedConstructor.peek().getB();
					
					if(TypeCheckUtils.isActor(this.getErrorRaiseableSupression(), namedType)){
						argsWanted.add(0, ScopeAndTypeChecker.const_classArray_nt_array);
					}
					
					namedType.setClassDef(resolvedTo);//early to support  getConstructor call below which caters for namesMap
					//Set<FuncType> accessaleConstrucotrs = getLocallyAccessableConstructors(namedType, resolvedTo.getConstructor(argsWanted.size(), (ErrorRaiseableSupressErrors)errorRaisableSupression));
					Set<FuncType> accessaleConstrucotrs = namedType.getConstructor(namedType.getLine(), namedType.getColumn(), argsWanted, namessMap, (ErrorRaiseableSupressErrors)ers, this);
					
					//filter to those consturctors setting all the generic types, rank from those having the fewest missing qualifications (partial qualification is acceptable, e.g. class with X and Y generics buy calling constructor this(x x) - Y shows error but we dont corrupt what X should be)
					HashMap<Integer, Set<FuncType>> missingQualiGenCountTomatchingFuncNames = new HashMap<Integer, Set<FuncType>>();
					Map<FuncType, Map<Type, Type>> funcTypeToGens=new HashMap<FuncType, Map<Type, Type>>();
					
					for( FuncType mostSpec : accessaleConstrucotrs ){
						List<Type> argsIncNamed = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, mostSpec, argsWanted, namessMap, 0, true, false);
						
						Map<Type, Type> fromGenToThing = TypeCheckUtils.attemptGenericBinding(this.getErrorRaiseableSupression(), mostSpec.inputs, argsIncNamed);
						
						ArrayList<GenericType> searchingFor = new ArrayList<GenericType>(requiredGens); 
						for(Type inpu : fromGenToThing.keySet()){
							searchingFor.remove((GenericType)inpu);
						}
						int mssingCnt = searchingFor.size();
						if(mssingCnt < requiredGens.size()){//if match some/all of the generic elements... (we dont have to match all of them, herer we rank the ones with the fewest entries) - slightly OTT datastructure but its ok
							//JPT: slighly over the top for what this does e.g. could use a counter and a check to see if coverage is better in which case choose that instances etc
							Set<FuncType> forS;
							if(missingQualiGenCountTomatchingFuncNames.containsKey(mssingCnt)){
								forS = missingQualiGenCountTomatchingFuncNames.get(mssingCnt);
							}else{
								forS = new HashSet<FuncType>();
								missingQualiGenCountTomatchingFuncNames.put(mssingCnt, forS);
							}
							
							forS.add(mostSpec);
							funcTypeToGens.put(mostSpec, fromGenToThing);
						}
					}
					
					//choose longest matchingFuncNames hitting the generics
					Set<FuncType> matchingFuncNames = new HashSet<FuncType>(0);
					if(!missingQualiGenCountTomatchingFuncNames.isEmpty()){
						for(int n=0; n < requiredGens.size(); n++){
							if(missingQualiGenCountTomatchingFuncNames.containsKey(n)){
								matchingFuncNames = missingQualiGenCountTomatchingFuncNames.get(n);
								break;
							}
						}
					}
					
					
					FuncType mostSpec;
					if(matchingFuncNames.isEmpty()){
						noraw = " - generic type parameters must be defined";
						mostSpec=null;
					}
					else if(matchingFuncNames.size() > 1){
						//maybe one of them is more precise than the other....
						mostSpec = TypeCheckUtils.getMostSpecificFunctionForChoicesFT( this.getErrorRaiseableSupression(), ers, matchingFuncNames, argsWanted, namessMap, "", 0, 0, false, this, false).getA();
						if(null == mostSpec){//nope ambigious
							noraw = " - generic type parameters must be defined - it is not possible to infer generic parameters as is more than one matching constructor";
						}
					}
					else{
						mostSpec = matchingFuncNames.iterator().next();
					}
					
					if(null != mostSpec){//just one
						Map<Type, Type> fromGenToThing = funcTypeToGens.get(mostSpec);
						ArrayList<Type> qualiGens = new ArrayList<Type>(resolvedTo.classGenricList.size());
						
						ArrayList<GenericType> missingGens = new  ArrayList<GenericType>(0);
						
						for(GenericType clsGen : resolvedTo.classGenricList){
							if(fromGenToThing.containsKey(clsGen)){
								qualiGens.add(fromGenToThing.get(clsGen));
							}else{
								qualiGens.add(clsGen.getUpperBoundAsNamedType());
								missingGens.add(clsGen);
							}
							
						}
						
						if(!missingGens.isEmpty()){
							ArrayList<Type> quialified = new ArrayList<Type>(resolvedTo.classGenricList);
							quialified.removeAll(missingGens);
							noraw = String.format(" - Generic qualification inferred from called consturctor for: %s but not %s", Utils.listToStringAny(quialified) , Utils.listToStringAny(missingGens) );
							
							int sz = resolvedTo.classGenricList.size();
							qualiGens = new ArrayList<Type>();
							for(int n=0; n < sz; n++) {
								qualiGens.add(resolvedTo.classGenricList.get(n).getUpperBoundAsNamedType());
							}
							//set all to upper bound
							//qualiGens
							
							
						}
						
						namedType.errorOnPrevoiusGenTypeQualification=noraw != null;//error if not null
						
						namedType.setGenTypesInfered(qualiGens);
						//namedType.forcedConstructorDueToGenTypeInference = (FuncType)GenericTypeUtils.mapFuncTypeGenericsToOtherGenerics(mostSpec, fromGenToThing, false);//only one that supports binding
					}
					
				}
				else if(declGenericTypes != requiredGens.size()){
					noraw = "";
					if(namedType.getGenericTypeElements().size() == 0) { noraw = " - generic type parameters must be defined"; }
					
					if(requiredGens.size() - declGenericTypes == 1){
						if(!namedType.expectedToBeAbstractTypedActor){
							if(resolvedTo.getIsAbstract() && TypeCheckUtils.isTypedActor(this, namedType)){//its an abstract typed actor
								//e.g. o is AbstractActor<String>
								this.raiseError(namedType.getLine(), namedType.getColumn(), "abstract typed must use of qualification");
								noraw=null;
							}
						}
					}				
				}
				
				if(null != noraw && !namedType.getIsLHSClass() && !namedType.ignoreNonQualificationfGenerics){
					//this is not relevant in cases where we are doing XYZ.class
					this.raiseError(namedType.getLine(), namedType.getColumn(), String.format("Generic parameter count of: %s does not equal: %s%s", namedType.getGenericTypeElements().size() , requiredGens.size(), noraw ));
					namedType.requiresGenTypeInference = true;
					this.attemptGenTypeInference=true;
				}else if(!inferedArgs && requiredGensCnt == resolvedTypes.size()) {
					
					boolean pass = true;
					boolean nullableMismatch = false;
					for(int n = 0; n < requiredGensCnt; n++) {
						GenericType wanted = requiredGens.get(n);
						NamedType compWanted = wanted.upperBound;
						Type got = resolvedTypes.get(n);
						
						
						if(got instanceof GenericType && ((GenericType)got).isWildcard ) {
							//this is ok: any MyList<?> = g
							((GenericType)got).upperBound = compWanted.copyTypeSpecific();
							NamedType resolved = compWanted.copyTypeSpecific();
							resolved.fromisWildCardAny = true;
							resolvedTypes.set(n, resolved);
						}else if(!ScopeAndTypeChecker.const_object.equals(compWanted) && null == TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(),compWanted, got)) {
							pass = false;
							break;
						}
						
						if(pass) {
							NullStatus wantedStatus = wanted.getNullStatus();
							if(wantedStatus != NullStatus.UNKNOWN && got.getNullStatus() != NullStatus.UNKNOWN) {
								if(got.getNullStatus() != wantedStatus) {
									pass = false;
									nullableMismatch = true;
									break;
								}
							}
						}
					}
					
					if(!pass) {
						String msg = String.format("Generic parameter qualifcation mismatch: '%s' cannot be qualified with: '%s'", 
								String.join(", ", requiredGens.stream().map(a -> "" + a).collect(Collectors.toList())), 
								String.join(", ", resolvedTypes.stream().map(a -> "" + a).collect(Collectors.toList())));
						
						if(nullableMismatch) {
							msg += " - nullability mismatch";
						}
						
						this.raiseError(namedType.getLine(), namedType.getColumn(), msg);
					}
				}
				
				//TODO: actuall check bounds, x extends Object etc
				//special error for typed actors
			}
			else if(declGenericTypes > 0 && !ignoreGenericTypeCheck){
				this.raiseError(namedType.getLine(), namedType.getColumn(), String.format("Generic parameter count of: %s does not equal: %s", namedType.getGenericTypeElements().size() , requiredGens.size() ));
			}
			
			namedType.setClassDef(resolvedTo);
			

			//isNamedTypeAccessable(namedType, true);
			
			
			HashMap<String, ClassDef> nestorsFilledIn = new HashMap<String, ClassDef>();
			
			//e.g. from MyClass<String> => Parent<Object>.MyClass<String>
			ClassDef missingSegment = resolvedTo==null?null:resolvedTo.getParentNestor();
			while(null != missingSegment)
			{
				String maybeMissing = missingSegment.className;
				if(namedType.nestorSegments.isEmpty() || !namedType.hasNestorSegment(maybeMissing))
				{//missing, this will be a problem so now need to fill it in
					ClassDef inHerirachyQualifciaiton = searchUpWardsForNestedClass(maybeMissing);
					if(null != inHerirachyQualifciaiton)
					{
						namedType.nestorSegments.add(new Pair<String, ArrayList<Type>>(maybeMissing, (ArrayList<Type>)(Object)inHerirachyQualifciaiton.classGenricList) );
						nestorsFilledIn.put(maybeMissing, inHerirachyQualifciaiton);
					}
				}
				
				missingSegment = missingSegment.getParentNestor();
			}
			
			
			HashSet<String> qualifiedNestedParents = new HashSet<String>();
			if(!namedType.nestorSegments.isEmpty())
			{//e.g. boy Child[String].Boy[Float] = (new Child[String]() ).new Boy[Float]();
				for(Pair<String, ArrayList<Type>> nestorSeg : namedType.nestorSegments )
				{
					String nestorName = nestorSeg.getA();
					ArrayList<Type> parentgenericTypeElementsQualifcation = nestorSeg.getB();
					ClassDef nestorNameClassDef = getImportedClassDef(nestorName);
					
					if(null == nestorNameClassDef)
					{//maybe we already hacked up up previously...
						nestorNameClassDef = nestorsFilledIn.get(nestorName);
					}
					
					if(null == nestorNameClassDef && !this.dotOperatorLHS.isEmpty())
					{
						Type toplhsDot = this.dotOperatorLHS.peek();
						if(toplhsDot instanceof NamedType)
						{//return this.new Child[String]("arg", arg)
							nestorNameClassDef = ((NamedType)toplhsDot).getSetClassDef();
						}
					}
					
					if(null == nestorNameClassDef)
					{//still missing! how?
						this.raiseError(namedType.getLine(), namedType.getColumn(), String.format("Nested inner class: %s parent cannot be found: %s", namedType,  nestorName ));
					}
					else
					{
						qualifiedNestedParents.add(nestorNameClassDef.toString());//JPT: can nestorNameClassDef be null?
						
						if(parentgenericTypeElementsQualifcation.size() != nestorNameClassDef.getClassGenricList().size())
						{//TODO: actuall check bounds
							this.raiseError(namedType.getLine(), namedType.getColumn(), String.format("Nested inner class parent generic parameter count of: %s does not equal: %s", parentgenericTypeElementsQualifcation.size() , nestorNameClassDef.getClassGenricList().size() ));
						}
						else
						{
							ArrayList<Type> nestorResolvedClasses = resolveGenericTypeQualifciation(namedType.getLine(), namedType.getColumn(), parentgenericTypeElementsQualifcation);

							//JPT: do we need a check here to ensure we're not overriding generic parameters that have already been defined?
							HashMap<GenericType, Type> nestorAugment = new HashMap<GenericType, Type>();
							ArrayList<GenericType> clsGens = nestorNameClassDef.getClassGenricList();
							
							int sz = nestorResolvedClasses.size();
							for(int n = 0; n < sz; n++)
							{
								nestorAugment.put(clsGens.get(n), nestorResolvedClasses.get(n) );
							}
							
							namedType.augmentfromClassGenericToQualifiedType(nestorAugment);
						}
					}
					
				}
			}
			
			if(this.dotOperatorLHS.isEmpty())
			{//note that we don't use this logic for cases like this:(new Child[String]() ).new Boy[Float](); - as the generic type has already been defined in the parent
				ClassDef parentNestor = resolvedTo==null?null:resolvedTo.getParentNestor();
				while(null != parentNestor)//we're expecting a parent nestor qualification
				{//check that parent types have been qualified in the definition 
					String clsName = parentNestor.toString();
					int reqQual = parentNestor.getClassGenricList().size();
					if(reqQual>0 && !qualifiedNestedParents.contains(clsName) )
					{
						this.raiseError(namedType.getLine(), namedType.getColumn(), String.format("Nested inner class parent: %s for: %s requies %s generic paramaters", clsName, resolvedTo, reqQual));
					}
					parentNestor = parentNestor.getParentNestor();
				}
			}
			else
			{
				Type potentialParent = this.dotOperatorLHS.peek();
				if(potentialParent instanceof NamedType)
				{
					NamedType nestorLHSDot = (NamedType)potentialParent;
					HashMap<GenericType, Type> parentNestorQualified = nestorLHSDot.getFromClassGenericToQualifiedType();
					namedType.augmentfromClassGenericToQualifiedType(parentNestorQualified);
				}
				
				if(null != potentialParent && potentialParent.hasArrayLevels()) {
					this.raiseError(namedType.getLine(), namedType.getColumn(), String.format("Cannot instantiate type from class parent array of class: " + potentialParent));
				} 
			}
			
			ClassDef setCls = namedType.getSetClassDef();
			if(null != setCls)
			{
				String clsNambola = setCls.getPrettyName().replace('$', '.');
				if(UncallableMethods.isLambda(clsNambola))
				{
					List<Type> gens = namedType.getGenTypes();
					FuncType retft;
					if(!gens.isEmpty())//how could it be empty?
					{
						boolean retVoid = namedType.getSetClassDef().getClassName().endsWith("v");
						
						Type retty =  retVoid?(Type)ScopeAndTypeChecker.const_void.copy():gens.get(gens.size()-1);
						ArrayList<Type> inputs = new ArrayList<Type>(gens.size()-1);
						for(int n = 0; n < gens.size() - (retVoid?0:1); n++)
						{
							Type toAdd = gens.get(n);
							if(toAdd instanceof NamedType && ((NamedType)toAdd).toString().equals("java.lang.Void") )
							{
								this.raiseError(namedType.getLine(), namedType.getColumn(), String.format("Void is not a valid input type"));
							}
							inputs.add(toAdd);
						}
						
						retft = new FuncType(inputs, retty);
					}else {//must return void
						retft = new FuncType((Type)ScopeAndTypeChecker.const_void.copy());
					}

					tagLambdaDetails(retft);
					retft.setNullStatus(namedType.getNullStatus());
					return retft;
					
				}
				
				//isNamedTypeAccessable(namedType, true);
			}
			return namedType;
		}
		return null;
	}
	
	public boolean attemptGenTypeInference = false;
	
	public boolean isNamedTypeAccessable(NamedType namedType, boolean raiseError){
		ClassDef resolvedTo = namedType.getSetClassDef();
		if(null == resolvedTo){
			return true;//JPT: null - > err reported elsewhere
		}
		AccessModifier am = resolvedTo.accessModifier;
		if(am != AccessModifier.PUBLIC && !namedType.isCalledInConsructor){
			//only referenced if the thing is on a lower or equals nesting level
			
			//ignore check if we are invoking a constructor
			
			ClassDef parNest = resolvedTo.getParentNestor();
			if(null != parNest ){//nested class, therefore we must reside within the same nestor
				if(am == AccessModifier.PROTECTED){
					if(this.currentlyInClassDef.isEmpty() || null==this.currentlyInClassDef.peek().isParentNestorEQOrSUperClass(parNest)){
						//but this is ok: class X{ private class P{} private class P2{ P a = null;} //<- this is alright!
						if(raiseError){this.raiseError(namedType.getLine(), namedType.getColumn(), String.format("Protected nested class: %s is not visible", resolvedTo.className));}
						return false;
					}
				}
				else{
					if(this.currentlyInClassDef.isEmpty() || !this.currentlyInClassDef.peek().isParentNestorOrEQ(parNest)){
						//but this is ok: class X{ private class P{} private class P2{ P a = null;} //<- this is alright!
						if(raiseError){this.raiseError(namedType.getLine(), namedType.getColumn(), String.format("Private nested class: %s is not visible", resolvedTo.className));}
						return false;
					}
				}
			}
		}
		return true;
	}
	
	private ClassDef searchUpWardsForNestedClass(String name)
	{
		for(int n= this.currentlyInClassDef.size()-1; n >= 0; n--)
		{
			ClassDef potential = this.currentlyInClassDef.get(n);
			if(potential.className.equals(name))
			{
				return potential;
			}
		}
		return null;
	}


/*	@Override
	public Object visit(IfExpr ifExpr) {
		//Object a= 1==1 ? new String()  : new Object();
		int line = ifExpr.test.getLine();
		int col = ifExpr.test.getColumn();
		
		asisOverwriteType.push(new HashMap<String, Type>());
		autoCastSetterUpper.doSetup(ifExpr.test);
		TypeCheckUtils.assertNotVoid((Type)ifExpr.test.accept(this), this, ifExpr.test.getLine(), ifExpr.test.getColumn(), "if");
		
		if(!TypeCheckUtils.isBoolean(null, (Type)ifExpr.test.accept(this), line, col))
		{
			//this.raiseError(ifExpr.test.getLine(), ifExpr.test.getColumn(), String.format("Condition expression must resolve to a boolean"));
			//return null;
			//ifExpr.testOnObject = true;
		}
		
		List<Type> stuff = new ArrayList<Type>(2);
		Map<Type, Tuple<Integer, Integer>> offenders = new HashMap<Type, Tuple<Integer, Integer>>();
		
		asisOverwriteType.push(null);
		Type one = (Type)ifExpr.op1.accept(this);
		asisOverwriteType.pop();
		asisOverwriteType.pop();
		Type two = (Type)ifExpr.op2.accept(this);
		stuff.add(one);
		offenders.put(one, new Tuple<Integer, Integer>( line, col));
		stuff.add(two);
		offenders.put(two, new Tuple<Integer, Integer>( line, col));
		
		Type got = TypeCheckUtils.getMoreGeneric(this, this,  line, col, stuff, offenders);
		ifExpr.setTaggedType(got);
		
		TypeCheckUtils.assertAllSubtypeIfUnrefNeeded(this,  line, col, got, offenders);
		
		return got;
	}*/


	private String gettCurrentClassOwner()
	{
		return this.currentlyInClassDef.peek().bcFullName();
	}
	
	private boolean forceLocalScope = false;//e.g. when at module level for (nohoh=9;nohoh++<10;) {}//nohoh - creation is forec to local scope
	
	/*private TypeAndLocation createTypeAndLocationVarHolder(int line, int col, Type input, boolean isFinal, AccessModifier am, boolean isTransient)
	{
		return createTypeAndLocationVarHolder( line,  col,  input, isFinal,  am, false, isTransient);
	}*/
	
	private TypeAndLocation createTypeAndLocationVarHolder(int line, int col, Type input, boolean isFinal, AccessModifier am, boolean enumValue, boolean isTransient, boolean isShared, boolean localClassImportedField, boolean assignedOncreation, boolean isOverride, boolean isInjected)
	{
		if(input==null)
		{
			return null;
		}
		//localvar, staticfield or classfield
		final Location loc;
		if(enumValue )		{
			loc = new LocationStaticField(gettCurrentClassOwner(), input, true);
		}
		else if( (this.currentScopeFrame.paThisIsModule && !forceLocalScope))		{
			loc = new LocationStaticField(getFullModuleAndClassName(), input);
		}
		else if(this.currentScopeFrame.isClass())
		{
			loc = new LocationClassField(gettCurrentClassOwner(), new NamedType(line, col, this.currentlyInClassDef.peek()), false, assignedOncreation, isOverride);
		}
		else
		{
			loc = new LocationLocalVar(this.currentScopeFrame);
		}
		
		Type ftLambdaMaybe = input;
		
		if(TypeCheckUtils.hasRefLevels(ftLambdaMaybe)){
			ftLambdaMaybe=TypeCheckUtils.getRefType(ftLambdaMaybe);
		}
		
		if(ftLambdaMaybe instanceof FuncType && ((FuncType)ftLambdaMaybe).getLambdaDetails() != null)
		{
			loc.setLambda(true);
			loc.setLambdaOwner(((FuncLocation)((FuncType)ftLambdaMaybe).getLambdaDetails().getLocation()).getLambdaOwner());
		}
		
		if(isFinal){
			loc.setFinal(isFinal);
		}
		
		loc.setAccessModifier(am);
		
		if(isTransient){
			loc.setTransient(isTransient);
		}
		
		if(isShared){
			loc.setShared(isShared);
		}
		
		if(TypeCheckUtils.hasRefLevelsAndIsLocked(input)){
			NamedType asNamed = ((NamedType)input).copyTypeSpecific();
			asNamed.setLockedAsRef(false);
			input = asNamed;
		}
		
		if(localClassImportedField){//e.g. b=99; class Me{ def stuff() = b+1 };//b 'imported' from outside
			loc.localClassImportedField = localClassImportedField;
		}
		
		loc.isInjected = isInjected;
		
		return new TypeAndLocation(input, loc);
		
	}
	
	private TypeAndLocation createTypeAndLocationFuncHolder(int line, int col, FuncType input, boolean isNestedFunction)
	{
		return createTypeAndLocationFuncHolder( line,  col,  input,  isNestedFunction, false);
	}
	
	private TypeAndLocation createTypeAndLocationFuncHolder(int line, int col, FuncType input, boolean isNestedFunction, boolean isStaticMethod)
	{//TODO: this is wrong
		if (input == null) {
			return null;
		}
		
		final Location loc;
		
		if(isStaticMethod){
			//loc = new StaticFuncLocation(new NamedType(line, col, this.currentlyInClassDef.peek()));
			loc = new StaticFuncLocation(new NamedType(line, col, getfullClassName()));
		}
		else if(this.currentScopeFrame.paThisIsModule)
		{
			loc = new StaticFuncLocation(new NamedType(line, col, input.origin));//only at module level so no $...
		}
		else if(this.currentScopeFrame.isClass() || (isNestedFunction && !this.currentlyInClassDef.isEmpty()) )
		{
			String owner = gettCurrentClassOwner();
			
			loc = new ClassFunctionLocation(owner, new NamedType(line, col, this.currentlyInClassDef.peek()));
		}
		else
		{
			loc = new StaticFuncLocation(new NamedType(line, col, input.origin));//only at module level so no $...
		}
		
		return new TypeAndLocation(input, loc);
	}
	
	private Pair<Boolean, Type> resolvestoMultiArg(Type thing){
		if(thing instanceof MultiType) {
			((MultiType)thing).isValidAtThisLocation=true;
		}
		
		this.maskErrors();
		Type resTo = thing==null?null:(Type)thing.accept(this);
		boolean errs = this.maskedErrors();
		
		if(!(resTo instanceof MultiType)){
			resTo = null;
		}
		
		return new Pair<Boolean, Type>( errs, resTo);
	}
	
	private static class MutitypesInsideFunctionBodyFinder extends AbstractVisitor{
		public ArrayList<MultiType> found;
		
		public ArrayList<MultiType> find(Block fd){
			found = new ArrayList<MultiType>();
			if(null != fd) {
				this.visit(fd);
			}
			
			return found;
		}
		
		@Override
		public Object visit(MultiType multiType) {
			found.add(multiType);
			return super.visit(multiType);
		}
	}
	
	private static class MutitypesInsideFunctionBodyQualifier extends AbstractVisitor{
		private int which;
		
		public void qualifyTo(Block fd, int which){
			this.which = which;
			this.visit(fd);
		}

		@Override
		public Object visit(ArrayConstructor ac) {
			ac.setTaggedType(null);
			return super.visit(ac);
		}

		@Override
		public Object visit(New namedConstructor) {
			namedConstructor.getTaggedType().accept(this);
			return super.visit(namedConstructor);
		}
		
		@Override
		public Object visit(MultiType multiType) {
			multiType.astOverride = multiType.multitype.get(which);
			multiType.astOverride.setArrayLevels(multiType.getArrayLevels());
			return super.visit(multiType);
		}
	}
	
	private final MutitypesInsideFunctionBodyFinder multitypeFinder = new MutitypesInsideFunctionBodyFinder();
	private final MutitypesInsideFunctionBodyQualifier multitypequalifer = new MutitypesInsideFunctionBodyQualifier();
	
	private Thruple<Boolean, ArrayList<FuncDef>, Boolean> processMultiArgs(FuncDef funcDef) {
		String isConst = funcDef instanceof ConstructorDef?"constructor":("method: " + funcDef.getMethodName());
		
		boolean multiArgExtFunc=false;
		boolean hasMultiArgs=false;
		boolean hasMultiArgRet=false;
		boolean canResolveAllTypes=true;
		HashSet<MultiType> allMultiTypes = new HashSet<MultiType>();
		ArrayList<Integer> multiargs = new ArrayList<Integer>();
		int nx=0;
		for(FuncParam fp : funcDef.params.params) {
			Pair<Boolean, Type> got = resolvestoMultiArg(fp.type);
			Type resTo = got.getB();
			if(resTo instanceof MultiType) {
				hasMultiArgs=true;
				fp.type = resTo;
				allMultiTypes.add((MultiType)resTo);
				multiargs.add(nx);
			}
			if(got.getA()){
				canResolveAllTypes=false;
			}
			
			nx++;
		}
		
		
		if(null != funcDef.extFunOn){
			Pair<Boolean, Type> got = resolvestoMultiArg(funcDef.extFunOn);
			Type resTo = got.getB();
			if(resTo instanceof MultiType) {
				hasMultiArgs=true;
				multiArgExtFunc=true;
				funcDef.extFunOn = resTo;
				//multiargs.add(nx);
			}
			if(got.getA()){
				canResolveAllTypes=false;
			}
		}
		
		if(null != funcDef.getReturnType()){
			Pair<Boolean, Type> got = resolvestoMultiArg(funcDef.getReturnType());
			Type resTo = got.getB();
			if(resTo instanceof MultiType) {
				hasMultiArgRet=true;
				funcDef.retType = resTo;
			}
			if(got.getA()){
				canResolveAllTypes=false;
			}
		}
		
		if(hasMultiArgs || hasMultiArgRet) {
			int multiTypeArgCnt = -1;
			if(!hasMultiArgs) {//only ret
				this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("%s return type has been declared as a multi type, multitype input arguments with matching count must be defined", isConst));
				//allMultiTypes.forEach(a -> a.ignore=true);
				return new Thruple<>(true, null, true);
			}else {
				if(multiArgExtFunc) {
					multiTypeArgCnt = ((MultiType)funcDef.extFunOn).multitype.size();
				}
				
				if(multiargs.size() >= 1 || hasMultiArgRet) {//check all same size
					for(Integer idx : multiargs) {
						int thisOne = ((MultiType)funcDef.params.params.get(idx).type).multitype.size();
						if(multiTypeArgCnt == -1) {
							multiTypeArgCnt = thisOne;
						}else if(multiTypeArgCnt != thisOne) {
							this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("%s uses multitype arguments, these must all be of the same count of: %s. Input argument %s has count: %s", isConst, multiTypeArgCnt, idx+1, thisOne));
							//allMultiTypes.forEach(a -> a.ignore=true);
							return new Thruple<>(true, null, true);
						}
					}
					
					if(hasMultiArgRet) {
						int thisOne = ((MultiType)funcDef.getReturnType()).multitype.size();
						if(multiTypeArgCnt != thisOne) {
							this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("%s uses multitype arguments, these must all be of the same count of: %s. Return type has count: %s", isConst, multiTypeArgCnt, thisOne));
							//allMultiTypes.forEach(a -> a.ignore=true);
							return new Thruple<>(true, null, true);
						}
					}
				}
			}
			
			//now check to see if multitypes are used inside the function body
			this.maskErrors();
			
			this.currentlyInRet.add("");
			this.returnTypeExpected.add(this.const_object);
			if(null != funcDef.funcblock) {
				funcDef.funcblock.canContainAReturnStmt = true;
				
				funcDef.funcblock.accept(this);//yuck, we need to do this such that NamedTypes are mapped correctly to multitypes as approperiate
			}
			
			this.currentlyInRet.pop();
			this.returnTypeExpected.pop();
			
			
			this.maskedErrors();
			ArrayList<MultiType> inbody = multitypeFinder.find(funcDef.funcblock);

			if(!inbody.isEmpty()) {
				boolean fail = false;
				for(MultiType fella : inbody) {
					int thisOne = fella.multitype.size();
					if(thisOne != multiTypeArgCnt) {
						this.raiseError(fella.getLine(), fella.getColumn(), String.format("%s uses multitype arguments, these must all be of the same count of: %s. Multitype referenced in body has count: %s", isConst, multiTypeArgCnt, thisOne));
						fail=true;
					}
				}
				
				if(fail) {
					return new Thruple<>(true, null, true);
				}
			}
			
			//validated, now ouput variants of FuncDef with 
			ArrayList<FuncDef> ret = new ArrayList<FuncDef>(multiTypeArgCnt);
			for(int n=0; n < multiTypeArgCnt; n++) {
				FuncDef funcDefInst = (FuncDef)funcDef.copy();
				if(hasMultiArgs) {//need to adjust args
					//ArrayList<FuncParam> newParams = new ArrayList<FuncParam>(funcDef.params.params.size());
					for(FuncParam fp : funcDefInst.params.params) {
						Type tt = fp.type;
						if(tt instanceof MultiType) {
							MultiType mt = (MultiType)tt;
							fp.type = mt.multitype.get(n);
							fp.type.setArrayLevels(mt.getArrayLevels());
						}
					}
					
					if(funcDefInst.extFunOn instanceof MultiType) {
						MultiType mt = (MultiType)funcDefInst.extFunOn;
						funcDefInst.extFunOn = mt.multitype.get(n);
						funcDefInst.extFunOn.setArrayLevels(mt.getArrayLevels());
					}
				}

				if(hasMultiArgRet) {//addjust ret
					MultiType mt = (MultiType)funcDefInst.getReturnType();
					funcDefInst.retType = mt.multitype.get(n);
					funcDefInst.retType.setArrayLevels(mt.getArrayLevels());
				}
				
				if(!inbody.isEmpty()) {
					multitypequalifer.qualifyTo(funcDefInst.funcblock, n);
				}
				
				ret.add(funcDefInst);
			}
			
			return new Thruple<>(true, ret, false);
		}
		
		/*if(canResolveAllTypes) {//all types resolved ok, and we're not having multitypes - no need to check again
			//allMultiTypes.forEach(a -> a.ignore=true);
			return new Thruple<>(false, null, true);
		}*/
		
		return new Thruple<>(!canResolveAllTypes, null, false);
	}
	
	public boolean hasGPUFuncorkernals = false;//if false we can skip a compilation step

	@Override
	public Object visit(FuncDef funcDef) {
		//tag location of error
		Object ret = visitFuncDef(funcDef);
		//re apply tagged errors, adapt function as approperiate
		
		return ret;
	}
	
	public Object visitFuncDef(FuncDef funcDef) {
		funcDef.ignore = false;
		
		//System.err.println("funcDef: " + funcDef.funcName);
		
		TheScopeFrame cs = this.currentScopeFrame;
		if(cs.isconstructor || cs.isFuncDefBlock || cs.isExtFunc) {
			funcDef.isNestedFuncionDef = true;
		}
		
		if(funcDef.checkForFDVariants && null == funcDef.funcDefVariants) {
			//TODO: find way to perm exclude if we know thing works
			Thruple<Boolean, ArrayList<FuncDef>, Boolean> checkAgainAndVariants = processMultiArgs(funcDef);

			funcDef.funcDefVariants = checkAgainAndVariants.getB();
			
			if(checkAgainAndVariants.getC()) {//errors concerning multitypes, give up
				funcDef.funcDefVariants = null;
				funcDef.ignore = true;
				return null;
			}
			
			funcDef.checkForFDVariants = checkAgainAndVariants.getA();
		}
		boolean iskernal = false;
		if(funcDef.isGPUKernalOrFunction != null) {
			hasGPUFuncorkernals=true;
			
			if(funcDef.extFunOn != null) {
				this.raiseError(funcDef.getLine(), funcDef.getColumn(), "gpu kernels or gpu functions may not be extension functions");
			}
			else {
				if(null != funcDef.kernelDim) {
					Type expr = (Type)funcDef.kernelDim.accept(this);
					if(!(funcDef.kernelDim instanceof VarInt)) {
						this.raiseError(funcDef.kernelDim.getLine(), funcDef.kernelDim.getColumn(), "kernel dimentions must be a number between 1 and 3");
					}
					else {
						VarInt asVar = (VarInt)funcDef.kernelDim;
						if(asVar.inter > 3 || asVar.inter < 1) {
							this.raiseError(funcDef.kernelDim.getLine(), funcDef.kernelDim.getColumn(), "kernel dimentions must be a number between 1 and 3");
						}
					}
					iskernal=true;
				}
				
				if(!this.currentlyInClassDef.isEmpty()) {
					this.raiseError(funcDef.getLine(), funcDef.getColumn(), "gpu kernels or gpu functions may not be defined within classes");
				}
				
				if(!this.currentlyInFuncDef.isEmpty()) {
					this.raiseError(funcDef.getLine(), funcDef.getColumn(), "gpu kernels or gpu functions may not be nested");
				}
			}
			
		}
		
		if(funcDef.checkForFDVariants && null != funcDef.funcDefVariants && !funcDef.funcDefVariants.isEmpty()) {
			Object last = null;
			
			for(FuncDef fd : funcDef.funcDefVariants) {
				last = visitReal((FuncDef)fd);
			}
			
			return last;
		}
		
		Type toret = (Type)visitReal(funcDef);
		
		Type declReturn = funcDef.retType;
		
		if(funcDef.isGPUKernalOrFunction != null) {
			if(iskernal && null != declReturn && !TypeCheckUtils.isVoid(declReturn)) {
				this.raiseError(funcDef.getLine(), funcDef.getColumn(), "gpu kernel functions may only return type void, not: " + declReturn);
			}
			
			if(funcDef.annotations != null && funcDef.annotations.annotations != null && !funcDef.annotations.annotations.isEmpty()) {
				//annotations defined
				if(/*GPUFuncVariant.gpudef == funcDef.isGPUKernalOrFunction &&*/ funcDef.isGPUStubFunction()) {
					if(null != funcDef.getBody() ) {
						this.raiseError(funcDef.getLine(), funcDef.getColumn(), "gpudef stub functions or kernels can only be abstract");
					}
				}else {
					this.raiseError(funcDef.getLine(), funcDef.getColumn(), "gpu kernel or gpu functions may not have annotations");
				}
			}
			if(funcDef.extFunOn != null ) {//impossible to get here?
				this.raiseError(funcDef.getLine(), funcDef.getColumn(), "gpu kernel or gpu functions may not be an extension functions");
			}
			if(funcDef.methodGenricList != null && !funcDef.methodGenricList.isEmpty()) {//impossible to get here?
				this.raiseError(funcDef.getLine(), funcDef.getColumn(), "gpu kernel or gpu functions may have local generics");
			}
		}else if(TypeCheckUtils.isLambdaaOrLikelyASAMTypeOrTuple(this, declReturn) && null != funcDef.funcblock){
			Utils.inferAnonLambda(this, (Node)funcDef.funcblock, declReturn);
			InferAnonLambdaToReturnStatements inferAnonForReturns = new InferAnonLambdaToReturnStatements(this, declReturn);
			funcDef.funcblock.accept(inferAnonForReturns);
		}
		
		return toret;
	}
	
	private static class InferAnonLambdaToReturnStatements extends AbstractVisitor {
		@Override public Object visit(LambdaDef lambdaDef) { return null; }
		@Override public Object visit(FuncDef funcDef) {return null;}
		@Override public Object visit(ClassDef cd) {return null;}
		@Override public Object visit(AnonLambdaDef cd) {return null;}
		@Override public Object visit(AnnotationDef cd) {return null;}
		@Override public Object visit(EnumDef cd) {return null;}
		//skip above, dont tag the return statements in here
		
		private ScopeAndTypeChecker satc;
		private Type declReturn;

		
		public InferAnonLambdaToReturnStatements(ScopeAndTypeChecker satc, Type declReturn) {
			this.satc = satc;
			this.declReturn = declReturn;
		}
		
		@Override
		public Object visit(ReturnStatement returnStatement) {
			if(null!=returnStatement.ret) {
				Utils.inferAnonLambda(satc, (Node)returnStatement.ret, declReturn);
				returnStatement.ret.accept(this);
			}
			return null;
		}
	}

	@Override
	public Object visit(ConstructorDef conDef) {
		conDef.ignore = false;
		if(conDef.checkForFDVariants && null == conDef.funcDefVariants) {
			//TODO: find way to perm exclude if we know thing works
			Thruple<Boolean, ArrayList<FuncDef>, Boolean> checkAgainAndVariants = processMultiArgs(conDef);

			conDef.funcDefVariants = checkAgainAndVariants.getB();
			
			if(checkAgainAndVariants.getC()) {//errors concerning multitypes, give up
				conDef.funcDefVariants = null;
				conDef.ignore = true;
				return null;
			}
			
			conDef.checkForFDVariants = checkAgainAndVariants.getA();
		}
		
		if(conDef.checkForFDVariants && null != conDef.funcDefVariants && !conDef.funcDefVariants.isEmpty()) {
			Object last = null;
			
			for(FuncDef fd : conDef.funcDefVariants) {
				last = visitReal((ConstructorDef)fd);
			}
			
			return last;
		}
		
		if(null != conDef.funcblock) {
			conDef.funcblock.setShouldBePresevedOnStack(false);
		}
		
		return visitReal(conDef);
	}
	
	@Override
	public Object visit(LambdaDef lambdaDef) {
		boolean hasMultiTypes = false;
		
		for(FuncParam t : lambdaDef.getParams().params) {
			if(!lambdaDef.getSupressTypeBoxing() && !(t.name != null && t.name.contains("$"))) {
				t.type = TypeCheckUtils.boxTypeIfPrimative(t.type, false);
			}
			if(t.type instanceof MultiType) {
				hasMultiTypes=true;
				break;
			}
		}
		
		if(!lambdaDef.getSupressTypeBoxing()) {
			lambdaDef.returnType = TypeCheckUtils.boxTypeIfPrimative(lambdaDef.returnType, false, false);
		}
		
		if(lambdaDef.returnType instanceof MultiType) {
			hasMultiTypes=true;
		}
		
		lambdaDef.ignore = hasMultiTypes;
		
		if(hasMultiTypes) {
			this.raiseError(lambdaDef.getLine(), lambdaDef.getColumn(), "lambdas cannot have multitype arguments or return types");
			return null;
		}
		
		if(lambdaDef.isGPUKernalOrFunction != null) {
			this.raiseError(lambdaDef.getLine(), lambdaDef.getColumn(), "gpukernals and gpufunctions may not be declared as lambdas");
		}
		
		if(this.isInSuperConstructorCall()) {
			
			String msg = lambdaDef.origSource != null ? lambdaDef.origSource: "lambdas";
			
			this.raiseError(lambdaDef.getLine(), lambdaDef.getColumn(), String.format("%s may not be defined in super or this constructor calls", msg));
		}
		
		Type ret = (Type)visitReal(lambdaDef);
		Type declReturn = lambdaDef.returnType;
		if(TypeCheckUtils.isLambdaaOrLikelyASAMTypeOrTuple(this, declReturn) && null != lambdaDef.body){
			Utils.inferAnonLambda(this, (Node)lambdaDef.body, declReturn);
			InferAnonLambdaToReturnStatements inferAnonForReturns = new InferAnonLambdaToReturnStatements(this, declReturn);
			lambdaDef.body.accept(inferAnonForReturns);
		}
		
		return ret;
	}
	
	private void tagLastExprListsWithNoReturnNeeded(Node element) {
		if(element instanceof Block) {
			LineHolder last = ((Block)element).getLastLogical();
			if(null != last) {
				tagLastExprListsWithNoReturnNeeded(last.l);
			}
		}else if(element instanceof ExpressionList) {
			ExpressionList exprList = (ExpressionList)element;
			exprList.supressLastItemDoubleDotAttempt = true;
		}else if(element instanceof DuffAssign) {
			tagLastExprListsWithNoReturnNeeded((Node) ((DuffAssign)element).e);
		}
	}
	
	public Object visitReal(FuncDef funcDef) {
		
		FuncType oldFuncType = funcDef.getFuncType();
		
		//System.err.println("visit funcDef:" + funcDef);
		
		this.maskErrors(true);
		
		if(this.currentScopeFrame.isAnnotation){
			this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("method: %s cannot be defined within annotation", funcDef.funcName));
		}
		
		if(this.currentScopeFrame.isClass()){
			funcDef.definedAtClassLevel = true;
			funcDef.definedAtLocalClassLevel = this.currentlyInClassDef.peek().isLocalClass;
			
			//ClassDef top = this.currentlyInClassDef.peek();
			//if(funcDef.isInjected && (top.isLocalClass || top.isAnonClass)) {
				//this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("Anonymous and local classes may not have injectable %s",  funcDef instanceof ConstructorDef?"constructors":"methods"));
			//}
			
		}else if(this.currentScopeFrame.paThisIsModule && funcDef.isInjected) {
			this.raiseError(funcDef.getLine(), funcDef.getColumn(), "Only class level methods may be injected");
		}
		
		this.level++;
		boolean isAbstract = funcDef.isAbstract();
		
		if(funcDef.accessModifier == null){
			funcDef.accessModifier=funcDef.extFunOn != null && funcDef.definedAtClassLevel?AccessModifier.PROTECTED : AccessModifier.PUBLIC;
			if(!funcDef.isOverride){
				if(!currentlyInBlock.isEmpty() && currentlyInBlock.peek().isEnum){
					ClassDef cls = this.currentlyInClassDef.peek();
					if(cls.isEnumSubClass){
						funcDef.accessModifier=AccessModifier.PRIVATE;
					}
				}
			}
		}
		
		if(isAbstract && !funcDef.isGPUStubFunction())
		{
			if(funcDef.retType == null){
				//this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("Return type must be specified for abstract method: %s", funcDef.funcName));
				funcDef.retType = (Type)ScopeAndTypeChecker.const_void.copy();
			}
			
			if(this.currentlyInClassDef.isEmpty())
			{
				this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("Abstract method definition of '%s' can only exist within (abstract) classes", funcDef.funcName));
			}
			else
			{
				ClassDef cls = this.currentlyInClassDef.peek();
				cls.setHasAbstractMethods();
			}
			if(funcDef.isFinal){
				this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("Abstract method definition of '%s' cannnot be final", funcDef.funcName));
			}
			
			AccessModifier am = funcDef.accessModifier;
			
			if( am == AccessModifier.PRIVATE ){
				this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("The abstract method %s cannot be declared private", funcDef.funcName));
				
			}
			
		}
		if(!this.currentlyInClassDef.isEmpty()){
			funcDef.origin = this.currentlyInClassDef.peek();
		}
		else{
			//static in module itself
			funcDef.origin = this.moduleLevelNamedType;
		}
		
		this.currentlyInFuncDef.add(funcDef);

		if(funcDef.extFunOn != null){
			Type extFuncType = (Type)funcDef.extFunOn.accept(this);
			//com.concurnas.lang.ExtensionFunction
			if(funcDef.annotations == null){
				funcDef.annotations = new Annotations();
			}
			
			if(!funcDef.annotations.annotations.contains(const_extensionFunctionAnnot)){
				funcDef.annotations.annotations.add((Annotation)const_extensionFunctionAnnot.copy());
			}
			
			FuncParam fp =new FuncParam(funcDef.getLine(), funcDef.getColumn(), "this$extFunc", extFuncType, false);
			fp.accept(this);
			
			
			if( funcDef.definedAtClassLevel && funcDef.accessModifier != AccessModifier.PRIVATE && funcDef.accessModifier != AccessModifier.PROTECTED  ){
				this.raiseError(funcDef.getLine(), funcDef.getColumn(), "Extension methods can only be declared protected or private");
			}
			
		}
		
		if(funcDef.isInjected) {
			if(funcDef.annotations == null){
				funcDef.annotations = new Annotations();
			}else {
				if(!funcDef.annotations.hasAnnotation(const_InjectAnnotationStr)) {
					funcDef.annotations.annotations.add((Annotation)const_InjectAnnotation.copy());
				}
			}
			
			/*if(!this.currentlyInClassDef.isEmpty()) {
				ClassDef cd = this.currentlyInClassDef.peek();
				if(cd.isLocalClass || cd.isAnonClass) {
					this.raiseError(funcDef.getLine(), funcDef.getColumn(), "local and anonymous classes may not have methods marked with inject");
				}
			}*/
		}
		
		if(funcDef.annotations!= null){
			funcDef.annotations.setUsedAt(ElementType.METHOD);
			funcDef.annotations.accept(this);
			if(null != funcDef.funcblock){
				HashSet<WarningVariant> toSupress = Utils.extractSuppressedWarningsFromAnnotations(funcDef.annotations, this);
				if(!toSupress.isEmpty()){
					funcDef.funcblock.suppressedWarnings.addAll(toSupress);
				}
			}
		}
		
		
		//boolean isMissingNames = false;
		HashSet<String> funcArgNames = new HashSet<String>();
		boolean hasVararg = false;
		FuncParam prevP = null;
		for(FuncParam p : funcDef.params.params)
		{
			if(funcArgNames.contains(p.name))
			{
				this.raiseError(p.getLine(), p.getColumn(), String.format("Duplicate parameter: %s in arguments of: %s", p.name, funcDef.getMethodName()));
			}
			else
			{
				funcArgNames.add(p.name);
			}
			
			if(p.isVararg){
				if(hasVararg){
					this.raiseError(p.getLine(), p.getColumn(), "Only one parameter per method may be declared as a vararg");
				}
				hasVararg = true;
			}
			

			p.accept(this);
			
			if(p.defaultValue != null && prevP != null && prevP.isVararg ){//JPT: below is dirty copy paste, refactor?
				//check type is not compatible with the prevous thing
				Type withDefault = p.getTaggedType();
				Type theVararg = prevP.getTaggedType();
				if(null != theVararg && null != withDefault && theVararg.hasArrayLevels()){
					theVararg = (Type)theVararg.copy();
					theVararg.setArrayLevels(theVararg.getArrayLevels()-1);
					
					if(null != TypeCheckUtils.checkSubType(this.ers, theVararg, withDefault, 0, 0, 0, 0)){
						this.raiseError(p.getLine(), p.getColumn(), String.format("Parameter %s with default value may not immediately follow vararg parameter: %s having type of: %s which can be included in the vararg", p.name, prevP.name, withDefault ));
					}
				}
			}
			
			if(p.isVararg  && prevP != null && prevP.defaultValue != null){
				//check type is not compatible with the prevous thing
				Type withDefault = prevP.getTaggedType();
				Type theVararg = p.getTaggedType();
				if(null != theVararg && null != withDefault && theVararg.hasArrayLevels()){
					theVararg = (Type)theVararg.copy();
					theVararg.setArrayLevels(theVararg.getArrayLevels()-1);
					
					if(null != TypeCheckUtils.checkSubType(this.ers, theVararg, withDefault, 0, 0, 0, 0)){
						this.raiseError(p.getLine(), p.getColumn(), String.format("Vararg parameter %s may not immediately follow parameter with default value: %s having type of: %s which can be included in the vararg", p.name, prevP.name, withDefault ));
					}
				}
			}
			
			
			
			if(p.name == null && !isAbstract)
			{
				this.raiseError(p.getLine(), p.getColumn(), String.format("Parameter names must be defined for non abstract method definition '%s'", funcDef.funcName));
			}
			prevP = p;
		}
		
		boolean signatureExpectedToChange = funcDef.retType == null;
		
		if(null != funcDef.retType)
		{
			if(funcDef.retType instanceof FuncType) {
				funcDef.retType = TypeCheckUtils.boxTypeIfPrimative((FuncType)funcDef.retType, false);
			}
			
			Type gotRet = (Type)funcDef.retType.accept(this);
			if(null != gotRet){
				funcDef.retType = gotRet;
			}
		}
		
		ArrayList<CapMaskedErrs> cap = this.getmaskedErrors();
		if(!cap.isEmpty()) {
			signatureExpectedToChange = true;
		}
		this.applyMaskedErrors(cap);
		
		
		this.currentlyInFuncDef.pop();//TODO: do we need the pop here? - should we just enter once?
		
		boolean isOverride = funcDef.isOverride;
		
		//if override then MUST override the thing
		//if no overide the must not override the thing in the parent
		//the funcname, arguments and reutrn type must all match
		
		ExisitsAlready existAlready = this.currentScopeFrame.hasFuncDef(this.currentScopeFrame, funcDef.funcName, funcDef.getFuncType(), false, funcDef.isAutoGennerated, true, false, true);
		Pair<TypeAndLocation, Boolean> varEx = this.currentScopeFrame.getVariable(this.currentScopeFrame, funcDef.funcName, false);
		
		
		Type matchFunc = varEx ==null?null:  varEx.getA()==null?null  : varEx.getA().getType();
		TypeAndLocation tt=null;
		if(matchFunc instanceof FuncType){
			this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("Method %s is hidden by existing variable declared as a method reference variable", funcDef.funcName));
		}
		else if(ExisitsAlready.TRUE == existAlready){
			if(!funcDef.funcName.contains("$")){//exlcude synthetics like: $$onChange1$apply, this way omchange can be created inside function argument, or other places where they get double visisted in the same pass
				this.raiseError(true, funcDef.getLine(), funcDef.getColumn(), String.format("Method %s with matching argument definition exists already in current Scope", funcDef.funcName));
			}
		}
		else if(ExisitsAlready.TRUE_IMPLICIT == existAlready){
			this.raiseError(true, funcDef.getLine(), funcDef.getColumn(), String.format("Method %s with matching argument definition exists implicitly already in current Scope", funcDef.funcName));
		}
		else if(ExisitsAlready.TRUE_GT_ERASED == existAlready){
			this.raiseError(true, funcDef.getLine(), funcDef.getColumn(), String.format("Method %s with matching argument definition exists already in current Scope - generic types are erased at runtime", funcDef.funcName));
		}
		else
		{
			//check to see if exists with default arguments ignored
			ExisitsAlready existAlreadyMinSet = this.currentScopeFrame.hasFuncDef(this.currentScopeFrame, funcDef.funcName, funcDef.getFuncType(), false, funcDef.isAutoGennerated, true, true, true);
			
			if(ExisitsAlready.TRUE == existAlreadyMinSet){
				this.raiseError(true, funcDef.getLine(), funcDef.getColumn(), String.format("Method %s with matching argument definition exists already in current Scope when default arguments are ignored", funcDef.funcName));
			}
			else if(ExisitsAlready.TRUE_IMPLICIT == existAlreadyMinSet){
				this.raiseError(true, funcDef.getLine(), funcDef.getColumn(), String.format("Method %s with matching argument definition exists implicitly already in current Scope when default arguments are ignored", funcDef.funcName));
			}
			else if(ExisitsAlready.TRUE_GT_ERASED == existAlreadyMinSet){
				this.raiseError(true, funcDef.getLine(), funcDef.getColumn(), String.format("Method %s with matching argument definition exists already in current Scope - generic types are erased at runtime when default arguments are ignored", funcDef.funcName));
			}
			
			
			ClassDef holdingCls = this.currentlyInClassDef == null || this.currentlyInClassDef.isEmpty()? null :  this.currentlyInClassDef.peek();
			ClassDef superClass = holdingCls == null ? null : holdingCls.getSuperclass();
			
			//check for prescence in parent which is generic of another type... //e.g. arraylist[String] vs ArrayList[Integer] etc
			FuncType theFuncType = funcDef.getFuncType();
			theFuncType.signatureExpectedToChange = signatureExpectedToChange;
			
			tt = createTypeAndLocationFuncHolder(funcDef.getLine(), funcDef.getColumn(), theFuncType, funcDef.isNestedFunc);//TODO: is this the correct location?
			
			//Set<FuncType> superFuncsfuncs = superClass==null? null : superClass.getFuncDef(funcDef.funcName, true);
			HashSet<TypeAndLocation> superFuncsfuncs = superClass==null? null : holdingCls.getSuperClassFuncDefsMatchingName(funcDef.funcName, true);
			
			HashSet<ClassDef> traits = holdingCls==null?null:holdingCls.getTraits();
			if(traits != null && !traits.isEmpty()) {
				superFuncsfuncs.addAll(holdingCls.getTraitFuncDefsMatchingName(funcDef.funcName, true));
			}
			
			funcDef.createTraitStaticMethod = !funcDef.isAbstract() && this.currentlyInTraitDef();
			
			boolean blacklist = false;//why is it called a black list?
			if(isOverride && superClass == null)
			{
				this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("Method: %s which has been declared as overriden can only be defined within a subclass", String.format(((FuncType)tt.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName)));
			}
			else
			{
				String superClassStr = "" + superClass;
				
				if(null != traits && !traits.isEmpty()) {
					superClassStr += " or traits: " + String.join(", ", traits.stream().map(a -> a.toString()).sorted().collect(Collectors.toList()));
				}
				
				TypeAndLocation ttIgnoreRet = tt.cloneWithNoRetType();
				
				HashSet<TypeAndLocation> superFuncsfuncsNoRet =  Utils.funcsWithoutRets(superFuncsfuncs);
				TypeAndLocation matchButDifferingreturnTypeMaybe = superFuncsfuncs==null?null:MiscUtils.getMatchingFuncTypeDontConsiderReturnType(superFuncsfuncs, tt);
				
				if(null != superFuncsfuncs && superFuncsfuncsNoRet.contains(ttIgnoreRet))
				{//aldready defined.
					//super is abstract
					TypeAndLocation matchSuperDef = MiscUtils.getMatchingFuncType(this.getErrorRaiseableSupression(), superFuncsfuncs, tt);
					
					//if no match, ret not compatible
					
					if(null == matchSuperDef){
						blacklist = true;
						
						if(null != matchButDifferingreturnTypeMaybe){
							this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("The return type of method '%s' in class %s cannot be matched with method: '%s' in superclass: %s", String.format(((FuncType)tt.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName), holdingCls,  String.format(((FuncType)matchButDifferingreturnTypeMaybe.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName), superClassStr));
						}else {
							this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("The return type of method '%s' in class %s cannot be matched with method: '%s' in superclass: %s", String.format(((FuncType)tt.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName), holdingCls,  String.format(((FuncType)tt.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName), superClassStr));
						}
					}
					else{
						//add accessModifier parent check logic here....
						FuncType matchSuperDefType = (FuncType)matchSuperDef.getType();
						/*if(null != matchSuperDefType.origonatingFuncDef) {
							matchSuperDefType = matchSuperDefType.origonatingFuncDef.getFuncType();//without generic qualification
						}*/
						
						
						AccessModifier thisAM = funcDef.accessModifier;
						AccessModifier supAM = matchSuperDefType.getUnderlyingDefAccessMod();
						
						funcDef.requiresBridgeMethodTo = null;
						if(matchSuperDefType.retType != null && !matchSuperDefType.retType.equals(funcDef.retType)) {
							funcDef.requiresBridgeMethodTo = matchSuperDefType;
						}
						
						if(Utils.isNarrowingScope(thisAM, supAM)){
							this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("Method: '%s' of class: '%s' has been declared with accesability: %s but implementation in subclass: %s attempts to narrow scope to: %s - this cannot be done", String.format(((FuncType)tt.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName), superClassStr, supAM, holdingCls, thisAM));
							
						}
						else if(matchSuperDefType.isFinal()){
							this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("Method: '%s' of class: '%s' has been defined as final and cannot be be overriden in subclass: %s", String.format(((FuncType)tt.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName), superClassStr, holdingCls));
						}
						else{
							if(!isOverride && !matchSuperDefType.isAbstarct() && !((AbstractType)tt.getType()).getAutoGennerated() )     
							{//if not override, error, unless super was abstract in which case we dont have to deinfe it at all!
								blacklist = true;
								this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("Method: '%s' of class: '%s' should be explicitly overriden in subclass: %s. Use the override keyword", String.format(((FuncType)tt.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName), superClassStr, holdingCls));
							}
							else if(isOverride && matchSuperDefType.isAbstarct() && !((AbstractType)tt.getType()).getAutoGennerated() )
							{
								blacklist = true;
								this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("In order for the method '%s' of class: '%s' to be overriden it must be defined in the superclass: %s - its been declared abstract", String.format(((FuncType)tt.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName), holdingCls, superClassStr));
							}
						}
					}
					
				}
				else
				{
					//also need to bind the superytpyes genericals
					if(null != matchButDifferingreturnTypeMaybe && null == ((FuncType)matchButDifferingreturnTypeMaybe.getType()).retType){
						blacklist = true;
						this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("The return type of method '%s' in class %s cannot be matched with method: '%s' in superclass: %s because no return type has been defined for instance in superclass", String.format(((FuncType)tt.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName), holdingCls,  String.format(((FuncType)matchButDifferingreturnTypeMaybe.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName), superClassStr));
					}
					else if(null != matchButDifferingreturnTypeMaybe && !TypeCheckUtils.isAlreadyDefinedFuncReturnTypeCompatible(this.getErrorRaiseableSupression(), ((FuncType)tt.getType()).retType, ((FuncType)matchButDifferingreturnTypeMaybe.getType()).retType) )
					{//class Sup{ fun foo() int } class Child extends Sup{ fun foo() double} //fail! because ambig ret
						//object to float etc is ok though
						blacklist = true;
						this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("The return type of method '%s' in class %s is incompatible with method: '%s' in superclass: %s", String.format(((FuncType)tt.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName), holdingCls,  String.format(((FuncType)matchButDifferingreturnTypeMaybe.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName), superClassStr));
					}
					else if(isOverride)
					{
						blacklist = true;
						this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("In order for the method '%s' of class: '%s' to be overriden it must be defined in superclass: %s", String.format(((FuncType)tt.getType()).getFormatStringWithPalceholderforMethName(), funcDef.funcName), holdingCls, superClassStr));
					}
				}
				
				
				if(superFuncsfuncs!= null && theFuncType.hasGenericArgument())
				{
					int sizeToChec = theFuncType.getInputs().size();
					FuncType offendingSuperDelc = null;
					for(TypeAndLocation potentialo : superFuncsfuncs)
					{
						FuncType potential = (FuncType) potentialo.getType();
						if(!potential.isAbstarct() && potential.hasBeenInputsGenericTypeQualified() && sizeToChec == potential.getInputs().size())
						{
							for(int nn = 0; nn < sizeToChec; nn++)
							{//cycle through arguments, is there one not matching arg count
								Type ttType = theFuncType.getInputs().get(nn);
								Type potenType = potential.getInputs().get(nn);
								if(!ttType.equals(potenType))
								{//e.g. supertpye is String, but I have declared X - this causes erasure mismatch
									if(!(ttType instanceof FuncType && potenType instanceof FuncType && ((FuncType)ttType).argCount() != ((FuncType)potenType).argCount()))
									{
										if(potential.isSameWithGenericsErased(theFuncType)){//perform erasure on potential here
											offendingSuperDelc = potential;
											break;
										}
									}
								}
							}
						}
						if(null != offendingSuperDelc) {
							break;
						}
					}
					
					if(null != offendingSuperDelc)
					{
						blacklist = true;
						this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("Method %s with matching argument definition exists already in supertype or traits as: %s - generic types are erased at runtime", tt==null?null:tt.getType(), offendingSuperDelc));
					}
				}
			}
			
			if(!blacklist)
			{
				HashSet<TypeAndLocation> superFuncsfuncsWithGenerics = superClass==null? null : holdingCls.getSuperClassFuncDefsMatchingName(funcDef.funcName, false);
				if(null != superFuncsfuncsWithGenerics)
				{
					for(TypeAndLocation candidatel : superFuncsfuncsWithGenerics)
					{
						FuncType candidate = (FuncType) candidatel.getType();
						if(theFuncType.getInputs().size() == candidate.getInputs().size())
						{
							boolean atleastOneGenericOffender = false;
							boolean atleastoneargnotmatch = false;
							for(int n = 0; n < theFuncType.getInputs().size(); n++)
							{
								Type superArg = candidate.getInputs().get(n);
								Type ttArg = theFuncType.getInputs().get(n);
								
								if(superArg instanceof GenericType && ttArg instanceof NamedType)
								{
									NamedType superArgGenNT = ((GenericType)superArg).upperBound;
									NamedType wantedNT = (NamedType)ttArg;
									if(superArgGenNT.toStringNoGeneric().equals(wantedNT.toStringNoGeneric()))
									{//JPT: test for case where upper bound on generic type is defined
										atleastOneGenericOffender =true;
									}
								}
								else if(null == TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), superArg, ttArg, 0, 0, 0, 0))
								{
									atleastoneargnotmatch = true;
								}
							}
							
							if(atleastOneGenericOffender && !atleastoneargnotmatch)
							{
								this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("Method %s with matching argument definition exists already in supertype or traits as: %s - generic types are erased at runtime", tt==null?null:tt.getType(), candidate));
								break;
							}
						}
					}
				}
			}
			tt.getLocation().setTaggedFuncDef(funcDef);

			reMapFuncDef(funcDef, theFuncType, tt, false);
			
			this.currentScopeFrame.removeFuncDef(funcDef.funcName, oldFuncType);
			this.currentScopeFrame.setFuncDef(this.currentScopeFrame, funcDef.funcName, tt, Modifier.PUBLIC);
		}
		this.currentlyInFuncDef.add(funcDef);
		this.returnTypeExpected.add(funcDef.getTaggedType());
		this.currentlyInRet.add("method");
		

		//System.err.println(String.format("%s -> %s *", funcDef.funcName, funcDef.retType));
		
		if(null != funcDef.funcblock){
			funcDef.funcblock.isFuncDefBlock=true;
			funcDef.funcblock.funcDef = funcDef;
			funcDef.funcblock.canContainAReturnStmt = true;
			
			//I think this is ok::
			if((!const_void.equals(funcDef.retType) && null != funcDef.retType) || funcDef.getShouldInferFuncType()){
				funcDef.funcblock.setShouldBePresevedOnStack(true);
				if(funcDef.getShouldInferFuncType()) {
					tagLastExprListsWithNoReturnNeeded(funcDef.funcblock);
				}
			}

			if(funcDef.extFunOn != null) {
				funcDef.funcblock.isExtFunc = true;
			}
			
			typesReturnedCurrentFunc.push(new HashSet<Type>());
			Type got = (Type)funcDef.funcblock.accept(this);
			HashSet<Type> retTypes = typesReturnedCurrentFunc.pop();
			
			if(funcDef.getShouldInferFuncType())
			{//infer ret type!
				//add the one from the last statement
				TypeCheckUtils.assertRefIsGettable(this, funcDef.getLine(), funcDef.getColumn(), got, -1);
					
				got = TypeCheckUtils.getRefTypeToLocked(got);
				retTypes.add(got);
				
				Type retTypeOption = inferReturnType(funcDef.getLine(), funcDef.getColumn(), retTypes);
				
				if(null != retTypeOption){//great, we were able to infer the type
					Type prevSet = funcDef.retType;
					funcDef.retType = (Type)retTypeOption.accept(this);
					if(funcDef.retType == null){//cant determine the type
						//funcDef.retType = ScopeAndTypeChecker.const_void;
						//funcDef.retType = ScopeAndTypeChecker.const_object;//be nice to dependants and return a placeholder
						funcDef.retType = ScopeAndTypeChecker.const_void_errored;//be nice to dependants and return a placeholder, we've already thrown an error
					}
					
					boolean replaceDef=prevSet != null && !prevSet.equals(funcDef.retType);
										
					/*if(const_void.equals(funcDef.retType)){
						funcDef.funcblock.setShouldBePresevedOnStack(false);
					}*/
					
					FuncType theFuncType = funcDef.getFuncType();
					theFuncType.signatureExpectedToChange = signatureExpectedToChange;
					TypeAndLocation newtt = createTypeAndLocationFuncHolder(funcDef.getLine(), funcDef.getColumn(), theFuncType, funcDef.isNestedFunc);
					newtt.getLocation().setTaggedFuncDef(funcDef);
					
					boolean toMapToActorSuperCallImp = reMapFuncDef(funcDef, theFuncType, newtt, true);
					//remove lock...
					if(!toMapToActorSuperCallImp || replaceDef){
						this.currentScopeFrame.replaceFuncDef(this.currentScopeFrame, funcDef.funcName, tt, newtt, Modifier.PUBLIC);//TODO: location here is wrongly defined
						//tt = newtt;
					}
				}
			}
			
			
			if(null!= tt){
				if(tt.getType() instanceof FuncType)
				{
					Type tttype = ((FuncType)tt.getType()).retType;
					if(tttype instanceof FuncType && got instanceof FuncType){
						((FuncType)tttype).setLambdaDetails( ((FuncType)got).getLambdaDetails());
					}
				}
				
			}
		}
		
		if(!currentlyInBlock.isEmpty() && currentlyInBlock.peek().isEnum){
			/*if(funcDef.accessModifier == AccessModifier.PROTECTED){
				this.raiseError(funcDef.getLine(), funcDef.getColumn(), String.format("enum methods can only be public or private. '%s' is protected", funcDef.funcName));//doesnt make sens otherwise
			}*/
			if(funcDef.accessModifier == AccessModifier.PUBLIC){
				ClassDef cls = this.currentlyInClassDef.peek();
				if(cls.isEnumSubClass){//defined in enum subclass, we must ensure that its overriden in the superclass else its pointless
					HashSet<TypeAndLocation> things = cls.getSuperclass().getFuncDef(funcDef.funcName, true, false);
					boolean found = false;
					FuncType toMatch = funcDef.getFuncType();
					for(TypeAndLocation tal : things){
						if(tal.getType().equals(toMatch)){
							found = true; break;
						}
					}
					if(!found){
						this.raiseError(funcDef.getLine(), funcDef.getColumn(),  String.format("public enum item method '%s' must be defined in containing enum", funcDef.funcName));//doesnt make sens otherwise
					}
				}
			}else if(funcDef.accessModifier != AccessModifier.PRIVATE){
				ClassDef cls = this.currentlyInClassDef.peek();
				if(cls.isEnumSubClass && nestorParens.size() > 1){//defined in enum subclass, we must ensure that its overriden in the superclass else its pointless
					this.raiseError(funcDef.getLine(), funcDef.getColumn(),  String.format("protected method '%s' cannot be defined in enum element (only public and private are permitted)", funcDef.funcName));//doesnt make sens otherwise
				}
			}
		}
		
		
		this.currentlyInFuncDef.pop();
		this.returnTypeExpected.pop();
		this.currentlyInRet.pop();
		this.level--;
		
		if(!funcDef.isGPUKernalFuncOrStub()) {
			if(Utils.funcParamsHaveDefaults(funcDef.params) && !funcDef.funcName.endsWith("$ActorCall")){
				FunctionGenneratorUtils.addwithDefaultsMethod(this.ers, this, funcDef, this.currentScopeFrame, this.currentlyInBlock.peek());
			}
			
			if(funcDef.getShouldBeDeletedOnUsusedReturn() && (!(funcDef.retType instanceof NamedType) || funcDef.retType.hasArrayLevels() )) {
				this.raiseError(funcDef.getLine(), funcDef.getColumn(),  String.format("@DeleteOnUnusedReturn annotation can only be used on methods which return non array objects '%s' does not", funcDef.funcName));//doesnt make sens otherwise
			}
		}
		
		return null;//funcDef.retType;
	}
	
	private boolean reMapFuncDef(FuncDef funcDef, FuncType theFuncType, TypeAndLocation newtt, boolean adjustScopeFrame){
		//TODO: remove hack when default agents are changed to form of DefaultAgent of XXX
		boolean toMapToActorSuperCallImp = false;
		if(theFuncType.retType != null && !this.currentlyInClassDef.isEmpty() && funcDef.origin.isActor && !funcDef.isAutoGennerated ){
			if(funcDef.funcName.equals("toString") ){
				if(theFuncType.inputs.isEmpty() && theFuncType.retType.equals(const_string)){
					toMapToActorSuperCallImp = true;
				}
			}
			else if(funcDef.funcName.equals("hashCode") ){
				if(theFuncType.inputs.isEmpty() && theFuncType.retType.equals(const_int)){
					toMapToActorSuperCallImp = true;
				}
			}
			else if(funcDef.funcName.equals("equals") ){
				if(theFuncType.inputs.size() == 1 && theFuncType.inputs.get(0).equals(const_object) && theFuncType.retType.equals(const_boolean)){
					toMapToActorSuperCallImp = true;
				}
			}
			
			if(toMapToActorSuperCallImp){
				if(funcDef.isOverride){//check so raise error if input wrong
					funcDef.isOverride=false;
				}
				
				if(adjustScopeFrame){
					this.currentScopeFrame.removeFuncDef(funcDef.funcName, theFuncType);
				}
				funcDef.funcName += "$ActorSuperCallObjM";
				if(adjustScopeFrame){
					this.currentScopeFrame.setFuncDef(this.currentScopeFrame, funcDef.funcName, newtt, Modifier.PUBLIC); //TODO: location here is wrongly defined
				}
			}
			
		}
		
		return toMapToActorSuperCallImp;
		
	}

	private Type inferReturnType(int line, int col, HashSet<Type> retTypes){
		HashSet<Type> nonNulls = new HashSet<Type>(retTypes.size());
		for(Type r : retTypes){
			if(r != null){
				nonNulls.add(r);
			}
		}
		
		if(retTypes.contains(const_void_errored)) {
			//this.raiseError(0, 0, "uh oh");
			return const_void_errored;
		} else if(retTypes.contains(const_void) && !retTypes.stream().allMatch(a -> a == null || a.equals(const_void))) {
			this.raiseError(line, col, "all return statements must return a value");
			//return const_void;
		}
		
		Type retTypeOption = const_void;
		if(!nonNulls.isEmpty()){
			if(!areAllVoid(nonNulls)){
				ArrayList<Type> nonVoids = new ArrayList<Type>(retTypes.size());
				for(Type t : nonNulls){
					if(t instanceof VarNull) {
						t = const_object.copyTypeSpecific();
					}
					if(TypeCheckUtils.isValidType(t)){
						nonVoids.add(t);
					}
				}
				
				if(nonVoids.isEmpty()) {
					return const_void_errored;
				}
				
				retTypeOption = TypeCheckUtils.getMoreGeneric(this.ers, this, 0, 0, nonVoids, null);
			}
		}
		
		/*if(retTypeOption instanceof NamedType) {//dont return a local class, these cannot be invoked outside creating method
			NamedType nt = (NamedType)retTypeOption;
			ClassDef cd = nt.getSetClassDef();
			while(cd != null && cd.isLocalClass && !cd.isActor) {
				ClassDef sup = cd.getSuperclass();
				if(sup != null && !sup.isLocalClass) {
					cd = sup;
				}else {
					break;
				}
			}
			if(cd != nt.getSetClassDef()) {
				retTypeOption = new NamedType(cd);
			}
		}*/
		
		/*(retTypeOption instanceof NamedType) {//dont return a local class, these cannot be invoked outside creating method
			NamedType nt = (NamedType)retTypeOption;
			ClassDef cd = nt.getSetClassDef();
			while(cd != null && cd.isLocalClass && !cd.isActor) {
				ClassDef sup = cd.getSuperclass();
				if(sup != null && !sup.isLocalClass) {
					cd = sup;
				}else {
					break;
				}
			}
			if(cd != nt.getSetClassDef()) {
				retTypeOption = new NamedType(cd);
			}
		}*/
		
		
		return retTypeOption;
	}
	
	private boolean areAllVoid(Set<Type> types){
		boolean ret = true;
		for(Type t : types){
			if(!(t.equals(const_void_thrown) || t.equals(const_void))){
				ret = false;
				break;
			}
		}
		return ret;
	}
	
	
	private Stack<HashSet<Type>> typesReturnedCurrentFunc = new Stack<HashSet<Type>>();

	@Override
	public Object visit(GrandLogicalElement equalityElement) {
		return null; //not called directly
	}


	@Override
	public Object visit(EqReExpression equalityExpression) {
		ArrayList<Type> elementTypes = vectorizeElementsIfApproperiate(equalityExpression);
		
		Type ret; 
		
		Type lhsType = elementTypes.get(0);//(Type)equalityExpression.head.accept(this);
		lhsType = lhsType == null?null:(Type)lhsType.copy();
		lhsType = TypeCheckUtils.extractRawRefType(lhsType);
		
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> lhsvec = vectorizedOperator(lhsType);
		ArrayList<Pair<Boolean, NullStatus>> vectorized = lhsvec.getA();
		
		if(vectorized != null) {
			lhsType = lhsvec.getB();
		}

		int n=1;

		//boolean lastWasOpOverload=false;
		if(equalityExpression.isFirstThingRelationalOrNothing())
		{//a <= b etc
			flagNullableForOperation(equalityExpression.head.getLine(), equalityExpression.head.getColumn(), lhsType);
			
			for(GrandLogicalElement rhsEle : equalityExpression.elements)	{
				//lastWasOpOverload=false;
				Type rhs = elementTypes.get(n++);//(Type)rhsEle.e2.accept(this);
				rhs = rhs == null?null:(Type)rhs.copy();
				rhs = TypeCheckUtils.extractRawRefType(rhs);
				
				Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> rhsvec = vectorizedOperator(rhs);
				ArrayList<Pair<Boolean, NullStatus>> instVect = rhsvec.getA();
				if(instVect != null) {
					rhs = rhsvec.getB();
					vectorized = instVect;
				}	
				
				ArrayList<Type> rhstypes = new ArrayList<Type>();
				rhstypes.add(rhs);
				ArrayList<Expression> exprs = new ArrayList<Expression>();
				exprs.add(rhsEle.e2);
				
				FuncInvoke overloaded = canBeOperatorOverloaded(lhsType, rhstypes, null, "compareTo", exprs, rhsEle.getLine(), rhsEle.getColumn(), false, const_int, false, (Node)rhsEle.astOverrideOperatorOverload);
				if(null != overloaded){
					rhsEle.astOverrideOperatorOverload = overloaded;
					this.dotOperatorLHS.push(lhsType);
					lhsType = (Type)rhsEle.accept(this);
					this.dotOperatorLHS.pop();
					//lastWasOpOverload=overloaded.vectroizedDegreeAndArgs != null;
				}
				else{
					flagNullableForOperation(rhsEle.e2.getLine(), rhsEle.e2.getColumn(), rhs);
					lhsType = TypeCheckUtils.checkNumericalInfix(this, lhsType, rhs, rhsEle.e2.getLine(), rhsEle.e2.getColumn(), rhsEle.e2.getLine(), rhsEle.e2.getColumn(), makeMissingOpOverLoadMessage("compareTo", lhsType, rhs, const_int));
				}
				lhsType = const_boolean;
				
				rhsEle.setTaggedType(lhsType);
			}
			ret= lhsType;
		}
		else
		{//== -> .equals()
			
			//have a good thinks about this
			
			for(GrandLogicalElement e : equalityExpression.elements)
			{
				//EqualityOperatorEnum comp = e.compOp;
				Type rhstype =elementTypes.get(n++);//(Type) e.e2.accept(this);
				rhstype = rhstype == null?null:(Type)rhstype.copy();
				rhstype = TypeCheckUtils.extractRawRefType(rhstype);
				
				Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> rhsvec = vectorizedOperator(rhstype);
				ArrayList<Pair<Boolean, NullStatus>> instVect = rhsvec.getA();
				if(instVect != null) {
					rhstype = rhsvec.getB();
					vectorized = instVect;
				}
				
				boolean diderr = false;
				if(e.compOp == GrandLogicalOperatorEnum.REFEQ || e.compOp == GrandLogicalOperatorEnum.REFNE)
				{
					if(!TypeCheckUtils.isObjectType(lhsType) || !TypeCheckUtils.isObjectType(rhstype))
					{
						this.raiseError(equalityExpression.head.getLine(), equalityExpression.head.getColumn(), String.format("Refernce equality can only be applied to objects not: %s, %s", lhsType, rhstype ));
					}
					
				}
				if(!diderr)
				{
					//It is a compile-time error if it is impossible to convert the type of either operand to the type of the other by a casting conversion (ï¿½5.5). The run-time values of the two operands would necessarily be unequal.
					//MHA
					ErrorRaiseableSupressErrorsAndLogProblem erlog = new ErrorRaiseableSupressErrorsAndLogProblem(this.ers);
					ErrorRaiseableSupressErrorsAndLogProblem erlog2 = new ErrorRaiseableSupressErrorsAndLogProblem(this.ers);
					
					
					Type cast1way = null;
					Type castOtherWay = null;
					
					{
						Type testLeft = lhsType==null?null:(Type)lhsType.copy();
						Type testRight = rhstype==null?null:(Type)rhstype.copy();
						
						if(testLeft instanceof NamedType) {
							((NamedType) testLeft).setGenTypes(new ArrayList<Type>());
						}
						if(testRight instanceof NamedType) {
							((NamedType) testRight).setGenTypes(new ArrayList<Type>());
						}
						
						
						cast1way = CastCheck.checkCast(erlog, 0,0, testLeft, testRight, true);
						if(null == cast1way) {
							castOtherWay = CastCheck.checkCast(erlog2, 0,0, testRight, testLeft, true);
						}
						
						if((erlog.isHasErrored() && erlog2.isHasErrored()) || (null == cast1way && null == castOtherWay))
						{
							this.raiseError(equalityExpression.head.getLine(), equalityExpression.head.getColumn(), String.format("Incompatible operand types %s and %s", lhsType, rhstype ));
						}
						
						if(null == TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), testLeft, testRight, equalityExpression.head.getLine(), equalityExpression.head.getColumn(), e.e2.getLine(), e.e2.getColumn())
								&& null == TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), testRight, testLeft, equalityExpression.head.getLine(), equalityExpression.head.getColumn(), e.e2.getLine(), e.e2.getColumn())
						)
						{//if u cant go either way on boolean check...
							this.raiseError(equalityExpression.head.getLine(), equalityExpression.head.getColumn(), String.format("Incompatible operand types %s and %s", lhsType, rhstype ));
						}
						
					}
					//a==b==false==true==
				}
				
				lhsType = new PrimativeType(PrimativeTypeEnum.BOOLEAN);
			}
			
			ret= lhsType;
		}
		
		if(vectorized != null) {
			equalityExpression.depth = vectorized;
			if(ret != null /*&& !lastWasOpOverload*/) {
				ret = (Type)ret.copy();
				ret = TypeCheckUtils.applyVectStruct(vectorized, ret);
			}
		}else {
			ret = validateAndReturnPointerType(equalityExpression.getLine(),equalityExpression.getColumn(), elementTypes, ret, false);
		}
		
		equalityExpression.setTaggedType(ret);
		
		return ret;
	}
	
	@Override
	public Object visit(LineHolder lineHolder) {
		this.enterLine();
		if(lineHolder.l instanceof DuffAssign){
			//if a line contains a duff asign which accidentally goes to a compund statement/otherwise a line, then repoint it back to a line [yuck]
			Expression e = ((DuffAssign)lineHolder.l).e;
			if(e instanceof Line){
				if(e instanceof Statement && !lineHolder.lastLine && !lastThingBlockReturns.peek() ){
					((Line) e).setShouldBePresevedOnStack(false);//cater for this case: "" + while(a++ <= 10) { b=1; while(b++ <= 10) { b++ * a++ } }
				}
				lineHolder.l = (Line)e;
			}
		}
		
		lineHolder.l.isOnItsOwnLine=true;
		
		lineHolder.l.setIfReturnsExpectImmediateUse(false);
		
		Type ret = (Type)lineHolder.l.accept(this);
		this.leaveLine();
		return ret;
	}


	@Override
	public Object visit(New namedConstructor) {
		//TODO: check number of generic  type arguments
		//canBeOperatorOverloaded(Type lhs, Type rhs, String operation, Expression rhsExprssion, int line, int col)
		Type t = namedConstructor.typeee;

		int line = namedConstructor.getLine();
		int col = namedConstructor.getColumn();
		/*
		if(t.hasArrayLevels()) {//incorrectly mapped here
			namedConstructor.astRedirect = new ArrayConstructor(line, col, Type t, ArrayList<Expression> arrayLevels, Expression defaultValue);
			return namedConstructor.setTaggedType((Type)namedConstructor.astRedirect.accept(this))
		}*/
		
		Type got;
		
		if(t instanceof NamedType && namedConstructor.args != null){
			NamedType asNamed = (NamedType)t;
			
			//this.dotOperatorLHS.push(null);
			this.maskErrors();
			Pair<Node, Object> redirectToFuncRef = redirectToFuncRef(line, col, namedConstructor.args, asNamed.getGenericTypeElements(), asNamed.namedType);
			//this.dotOperatorLHS.pop();
			
			if(!this.maskedErrors() && null != redirectToFuncRef){
				namedConstructor.astRedirect = redirectToFuncRef.getA();
				return redirectToFuncRef.getB();
			}
		}
		
		List<Type> consArgs = processArgTypes(namedConstructor.args, false, line,col);

		ArrayList<Pair<String, Type>> namessMap = getNameMap(namedConstructor.args);
		
		inNamedConstructor.add(new Pair<List<Type>, ArrayList<Pair<String, Type>>>(consArgs, namessMap));
		
		boolean isTypedActor =false;
		
		//namedConstructor.actorOfClassRef = null;
		boolean ammendedGensForActorOfClassRef=false;
		
		if(t instanceof NamedType){
			NamedType asNamed = (NamedType)t;
			isTypedActor = TypeCheckUtils.isTypedActor(this, asNamed);
			
			asNamed.isCalledInConsructor = true;
			this.maskErrors(true);
			got = (Type)asNamed.accept(this);
			ArrayList<CapMaskedErrs> normalErors = this.getmaskedErrors();
			
			boolean noGenerics = (asNamed.getGenericTypeElements() == null || asNamed.getGenericTypeElements().isEmpty());
			boolean errors = !normalErors.isEmpty();
			if(errors && got == null && noGenerics && !namedConstructor.calledInFuncRef){
				String thingName = asNamed.getNamedTypeStr();
				FuncInvoke asFuncInvoke = new FuncInvoke(line, col, thingName, namedConstructor.args == null? new FuncInvokeArgs(line, col): namedConstructor.args);//try as a function invokation
				this.maskErrors();
				Type tgto = (Type)asFuncInvoke.accept(this);
				if(!this.maskedErrors()){//no errors and ...
					this.maskErrors();
					RefName asRefName = new RefName(line, col, thingName);
					Type typeFromRefName = (Type)asRefName.accept(this);
					if(!this.maskedErrors() && typeFromRefName instanceof FuncType && ((FuncType)typeFromRefName).isClassRefType) {//... is class ref
						namedConstructor.astRedirect = asFuncInvoke;
						return tgto;
					}
				}
			}else if(errors && isTypedActor && !noGenerics && asNamed.getGenericTypeElements().size() == 1){
				//cater for this case: mc = MyClass&; inst = actor mc(33)
				Type actorQaulification = asNamed.getGenericTypeElements().get(0);
				if(actorQaulification instanceof NamedType){
					NamedType asnameactorq = (NamedType)actorQaulification;
					if(asnameactorq.getGenericTypeElements() == null || asnameactorq.getGenericTypeElements().isEmpty()){
						RefName refname = new RefName(asnameactorq.getNamedTypeStr());
						this.maskErrors();
						Type maybeFuncType = (Type)refname.accept(this);
						
						if(!this.maskedErrors() && maybeFuncType instanceof FuncType && ((FuncType)maybeFuncType).isClassRefType){
							namedConstructor.actorOfClassRef = (FuncType)maybeFuncType.copy();
							namedConstructor.actorOfClassRef.retType.setInOutGenModifier(InoutGenericModifier.OUT);
							ArrayList<Type> genTypes = new ArrayList<Type>();
							genTypes.add((NamedType)((FuncType)maybeFuncType).retType);
							asNamed.setGenTypes(genTypes);
							namedConstructor.args.prefixadd(refname);
							ammendedGensForActorOfClassRef = true;
						}
					}
				}
			}
			
			if(errors && !ammendedGensForActorOfClassRef){//maybe previous thing has overlaoded the new operator
				if( got == null && t instanceof NamedType  && !this.dotOperatorLHS.isEmpty() && this.dotOperatorLHS.peek() instanceof NamedType){
					Type overloadedResolvesTo = null;
					//see if lhs implements new operator overloader
					namedConstructor.newOpOverloaded=null;
					this.maskErrors(true);
					
					NamedType tryingToConstruct = ((NamedType)t).copyTypeSpecific();
					//full pck name
					this.dotOperatorLHS.push(null);
					this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
					this.maskErrors();
					tryingToConstruct = (NamedType)tryingToConstruct.accept(this);
					this.maskedErrors();
					this.dotOperatorLHS.pop();
					this.currentDotOperatorTracker.pop();
					
					List<Type> ooTypes = consArgs == null?new ArrayList<Type>():new ArrayList<Type>(consArgs);
					ooTypes.add(0, ScopeAndTypeChecker.const_string);
					
					//
					//System.err.println("getCheckCastType: " +tryingToConstruct.getCheckCastType());
					//System.err.println("getNonGenericPrettyName: " +tryingToConstruct.getNonGenericPrettyName());
					VarString firsArg = new VarString(0,0, tryingToConstruct !=null?tryingToConstruct.getCheckCastType():((NamedType)t).getNamedTypeStr());
					ArrayList<Expression> ooExprs = new ArrayList<Expression>(namedConstructor.args.asnames);
					ooExprs.add(0, firsArg);
					
					NamedType operatingOn = (NamedType)this.dotOperatorLHS.peek();
					
					FuncInvoke overloaded =  canBeOperatorOverloaded(operatingOn, ooTypes, namedConstructor.args, "new", ooExprs, namedConstructor.getLine(), namedConstructor.getColumn(), false, null, false, namedConstructor.newOpOverloaded);
					if(null != overloaded){
						overloadedResolvesTo = (Type)overloaded.accept(this);
						namedConstructor.newOpOverloaded = overloaded;
						
						//check non namedType
						if(!(overloadedResolvesTo instanceof NamedType)){
							this.raiseError(namedConstructor.getLine(), namedConstructor.getColumn(), String.format("Operator overloading of: %s produces type of: %s for requested class: %s which is not compatible", this.dotOperatorLHS.peek(), overloadedResolvesTo, firsArg.str));
						}
						
						if(namedConstructor.actingOn != null){//JPT: future improvement, for now i cant see why anyone would want to do this...
							this.raiseError(namedConstructor.getLine(), namedConstructor.getColumn(), String.format("Operator overloading of: %s cannot be used to produce an actor", this.dotOperatorLHS.peek()));
						}
						
						if(null != tryingToConstruct){
							if(null != TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), overloadedResolvesTo, tryingToConstruct)){
								namedConstructor.newOpOverloadedNeedsCast=true;
							}else if(null == TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), tryingToConstruct, overloadedResolvesTo) ){
								this.raiseError(namedConstructor.getLine(), namedConstructor.getColumn(), String.format("Operator overloading of: %s produces type of: %s for requested class: %s which is not compatible", this.dotOperatorLHS.peek(), overloadedResolvesTo, firsArg.str));
								namedConstructor.newOpOverloaded = null;
							}
						}
					}
					else if(null != TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), const_classLoader, operatingOn)){
						//'new' has not been operator overloaded, but we're operating on a classloader...
						
						//check it's a 'genuiune' call that we can direct via the classloader
						New namedCop;				
						if(namedConstructor.calledInFuncRef){
							namedCop = namedConstructor;
						}else{
							namedCop = (New)namedConstructor.copy();
						}
						
						this.dotOperatorLHS.push(null);
						this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
						this.maskErrors(true);
						namedCop.accept(this);
						boolean wereErrors = this.maskedErrors();
						this.dotOperatorLHS.pop();
						this.currentDotOperatorTracker.pop();
						
						if(!wereErrors){//nice, we can extract the resovled type and arg info from the partial processing
							FuncInvokeArgs getDeclaredConstructorFIA = new FuncInvokeArgs(line, col);
							Expression newInstance;
							if(namedCop.astRedirect != null  && (namedCop.astRedirect instanceof FuncRef)){
								FuncRef asFuncRef = (FuncRef)namedCop.astRedirect;
								for(Object item : asFuncRef.args.exprOrTypeArgsList){
									Type constInput = ((Node)item).getTaggedType();
									NamedType inputArg = TypeCheckUtils.converToNamedType(constInput);
									getDeclaredConstructorFIA.add(new RefClass(line, col, inputArg));
								}
								
								FuncRef frCorrectedArgs = new FuncRef(line, col, new RefName(line, col, "newInstance"), ((FuncRef)namedCop.astRedirect).args); 
								
								newInstance = frCorrectedArgs;
								
							}else{
								for(Type constInput : namedCop.constType.inputs){
									NamedType inputArg = TypeCheckUtils.converToNamedType(constInput);
									getDeclaredConstructorFIA.add(new RefClass(line, col, inputArg));
								}
								newInstance = new FuncInvoke(line, col, "newInstance", namedConstructor.args);
							}
							
							//mc.new AClass('one', 'two') => 
							//mc.loadClass(AClass.class.name).getDeclaredConstructor(String.class, String.class).newInstance('one', 'two')
							String makeType = tryingToConstruct !=null?tryingToConstruct.getNonGenericPrettyName():((NamedType)t).getNamedTypeStr();
							
							DotOperator thingDotClassDotName = DotOperator.buildDotOperator(line, col, new RefClass(line, col, new NamedType(line, col, makeType)), new FuncInvoke(line, col, "getName"));
							FuncInvoke loadClass = FuncInvoke.makeFuncInvoke(line, col, "loadClass", thingDotClassDotName);
							
							FuncInvoke getDeclaredConstructor = new FuncInvoke(line, col, "getDeclaredConstructor", getDeclaredConstructorFIA);
							
							
							DotOperator wholeChain = DotOperator.buildDotOperator(line, col, loadClass, getDeclaredConstructor, newInstance);
							
							namedConstructor.astRedirect = wholeChain;
						}
					}
					
					if(namedConstructor.astRedirect != null){
						Type ret = (Type)namedConstructor.astRedirect.accept(this);
						namedConstructor.setTaggedType(ret);
						this.getmaskedErrors();
						return ret;
					}
					
					//cast if rhs type known already

					ArrayList<CapMaskedErrs> ooErrors = this.getmaskedErrors();
					
					if(!ooErrors.isEmpty()|| namedConstructor.newOpOverloaded==null){//uh oh
						this.applyMaskedErrors(!ooErrors.isEmpty()?ooErrors:normalErors);
					}else{
						got = tryingToConstruct;
						asNamed.setClassDef(null != tryingToConstruct?tryingToConstruct.getSetClassDef():((NamedType)overloadedResolvesTo).getSetClassDef());
					}
				}else{
					this.applyMaskedErrors(normalErors);
				}
			}
			
			asNamed.isCalledInConsructor = false;//yuck
			
			for(Type tt : asNamed.getGenericTypeElements()){
				if(null != tt.getInOutGenModifier()){
					this.raiseError(namedConstructor.getLine(), namedConstructor.getLine(), String.format("Generic qualifications for constructors may not use in out", got));
				}
			}
			
		}
		else{
			got = (Type)t.accept(this);
		}
	
		inNamedConstructor.pop();
		
		if(TypeCheckUtils.isAnnotation(got)){
			this.raiseError(namedConstructor.getLine(), namedConstructor.getLine(), String.format("Instances of annotation: %s cannot be created", got));
		}
		
		namedConstructor.setTaggedType(got);
		if(got instanceof GenericType)
		{
			this.raiseError(namedConstructor.getLine(), namedConstructor.getLine(), String.format("Cannot instantiate generic type %s", got));
			return null;
		}
		
		if(!(got instanceof NamedType))
		{
			this.raiseError(namedConstructor.getLine(), namedConstructor.getLine(), String.format("Cannot instantiate type %s", got));
			
			/*if(namedConstructor.actingOn != null){//better than returning something that doesnt exist
				return namedConstructor.actingOn;
			}*/
			return ScopeAndTypeChecker.const_object.copyTypeSpecific();// new VarNull(namedConstructor.getLine(), namedConstructor.getColumn());//otherwise causes issues
		}
		
		//fromClassGenericToQualifiedType
		
		NamedType named = (NamedType)got;
		
		{
			ClassDef setClassDef = named.getSetClassDef();
			if(null != setClassDef && ScopeAndTypeChecker.const_typed_actor_class.equals(setClassDef)){//if its a typed actor...
				Type actorOf = named.getGenTypes().get(0);
				if(actorOf instanceof NamedType && TypeCheckUtils.isTypedOrUntypedActor(this, (NamedType)actorOf)){//and it's already an actor!
					named = (NamedType)actorOf;
					namedConstructor.typeee = named;//then just set the type to be that of the actee, since we dont permit actors of actors
				}
			}
		}
		
		if (null != named) {
			ClassDef clu = named.getSetClassDef();
			if(null == clu)
			{
				this.raiseError(namedConstructor.getLine(), namedConstructor.getLine(), "Class not found for: " + named);
				return null;
			}
			else if(clu.isNestedAndNonStatic())
			{//we canot do this: class Outer { class Inner{}}; Outer.Inner();
				//only hope is doing this: (new Outer()).new Inner();
				//except the exception below
				boolean ok = false;
				ClassDef netsorParentWanted = clu.getParentNestor();
				if(!this.dotOperatorLHS.isEmpty())
				{
					Type lastdotOpLhs = this.dotOperatorLHS.lastElement();
					
					if(lastdotOpLhs instanceof NamedType)
					{
						NamedType nt = (NamedType)lastdotOpLhs;
						ClassDef maybeParentCls = (nt).getSetClassDef();
						named.augmentfromClassGenericToQualifiedType(nt.getFromClassGenericToQualifiedType());
						if(null != maybeParentCls && null!= maybeParentCls.isParentNestorEQOrSUperClass(netsorParentWanted))
						{//so its nested parent is the one holding it
							ok = true;
						}
					}
					
					isNamedTypeAccessable(named, true);
					
					//this case is not permitte: Outer.new Innter() //where outer is the classname and not a variable name
					Expression prevExpr = this.currentDotOperatorTracker.peek().getprevious();
					if(prevExpr instanceof RefName){
						RefName rn = (RefName)prevExpr;
						ok = !rn.ignoreWhenGenByteCode;//if the previous thing is to be ignored then we cannot instaniate off it
					}
					
					/*if(lastdotOpLhs.hasArrayLevels()) {
						ok=false;
					}*/
						
				}
				else if(!this.currentlyInClassDef.isEmpty()) //has to be in a nested class
				{//looking grim, but there is an exception...
					//note this exception:
					/*
						class Outer { 
						  	class Inner1 { var = new Inner2(); }
						  	class Inner2 {  }
						  	alsook =  new Inner2();
						  }//this is permitted (fwd ref and non outer class object ref)
					 */
					//reverse iterate upwards
					ClassDef currentlyIn = this.currentlyInClassDef.peek();
					
					if(null != currentlyIn && null!= currentlyIn.isParentNestorEQOrSUperClass(netsorParentWanted))
					{//implicit this. reference
						ok=true;
						isNamedTypeAccessable(named, true);
					}
					else{//TODO: remove this else block and see what happenes
						String fullClsPathWanted =  ""+clu;
						for(int j=this.currentlyInClassDef.size() -1;j>=0;j--)
						{
							ClassDef top = this.currentlyInClassDef.get(j);
							String topClsStr = ""+top;
							if(fullClsPathWanted.startsWith(topClsStr))
							{//play.Outer.Inner2 startsiwth: play.Outer 
								TheScopeFrame sf = top.getScopeFrame();
								if(null!= sf)
								{
									String lastBit = fullClsPathWanted.equals(topClsStr) ? topClsStr: fullClsPathWanted.substring(topClsStr.length()+1);
									if(null != sf.getClassDef(null,lastBit, true, false))
									{
										ok = true;
										break;
									}
								}
							}
							
						}
					}
				}
				
				if(!ok)
				{
					this.raiseError(namedConstructor.getLine(), namedConstructor.getLine(), String.format("Nested Class: %s cannot be directly instantiated. Can only be instantiated via reference of class: %s", named, netsorParentWanted));
					return null;
				}
			}
			else if(!clu.isInstantiable())
			{
				this.raiseError(namedConstructor.getLine(), namedConstructor.getLine(), String.format("Class: %s is not instantiable" , named));
				return null;
			}
			
			
			if(!namedConstructor.isPreceededByDotInDotOperator() && clu.isLocalClass){
				clu.callingConstructors.add(namedConstructor);
			}
			
			this.maskErrors(true);
			boolean hasUnqualifiedGenerics = (consArgs!=null && consArgs.stream().anyMatch(a -> a instanceof NamedType && ((NamedType)a).requiresGenTypeInference)) ||
				namessMap.stream().anyMatch(a -> a.getB() instanceof NamedType && ((NamedType)a.getB()).requiresGenTypeInference ) ||
				named.requiresGenTypeInference;
			
			
			EvaluatedConstructor gotola = namedConstructor.newOpOverloaded!=null?null:evaluateConstructor(named, consArgs, namessMap, namedConstructor.getLine(), namedConstructor.getColumn(), "", hasUnqualifiedGenerics);
			ArrayList<CapMaskedErrs> wereErrors = this.getmaskedErrors();
			this.applyMaskedErrors(wereErrors);
			
			namedConstructor.constType = gotola == null?null:gotola.getB();
			
			if(hasUnqualifiedGenerics && null == namedConstructor.constType) {	
				namedConstructor.constType = gotola == null?null:gotola.getNextBest();
				
				if(!namessMap.isEmpty()) {
					boolean isActor = false;
					Type rtype = namedConstructor.constType != null?(NamedType)namedConstructor.constType.retType:null;
					if(rtype instanceof NamedType) {
						NamedType asNamed = (NamedType)rtype.copy();
						asNamed.setArrayLevels(0);
						isActor = TypeCheckUtils.isActor(ers, asNamed);
					}
					namedConstructor.args.argsWithNamedParams = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, namedConstructor.constType, namedConstructor.args.asnames, getNameMapExpr(namedConstructor.args), isActor?1:0, false, false);
				}
			}
			
			if(null != gotola){
				FuncType consft = gotola.getB();
				if(null != consft && !gotola.getC()){
					
					if(consft.hasBeenVectorized != null){
						//dealt with later
						namedConstructor.vectroizedDegreeAndArgs = consft.hasBeenVectorized;
						
						//consft.retType = consft.hasBeenVectorized.getD();
						
						//JPT: nasty copy paste from below, see if this can be removed
						ArrayList<Expression> exprArgs = namedConstructor.args.asnames;
						ArrayList<Pair<String, Expression>> namessMapExpr = getNameMapExpr(namedConstructor.args);
						
						boolean isActor = false;
						Type rtype = (NamedType)consft.retType;
						if(rtype instanceof NamedType) {
							NamedType asNamed = (NamedType)rtype.copy();
							asNamed.setArrayLevels(0);
							isActor = TypeCheckUtils.isActor(ers, asNamed);
						}
						
						List<Expression> mappedArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, consft, exprArgs, namessMapExpr, isActor?1:0, false, false);
						//check all mapped
						
						if(!TypeCheckUtils.typeListEquals(mappedArgs, exprArgs)){//changes made?
							namedConstructor.args.argsWithNamedParams = mappedArgs;
						}
						
						return namedConstructor.setTaggedType(consft.retType);
					}
					
					//if(null != namessMap && !namessMap.isEmpty()){
					if(null != namedConstructor.args && wereErrors.isEmpty()){
						ArrayList<Expression> exprArgs = namedConstructor.args.asnames;
						ArrayList<Pair<String, Expression>> namessMapExpr = getNameMapExpr(namedConstructor.args);
						int appendedArgs = gotola.getD();
						List<Expression> mappedArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, consft, exprArgs, namessMapExpr, appendedArgs, false, false);
						namedConstructor.args.argsWithNamedParams = mappedArgs;
						//also convert arguments
						ArrayList<Pair<String, Type>> namesMapType = getNameMap(namedConstructor.args);
						if(appendedArgs > 0){
							List<Type> firstPart = consArgs.subList(0, appendedArgs);
							consArgs = consArgs.subList(appendedArgs, consArgs.size());
							consArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, consft, consArgs, namesMapType, appendedArgs, true, false);
							firstPart.addAll(consArgs);
							consArgs=firstPart;
						}
						else{
							consArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, consft, consArgs, namesMapType, appendedArgs, true, false);
						}
					}
					
					if(consArgs.size() != consft.inputs.size()){
						this.raiseError(namedConstructor.getLine(), namedConstructor.getLine(), String.format("Incorrect number of arguments passed for constructor, expected: %s received: %s" , consft.inputs.size(), consArgs.size()));
					}
					else{
						for(int na=0; na < consArgs.size(); na++){//check arguments if ref types need to be unreffed or reffed and that this is possible
							Type wanted = (Type)consArgs.get(na).copy();
							Type available = consft.inputs.get(na);
							TypeCheckUtils.unlockAllNestedRefs(wanted);
							
							TypeCheckUtils.checkSubType(this, available, wanted, namedConstructor.getLine(), namedConstructor.getColumn(), namedConstructor.getLine(), namedConstructor.getColumn(), false);
						}
					}
					
				}
			}
			
			Type ret = gotola==null?null:gotola.getA();
			
			if(isTypedActor){
				NamedType asNamed = (NamedType)named;
				ClassDef toClass = asNamed.getSetClassDef();
				
				if(toClass!=null){
					if(namedConstructor.actingOn == null && toClass.equals(actor_const)){//create default actor...
						NamedType actee = (NamedType) named.getGenTypes().get(0);
						if(null != actee.getSetClassDef()){
							String actinOnstr = actee.getCheckCastType();
							NamedType genericVersion = actee.getGenericVersion();
							
							if(actee.getGenericTypeElements().size() != genericVersion.getGenericTypeElements().size()){
								this.raiseError(namedConstructor.getLine(), namedConstructor.getColumn(), String.format("Generic parameter count of: %s does not equal: %s", actee.getGenericTypeElements().size(), genericVersion.getGenericTypeElements().size() ));
							}
							else if(genericVersion.allGenericTypesExistant()){
								ArrayList<GenericType> gens = new ArrayList<GenericType>(); 
								ClassDef cd = genericVersion.getSetClassDef();
								while(cd != null){
									for(GenericType gen : cd.classGenricList){
										gen = (GenericType)gen.copy();
										gen.setInOutGenModifier(null);
										gens.add(gen);//prepend
									}
									
									cd = cd.getParentNestor();
								}
								
								if(null == namedConstructor.defaultActorName){
									namedConstructor.defaultActorName = getDefaultActorName(actinOnstr);
									namedConstructor.defaultActorNameFull = namedConstructor.defaultActorName;
									
									if(!gens.isEmpty()){//add <> gens
										StringBuilder ge = new StringBuilder("<");
										int sz = gens.size();
										for(int n=0; n < sz; n++){
											ge.append(""+gens.get(n));
											if(n != sz-1){
												ge.append(", ");
											}
										}
										namedConstructor.defaultActorNameFull += ge.append(">");
									}
								}
								else{
									classNameToDefaultActorName.put(actinOnstr, namedConstructor.defaultActorName);
									defaultActorCnt++;
									namedConstructor.defaultActorName = getDefaultActorName(actinOnstr);
								}
								
								//repoint to default actor
								
								ArrayList<Type> genzFortype = new ArrayList<Type>(gens.size());
								for(GenericType tt : gens){
									Type found = actee.fromClassGenericToQualifiedType.get(tt);
									if(found==null){
										found = tt;
									}
									genzFortype.add(found);
								}
								
								
								namedConstructor.typeee = new NamedType(asNamed.getLine(), asNamed.getColumn(), namedConstructor.defaultActorName, genzFortype);
								namedConstructor.actingOn = ((NamedType) asNamed.getGenTypes().get(0)).getGenericVersion();
							}
						}
					}
				}
			}
			
			
			if(ret instanceof NamedType && (TypeCheckUtils.isTypedActor(this, (NamedType)ret) || TypeCheckUtils.getRefLevels(ret) >=1)){
				
				HashSet<GenericType> unbounded = TypeCheckUtils.findUnboundedGenerics(ret);
				if(!unbounded.isEmpty()){
					NamedType asNamed = (NamedType)ret;
					HashMap<GenericType, GenericType> passedInTypeToNamedGeneric = new HashMap<GenericType, GenericType>();
					HashMap<GenericType, Type> fromGenericToType = asNamed.getFromClassGenericToQualifiedType();
					for(GenericType k: fromGenericToType.keySet()){
						Type val = fromGenericToType.get(k);
						if(val instanceof GenericType){
							passedInTypeToNamedGeneric.put((GenericType)val, k);
						}
					}
					List<Type> rawGens = asNamed.getGenericVersion().getGenTypes();
					HashMap<Type, Integer> rawGenToPosition = new HashMap<Type, Integer>();
					for(int n=0; n < rawGens.size(); n++){
						rawGenToPosition.put(rawGens.get(n), n);
					}
					//why is this so elaborate?
					
					HashSet<GenericType> unboundedFromArgs = new HashSet<GenericType>(unbounded);
					//oh no, we are calling like this: fun getStuff2<Y>(a Y) Object = new actor MyClass<Y>(a) - so what is Y?
					FuncType ft = namedConstructor.constType;
					
					HashMap<GenericType, HashSet<Integer>> unboundedToArgNumber = new HashMap<GenericType, HashSet<Integer>>();
					
					if(null != ft){
						namedConstructor.genericInputsToQualifingArgsAtRuntime = new HashMap<Integer, Integer>();
						//we can qualify those in genericInputsToQualifyAtruntime from the arguments passed into the constructor
						int n = 0;
						ArrayList<Type> originFTInputs = ft.origonatingFuncDef.getFuncType().getInputs();
						
						for(Type input : ft.inputs){//see if the inputs get qualified
							if(input instanceof GenericType && unbounded.contains(input)){
								Type origonalDef = originFTInputs.get(n);
								Integer argPosition = rawGenToPosition.get(origonalDef);
								if(null != argPosition){
									namedConstructor.genericInputsToQualifingArgsAtRuntime.put(argPosition, n-1);//minus one because the first arg is the type array
									//we can map from this fella, great
									unboundedFromArgs.remove(input);
									
									if(origonalDef instanceof GenericType){
										GenericType asGen = (GenericType)origonalDef;
										HashSet<Integer> args = unboundedToArgNumber.get(asGen);
										if(null == args){
											args = new HashSet<Integer>();
											unboundedToArgNumber.put(asGen, args);
										}
										args.add(n);
									}
								}
							}
							n++;
						}
					}
					
					String postMesg = "";
					if(unboundedFromArgs.isEmpty()){
						for(HashSet<Integer> qual : unboundedToArgNumber.values()){
							if(qual.size() > 1){//more than one qualifying, e.g. fun getStuff2<Y>(a Y, b Y) = new actor MyClass(a, b) where MyClass<X>( a X, b X)
								namedConstructor.genericInputsToQualifingArgsAtRuntime = new HashMap<Integer, Integer>();
								unboundedFromArgs = unbounded;
								postMesg = ". Cannot infer type from arguments due to ambiguity arising from more than one argument to infer type from.";
								break;
							}
						}
					}
					
					if(!unboundedFromArgs.isEmpty()){
						warnOnUnboundedGenerics(unboundedFromArgs, namedConstructor.getLine(), namedConstructor.getColumn(), "use as argument in constructor of actor", postMesg);
					}
				}
			}
			
			/*if(ret != null && ret instanceof NamedType && !ret.hasArrayLevels() && TypeCheckUtils.isActor(ers, (NamedType)ret) && !namedConstructor.preventActorRedirect) {
				
				if(namedConstructor.astRedirect == null) {
					Block actorConContainter = new Block(line, col);
					//actorConContainter.isolated=false;
					
					String fname = actorCallingFuncName();
					
					FuncDef callthis = FuncDef.build(ret);
					callthis.setLine(line);
					callthis.setColumn(col);
					callthis.funcName = fname;
					Block fdblock = new Block(line, col);
					fdblock.isMethodBlock=true;
					New refToNc = (New)namedConstructor.copy();
					refToNc.preventActorRedirect=true;//prevent inf loop
					fdblock.add(new DuffAssign(refToNc));
					callthis.funcblock = fdblock;
					
					actorConContainter.add(new DuffAssign(callthis));
					FuncInvoke fi = new FuncInvoke(line, col, fname);
					fi.copyInArgs = true;
					actorConContainter.add(new DuffAssign(fi));
					
					namedConstructor.astRedirect = actorConContainter;
					actorConContainter.setShouldBePresevedOnStack(true);
				}
				
				return namedConstructor.astRedirect.accept(this);
			}*/
			
			return ret==null?named:ret;//by returning our best guess at what is returned we cut down on errors
		} else {
			return null;
		}
	}
	
	/*private static String actorCallingFuncName() {
		return "$actorOp$" + actorCallingFuncCnt++;
	}*/
	
	//private static long actorCallingFuncCnt = 0;
	
	private static ClassDef actor_const = new ClassDefJava(com.concurnas.lang.TypedActor.class);
	
	//not perfect creates one per module but good enough
	private int defaultActorCnt = 0;
	private HashMap<String, String> classNameToDefaultActorName = new  HashMap<String, String>();
	
	private String getDefaultActorName(String forname){
		String found = classNameToDefaultActorName.get(forname);
		if(null == found){
			found = "DefaultActor$" + defaultActorCnt++;
			classNameToDefaultActorName.put(forname, found);
		}
		return found;
	}
	
	private ArrayList<Type> processArgTypes(FuncInvokeArgs argsHolder, boolean isThisOrSupercall, int line, int col){
		
		if(null == argsHolder){
			return new ArrayList<Type>(0);
		}
		
		if(isThisOrSupercall && currentlyInActorDef()){
			if(!argsHolder.asnames.isEmpty()){
				Expression firstOne = argsHolder.asnames.get(0);
				if(!(firstOne instanceof RefName && ((RefName)firstOne).name.equals(TypesForActor))){
					argsHolder.asnames.add(0,new RefName(line, col, TypesForActor));
				}
			}
			else{
				argsHolder.asnames.add(0,new RefName(line, col, TypesForActor));
			}
		}
		
		ArrayList<Expression> args = argsHolder.asnames;
		ArrayList<Type> argsWanted = new ArrayList<Type>(args.size());
		for(Expression e : args )
		{
			this.dotOperatorLHS.push(null);
			this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));

			Type argType = (Type)e.accept(this);
			if(null == argType)
			{
				this.raiseError(e.getLine(), e.getLine(), "Unable to resolve argument for constructor");
				//denyMethodInvokationDueToFiberizationImpossible.pop();
				this.dotOperatorLHS.pop();
				this.currentDotOperatorTracker.pop();
				return null;
			}
			//argType = ((Node)argType).getTaggedType();//TODO: try this and see if tests are ok?

			//TypeCheckUtils.assertRefIsGettable(this, e.getLine(), e.getColumn(), argType);
			
			if(null != argType && argType.getInOutGenModifier() != null){
				argType = (Type)argType.copy();
				argType.setInOutGenModifier(null);
			}
			
			argsWanted.add(argType);

			this.dotOperatorLHS.pop();
			this.currentDotOperatorTracker.pop();
		}
		
		return argsWanted;
	}
	
	private Stack<HashMap<ConstLocationAndType, Type>> currentConstructorCallGraph = new Stack<HashMap<ConstLocationAndType, Type>>();
	
	private boolean inThisOrSuperConstructorInvokation = false; //this(asdasd, asdasd), super(sdfsdf, sdfdsf)
	
	@Override
	public Object visit(ThisConstructorInvoke thisConstructorInvoke) {
		/*if(!currentConstructorDef.isEmpty())
		{//tag irregardless of mostSpec actually existing, else we get two errors where one suffices
			currentConstructorDef.peek().callsAnotherConstructor=true;
		}*/
		enterSuperConstructorCall();
		
		Type found = null;
		inThisOrSuperConstructorInvokation=true;
		
		if(!this.inConstructor)
		{//only when in a constructor.. can this(x,y,z) be called
			this.raiseError(thisConstructorInvoke.getLine(), thisConstructorInvoke.getLine(), String.format("Constructor can only be called inside a class from within existing constructor"));
		}
		else if(!isFirstStmtInBlock)
		{
			this.raiseError(thisConstructorInvoke.getLine(), thisConstructorInvoke.getLine(), String.format("Constructor call must be the first call in a constructor"));
		}
		else
		{
			List<Type> consArgs = processArgTypes(thisConstructorInvoke.args, true, thisConstructorInvoke.getLine(), thisConstructorInvoke.getColumn());
			
			ArrayList<Pair<String, Type>> namessMap = getNameMap(thisConstructorInvoke.args);
			
			EvaluatedConstructor got = evaluateConstructor(new NamedType(thisConstructorInvoke.getLine(), thisConstructorInvoke.getLine(), this.currentlyInClassDef.peek()), consArgs, namessMap, thisConstructorInvoke.getLine(), thisConstructorInvoke.getColumn(), "this ", false);
			
			if(null != got){
				FuncType consft = got.getB();
				if(null != consft && !got.getC()){
					
					//if(null != namessMap && !namessMap.isEmpty()){
						ArrayList<Expression> exprArgs = thisConstructorInvoke.args.asnames;
						ArrayList<Pair<String, Expression>> namessMapExpr = getNameMapExpr(thisConstructorInvoke.args);
						List<Expression> mappedArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, consft, exprArgs, namessMapExpr, got.getD(), false, false);
						//check all mapped
						if(mappedArgs != exprArgs){//changes made?
							thisConstructorInvoke.args.argsWithNamedParams = mappedArgs;
							//also convert arguments
							ArrayList<Pair<String, Type>> namesMapType = getNameMap(thisConstructorInvoke.args);
							consArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, consft, consArgs, namesMapType, got.getD(), true, false);
						}
					//}
					
					
					for(int na=0; na < consArgs.size(); na++){//check arguments if ref types need to be unreffed or reffed and that this is possible
						Type wanted = consArgs.get(na);
						Type available = consft.inputs.get(na);
						
						TypeCheckUtils.checkSubType(this, available, wanted, thisConstructorInvoke.getLine(), thisConstructorInvoke.getColumn(), thisConstructorInvoke.getLine(), thisConstructorInvoke.getColumn(), false);
					}
				}
			}
			
			found = got==null?null:got.getA();
			FuncType resolveed = got==null?null:got.getB();
			if(null != found && !currentConstructorDef.isEmpty())
			{
				ConstructorDef cd = currentConstructorDef.peek();
				currentConstructorCallGraph.peek().put(cd.getConstLocationAndType(), got.getB());
				thisConstructorInvoke.isEnumconstru = cd.isEnumconstru;
				if(thisConstructorInvoke.isEnumconstru){
					thisConstructorInvoke.isEnumconstruSubClass = cd.isEnumconstruSubClass;
				}
			}
			thisConstructorInvoke.resolvedFuncType = resolveed;
			
			if(!currentConstructorDef.isEmpty()){//tag irregardless of mostSpec actually existing, else we get two errors where one suffices
				
				ConstructorDef conDef = currentConstructorDef.peek();
				conDef.callsAnotherConstructor = true;
				if(null !=resolveed){
					conDef.callsThisConstructor=(ConstructorDef)resolveed.origonatingFuncDef;
				}
				
				
			}
		}
		inThisOrSuperConstructorInvokation=false;
		leaveSuperConstructorCall();
		return found;
	}

	private Stack<ConstructorDef> currentConstructorDef = new Stack<ConstructorDef>(); 
	
	@Override
	public Object visit(SuperConstructorInvoke superConstructorInvoke) {
		Type ret = null;
		inThisOrSuperConstructorInvokation=true;
		
		if(!currentConstructorDef.isEmpty())
		{//tag irregardless of mostSpec actually existing, else we get two errors where one suffices
			ConstructorDef cd = currentConstructorDef.peek();
			cd.callsAnotherConstructor=true;
			superConstructorInvoke.isEnumconstru = cd.isEnumconstru;
			if(superConstructorInvoke.isEnumconstru){
				superConstructorInvoke.isEnumconstruSubClass = cd.isEnumconstruSubClass;
			}
		}
		
		if(!this.inConstructor)
		{//only when in a constructor.. can super(x,y,z) be called
			this.raiseError(superConstructorInvoke.getLine(), superConstructorInvoke.getLine(), String.format("Super constructor can only be called inside a class from within existing constructor"));
		}
		else if(!isFirstStmtInBlock)
		{
			this.raiseError(superConstructorInvoke.getLine(), superConstructorInvoke.getLine(), String.format("Super constructor call must be the first call in a constructor"));
		}
		else
		{
			enterSuperConstructorCall();
			ClassDef cd = this.currentlyInClassDef.peek();
			
			if(cd.isEnum && !cd.isEnumSubClass){
				this.raiseError(superConstructorInvoke.getLine(), superConstructorInvoke.getLine(), String.format("Super constructor cannot be directly invoked for enums"));
			}
			
			/*superConstructorInvoke.isEnumconstru = cd.isEnumconstru;
			if(superConstructorInvoke.isEnumconstru){
				superConstructorInvoke.isEnumconstruSubClass = cd.isEnumconstruSubClass;
			}*/
			
			
			ClassDef superc = cd.getSuperclass();
			
			if(null != superc && superc.isLocalClass){
				superc.localsuperInvokations.add(superConstructorInvoke);
			}
			
			//TODO: qualify supertype here which is called in superconstructor
			//super() - ensure generic type is passed upwards
			
			NamedType supNT = new NamedType(superConstructorInvoke.getLine(), superConstructorInvoke.getLine(), superc);
			HashMap<GenericType, Type> ugh = new HashMap<GenericType, Type>();
			for(Type key : cd.superclassTypeToClsGeneric.keySet())
			{
				ugh.put((GenericType)key, cd.superclassTypeToClsGeneric.get(key));
			}
			supNT.augmentfromClassGenericToQualifiedType(ugh);
			List<Type> consArgs = processArgTypes(superConstructorInvoke.args, true, superConstructorInvoke.getLine(), superConstructorInvoke.getColumn());

			ArrayList<Pair<String, Type>> namessMap = getNameMap(superConstructorInvoke.args);
			EvaluatedConstructor got = evaluateConstructor(supNT, consArgs, namessMap, superConstructorInvoke.getLine(), superConstructorInvoke.getColumn(), "super ", false);
			
			if(null != got){
				FuncType consft = got.getB();
				if(null != consft && !got.getC()){
					
					
					//if(null != namessMap && !namessMap.isEmpty()){//JPT: copy pasted this block from elsewhere, naughty
						ArrayList<Expression> exprArgs = superConstructorInvoke.args.asnames;
						ArrayList<Pair<String, Expression>> namessMapExpr = getNameMapExpr(superConstructorInvoke.args);
						List<Expression> mappedArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, consft, exprArgs, namessMapExpr, got.getD(), false, false);
						//check all mapped
						if(mappedArgs != exprArgs){//changes made?
							superConstructorInvoke.args.argsWithNamedParams = mappedArgs;
							//also convert arguments
							ArrayList<Pair<String, Type>> namesMapType = getNameMap(superConstructorInvoke.args);
							consArgs = TypeCheckUtils.mapFunctionParameterNamesToNewArguments(this, consft, consArgs, namesMapType, got.getD(), true, false);
						}
					//}
					
					
					if(consArgs != null) {
						for(int na=0; na < consArgs.size(); na++){//check arguments if ref types need to be unreffed or reffed and that this is possible
							Type wanted = consArgs.get(na);
							Type available = consft.inputs.get(na);
							
							TypeCheckUtils.checkSubType(this, available, wanted, superConstructorInvoke.getLine(), superConstructorInvoke.getColumn(), superConstructorInvoke.getLine(), superConstructorInvoke.getColumn(), false);
						}
					}
				}
			}
			
			ret = got==null?null:got.getA();
			FuncType resolveed = got==null?null:got.getB();
			leaveSuperConstructorCall();
			superConstructorInvoke.resolvedFuncType = resolveed;
		}
		inThisOrSuperConstructorInvokation=false;
		return ret;
	}

	@Override
	public Object visit(FuncRefArgs funcRefArgs) {
		for(Object o : funcRefArgs.exprOrTypeArgsList)
		{
			/*if(o instanceof Type){
				return ((Type)o).accept(this);
			}
			else if(o instanceof Expression){
				return ((Expression)o).accept(this);
			}*/
			
			if(o instanceof Type){
				((Type)o).accept(this);
			}
			else if(o instanceof Expression){
				Expression e = ((Expression)o);
				/*Type tagged = (Type)*/ e.accept(this);
				//e.setTaggedType(tagged);
			}
			else{
				this.raiseError(funcRefArgs.getLine(), funcRefArgs.getColumn(), String.format("Compiler error, unexpected token for evaluation: %s", o.getClass().toString()));
			}
		}
				
		return null;
	}

	@Override
	public Object visit(GenericType genericType) {
		genericType.upperBound.accept(this);
		
		return genericType;
	}
	
	@Override
	public ClassDef getImportedOrDeclaredClassDef(String name) {
		// TODO: wtf is this for?
		return null;
	}

	@Override
	public ErrorRaiseable getErrorRaiseableSupression() {
		return ers;
	}

	@Override
	public Object visit(NOP nop) {
		return this.const_void;
	}

	public Object visit(RefQualifiedGenericNamedType refQualifiedGenericNamedType) {
		
		if(!refQualifiedGenericNamedType.isInDotOperator){//prevents this: xx =  MyClass<String> //cannot be on its own
			this.raiseError(refQualifiedGenericNamedType.getLine(), refQualifiedGenericNamedType.getColumn(), "type cannot be used in this way");//TODO: enhance with name of thing which is not suitable
		}
		
		return refQualifiedGenericNamedType.mynamed.accept(this);
	}

	private String getTempVar(){
		return "temp$" + tempVarCnt++;
	}
	
	@Override
	public Object visit(InExpression inExpression) {
		Type thingType = (Type)inExpression.thing.accept(this);
		Type insideOfType = (Type)inExpression.insideof.accept(this);
		
		flagNullableForOperation(inExpression.insideof.getLine(), inExpression.insideof.getColumn(), insideOfType);
		
		this.maskErrors(true);
		Object ret = visitRealInExpression(inExpression, thingType, insideOfType);
		ArrayList<CapMaskedErrs> masekErrors = this.getmaskedErrors();
		
		if(!masekErrors.isEmpty()) {
			ArrayList<Type> lhsTypes = TypeCheckUtils.extractIntermediateVectTypes(ers, thingType, false);
			ArrayList<Type> rhsTypes = TypeCheckUtils.extractIntermediateVectTypes(ers, insideOfType, false);
			
			if(lhsTypes.isEmpty() && rhsTypes.isEmpty()) {//certainly cannot be vectorized
				this.applyMaskedErrors(masekErrors);
			}else {//rhs may be vectoriable
				this.maskErrors();
				Expression origInsideOf = inExpression.insideof;
				Expression origThing = inExpression.thing;
				if(!rhsTypes.isEmpty()) {
					inExpression.insideof = new Vectorized((Expression)inExpression.insideof.copy());
					insideOfType = (Type)inExpression.insideof.accept(this);
				}else {//lhs may be vectorizable
					inExpression.thing = new Vectorized((Expression)inExpression.thing.copy());
					thingType = (Type)inExpression.thing.accept(this);
				}
				
				Object retMaybe = visitRealInExpression(inExpression, thingType, insideOfType);
				if(!this.maskedErrors()) {
					ret = retMaybe;
				}else {//doesnt work
					inExpression.insideof = origInsideOf;
					inExpression.thing = origThing;
					this.applyMaskedErrors(masekErrors);
				}
			}
		}
		
		return ret;
		
	}
	
	public Object visitRealInExpression(InExpression inExpression, Type thingType, Type insideOfType) {
		
		int line = inExpression.getLine();
		int col = inExpression.getColumn();
		
		Type ret = null;
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> thingVect = vectorizedOperator(thingType);
		Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> insideOfVect = vectorizedOperator(insideOfType);
		
		//auto vect here. if config non compatible and can be converted etc
		
		ArrayList<Pair<Boolean, NullStatus>> vectorized = null;
		ArrayList<Pair<Boolean, NullStatus>> thingVectLevels = thingVect.getA();
		ArrayList<Pair<Boolean, NullStatus>> insideOfVectLevels = insideOfVect.getA();
		FuncInvoke vectFuncInvoke = null;
		
		Expression containsMethodCall = null;
		
		/*if(insideOfVectLevels != null && !insideOfVectLevels.get(0)) {
			this.raiseError(line, col, String.format("Vectorization may not be applied to right hand side of %s operator when the type of the right hand side is a list", inExpression.inverted?"not in":"in"));
			ret = const_boolean;
		}
		else*/ if(thingVectLevels != null &&  null != insideOfVectLevels) {
			this.raiseError(line, col, String.format("Only left or right hand side operand of %s expression may be vectorized, not both", inExpression.inverted?"not in":"in"));
			ret = const_boolean;
		}else {
			if(thingVectLevels != null) {
				ArrayList<Type> insideOfTypesIfVect = TypeCheckUtils.extractIntermediateVectTypes(ers, insideOfType, false);
				
				boolean expandableInsideof = !insideOfTypesIfVect.isEmpty();
				
				Type shoudlbeinstacenof = expandableInsideof?insideOfTypesIfVect.get(0):insideOfType;
				
				Type unvectthing = (Type)thingType.copy();
				unvectthing.setVectorized(null);
				ArrayList<Type> thingTypesIfVect = TypeCheckUtils.extractIntermediateVectTypes(ers, unvectthing, false);
				
				int vectConsume=0;
				Type thingTypeResolvesto = null;
				for(Type totry : thingTypesIfVect) {
					vectConsume++;
					
					vectFuncInvoke = canBeOperatorOverloaded(shoudlbeinstacenof, totry, "contains", inExpression.thing, line, col, (Node)inExpression.containsMethodCall);
					
					if(null != vectFuncInvoke || (expandableInsideof && null != TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), shoudlbeinstacenof, totry))) {
						vectorized = new ArrayList<>(thingVectLevels.subList(0, vectConsume));
						thingTypeResolvesto=totry;
						break;
					}
				}
				
				if(vectorized != null) {
					thingType = thingTypeResolvesto;
				}
			}else if(insideOfVectLevels != null){//insideOfVectLevels
				//thing on rhs vectorized, copy paste yuck!
				ArrayList<Type> thingsTypes = TypeCheckUtils.extractIntermediateVectTypes(ers, thingType , false);
				
				boolean expandableInsideof = !thingsTypes.isEmpty();
				
				Type shoudlbeinstacenof = expandableInsideof?thingsTypes.get(0):thingType;
				
				Type insideOfCopy = (Type)insideOfType.copy();
				Vectorization vtype = insideOfCopy.setVectorized(null);
				ArrayList<Type> thingTypesIfVect = TypeCheckUtils.extractIntermediateVectTypes(ers, insideOfCopy, false);
				
				int vectConsume=0;
				Type rhsIsInResolvesTo = null;
				for(Type totry : thingTypesIfVect) {
					vectConsume++;
					
					vectFuncInvoke = canBeOperatorOverloaded(totry, shoudlbeinstacenof, "contains", inExpression.thing, line, col, (Node)inExpression.containsMethodCall);
					
					if(null != vectFuncInvoke || (expandableInsideof && null != TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), totry, shoudlbeinstacenof))) {
						if(null != vectFuncInvoke) {
							//create full expr
							Vectorized iofasVect = (Vectorized)inExpression.insideof;
							containsMethodCall = new VectorizedFuncInvoke(line, col, "contains", FuncInvokeArgs.singleFIA(line,  col, inExpression.thing), null, iofasVect.expr, vtype == Vectorization.SELF, false);
							if(inExpression.inverted){
								containsMethodCall = new NotExpression(line, col, new Vectorized(containsMethodCall));
							}
						}
						
						vectorized = new ArrayList<>(insideOfVectLevels.subList(0, vectConsume));
						rhsIsInResolvesTo=totry;
						break;
					}
				}
				
				if(vectorized != null) {
					insideOfType = rhsIsInResolvesTo;
				}
			}
		}

		if(null == ret) {
			if(null == insideOfType || null == thingType ){
				ret = const_boolean;//seems reasonable
			}
			else if(TypeCheckUtils.isVoid(thingType)){
				this.raiseError(inExpression.insideof.getLine(), inExpression.insideof.getColumn(), String.format("unexpected type void inside %s expression", inExpression.inverted?"not in":"in"));
				ret = const_boolean;//seems reasonable
			}
		}
		
		if(null == ret) {

			if(vectorized != null) {
				inExpression.depth = vectorized;
			}
			
			if(insideOfType.hasArrayLevels() && vectFuncInvoke == null){
				
				Type arminus1 = (Type)insideOfType.copy();
				arminus1.setArrayLevels(arminus1.getArrayLevels()-1);
				
				if(null != TypeCheckUtils.checkSubType(this, arminus1, thingType, inExpression.insideof.getLine(), inExpression.insideof.getColumn(), inExpression.thing.getLine(), inExpression.thing.getColumn())){
					//convert to for loop check
					
					//{thingtype = cont.thing; ret = false; for( tempX in thingy){ if(tempX == thingtype) { ret= true; break;}; } ret}
					
					String forElement = getTempVar();
					String retvar = getTempVar();
					String thingBeingChecked = getTempVar();
					Block isArrayMatch = new Block(line, col);
					isArrayMatch.isolated=true;
					isArrayMatch.setShouldBePresevedOnStack(true);
					isArrayMatch.add(new LineHolder(new AssignExisting(line, col, new RefName(thingBeingChecked), AssignStyleEnum.EQUALS, inExpression.thing)));
					isArrayMatch.add(new LineHolder(new AssignExisting(line, col, new RefName(retvar), AssignStyleEnum.EQUALS, new RefBoolean(line, col, false))));
					
					
					Block insideFor = new Block(line, col);
					ForBlock forblk = new ForBlock(line, col, forElement, null, inExpression.insideof, insideFor, null);
					Block eqCheckPass = new Block(line, col);
					
					EqReExpression iftest = new EqReExpression(line, col, new RefName(thingBeingChecked),  GrandLogicalOperatorEnum.EQ, new RefName(forElement));
					
					IfStatement eqCheck = new IfStatement(line, col, iftest, eqCheckPass, null);
					insideFor.add(new LineHolder(eqCheck));
					
					eqCheckPass.add(new LineHolder(new AssignExisting(line, col, new RefName(retvar), AssignStyleEnum.EQUALS_STRICT, new RefBoolean(line, col, true))));
					eqCheckPass.add(new LineHolder(new BreakStatement(line, col)));
					
					isArrayMatch.add(new LineHolder(forblk));
					if(!inExpression.inverted){
						isArrayMatch.add(new LineHolder(new DuffAssign(new RefName(retvar))));
					}
					else{
						isArrayMatch.add(new LineHolder(new DuffAssign(new NotExpression(line, col, new RefName(retvar)))));
					}
					
					
					isArrayMatch.accept(this);
					
					if(vectorized == null) {
						inExpression.isArrayMatch = isArrayMatch;
					}
				}
				
				ret = const_boolean;
			}
			else if(!(insideOfType instanceof NamedType)){
				this.raiseError(inExpression.insideof.getLine(), inExpression.insideof.getColumn(), String.format("%s check can only be performed on objets", inExpression.inverted?"not in":"in"));
				return const_boolean;//seems reasonable
			}
			else{
				NamedType asNamed = (NamedType)insideOfType;
				
				if( null != TypeCheckUtils.checkSubType(this.ers, const_Pattern, thingType, 0, 0, 0, 0) ){
					//e.g. x = r"a*b" in "aaaaaabb" 
					if(!asNamed.equals(const_string)){
						this.raiseError(inExpression.insideof.getLine(), inExpression.insideof.getColumn(), "Regex pattern match can only be performend on Strings");
					}
					inExpression.isRegexPatternMatch = true;
					
					ret = const_boolean;
				}
				else{
					if(containsMethodCall == null) {
						FuncInvoke containsFuncInvokation;
						if(null != vectFuncInvoke) {
							containsFuncInvokation = vectFuncInvoke;
						}else {
							if(null != TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), const_map, asNamed, 0, 0, 0, 0)){
								containsFuncInvokation = new FuncInvoke(line, col, "containsKey", inExpression.thing);
							}
							else{//string lists etc, vanilla objects
								containsFuncInvokation = new FuncInvoke(line, col, "contains", inExpression.thing);
							}
						}
						
						containsMethodCall =  DotOperator.buildDotOperator(line, col, inExpression.insideof, containsFuncInvokation);
						
						if(inExpression.inverted){
							containsMethodCall = new NotExpression(line, col, containsMethodCall);
						}
					}
					
					if(null == inExpression.containsMethodCall) {
						inExpression.containsMethodCall = containsMethodCall;
					}
					
					this.maskErrors(true);
					Type resolvesTo = (Type)inExpression.containsMethodCall.accept(this);
					ArrayList<CapMaskedErrs> errrs = this.getmaskedErrors();
					if(!errrs.isEmpty()){
						applyMaskedErrors(errrs, String.format("inside %s expression - ", inExpression.inverted?"not in":"in"));
						inExpression.containsMethodCall=null;
					}
					inExpression.depth = null;
					return inExpression.setTaggedType(resolvesTo);//seems reasonable
				}
			}
		}
		
		if(vectorized != null) {
			if(null != ret /*&& !lastWasOpOverload*/) {
				ret = TypeCheckUtils.applyVectStruct(vectorized, ret);
			}
		}
		
		return inExpression.setTaggedType(ret);//seems reasonable
		
	}

	private void buildEnumSubclasses(EnumDef enumDefa, ArrayList<EnumItem> enumItemz){
		//e.g. enum ASD{ PLUS{ f=8} }//plus has own stuff seperate from main enum cls
		int idx = 0;
		for(EnumItem itm : enumItemz){
			
			if(itm.block !=null && !itm.block.isEmpty()){
				ClassDef fakeclassDef = itm.fakeclassDef;
				String itemName = enumDefa.enaumName+ "$" + idx;
				if(null == fakeclassDef){
					//ok we need a custom class for this
					fakeclassDef = new ClassDef(enumDefa.getLine(), enumDefa.getColumn(), itemName, this.packageName.peek());
					fakeclassDef.classBlock=itm.block;
					fakeclassDef.setCcFullName(enumDefa.bcFullName() + "$" + idx) ;
					fakeclassDef.setResolvedSuperType(this, enumDefa.fakeclassDef);
					fakeclassDef.setParentNestor(enumDefa.fakeclassDef);
					fakeclassDef.isEnumSubClass=true;
					fakeclassDef.isEnum=true;
					itm.fakeclassDef=fakeclassDef;
					itm.className = itemName;
				}else{
					itm.fakeclassDef.packageName = this.packageName.peek();
					itm.fakeclassDef.setCcFullName(enumDefa.bcFullName() + "$" + idx) ;
				}
				//now accept body block
				TheScopeFrame classSF = fakeclassDef.getScopeFrameGenIfMissing(this.currentScopeFrame, fakeclassDef);

				TheScopeFrame parentDF = this.currentScopeFrame;
				parentDF.setClassDef(classSF, itemName, fakeclassDef, Modifier.PUBLIC);
				
				//packageName.push(enumDef.enaumName);
				
				//this.addImport(enumDef.enaumName, getFullyDottedPackage()); //add C -> a.b.C to local ref table 
				
				this.currentScopeFrame = classSF;
				this.currentScopeFrame.enterScope();

				nestorParens.push(itemName);
				currentlyInClassDef.add(fakeclassDef);
				
				itm.block.isClass = true;
				itm.block.isEnum = true;
				
				currentConstructorCallGraph.push(new HashMap<ConstLocationAndType, Type>());
				
				itm.block.accept(this);

				HashMap<ConstLocationAndType, Type> constructorInvokeGraph = currentConstructorCallGraph.pop();
				checkConstrutorInvokeGraphForLoops(constructorInvokeGraph);
				
				currentlyInClassDef.pop();
				nestorParens.pop();
				//packageName.pop();
				
				this.currentScopeFrame = this.currentScopeFrame.leaveScope();
				//add to local dictionary of names?
				this.currentScopeFrame.setClassDef(classSF, itemName, fakeclassDef, Modifier.PUBLIC);
			}
			/*else{itm.fakeclassDef=null;}*/
			idx++;
		}
	}
	
	private void addConstructorsTSubEnums(EnumDef enumDefa, ArrayList<EnumItem> enumItemz){
		//e.g. enum ASD{ PLUS{ f=8} }//plus has own stuff seperate from main enum cls
		HashSet<FuncType> mastercons = enumDefa.fakeclassDef.getAllConstructors();
		
		for(EnumItem itm : enumItemz){
			if(null != itm.fakeclassDef){
				//get all cons, check sig here, add only if missings
				
				//remove all previously defined synthetic constructors
				ArrayList<LineHolder> lines = new ArrayList<LineHolder>(itm.fakeclassDef.classBlock.lines.size());
				for(LineHolder lh : itm.fakeclassDef.classBlock.lines){
					if(lh.l instanceof ConstructorDef){
						if(((ConstructorDef)lh.l).isAutoGennerated){
							continue;
						}
					}
					lines.add(lh);
				}
				
				HashSet<FuncType> locallyDefined = itm.fakeclassDef.getAllConstructors();
				for(FuncType con : mastercons){
					if(!locallyDefined.contains(con)){//add it
						ArrayList<ConstArg> conArgs = new ArrayList<ConstArg>();
						ArrayList<Expression> forSup = new ArrayList<Expression>();
						HashSet<String> sups = new HashSet<String>();
						int n=0;
						List<Type> inputs = con.getInputs();
						for(Type ta : inputs){
							String argName = "a" + n++;
							boolean isLast = inputs.size() == n;
							RefName supercon = new RefName(argName);
							conArgs.add(new ConstArg(argName, ta, true, null, null, ta.hasArrayLevels() && isLast, false, false));
							forSup.add(supercon);
							sups.add(argName);
						}
						
						FunctionGenneratorUtils.addConstructor(this.ers, this, itm.fakeclassDef, conArgs, forSup, sups, itm.getLine(), itm.getColumn(), false, false, null, true, false);
					}
				}
			}
		}
	}
	
	@Override
	public Object visit(EnumDef enumDef) {
		int line = enumDef.getLine();
		int col = enumDef.getColumn();

		if(!this.currentlyInClassDef.isEmpty()){
			if(this.currentlyInClassDef.peek().isEnumSubClass){
				this.raiseError(line, col, "enums cannot be defined inside enum elements");
				return null;
			}
		}
		
		nestorParens.push(enumDef.enaumName);
		enumDef.setCcFullName(getfullClassName());
		
		//enumDef.block.accept(this);

		if(enumDef.accessModifier == null){//nested
			if(this.currentScopeFrame.isAnnotation){
				enumDef.accessModifier=AccessModifier.PUBLIC;
			}
			else{
				enumDef.accessModifier = !this.currentlyInClassDef.isEmpty()?AccessModifier.PRIVATE: AccessModifier.PUBLIC;
			}
		}
		
		if(this.currentScopeFrame.isAnnotation && enumDef.accessModifier != AccessModifier.PUBLIC){
			this.raiseError(line, col, "enums within annotations can only be defined as public");
		}
		
		Annotations annotationsForConstructor=null;
		if(enumDef.annotations != null){
			for(Annotation annot : enumDef.annotations.annotations){
				annot.location = Annotation.AnnotationLocation.CLASS;
			}
			
			annotationsForConstructor = extractAnnotationsForElement(enumDef.annotations, "this", false);
			enumDef.annotations.setUsedAt(ElementType.TYPE);
			enumDef.annotations.accept(this);
		}
		
		//=> makes a calssdef
		if(null == enumDef.fakeclassDef){
			ClassDef fakeclassDef = new ClassDef(enumDef.getLine(), enumDef.getColumn(), enumDef.enaumName, this.packageName.peek());
			fakeclassDef.classBlock=enumDef.block.mainBlock;
			fakeclassDef.accessModifier = enumDef.accessModifier;
			fakeclassDef.setCcFullName(enumDef.bcFullName());
			fakeclassDef.setResolvedSuperType(this, new ClassDefJava(Enum.class));
			fakeclassDef.superClassGenricList = new ArrayList<Type>(0);
			fakeclassDef.superClassGenricList.add(new NamedType(fakeclassDef));
			fakeclassDef.isEnum=true;
			fakeclassDef.annotations=enumDef.annotations;
			
			if(!this.currentlyInClassDef.isEmpty()){
				fakeclassDef.setParentNestor(this.currentlyInClassDef.peek());
			}
			
			enumDef.fakeclassDef=fakeclassDef;
		}
		else{
			enumDef.fakeclassDef.packageName = this.packageName.peek();//incase nested in a local class and its been remapped
			enumDef.fakeclassDef.setCcFullName(enumDef.bcFullName());
		}
		
		enumDef.fakeclassDef.classDefArgs = enumDef.classDefArgs;

		TheScopeFrame classSF = enumDef.fakeclassDef.getScopeFrameGenIfMissing(this.currentScopeFrame, enumDef.fakeclassDef);

		buildEnumSubclasses(enumDef, enumDef.block.enumItemz);
		

		TheScopeFrame parentDF = this.currentScopeFrame;
		
		if(parentDF.hasClassDef(parentDF, enumDef.enaumName, false, true)){
			this.raiseError(line, col, String.format("enum %s has already been declared in current scope" , enumDef.enaumName));
		}
		
		parentDF.setClassDef(classSF, enumDef.enaumName, enumDef.fakeclassDef, Modifier.PUBLIC);
		
		packageName.push(enumDef.enaumName);

		currentConstructorCallGraph.push(new HashMap<ConstLocationAndType, Type>());
		
		if(this.currentlyInClassDef.isEmpty()){//only add at top level
			this.addImport(enumDef.enaumName, getFullyDottedPackage(), false); //add C -> a.b.C to local ref table 
		}
		
		this.currentScopeFrame = classSF;
		this.currentScopeFrame.enterScope();
		
		currentlyInClassDef.add(enumDef.fakeclassDef);
		//initblocks.push(new ArrayList<InitBlock>());
		
		for(EnumItem x : enumDef.block.enumItemz){
			TypeAndLocation taldet = createTypeAndLocationVarHolder(x.getLine(), x.getColumn(), new NamedType(enumDef.fakeclassDef), true, AccessModifier.PUBLIC, true, false, false, false, false, false, false);//cannot create final varibale via this path (though you can create a new one)
			classSF.setVariable(classSF, x.name, taldet, true, this.level, x.annotations, false);//TODO: enum element annotations
			classSF.setVariableAssigned(x.name);
		}
		
		currentScopeFrame.paThisIsModule =false;
		//add implicit functions
		
		//FuncDef funcDef = new FuncDef();
		{
			ArrayList<Type> inputs = new ArrayList<Type>();
			inputs.add(const_string);
			FuncType theFuncType = new FuncType(inputs, new NamedType(enumDef.fakeclassDef));//funcDef.getFuncType();
			theFuncType.isImplicit=true;
			TypeAndLocation tt = createTypeAndLocationFuncHolder(line, col, theFuncType, false, true);//TODO: is this the correct location?
			this.currentScopeFrame.setFuncDef(this.currentScopeFrame, "valueOf", tt, Modifier.PUBLIC);
		}
		
		{
			NamedType ar = new NamedType(enumDef.fakeclassDef);
			ar.setArrayLevels(1);
			FuncType theFuncType = new FuncType(ar);//ret enum array
			theFuncType.isImplicit=true;
			TypeAndLocation tt = createTypeAndLocationFuncHolder(line, col, theFuncType, false, true);//TODO: is this the correct location?
			this.currentScopeFrame.setFuncDef(this.currentScopeFrame, "values", tt, Modifier.PUBLIC);
		}
		
		enumDef.block.mainBlock.isClass = true;
		enumDef.block.mainBlock.isEnum = true;
		
		enumDef.block.accept(this);
		
		enumDef.block.mainBlock.accept(this);
		
		ArrayList<Type> defConArgs = new ArrayList<Type>();
		ArrayList<ConstArg> constructorArgs = new ArrayList<ConstArg>();
		boolean shouldMakeConstructor = validateClassDefArgs(enumDef.fakeclassDef, this.currentScopeFrame, new HashSet<String>(), new HashSet<String>(),  defConArgs, constructorArgs);
				
		HashSet<FuncType> consExistAlready = this.currentScopeFrame.getConstructor(null);
		FuncType signature = null;
		
		if(shouldMakeConstructor){//if constructor has been added already, dont do it again! user def or otherwise
			signature = new FuncType(defConArgs, null);
			shouldMakeConstructor = !consExistAlready.contains(signature);//just in case user has defined one of these already
			
			if(shouldMakeConstructor && (!constructorArgs.isEmpty() )){//rewrite ast -iif either the superconstructor or the this consturcor has elements to instantiate
				FunctionGenneratorUtils.addConstructor(this.ers, this, enumDef.fakeclassDef, constructorArgs, new ArrayList<Expression>(), new HashSet<String>(), enumDef.getLine(), enumDef.getColumn(), false, true, annotationsForConstructor, false, false);
			}
		}
		
		if(shouldMakeConstructor && this.currentScopeFrame.getConstructor(null).isEmpty() && constructorArgs.isEmpty()){//no constructors so we must add a default one with no args
			//and we havnt just created one above
			FunctionGenneratorUtils.addConstructor(this.ers, this, enumDef.fakeclassDef, new ArrayList<ConstArg>(), new ArrayList<Expression>(), new HashSet<String>(), enumDef.getLine(), enumDef.getColumn(), false, true, annotationsForConstructor, false, false);
		}

		addConstructorsTSubEnums(enumDef, enumDef.block.enumItemz);

		//initblocks.pop();
		currentlyInClassDef.pop();
		nestorParens.pop();
		packageName.pop();
		
		HashMap<ConstLocationAndType, Type> constructorInvokeGraph = currentConstructorCallGraph.pop();
		checkConstrutorInvokeGraphForLoops(constructorInvokeGraph);
		
		this.currentScopeFrame = this.currentScopeFrame.leaveScope();
		//add to local dictionary of names?
		this.currentScopeFrame.setClassDef(classSF, enumDef.enaumName, enumDef.fakeclassDef, enumDef.accessModifier.getByteCodeAccess());
		
		return null;
	}

	@Override
	public Object visit(EnumItem enumItem) {
		//enumItem.args.accept(this);
		//unused
		
		if(enumItem.annotations != null){
			enumItem.annotations.setUsedAt(ElementType.FIELD);
			enumItem.annotations.accept(this);
		}
		
		//New nc = enumItem.mappedConstructor;
		//if(null == nc){
			ClassDef fakeclassDef = enumItem.fakeclassDef;
			NamedType nt = new NamedType(fakeclassDef==null?this.currentlyInClassDef.peek():fakeclassDef);
			nt.ignorePPPCheck = true;
			New nc = new New(enumItem.getLine(), enumItem.getColumn(), nt, enumItem.args, true);
			nc.enumItemNameAndIndex = new Pair<String, Integer>(enumItem.name, enumItem.idx);
			enumItem.mappedConstructor = nc;
		//}
		
		
		nc.accept(this);
		
		return null;
	}

	@Override
	public Object visit(EnumBlock enumBlock) {
		
		HashSet<String> enumsDeclared = new HashSet<String>();
		int idx = 0;
		for(EnumItem itm :  enumBlock.enumItemz){
			if(enumsDeclared.contains(itm.name)){
				this.raiseError(itm.getLine(), itm.getColumn(), "Duplicate enum value declaration: " + itm.name);
			}
			enumsDeclared.add(itm.name);
			itm.idx = idx++;
			itm.accept(this);
		}
		
		//enter class etc
		
		//enumBlock.mainBlock.accept(this);
		
		return null;
	}

	//private Stack<ArrayList<InitBlock>> initblocks = new Stack<ArrayList<InitBlock>>();
	
	@Override
	public Object visit(InitBlock initBlock) {
		if(!(this.currentScopeFrame.isClass() && this.currentlyInClassDef.peek().hasClassDefArgs())){
			ClassDef where = this.currentlyInClassDef.isEmpty()?null:this.currentlyInClassDef.peek();
			
			if(where != null && where.isTrait) {
				this.raiseError(initBlock.getLine(), initBlock.getColumn(), "init blocks may not be defined within traits");
			}else {
				this.raiseError(initBlock.getLine(), initBlock.getColumn(), "init block may only be declared within classes or enums having declaration level parameters");
			}
		}
		return null;
	}
	
	
	
	@Override
	public Object visit(Annotation annotation){
		
		String className = annotation.className;
		ClassDef resolvedTo = getImportedClassDef(className);
		
		if(!annotation.validAtThisLocation){//e.g. function(@Annot(name="hi"))//this is not a valid place for an annotation
			this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("Annotation: %s cannot be used at this location",  className));
		}
		
		if(null == resolvedTo){
			this.raiseError(annotation.getLine(), annotation.getColumn(), "Unable to resolve type corresponding to name: " + className);
			return null;
		}
		else if(UncallableMethods.UNAVAILABLE_CLASSES.contains(resolvedTo))
		{//null check needed?
			this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("Instances of %s cannot be created", resolvedTo));
			return null;
		}
		else if(!resolvedTo.isAnnotation()){
			this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("%s is not an annotation", className));
			return null;
		}
		
		//ensure access modifier respected
		checkTypeDefAccessiableCD(resolvedTo, annotation.getLine(), annotation.getColumn());
		
		
		//ensure instantiated correctly
		List<Thruple<String, FuncType, Boolean>> args = resolvedTo.getAllAnnotationMethods();

		ArrayList<String> argNames = new ArrayList<String>(args.size());
		ArrayList<String> argsWithoutDefault = new ArrayList<String>(args.size());
		ArrayList<Pair<String, FuncType>> argsWithoutDefaultPlusType = new ArrayList<Pair<String, FuncType>>(args.size());//lazy
		for(Thruple<String, FuncType, Boolean> arg : args){
			if(!arg.getC()){
				argsWithoutDefault.add(arg.getA());
				argsWithoutDefaultPlusType.add(new Pair<String, FuncType>(arg.getA(), arg.getB()));
			}
			argNames.add(arg.getA());
		}
		
		//HashMap<String, Type> keyToType = new HashMap<String, Type>();
		
		if(annotation.singleArg != null){
			
			//if one value great, if more than one pick the one with no default
			FuncType expectedType;
			String feildName;
			if(args.size() == 1){
				expectedType = args.get(0).getB();
				feildName = args.get(0).getA();
			}
			else{
				if(argsWithoutDefault.size() > 1){
					this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("More than one value to qualify from single annotation arugment. Could be one of: %s", Utils.justJoin(argsWithoutDefault)));
					return null;
				}
				else if(argsWithoutDefault.isEmpty()){
					this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("More than one value to qualify from single annotation arugment. Could be one of: %s", Utils.justJoin(argNames)));
					return null;
				}
				else{
					expectedType = argsWithoutDefaultPlusType.get(0).getB();
					feildName = argsWithoutDefaultPlusType.get(0).getA();
				}
			}
			
			annotation.singleArgFeildName = feildName;
			
			annotation.keyToType.put(feildName, expectedType.retType);
			
			//check the one and only arg types wise
			Expression expr = annotation.singleArg;
			validizeAnnotationUseage(expr);
			/*if(expr instanceof Annotation){
				((Annotation)expr).validAtThisLocation=true;
			}*/
			
			Type argType = (Type)expr.accept(this);
			
			if(null == TypeCheckUtils.checkSubType(this.ers, expectedType.retType, argType, 0, 0, 0, 0)){
				boolean pass=false;
				if(argType.getArrayLevels() == 0){//only thing it could be, upgrade arg type to array
					Type toArrPlus1 = (Type)argType.copy();
					toArrPlus1.setArrayLevels(1);
					pass = null != TypeCheckUtils.checkSubType(this.ers, expectedType.retType, toArrPlus1, 0, 0, 0, 0);
				}
				
				if(!pass){
					this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("Annotation type mismatch: cannot convert from %s to %s", argType, expectedType.retType));
				}
				
				//this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("Annotation type mismatch: cannot convert from %s to %s", argType, expectedType.retType));
				//return null;
			}
		}
		else if(annotation.manyArgs != null && !annotation.manyArgs.isEmpty()){
			HashMap<String, Pair<FuncType, Boolean>> anotArgs = new HashMap<String, Pair<FuncType, Boolean>>();
			
			for(Thruple<String, FuncType, Boolean> a : args){
				anotArgs.put(a.getA(), new Pair<FuncType, Boolean>(a.getB(), a.getC()));
			}

			Set<String> keysAlreadyh = new HashSet<String>();
			
			for(Pair<String, Expression> providedArg : annotation.manyArgs){
				String key = providedArg.getA();
				Expression expr = providedArg.getB();
				validizeAnnotationUseage(expr);
				/*if(expr instanceof Annotation){
					((Annotation)expr).validAtThisLocation=true;
				}*/
				
				boolean prevdsse = disableStringSubExprs;
				disableStringSubExprs = true;
				Type argType = (Type)expr.accept(this);
				disableStringSubExprs = prevdsse;
				
				if(keysAlreadyh.contains(key)){
					this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("Duplicate attribute %s in annotation", key));
				}
				else{
					Pair<FuncType, Boolean> typeAndIsDefault = anotArgs.remove(key);
					if(typeAndIsDefault==null){
						this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("Unknown attribute %s in annotation", key));
					}
					else{
						Type expected = typeAndIsDefault.getA().retType;

						annotation.keyToType.put(key, expected);
						
						if(null == TypeCheckUtils.checkSubType(this.ers, expected, argType, 0, 0, 0, 0)){
							boolean pass=false;
							if(argType.getArrayLevels() == 0){//only thing it could be, upgrade arg type to array
								Type toArrPlus1 = (Type)argType.copy();
								toArrPlus1.setArrayLevels(1);
								pass = null != TypeCheckUtils.checkSubType(this.ers, expected, toArrPlus1, 0, 0, 0, 0);
							}
							
							if(!pass){
								this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("Annotation type mismatch: cannot convert from %s to %s", argType, expected));
							}
						}
					}
					
					keysAlreadyh.add(key);
				}
			}
			
			for(String key : anotArgs.keySet()){
				Pair<FuncType, Boolean> value = anotArgs.get(key);
				
				if(!value.getB()){//no default value
					this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("Missing argument for attribute %s in annotation", key));
				}
			}
		}
		else{//no args
			if(!argsWithoutDefault.isEmpty()){
				this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("Missing annotation arguments for: %s", Utils.justJoin(argsWithoutDefault)));
				return null;
			}
		}
		
		if(!annotation.locations.isEmpty()){
			if(annotation.location == null){
				this.raiseError(annotation.getLine(), annotation.getColumn(), "Annotation locations can only be specified for field, class or class parameter definitions");
			}
			else{
				for(String loc : annotation.locations){
					LinkedHashSet<String> validChocies;
					String errMsg;
					if(annotation.location == AnnotationLocation.CLASSDEFPARAM){
						validChocies = validAnnoationLocationsClassDefArgs;
						errMsg = annotationLocationListClassDefArgs;
					}
					else if(annotation.location == AnnotationLocation.CLASS){
						validChocies = validAnnoationLocationsThis;
						errMsg = annotationLocationListThis;
					}else{//field
						validChocies = validAnnoationLocationsField;
						errMsg = annotationLocationListField;
					}
					
					if(!validChocies.contains(loc)){
						this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("Invalid location specified for annotation: %s, valid locations are: %s", loc, errMsg));
					}
				}
			}
		}
		 
		//ensure that annotaion is being correctly used regarding the bounds of the annotation definition 
		//ElementType
		ElementType usedAt = annotation.usedAt;
		if(null != usedAt){//nested stuff we dont check the use site since they dont have one
			//if annotation has usage site, check this
			Annotations annot = resolvedTo.getAnnotations();
			
			HashSet<ElementType> usagerestrictions = Utils.extractUsagetargets(annot);
			if(!usagerestrictions.isEmpty()){
				ArrayList<ElementType> placesUsed = new ArrayList<ElementType>();
				if(annotation.locations.isEmpty()){
					//just go with default if no locations defined
					placesUsed.add(usedAt);
				}
				else{//override places used with location mappings
					for(String loc : annotation.locations){
						ElementType et =locToUsageSite.get(loc);
						placesUsed.add(et);
					}
				}
				
				for(ElementType used : placesUsed){
					if(!usagerestrictions.contains(used)){//uh oh, u cant use that here...
						
						ArrayList<ElementType> restri = new ArrayList<ElementType>(usagerestrictions);
						Collections.sort(restri);
						
						PrintSourceVisitor fancyname = new PrintSourceVisitor();
						annotation.accept(fancyname);
						
						this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("The cannot use annotation %s at this location. It is restricted to use at these locations only: %s", fancyname.toString(), Utils.justJoin(restri)));
					}
				}
			}
		}

		NamedType ret = new NamedType(resolvedTo);
		annotation.setTaggedType(ret);
		
		//if this was a suppresswarnnings, check them
		HashSet<String> suppressedWarings = Utils.extractSuppressedWarningsFromAnnotation(annotation, this);
		if(!suppressedWarings.isEmpty()){
			ArrayList<String> ord = new ArrayList<String>(suppressedWarings);
			Collections.sort(ord);
			ArrayList<String> invalids = new ArrayList<String>(ord.size());
			HashSet<WarningVariant> oks = new HashSet<WarningVariant>();
			for(String what : suppressedWarings){
				if(!WarningVariant.WarningVariantMap.containsKey(what)){
					invalids.add(what);
				}else{
					oks.add(WarningVariant.WarningVariantMap.get(what));
				}
			}
			if(suppressedWarings.contains("all") && suppressedWarings.size() > 1){
				this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("Invalid SuppressWarnings arguments: '%s' valid options are one or many of: '%s' or 'all' - 'all' cannot be used in conjunction with other options", Utils.justJoin(ord), WarningVariant.WarningVariantList));
			}
			
			if(!invalids.isEmpty()){
				this.raiseError(annotation.getLine(), annotation.getColumn(), String.format("Invalid SuppressWarnings arguments: '%s' valid options are one or many of: '%s' or 'all'", Utils.justJoin(invalids), WarningVariant.WarningVariantList));
			}
		}
		
		return ret;//ignore non functional
	}
	
	private final static LinkedHashSet<String> validAnnoationLocationsClassDefArgs = new LinkedHashSet<String>();
	private final static String annotationLocationListClassDefArgs;
	static{
		validAnnoationLocationsClassDefArgs.add("setter");
		validAnnoationLocationsClassDefArgs.add("getter");
		validAnnoationLocationsClassDefArgs.add("field");
		validAnnoationLocationsClassDefArgs.add("param");
		annotationLocationListClassDefArgs = "setter, getter, field, param";
	}
	
	private final static LinkedHashSet<String> validAnnoationLocationsField = new LinkedHashSet<String>();
	private final static String annotationLocationListField;
	static{
		validAnnoationLocationsField.add("setter");
		validAnnoationLocationsField.add("getter");
		validAnnoationLocationsField.add("field");
		annotationLocationListField = "setter, getter, field";
	}
	
	private final static LinkedHashSet<String> validAnnoationLocationsThis = new LinkedHashSet<String>();
	private final static String annotationLocationListThis;
	static{
		validAnnoationLocationsThis.add("this");
		annotationLocationListThis = "this";
	}
	
	private final static HashMap<String, ElementType > locToUsageSite = new HashMap<String, ElementType >();
	static{
		locToUsageSite.put("setter", ElementType.METHOD);
		locToUsageSite.put("getter", ElementType.METHOD);
		locToUsageSite.put("field", ElementType.FIELD);
		locToUsageSite.put("param", ElementType.PARAMETER);
		locToUsageSite.put("this", ElementType.CONSTRUCTOR);
		//ANNOTATION_TYPE not mapped but it is used
	}
	
	
	@Override
	public Object visit(Annotations annotations){
		//not interesting
		//ArrayList<Type> types = new ArrayList<Type>(annotations.annotations.size());
		HashMap<String, HashSet<Type>> types = new HashMap<String,HashSet<Type>>();
		
		for(Annotation annot : annotations.annotations){
			annot.validAtThisLocation=true;
			Type got = (Type)annot.accept(this);
			if(got != null){
				ArrayList<String> locs = new ArrayList<String>(annot.locations);
				if(locs.isEmpty()){
					locs.add(null);
				}
				for(String loc : locs){
					
					if(!types.containsKey(loc)){
						types.put(loc, new HashSet<Type>());
					}
					
					HashSet<Type> annots = types.get(loc);
					
					if(annots.contains(got)){
						this.raiseError(annot.getLine(), annot.getColumn(), String.format("Duplicate annotation %s", annot.className));
					}else{
						annots.add(got);
					}
				}
			}
		}
		
		Utils.extractSuppressedWarningsFromAnnotations(annotations, this);
		
		return annotations.annotations;//non functional
	}

	@Override
	public Object visit(AnnotationDef annotationDef) {
		int line = annotationDef.getLine();
		int col = annotationDef.getColumn();
/*
		if(!this.currentlyInClassDef.isEmpty()){
			if(this.currentlyInClassDef.peek().isEnumSubClass){
				this.raiseError(line, col, "enums cannot be defined inside enum elements");
				return null;
			}
		}*/
		
		nestorParens.push(annotationDef.name);
		annotationDef.setCcFullName(getfullClassName());
		
		if(annotationDef.am == null){//nested
			annotationDef.am = !this.currentlyInClassDef.isEmpty()?AccessModifier.PRIVATE: AccessModifier.PUBLIC;
		}
		
		HashSet<RetentionPolicy> retention=null;
		if(annotationDef.annotations != null){
			annotationDef.annotations.setUsedAt(ElementType.ANNOTATION_TYPE);
			annotationDef.annotations.accept(this);
			
			retention = Utils.extractARetentionPolicy(annotationDef.annotations);
		}
		
		
		if(retention==null || retention.isEmpty()){
			Annotation retentionAnnotation = new Annotation(line, col, "java.lang.annotation.Retention", DotOperator.buildDotOperator(line, col, "java", "lang", "annotation", "RetentionPolicy", "RUNTIME"), null, new ArrayList<String>());
			
			if(annotationDef.annotations==null){
				annotationDef.annotations = new Annotations(line, col, new ArrayList<Annotation>());
			}
			
			annotationDef.annotations.annotations.add(retentionAnnotation);
			annotationDef.annotations.accept(this);//visit again
		}
		
		
		//=> makes a calssdef
		if(null == annotationDef.fakeclassDef){
			ClassDef fakeclassDef = new ClassDef(annotationDef.getLine(), annotationDef.getColumn(), annotationDef.name, this.packageName.peek());
			fakeclassDef.classBlock=annotationDef.annotBlock;
			fakeclassDef.accessModifier = annotationDef.am;
			fakeclassDef.setCcFullName(annotationDef.bcFullName());
			fakeclassDef.setResolvedSuperType(this, new ClassDefJava(Object.class));//iface: new String[] { "java/lang/annotation/Annotation" }
			ArrayList<ClassDef> resolvedInterfaces = new ArrayList<ClassDef>();
			resolvedInterfaces.add(new ClassDefJava(Annotation.class));
			fakeclassDef.setResolvedInterfaces(resolvedInterfaces);
			fakeclassDef.annotations=annotationDef.annotations;
			fakeclassDef.isAnnotation=true;
			
			if(!this.currentlyInClassDef.isEmpty()){
				fakeclassDef.setParentNestor(this.currentlyInClassDef.peek());
			}
			
			annotationDef.fakeclassDef=fakeclassDef;
		}

		TheScopeFrame classSF = annotationDef.fakeclassDef.getScopeFrameGenIfMissing(this.currentScopeFrame, annotationDef.fakeclassDef);
		classSF.isAnnotation = true;
		
		//buildEnumSubclasses(enumDef, enumDef.block.enumItemz);

		TheScopeFrame parentDF = this.currentScopeFrame;
		
		if(parentDF.hasClassDef(parentDF, annotationDef.name, false, true)){
			this.raiseError(line, col, String.format("annotation %s has already been declared in current scope" , annotationDef.name));
		}
		
		parentDF.setClassDef(classSF, annotationDef.name, annotationDef.fakeclassDef, Modifier.PUBLIC);
		
		packageName.push(annotationDef.name);
		
		currentConstructorCallGraph.push(new HashMap<ConstLocationAndType, Type>());//there arnt any constructors
		
		if(this.currentlyInClassDef.isEmpty()){//only add at top level
			this.addImport(annotationDef.name, getFullyDottedPackage(), false); //add C -> a.b.C to local ref table 
		}
		
		this.currentScopeFrame = classSF;
		this.currentScopeFrame.enterScope();
		
		currentlyInClassDef.add(annotationDef.fakeclassDef);
		
		currentScopeFrame.paThisIsModule =false;
		//add implicit functions
		
		annotationDef.annotBlock.isClass = true;
		annotationDef.annotBlock.isAnnotation = true;
		
		
		annotationDef.annotBlock.accept(this);
		
		//initblocks.pop();
		currentlyInClassDef.pop();
		nestorParens.pop();
		packageName.pop();

		HashMap<ConstLocationAndType, Type> constructorInvokeGraph = currentConstructorCallGraph.pop();
		checkConstrutorInvokeGraphForLoops(constructorInvokeGraph);
		

		//add annotaion params defined at top level

		HashSet<String> alreadyDefined = new HashSet<String>();
		HashSet<String> topLevelDef = new HashSet<String>();
		for(AnnotationDefArg ada : annotationDef.annotationDefArgs){
			if(topLevelDef.contains(ada.name)){
				this.raiseError(line, col, String.format("Cannot define annotation field: %s more than once", ada.name));
			}
			if(classSF.hasVariable(classSF, ada.name, false, true, false) || alreadyDefined.contains(ada.name))
			{
				this.raiseError(line, col, String.format("Cannot define annotation field: %s more than once", ada.name));
			}
			else{//add the variable, to be picked up on the next sac round
				Type type;
				if(ada.optionalType == null){
					//infer type if we can
					if(ada.expression == null){
						this.raiseError(line, col, String.format("Either a type or default value must be specified for annotation field: %s", ada.name));
						type=null;
					}
					else{
						ada.expression.accept(this);
						type = ada.expression.getTaggedType();
					}
				}
				else{
					type = ada.optionalType;
				}
				
				if(null != type){
					FunctionGenneratorUtils.addClassVariable(ers, this, annotationDef.fakeclassDef, ada.name, null, type, line, col, false, null, ada.annotations, ada.expression, false, false, false, false);
				}
			}
			topLevelDef.add(ada.name);
		}
		
		this.currentScopeFrame = this.currentScopeFrame.leaveScope();
		//add to local dictionary of names?
		this.currentScopeFrame.setClassDef(classSF, annotationDef.name, annotationDef.fakeclassDef, annotationDef.am.getByteCodeAccess());
		
		return null;
	}

	
	private Stack<LinkedHashMap<String, GenericType>> currentTypedefQaulifiers = new Stack<LinkedHashMap<String, GenericType>>();
	private Stack<HashMap<Pair<String, Integer>, TypeDefTypeProvider>> typedefsAtThisLevel = new Stack<HashMap<Pair<String, Integer>, TypeDefTypeProvider>>();
	private Stack<TypedefStatement> currentlyInTypedefStatement = new Stack<TypedefStatement>();
	
	@Override
	public Object visit(TypedefStatement typedefStatement) {
		int line = typedefStatement.getLine();
		int column = typedefStatement.getColumn();
		
		String name = typedefStatement.name;
		
		if(this.hasImportBeenRegistered(name))
		{
			this.raiseError(line, column, String.format("typedef '%s' overrides an existing type - this is confusing", name));
			return null;
		}
		
		LinkedHashMap<String, GenericType> typedefQaulifiers = new LinkedHashMap<String, GenericType>();
		
		LinkedHashSet<String> uniqueArgs = new LinkedHashSet<String>();
		ArrayList<GenericType> generics = new ArrayList<GenericType>();
		for(String arg : typedefStatement.typedefargs){
			if(uniqueArgs.contains(arg)){
				this.raiseError(line, column, String.format("typedef qualifier '%s' has already been declared in qualifier parameter list", arg));
				
			}
			uniqueArgs.add(arg);
			
			if(this.hasImportBeenRegistered(arg) || (arg).equals(name) )
			{
				this.raiseError(line, column, String.format("typedef qualifier '%s' overrides an existing type - this is confusing", arg));
			}
			
			/*if(!this.currentlyInClassDef.isEmpty()){
				ClassDef classDef = this.currentlyInClassDef.peek();
				
				if(GenericTypeUtils.getAllGenericTypesDeclInHierarchy(classDef).contains(arg))
				{
					this.raiseError(classDef.getLine(), classDef.getColumn(), String.format("typedef qualifier '%s' has been defined already further up hierarchy", arg));
				}
			}*/
			
			GenericType gen = new GenericType(line, column, arg, 0);
			typedefQaulifiers.put(arg, gen);
			generics.add(gen);
		}
		currentTypedefQaulifiers.add(typedefQaulifiers);

		currentlyInTypedefStatement.push(typedefStatement);
		if(typedefStatement.type instanceof NamedType){
			((NamedType)typedefStatement.type).ignoreNonQualificationfGenerics = true;//thus the following is permitted: typedef  amyc = MyClass
		}

		if(typedefStatement.type instanceof MultiType) {
			((MultiType)typedefStatement.type).isValidAtThisLocation=true;
		}
		
		Type got = (Type)typedefStatement.type.accept(this);//rhs
		
		checkTypeDefGens(got, typedefStatement.getLine(), typedefStatement.getColumn(), name);
		currentlyInTypedefStatement.pop();

		if(!uniqueArgs.isEmpty()){
			HashMap<String, HashSet<Integer>> argToSubGens = new HashMap<String, HashSet<Integer>>();
			scanDefinitionForArgStructure(got, uniqueArgs, argToSubGens);
			
			for(String arg : argToSubGens.keySet()){
				if(argToSubGens.get(arg).size() > 1){
					this.raiseError(line, column, String.format("typedef %s variable: %s useage has inconsistent generic arguments in definition", name, arg));
				}
			}
			
			if(!uniqueArgs.isEmpty()){//warn unused args
				//List<String> itmz
				boolean many = uniqueArgs.size() > 1;
				this.raiseWarning(line, column, String.format("typedef qualifier%s unused in right hand side definition: %s", many?"s are":" is", Utils.justJoin(new ArrayList<>(uniqueArgs))), WarningVariant.TYPEDEFARGUSAGE);
			}
			
		}
				
		if(null == typedefStatement.accessModifier){
			typedefStatement.accessModifier = AccessModifier.PUBLIC;
		}
		
		if(got != null){
			int argcnt = typedefQaulifiers.size();
			Pair<String, Integer> key = new Pair<String, Integer>(name, argcnt);
			
			boolean definedAlready = typedefsAtThisLevel.peek().containsKey(key);
			
			if(definedAlready) {//can be overriden in later repl iterations
				definedAlready = !(this.currentScopeFrame.paThisIsModule && this.isREPL != null && this.isREPL.tliCache.toptypeDef.containsKey(key));
			}
			
			
			if(definedAlready){
				this.raiseError(typedefStatement.getLine(), typedefStatement.getColumn(), String.format("typedef %s has already been definted with %s arguments", name, argcnt));
			}
			else{
				TypeDefTypeProvider tp = this.currentScopeFrame.getTypeDef(name);
				if(null == tp){
					tp = new TypeDefTypeProvider();
					this.currentScopeFrame.setTypeDef(name, tp);
				}
				
				String loc = String.join(".", this.packageName);
				
				tp.add(got, generics, typedefStatement.accessModifier, loc, name);
				typedefsAtThisLevel.peek().put(key, tp);
			}
		}
		
		currentTypedefQaulifiers.pop();
		return typedefStatement.setTaggedType(got);
	}
	
	
	private void checkTypeDefGens(Type tt, int line, int col, String name){
		if(tt == null){
			return;
		}
		
		if(tt.getInOutGenModifier() != null){
			this.raiseError(line, col, String.format("definition of typedef %s may not contain %s generic qualification", name, tt.getInOutGenModifier()));
		}
		
		if(tt instanceof NamedType){
			for(Type t : ((NamedType)tt).getGenericTypeElements()){
				checkTypeDefGens(t,  line,  col,  name);
			}
		}else if(tt instanceof FuncType){
			FuncType asFunc = (FuncType)tt;
			for(Type t : asFunc.getInputs()){
				checkTypeDefGens(t,  line,  col,  name);
			}
			Type ret = (Type)asFunc.retType.copy();
			if(ret.getInOutGenModifier() != null){
				ret.setInOutGenModifier(null);//igonore returned out param
			}
			
			checkTypeDefGens(ret,  line,  col,  name);
		}
	}
	
	/**
	 * Remove args from args as they are used in the definition
	 * tag following errors:
	 * x<y<x>> - second x has inconsistent number of generic parameters
	 * x<x> - x has inconsistent number of generic parameters
	 * z<x, x<y>> - x has inconsistent number of generic parameters
	 */
	private void scanDefinitionForArgStructure(Type input, HashSet<String> args, HashMap<String, HashSet<Integer>> argToSubGens){
		if(null == input /*|| args.isEmpty()*/){
			return;
		}
		if(input instanceof GenericType){
			args.remove(( (GenericType)input).name);
			//GenericType gen  = (GenericType)input;
		}
		else if(input instanceof NamedType){
			NamedType nt = (NamedType)input;
			
			String name = nt.getNamedTypeStr();
			args.remove(name);
			List<Type> gens = nt.getGenTypes();
			
			HashSet<Integer> genCounter = argToSubGens.getOrDefault(name, new HashSet<Integer>());
			genCounter.add(gens.size());
			argToSubGens.put(name, genCounter);
			
			if(gens.isEmpty() && null != nt.getSetClassDef()){
				for(Type t : nt.getSetClassDef().getClassGenricList()){
					gens.add(t);
				}
			}
			
			//ArrayList<Type> newGens = new ArrayList<Type>();
			for(Type g : gens){
				scanDefinitionForArgStructure(g, args, argToSubGens);
			}
			
			for(Pair<String, ArrayList<Type>> tup: nt.nestorSegments){
				ArrayList<Type> gensa = tup.getB();
				for(Type g :  gensa)
				{
					scanDefinitionForArgStructure(g, args, argToSubGens);
				}
				
			}
			return;
		}
		else if(input instanceof FuncType)
		{
			FuncType fun = (FuncType)input;
			scanDefinitionForArgStructure(fun.retType, args, argToSubGens);
			//ArrayList<Type> inputs = new ArrayList<Type>();
			for(Type arg : fun.getInputs()){
				scanDefinitionForArgStructure(arg, args, argToSubGens);
			}
		}
	}
	
	private Expression nullForType(Type tt){
		if(tt instanceof PrimativeType && !tt.hasArrayLevels()){
			return new VarInt(0,0,0);
		}
		return new VarNull();
	}

	private boolean nullExpressionOrAlwaysResolvestoTrue(Expression expr){
		if(expr == null){
			return true;
		}
		
		Object obj = expr.getFoldedConstant();
		
		if(obj != null && obj instanceof Boolean){
			return (Boolean)obj;
		}
		
		return false;
	}
	private boolean expressionResolvesToFalse(Expression expr){
		if(expr == null){
			return false;
		}
		
		Object obj = expr.getFoldedConstant();
		
		if(obj != null && obj instanceof Boolean){
			return !(Boolean)obj;
		}
		
		return false;
	}
	
	private  ArrayList<Type> matchTypes(CaseExpression ce){
		ArrayList<Type> ret = new ArrayList<Type>();
		if(ce instanceof CaseExpressionAssign){
			ret.addAll(((CaseExpressionAssign)ce).types);
		}
		else if(ce instanceof TypedCaseExpression){
			ret.addAll(((TypedCaseExpression)ce).types);
		}
		
		return ret;
	}
	
	private Expression thingToRefOrDotOp(int line, int col, String thing){
		String[] items = thing.split("\\.");
		int sz = items.length;
		if(sz > 1){
			Expression[] elements = new Expression[items.length];
			for(int n=0; n < sz; n++){
				elements[n] = new RefName(items[n]);
			}
			
			return DotOperator.buildDotOperator(line, col, elements);
		}
		
		return new RefName(thing);
	}
	
	private boolean augmentEnumItem(int linex, int colx, CaseExpression ce, String enumType){
		if(ce instanceof CaseExpressionWrapper){
			CaseExpressionWrapper cew = (CaseExpressionWrapper)ce;
			Expression expr = cew.e;
			if(expr instanceof RefName){
				RefName rn = (RefName)expr;
				maskErrors();
				rn.accept(this);
				if(maskedErrors()){//try to map it Enum1 => Thing.Enum1
					expr = DotOperator.buildDotOperatorOne(linex, colx, new RefName(enumType), rn);
					maskErrors();//((NamedType)motype).getNamedTypeStr()
					expr.accept(this);
					if(!maskedErrors()){//that works...
						cew.e = expr;
						return true;
					}
				}
				
				
			}
		}
		
		return false;
	}
	
	private static class EnumNameExtractor extends AbstractVisitor{
		
		private Type lookingFor;
		
		public EnumNameExtractor(Type lookingFor){
			this.lookingFor=lookingFor;
		}
		
		public String enumCaseName;
		
		@Override
		public Object visit(RefName refName) {
			if(lookingFor == refName.getTaggedType()){
				enumCaseName = refName.name;
			}
			
			return super.visit(refName);
		}
	}
	
	private void extractEnumName(CaseExpression ce, HashSet<String> visitedEnums, NamedType enumType){
		if(ce instanceof CaseExpressionPre ){
			CaseExpressionPre asew = (CaseExpressionPre)ce;
			Expression expr = asew.e;
			
			maskErrors();
			expr.accept(this);
			maskedErrors();
			
			Type tt = expr.getTaggedType();
			if(null != tt && null != TypeCheckUtils.checkSubType(this.ers, enumType, tt) ){
				NamedType asNamed = (NamedType)tt;
				if(!asNamed.isEnumParent){//resolves to end node then use visitor above to extract name
					EnumNameExtractor extr = new EnumNameExtractor(asNamed);
					expr.accept(extr);
					if(null != extr.enumCaseName){
						visitedEnums.add(extr.enumCaseName);
					}
				}
			}
		}else if(ce instanceof CaseExpressionOr){//top level or only, actually this is ok to: (x or (y or f)) - at least it would be, but the expr statment will consume the part inside the inner ()
			CaseExpressionOr ceo = (CaseExpressionOr)ce;
			extractEnumName(ceo.head, visitedEnums, enumType);
			for(CaseExpression cex : ceo.caseOrs){///hehehe cex
				extractEnumName(cex, visitedEnums, enumType);
			}
		}
	}
	
	private boolean anyNullOrSubtype(ArrayList<Type> typez, Type motype){
		if(null != typez){
			
			
			for(Type tt : typez){
				if(tt == null || tt.equals(motype) || null != TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), tt, motype)){
					return true;
				}
			}
		}
		else{
			return true;
		}
		
		return false;
	}
	
	private String statmentIsRefName(Statement stmt){
		if(stmt instanceof DuffAssign){
			DuffAssign da = (DuffAssign)stmt;
			if(da.e instanceof RefName){
				return ((RefName)da.e).name;
			}
		}
		return null;
	}
	
	private CaseExpression convertToCaseExprTuple(int line, int col, NamedType tupType, CaseExpression newSecondsaryCaseExpr, NamedType matchOn) {
		ArrayList<Type> qualifyTup = null;
		if(matchOn != null) {
			qualifyTup = matchOn.getGenericTypeElements();
		}
		
		Expression additionalExpr = null;
		if(newSecondsaryCaseExpr != null) {
			
			if(!(newSecondsaryCaseExpr instanceof CaseExpressionWrapper)) {
				return null;
			}
			additionalExpr = ((CaseExpressionWrapper)newSecondsaryCaseExpr).e;
		}
		
		ArrayList<Type> elms =  tupType.getGenericTypeElements();
		ArrayList<Assign> components = new ArrayList<Assign>(elms.size());
		int n=0;
		ArrayList<String> justNames = new ArrayList<String>();
		boolean normalTupleExpr=false;
		for(Type tt : elms) {
			if(tt instanceof NamedType) {
				NamedType asNamed = (NamedType)tt;
				if(!asNamed.getGenericTypeElements().isEmpty()) {
					return null;
				}else {
					String name = asNamed.namedType;

					if(!normalTupleExpr) {
						this.maskErrors();
						RefName tryRn = new RefName(name);
						Type got = (Type)tryRn.accept(this);
						if(!this.maskedErrors() && TypeCheckUtils.isValidType(got)) {
							normalTupleExpr=true;
						}
					}
					
					
					justNames.add(name);
					Assign ass;
					if(null != qualifyTup) {
						Type qto = qualifyTup.get(n);
						ass = new AssignNew(null, line, col, name, qto);
					}else {
						ass = new AssignExisting(line, col, name, null, null);
						//ass = new AssignNew(null, line, col, name, ScopeAndTypeChecker.const_object);
					}
					components.add(ass);
				}
			}else {
				return null;
			}
			n++;
		}
		
		if(normalTupleExpr) {
			ArrayList<CaseExpression> componentsNames = new ArrayList<CaseExpression>(elms.size());
			justNames.forEach(a -> componentsNames.add(new CaseExpressionWrapper(line, col, new RefName(a))));
			CaseExpressionTuple tre = new CaseExpressionTuple(line, col, componentsNames);
			tre.caseExpression = additionalExpr;
			return tre;
		}else {
			return new CaseExpressionAssignTuple(line, col, additionalExpr, components);
		}
	}
	
	
	@Override
	public Object visit(MatchStatement matchStatement) {
		int line = matchStatement.getLine();
		int column = matchStatement.getColumn();
		//JPT:optimize, case( in [1,2,3]) => convert to a set ??worth the effort?
		
		Type motype = (Type)matchStatement.matchon.accept(this);
		
		if(!TypeCheckUtils.isValidType(motype)){
			//return null;
		}
		
		String matchOnVarName = statmentIsRefName(matchStatement.matchon);
		boolean isRefname = matchOnVarName != null;
		if(null == matchOnVarName){
			//copy paste from typeCheckUtils yuck!
			Statement ln = matchStatement.matchon;
			if(ln instanceof Assign && !(ln instanceof DuffAssign)){
				if(ln instanceof AssignNew){
					AssignNew asnew = (AssignNew)ln;
					matchOnVarName = asnew.name;
				}
				else{// if(ln instanceof AssignExisting){
					AssignExisting asnew = (AssignExisting)ln;
					//Node rhs = (Node)asnew.asignment;
					if(asnew.assignee instanceof RefName){
						matchOnVarName =  ((RefName)asnew.assignee).name;
					}
					else{
						PrintSourceVisitor psv = new PrintSourceVisitor();
						asnew.assignee.accept(psv);
						this.raiseError(ln.getLine(), ln.getColumn(), String.format("assignment specified in match must resolve to a variable, '%s' is not a variable", psv));
						return null;
						//matchOnVarName = "error";
					}
					//shouldNullExisting=asnew.isReallyNew || !this.currentScopeFrame.hasVariableAssigned(name) ;//assign existing
				}
			} else{
				matchOnVarName = "tmpVar$matchAssign$" + tempVarCnt++;
			}
		}
		
		Type ret=null;
		if(matchStatement.cases.isEmpty()){
			this.raiseError(line, column, "match must have at least one case");
		}
		else{
			Expression iftest=null;
			Block ifblock=null;
			ArrayList<ElifUnit> elifunits = new ArrayList<ElifUnit>();
			
			Block elseBlock = matchStatement.elseblok;
			//boolean elseFromCatchAll = false;
			boolean elseBlockOrigNull = elseBlock==null;
			
			Block astRedirect = new Block(line, column);
			astRedirect.isolated=true;
			
			if(!isRefname){
				//add the assignment to the top of the block here
				Statement ln = matchStatement.matchon;
				if(ln instanceof Assign && !(ln instanceof DuffAssign)){
					
					if(ln instanceof AssignExisting && ((AssignExisting)ln).assignee instanceof RefName ) {
						AssignExisting ae = (AssignExisting)ln;
						
						String nname = ((RefName)(ae.assignee)).name;
						ln = new AssignNew(null, ae.getLine(), ae.getColumn(), nname, ae.expr.getTaggedType(), ae.eq, ae.expr);
						ln.accept(this);
						matchStatement.matchon = ln;
					}
					
					astRedirect.add(ln);
				}else{
					Block holder = new Block(line, column);
					holder.isolated=true;
					holder.add((Statement)ln.copy());
					holder.setShouldBePresevedOnStack(true);
					astRedirect.add(new AssignExisting(line, column, matchOnVarName, AssignStyleEnum.EQUALS, holder));
				}
			}
			
			int n=0;
			boolean matchingOnEnum = TypeCheckUtils.isEnum(motype);
			AssignTupleDeref tupleDerefToAdd = null;
			
			HashSet<String> enumElements = !matchingOnEnum?null:((NamedType)motype).getEnumVars(this);
			HashSet<String> matchedEnums = matchingOnEnum?new HashSet<String>():null;
			for(MactchCase ceb : matchStatement.cases){
				CaseExpression ce = ceb.getA();
				Block bb = ceb.getB();

				int cline = ce.getLine(); 
				int ccol = ce.getColumn();
				
				ArrayList<Type> types = matchTypes(ce);
				if(TypeCheckUtils.isValidType(motype)){
					boolean ok=true;
					for(Type tt : types){
						if(tt!= null){
							maskErrors();
							tt=(Type)tt.accept(this);
							boolean hasErrors = maskedErrors();
							if(tt!= null) {
								
								if(hasErrors && types.size() == 1 && ce instanceof TypedCaseExpression && null != TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), getTupleType(0,0, null), tt)) {
									
									NamedType matchesToTuple = null;
									if(null != TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), getTupleType(0,0, null), motype)) {
										//matching on tuple type
										matchesToTuple = (NamedType)motype;
										
										int compareCount = ((NamedType)tt).getGenericTypeElements().size();
										int provided = matchesToTuple.getGenericTypeElements().size();
										
										if(compareCount != provided) {
											this.raiseError(cline, ccol, String.format("Cannot extract tuple components, expected: %s elements but there are: %s", compareCount, provided));
											n++;
											ok=false;
											break;
										}
									}
									
									CaseExpression cenew = convertToCaseExprTuple(cline, ccol, (NamedType)tt, ((TypedCaseExpression)ce).caseExpression, matchesToTuple);
									if(null != cenew) {
										cenew.alsoCondition = ce.alsoCondition;
										ce = cenew;
										continue;
									}
								}
								
								if( null == TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), motype, tt) && null == TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), tt, motype)){
									this.raiseError(cline, ccol, String.format("case will never be matched as %s and %s are not subtypes of each other", tt, motype));
									n++;
									ok=false;
									break;
								}
							}
						}
					}
					if(!ok){
						continue;
					}
				}
				
				if(ce instanceof CaseExpressionAssign){
					CaseExpressionAssign ascea = (CaseExpressionAssign)ce;
					if(!ascea.forceNew && ascea.types.isEmpty()){
						if(this.currentScopeFrame.hasVariableAssigned(ascea.varname)){
							//if exists already in scope then we check matchee against that value
							ce = new CaseExpressionPre(line, column, CaseOperatorEnum.EQ, new RefName(line, column,ascea.varname));
						}
						
					}
				}
				
				if(ce instanceof TypedCaseExpression){//if we do case(x) {...} this can be interpeted as either a type or a varname, so convert here if invalid type
					TypedCaseExpression tea = (TypedCaseExpression)ce;
					ArrayList<Type> ttypes = tea.types;
					int linex= tea.getLine();
					int colx = tea.getColumn();
					
					boolean allValidtypes = true;
					for(Type tt : ttypes){
						//see if all resolve to vars
						maskErrors();
						tt.accept(this);
						if(maskedErrors()){
							allValidtypes=false;
							break;
						}
					}
					
					if(!allValidtypes ){
						boolean allResolvetoVars = true;
						ArrayList<Expression> refnames = new ArrayList<Expression>(ttypes.size());
						for(Type tt : ttypes){
							//see if all resolve to vars
							boolean wasok = false;
							
							if(tt instanceof NamedType){
								String varString = ((NamedType)tt).getNamedTypeStr();
								
								//RefName rn = new RefName(varString);
								Expression rn = thingToRefOrDotOp(linex, colx, varString);;
								
								maskErrors();
								rn.accept(this);
								wasok = !maskedErrors();
								
								if(!wasok && matchingOnEnum && enumElements.contains(varString)){
									rn = DotOperator.buildDotOperatorOne(linex, colx, new RefName(((NamedType)motype).getNamedTypeStr()), rn);
									
									maskErrors();
									rn.accept(this);
									wasok = !maskedErrors();
									
								}
								
								
								refnames.add(rn);
								
							}

							if(!wasok){
								allResolvetoVars=false;
								break;
							}
						}
						
						if(allResolvetoVars){//all resolve to localvars, convert to CaseExpressionPre or CaseExpressionOR if many
							if(refnames.size() == 1){
								ce = new CaseExpressionPre(linex, colx, CaseOperatorEnum.EQ, refnames.get(0));
								/*Expression one = refnames.get(0);
								if(one instanceof RefName){
									ce = new CaseExpressionAssign(linex, colx, ((RefName)one).name, null, null);
								}
								*/
							}else{//n1 or n2
								ArrayList<CaseExpression> caseOrs = new ArrayList<CaseExpression>();
								
								CaseExpressionPre first=null;
								for(Expression expr : refnames){
									CaseExpressionPre cep = new CaseExpressionPre(linex, colx, CaseOperatorEnum.EQ, expr);
									
									if(null == first){
										first = cep;
									}else{
										caseOrs.add(cep);
									}
									
								}
								ce = new CaseExpressionOr(linex, colx, first, caseOrs);
							}
						}
						else if(refnames.size() == 1){//case(x) => //catch all
							Expression one = refnames.get(0);
							if(one instanceof RefName){
								String varname = ((RefName)one).name;
								
								Expression expr = null;
								if(tea.caseExpression != null){
									if(tea.caseExpression instanceof CaseExpressionWrapper){
										expr = ((CaseExpressionWrapper)tea.caseExpression).e;
									}else{
										CasePatternConverter cpc = new CasePatternConverter(new RefName(matchStatement.matchon.getLine(), matchStatement.matchon.getColumn(), varname), motype, n++, bb);
										expr = (Expression)tea.caseExpression.accept(cpc);
									}
								}
								ce = new CaseExpressionAssign(linex, colx, varname, expr, null, false, false);
							}
						}
						
					}
					
				}
				
				if(ce instanceof CaseExpressionTuple) {
					CaseExpressionTuple tea = (CaseExpressionTuple)ce;
					int nx=0;
					HashSet<Integer> toskip = new HashSet<Integer>();
					
					ArrayList<Assign> tupleDerefVars = new ArrayList<Assign>(tea.getComponents().size());
					
					for(CaseExpression cee : tea.getComponents()) {
						AssignExisting ass = null;
						if(cee instanceof CaseExpressionWrapper) {
							CaseExpressionWrapper wrap = (CaseExpressionWrapper)cee;
							if(wrap.e instanceof RefName) {
								maskErrors();
								wrap.e.accept(this);
								if(maskedErrors()){//must be new variable
									ass = new AssignExisting(cline, ccol, ((RefName)wrap.e).name, null, null);
								}
							}
						}
						
						if(ass != null) {
							toskip.add(nx);
						}
						
						tupleDerefVars.add(ass);
						nx++;
					}
					
					tea.toskip = toskip;
					
					if(!toskip.isEmpty()) {
						tupleDerefToAdd = new AssignTupleDeref(cline, ccol, tupleDerefVars, AssignStyleEnum.EQUALS, new RefName(cline, ccol, matchOnVarName));
					}
				} 
				
				Expression alsoCondition = ceb.getA().alsoCondition;
				if(ce instanceof CaseExpressionWrapper) {
					/*see if Record(age == 2, friendcnt > age) => YY
					 * "record: 
					 * Record; with(x as Record){ ret = age==2; ret and=friendcnt > age; ret} } => YY //TypedCaseExpression
					 */
					TypedCaseExpression newce = convertObjectContentPatternCase((CaseExpressionWrapper)ce, matchOnVarName, motype);
					if(null != newce) {
						ce = newce;
						alsoCondition = ce.alsoCondition;
					}
				}else if(ce instanceof CaseExpressionObjectTypeAssign) {
					CaseExpressionObjectTypeAssign asASsignObj = (CaseExpressionObjectTypeAssign)ce;
					TypedCaseExpression newce = convertObjectContentPatternCase(asASsignObj.expr, matchOnVarName, motype);
					if(null != newce) {
						CaseExpressionAssign asCEA = new CaseExpressionAssign(newce.getLine(), newce.getColumn(), asASsignObj.varname, null, newce.types, asASsignObj.forceNew, asASsignObj.isFinal);
						asCEA.alsoCondition = newce.alsoCondition;
						ce = asCEA;
						alsoCondition = ce.alsoCondition;
					}
				}
				
				//CasePatternConverter cpc = new CasePatternConverter((RefName)matchStatement.matchon.copy(), motype, n++, bb);
				CasePatternConverter cpc = new CasePatternConverter(new RefName(matchStatement.matchon.getLine(), matchStatement.matchon.getColumn(), matchOnVarName), motype, n++, bb);
				
				if(matchingOnEnum){//case(CASE2 or MyEnum.CASE3) => case(MyEnum.CASE2 or MyEnum.CASE3){//etc
					if(ce instanceof CaseExpressionOr){
						String enumName = ((NamedType)motype).getNamedTypeStr();
						CaseExpressionOr asor = (CaseExpressionOr)ce;
						augmentEnumItem(ce.getLine(), ce.getColumn(), asor.head, enumName);
						for(CaseExpression ces : asor.caseOrs){
							augmentEnumItem(ce.getLine(), ce.getColumn(), ces, enumName);
						}
					}
				}
				cpc.tuplevarUsedInBlock = tupleDerefToAdd;
				Expression converted = (Expression)ce.accept(cpc);
				
				/*PrintSourceVisitor psv = new PrintSourceVisitor();
				converted.accept(psv);
				System.err.println("post cc1 : " + psv.toString());*/
				
				//Expression alsoCondition = ce.alsoCondition;
				if(alsoCondition != null){
					int linep = ce.getLine();
					int colp = ce.getColumn();
					converted = AndExpression.AndExpressionBuilder(linep, colp, converted, new RedirectableExpression(alsoCondition));
				}
				
				/*
				PrintSourceVisitor psv = new PrintSourceVisitor();
				converted.accept(psv);
				System.err.println("post cc2 : " + psv.toString());*/
				
				
				ConstantFolding cf = new ConstantFolding("");
				cf.visit(converted);
				boolean iscea = ce instanceof CaseExpressionAssign;
				boolean istea = ce instanceof TypedCaseExpression;
				if(iscea || istea){
					ArrayList<Type> typez= null;
					Expression expr = null;
					if(iscea){
						CaseExpressionAssign cea = (CaseExpressionAssign)ce;
						expr = cea.expr;
						typez = cea.types;
					}else{//TypedCaseExpression
						TypedCaseExpression tea = (TypedCaseExpression)ce;
						typez = tea.types;
					}
					if( anyNullOrSubtype(typez,  motype)){//tt == null || tt.equals(motype) || null != TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), tt, motype)){
						if(nullExpressionOrAlwaysResolvestoTrue(expr)){//or always resolves to true?
							
							if(!elseBlockOrigNull){//elseBlock != null){
								this.raiseError(cline, ccol, "case will match all inputs hence else block will never be entered into");
							}
							else if(n != matchStatement.cases.size()){
								this.raiseError(cline, ccol, "case will match all inputs, cases after the one will never be triggered");
							}
							
							if(elseBlock == null){
								
								if(!iscea){//so typed
									if(istea){
										TypedCaseExpression tea = (TypedCaseExpression)ce;
										if(null == tea.caseExpression){//so it's just case(Object){}//so 
											this.raiseError(cline, ccol, "typed case expression without variable assingment is redundant all inputs will be matched, use else statement");
										}
									}
								}
								
								//great, use this as else block
								elseBlock = new Block(cline, ccol);
										
								if(cpc.varUsedInBlock != null){
									String usedVarName=cpc.varUsedInBlock.getC();
									Type thingy = cpc.varUsedInBlock.getB();
									AssignNew ae = new AssignNew(null,  line, column, usedVarName, thingy, AssignStyleEnum.EQUALS, new RefName(matchOnVarName));
									ae.skipNullableCheck = true;
									elseBlock.add(new LineHolder(ae));
								}else if(cpc.tuplevarUsedInBlock != null) {
									elseBlock.add(new LineHolder( (AssignTupleDeref)cpc.tuplevarUsedInBlock.copy() ));
								}
								
								elseBlock.add(new LineHolder(bb));
								
								if( matchStatement.cases.size() == 1){
									//this.raiseError(cline, ccol, "sole case will match all inputs, no need to use a match statement!");
									//add below to supress further errors
									astRedirect.add(new LineHolder(new AssignExisting(line, column, new RefName(cpc.varUsedInBlock.getC()), AssignStyleEnum.EQUALS, new RefName(matchOnVarName))));
									astRedirect.add(bb);
									ret = (Type)astRedirect.accept(this);
									matchStatement.setAstRedirect(astRedirect);
									matchStatement.setTaggedType(ret);
									return ret;
								}
							
								
								continue;
							}
						}
					}

					if(expressionResolvesToFalse(expr)){
						this.raiseError(cline, ccol, "case expression always resolves to false, hence will never be triggered");
					}
				}else {
					boolean cet = ce instanceof CaseExpressionTuple;
					boolean cetA = !cet && ce instanceof CaseExpressionAssignTuple;
					
					if(cet || cetA) {
						
						ArrayList<Type> typesExpected = null;
						if(null != TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), getTupleType(0,0, null), motype)) {
							typesExpected = ((NamedType)motype).getGenericTypeElements();
						}
						
						
						if(null != typesExpected) {
							//ArrayList<Type> typesGot = null;
							int gotSize;
							if(cet) {
								CaseExpressionTuple asTup = (CaseExpressionTuple)ce;
								gotSize = asTup.getComponentCountRaw();
								//typesGot=null;
							}else {
								CaseExpressionAssignTuple asTupAsssign = (CaseExpressionAssignTuple)ce;
								gotSize = asTupAsssign.lhss.size();
							}
							
							//check numbers
							if(gotSize != typesExpected.size()) {
								this.raiseError(cline, ccol, String.format("Cannot extract tuple components, expected: %s elements but there are: %s", typesExpected.size(), gotSize));
							}else if(cetA) {//can be catch all...
								//JPT: copy paste yuck!
								if(!elseBlockOrigNull){//elseBlock != null){
									this.raiseError(cline, ccol, "case will match all inputs hence else block will never be entered into");
								}
								else if(n != matchStatement.cases.size()){
									this.raiseError(cline, ccol, "case will match all inputs, cases after the one will never be triggered");
								}
								
								
								
								
								if(elseBlock == null){
									//great, use this as else block
									elseBlock = new Block(cline, ccol);
											
									if(cpc.varUsedInBlock != null){
										String usedVarName=cpc.varUsedInBlock.getC();
										Type thingy = cpc.varUsedInBlock.getB();
										AssignNew ae = new AssignNew(null,  line, column, usedVarName, thingy, AssignStyleEnum.EQUALS, new RefName(matchOnVarName));
										ae.skipNullableCheck = true;
										elseBlock.add(new LineHolder(ae));
									}else if(cpc.tuplevarUsedInBlock != null) {
										elseBlock.add(new LineHolder( (AssignTupleDeref)cpc.tuplevarUsedInBlock.copy() ));
									}
									
									elseBlock.add(new LineHolder(bb));
									
									if( matchStatement.cases.size() == 1){
										//this.raiseError(cline, ccol, "sole case will match all inputs, no need to use a match statement!");
										//add below to supress further errors
										
										if(null != cpc.tuplevarUsedInBlock) {
											astRedirect.add(new LineHolder( (AssignTupleDeref)cpc.tuplevarUsedInBlock.copy() ));
										}
										//astRedirect.add(new LineHolder(new AssignExisting(line, column, new RefName(cpc.varUsedInBlock.getC()), AssignStyleEnum.EQUALS, new RefName(matchOnVarName))));
										astRedirect.add(bb);
										astRedirect.setShouldBePresevedOnStack(matchStatement.getShouldBePresevedOnStack());
										ret = (Type)astRedirect.accept(this);
										matchStatement.setAstRedirect(astRedirect);
										matchStatement.setTaggedType(ret);
										return ret;
									}
								
									
									continue;
								}
								
								
								
							}
						}
					}
				}

				//boolean allocatesToTemp = false;
				if(cpc.varUsedInBlock != null){
					//allocatesToTemp=true;
					String tmpVarName=cpc.varUsedInBlock.getA();
					String usedVarName=cpc.varUsedInBlock.getC();
					Type thingy = cpc.varUsedInBlock.getB();
					Expression nuller = nullForType(thingy);
					
					AssignNew an = new AssignNew(null, line, column, tmpVarName, thingy, AssignStyleEnum.EQUALS, nuller);
					an.skipNullableCheck = true;
					astRedirect.add(new LineHolder( an));
					//assign here
					Block bWithAssign = new Block(line, column);
					bWithAssign.isolated=true;
					//bWithAssign.add(new LineHolder(new AssignExisting(line, column, new RefName(usedVarName), AssignStyleEnum.EQUALS, new RefName(tmpVarName))));
					AssignNew ane = new AssignNew(null, line, column, usedVarName, thingy, AssignStyleEnum.EQUALS, new RefName(tmpVarName));
					ane.skipNullableCheck = true;
					bWithAssign.add(new LineHolder(ane));
					bWithAssign.add(new LineHolder(bb));
					bb = bWithAssign;
				}else if(cpc.tuplevarUsedInBlock != null) {
					Block bWithAssign = new Block(line, column);
					bWithAssign.isolated=true;
					//bWithAssign.add(new LineHolder(new AssignExisting(line, column, new RefName(usedVarName), AssignStyleEnum.EQUALS, new RefName(tmpVarName))));
					bWithAssign.add(new LineHolder(  (AssignTupleDeref)cpc.tuplevarUsedInBlock.copy() ));
					bWithAssign.add(new LineHolder(bb));
					bb = bWithAssign;
				}else if(tupleDerefToAdd != null) {

					Block bWithAssign = new Block(line, column);
					bWithAssign.isolated=true;
					//bWithAssign.add(new LineHolder(new AssignExisting(line, column, new RefName(usedVarName), AssignStyleEnum.EQUALS, new RefName(tmpVarName))));
					bWithAssign.add(new LineHolder(  tupleDerefToAdd ));
					bWithAssign.add(new LineHolder(bb));
					bb = bWithAssign;
				}
				
				if(null == iftest){
					iftest = converted;
					ifblock = bb;
				}
				else{
					elifunits.add(new ElifUnit(converted.getLine(), converted.getColumn(), converted, bb));
				}
				
				if(matchingOnEnum){
					extractEnumName(ce, matchedEnums, (NamedType)motype);
				}
				
				
			}
			if(null == iftest){
				return null;
			}
			
			
			boolean moanedAboutLackOfElse = false;
			if(matchingOnEnum){
				
				
				enumElements.removeAll(matchedEnums);
				
				
				if(enumElements.isEmpty()){
					//all possibilities visited, no else block permitted
					if(elseBlock != null){
						//this.raiseError(line, column, String.format("match is acting on an enum, all enum elements are matched by case statement, as such %s can never be matched", elseFromCatchAll?"catch all case":"else" ));
						//null can be matched
					}
					else if(matchStatement.getShouldBePresevedOnStack()){
						//add dummy else
						//throw exception, unknown enum
						
						elseBlock = new Block(line, column);//NamedType(int line, int col, String namedType)
						//elseBlock.add(new LineHolder(new ThrowStatement(line, column, new NamedConstructor(line, column, new NamedType(line, column, "Exception"), FuncInvokeArgs.singleFIA(line, column, new VarString(line, column, "match statement acting on enum recieved unexpected element for which there is no case matching"))))));
						
						ThrowStatement throwe = Utils.parsethrowStmt(String.format("throw new Exception('match statement acting on enum recieved unexpected element for which there is no case matching' + %s);", matchOnVarName), this.fullPathFileName, line, column, this);
						
						elseBlock.add(throwe);
					}
					
				}else if(elseBlock == null){
					ArrayList<String> remainig = new ArrayList<String>(enumElements);
					Collections.sort(remainig);
					String errMsg = String.format("match returns something and is acting on an enum, all enum elements must be matched if no catch all case or else block is provided. These enum elements are not matched in any cases: %s", Utils.justJoin(remainig) );
					if(matchStatement.getShouldBePresevedOnStack()){
						//we need an else block - do else thing here
						this.raiseError(line, column, errMsg);
						moanedAboutLackOfElse=true;
					} else {
						this.raiseWarning(line, column, errMsg, WarningVariant.ENUMMATCHNONEXHAUSTIVE);
					}
					
				}
			}
			
			if(elseBlock == null && matchStatement.getShouldBePresevedOnStack()){
				if(!moanedAboutLackOfElse){
					this.raiseError(line, column, "else block or catch all case must be provided for match statement returns which something");
				}
			}
			else{
				IfStatement directed = new IfStatement(line, column, iftest, ifblock, elifunits, elseBlock);
				astRedirect.add(new LineHolder(directed));
				astRedirect.setShouldBePresevedOnStack(matchStatement.getShouldBePresevedOnStack());
				directed.setIfReturnsExpectImmediateUse(false);

				matchStatement.setAstRedirect(astRedirect);
				/*
				PrintSourceVisitor psv = new PrintSourceVisitor();
				astRedirect.accept(psv);
				System.err.println("match: " + psv.toString());*/
				
				ret = (Type)matchStatement.astRedirect.accept(this);
			}
		}
		matchStatement.setTaggedType(ret);
		return ret;
	}

	private static class IntHolder{
		public int theInt; 
	}
	
	private Pair<Type, WithBlock> convertExpressionToWithBlock(int line, int col, Expression expr, String matchArgName, IntHolder instCount, NamedType currentType) {
		boolean isTopLevel = instCount.theInt==0;
		
		NamedType className;
		FuncInvoke fi; 
		if(expr instanceof FuncInvoke) {
			fi = (FuncInvoke)expr;
			className = new NamedType(line, col, fi.funName);
		}else if(isTopLevel && expr instanceof DotOperator) {//com.my.thing.XXX - only valid at top level
			DotOperator dop = (DotOperator)expr;
			ArrayList<Expression> elements = dop.getElements(this);
			Expression last = elements.get(elements.size()-1);
			if(last instanceof FuncInvoke) {
				fi = (FuncInvoke)last;
				String nameSoFar = "";
				for(int n = 0; n < elements.size()-1; n++) {
					Expression item = elements.get(n);
					if(item instanceof RefName) {
						nameSoFar += ((RefName)item).name + ".";
					}else {
						return null;
					}
				}
				
				nameSoFar += fi.funName;
				className = new NamedType(line, col, nameSoFar);
			}else {
				return null;
			}
		}else {
			return null;
		}
		
		boolean valid = true;
		
		if(isTopLevel) {//only check if top level lower levels we assume to be valid
			this.maskErrors();
			Type resType = (Type)className.accept(this);
			valid = !this.maskedErrors() && TypeCheckUtils.isValidType(resType) && resType instanceof NamedType;
			if(valid) {
				currentType = (NamedType)resType;
			}
		}
		
		if(valid) {
			//classname is valid, now see if we can take the arguments from the funcinvoke and use them as pattern class object arguments
			if(!fi.args.nameMap.isEmpty() || fi.args.asnames.isEmpty()) {//no invok(a = 10) , and no () //etc
				return null;
			}
			
			Block objContentChecks = new Block(line, col);
			//convert to with expr
			boolean first=true;
			String varname = "cp$objCheck" + instCount.theInt++;
			for(Expression exprx : fi.args.asnames) {
				Assign ass;
				
				if(exprx instanceof FuncInvoke) {//see if MyThing(afield(v==7, f==9));//afield is a valid field
					String fname = ((FuncInvoke)exprx).funName;
					//check its a valid field
					Type ftype = currentType.getField(fname);
					if(ftype != null && ftype instanceof NamedType) {
						Pair<Type, WithBlock> mappedIfObjwithExpr = convertExpressionToWithBlock(line, col, exprx, fname, instCount, (NamedType)ftype);
						if(null != mappedIfObjwithExpr) {
							exprx = mappedIfObjwithExpr.getB();
						}
					}
				}
				
				if(first) {
					ass = new AssignNew(null, line, col, varname, ScopeAndTypeChecker.const_boolean, AssignStyleEnum.EQUALS, exprx);
					first=false;
				}else {
					ass = new AssignExisting(line, col, varname, AssignStyleEnum.AND_EQUALS, exprx);
				}
				
				objContentChecks.add(ass);
			}
			
			objContentChecks.add(new DuffAssign(new RefName(line, col, varname)));
			
			//wrapped in with statement...
			ArrayList<Type> types = new ArrayList<Type>();
			types.add(className);
			
			WithBlock ret = new WithBlock(line, col, isTopLevel?new CastExpression(line, col, className, new RefName(matchArgName)):new RefName(matchArgName), objContentChecks);
			ret = (WithBlock)ret.copy();
			ret.setShouldBePresevedOnStack(true);
			return new Pair<>(className, ret);
		}
		
		return null;
	}
	
	private TypedCaseExpression convertObjectContentPatternCase(CaseExpressionWrapper wrapper, String matchArgName, Type motype) {
		Expression e = wrapper.e;
		
		int line = e.getLine();
		int col = e.getColumn();
		
		if(null != motype && motype.getNullStatus() == NullStatus.NONNULL && e instanceof VarNull) {
			this.raiseError(line, col, "cannot match against null as input is not nullable" );
		}
		
		IntHolder intCount = new IntHolder();
		Pair<Type, WithBlock> boolAsWithAndClassType =  convertExpressionToWithBlock(line, col, e, matchArgName, intCount, null);
		if(null != boolAsWithAndClassType) {
			WithBlock boolAsWith = boolAsWithAndClassType.getB();
			Type classType = boolAsWithAndClassType.getA();
			
			PrintSourceVisitor psv = new PrintSourceVisitor();
			boolAsWith.accept(psv);
			String repointStr = psv.toString();//use this prior to accept, i.e. pre getter field mapping etc
			if(wrapper.repointedToWithBlockStr == null || !wrapper.repointedToWithBlockStr.equals(repointStr)) {
				//use existing wrapper unless there isnt one already defined
				wrapper.repointedToWithBlockStr = repointStr;
				wrapper.repointedToWithBlock = boolAsWith;
			}
				
			//checking could be better here but only problem is where there is a real funcinvoke with the same name as a class being matched on, seem rare
			ArrayList<Type> types = new ArrayList<Type>();
			types.add(classType);
			
			TypedCaseExpression ret = new TypedCaseExpression(line, col, types, null);
			ret.alsoCondition = wrapper.repointedToWithBlock;
			
			return ret;
			
		}
		
		return null;
	}
	
	@Override
	public Object visit(CaseExpressionWrapper caseExpressionWrapper) {
		return null;//ignore
	}

	@Override
	public Object visit(CaseExpressionPre caseExpressionPre) {
		return null;//ignore
	}
	
	@Override
	public Object visit(CaseExpressionTuple caseExpressionTuple) {
		return null;//ignore
	}

	@Override
	public Object visit(CaseExpressionPost caseExpressionPost) {
		return null;//ignore
	}

	@Override
	public Object visit(CaseExpressionAnd caseExpressionAnd) {
		return null;//ignore
	}

	@Override
	public Object visit(CaseExpressionOr caseExpressionOr) {
		return null;//ignore
	}

	@Override
	public Object visit(CaseExpressionAssign caseExpressionUntypedAssign) {
		return null;//ignore
	}
	
	@Override
	public Object visit(CaseExpressionObjectTypeAssign caseExpressionObjectTypeAssign) {
		return null;//ignore
	}
	
	@Override
	public Object visit(CaseExpressionAssignTuple caseExpressionUntypedAssign) {
		return null;//ignore
	}
	
	@Override
	public Object visit(TypedCaseExpression typedCaseExpression) {
		return null;//ignore
	}	

	private Expression rightestDelExpression(Expression thing){
		if(thing instanceof RefName || thing instanceof ArrayRef){
			return thing;
		}
		else{
			if(thing instanceof DotOperator){
				Expression lastThing = ((DotOperator)thing).getLastElement();
				if(lastThing instanceof RefName){
					return lastThing;
				}
			}
		}
		
		return null;
		
		//a.b.c[12] <- ArrayRef
	}
	
	@Override
	public Object visit(DeleteStatement deleteStatement){
		for(Expression ee : deleteStatement.exprs) {
			Expression rhsResovlesToExpr = rightestDelExpression(ee);
			if( rhsResovlesToExpr instanceof ArrayRef ){
				ArrayRef ar = (ArrayRef)rhsResovlesToExpr;
				ar.arrayLevelElements.getLastArrayRefElement().liToMap = LISTorMAPType.REMOVE;
			}
			
			Type opon = (Type)ee.accept(this);
			if(!TypeCheckUtils.isValidType(opon)){
				this.raiseError(ee.getLine(), ee.getColumn(), String.format("Invalid type %s", opon) );
			}
			else{
				if(null == rhsResovlesToExpr){
					this.raiseError(ee.getLine(), ee.getColumn(), String.format("Can only delete local variables or list/map references") );
				}else if(rhsResovlesToExpr instanceof RefName){
					RefName asRef = (RefName)rhsResovlesToExpr;
					if(null != asRef.resolvesTo){
						Location loc = asRef.resolvesTo.getLocation();
						if(null != loc && !(loc instanceof LocationLocalVar)){
							this.raiseError(ee.getLine(), ee.getColumn(), "Only local variables can be deleted");
						}else{
							deleteStatement.operatesOn = DSOpOn.LOCALVAR;
							this.currentScopeFrame.removeVariable(asRef.name);
						}
					}
				}
				else if( rhsResovlesToExpr instanceof ArrayRef ){
					ArrayRef ar = (ArrayRef)rhsResovlesToExpr;
					
					ArrayRefElement lastElement = ar.getLastArrayRefElement();
					
					if(!lastElement.isSingleElementRefEle()){
						this.raiseError(ee.getLine(), ee.getColumn(), "ranges cannot be deleted");
					}else{
						lastElement.liToMap = LISTorMAPType.REMOVE;
						Type exprType = ar.expr.getTaggedType();
						if(null != exprType){
							if(null != TypeCheckUtils.checkSubType(this.ers, map_object, exprType, 0, 0, 0, 0)){
								deleteStatement.operatesOn = DSOpOn.MAPREF;
							}else if(null != TypeCheckUtils.checkSubType(this.ers, list_object, exprType, 0, 0, 0, 0)){
								deleteStatement.operatesOn = DSOpOn.LISTREF;
							}else{
								//check operator overload for remove?
								deleteStatement.operatesOn = DSOpOn.OBJREF;
							}
						}
					}
				}
			}
		}
		
		return null;
	}
	
	@Override
	public Object visit(SizeofStatement sizeofStmt){
		Type opon = (Type)sizeofStmt.e.accept(this);

		if(!TypeCheckUtils.isValidType(opon)){
			this.raiseError(sizeofStmt.getLine(), sizeofStmt.getColumn(), String.format("Invalid type %s", opon) );
		}
		if(TypeCheckUtils.isPurePrimativeNonArray(opon)){
			this.raiseError(sizeofStmt.getLine(), sizeofStmt.getColumn(), String.format("sizeof can only operate on objects, not primative types such as %s", opon) );
		}
		
		Type tt;
		if(!this.currentlyInFuncDef.isEmpty() && this.currentlyInFuncDef.peek().isGPUKernalOrFunction != null) {
			tt = (Type)const_size_t.copyTypeSpecific();
		}else {
			tt = (Type)const_int.copyTypeSpecific();
		}
		
		if(sizeofStmt.variant != null){
			
			if(sizeofStmt.variant.trim().isEmpty()) {
				this.raiseError(sizeofStmt.getLine(), sizeofStmt.getColumn(), "qualifier for sizeof must be specified where <> is used");
			}else {
				String[] items = sizeofStmt.variant.split("\\.");
				
				Expression eval;
				if(items.length == 1) {
					FuncInvoke fi = new FuncInvoke(sizeofStmt.getLine(), sizeofStmt.getColumn(), sizeofStmt.variant, sizeofStmt.e);
					fi.supressVectorization = true;
					eval = fi;
				}else {
					ArrayList<Expression> elements = new ArrayList<Expression>();
					for(int n=0; n < items.length; n++) {
						if(n == items.length-1) {
							FuncInvoke fi = new FuncInvoke(sizeofStmt.getLine(), sizeofStmt.getColumn(), items[n], sizeofStmt.e);
							fi.supressVectorization = true;
							elements.add(fi);
						}else {
							elements.add(new RefName(items[n]));
						}
					}
					
					eval = new DotOperator(sizeofStmt.getLine(), sizeofStmt.getColumn(), elements);
				}
				
				this.maskErrors(true);
				tt = (Type) eval.accept(this);
				ArrayList<CapMaskedErrs> masked = this.getmaskedErrors();
				
				sizeofStmt.astOverride = eval;
				if(masked.isEmpty()) {
					if(!tt.equals(const_int)) {
						this.raiseError(sizeofStmt.getLine(), sizeofStmt.getColumn(), "qualifier for sizeof must return an int");
					}
				}else {
					this.applyMaskedErrors(masked);
				}
				
			}
		}
		
		sizeofStmt.setTaggedType(tt);
		return tt;
	}
	
	@Override
	public Object visit(DMANewFromExpression dmaNewFromExpression){
		Type tt = (Type)dmaNewFromExpression.e.accept(this);
		dmaNewFromExpression.setTaggedType(tt);
		return tt;
	}

	private int localClassDefN = -1;
	
	@Override
	public Object visit(LocalClassDef localClassDef) {
		localClassDefN++;//always inc for consistancy
		if(localClassDef.cd.className == null){
			localClassDef.cd.className = "localClassDef$" + localClassDefN;
			
			int line = localClassDef.getLine();
			int col = localClassDef.getColumn();
			Block astredirect = new Block(line, col);
			astredirect.isolated=true;
			astredirect.setShouldBePresevedOnStack(localClassDef.getShouldBePresevedOnStack());
			astredirect.add(localClassDef.cd);
			FuncRef refToClass = new FuncRef(line, col, new RefName(line, col, localClassDef.cd.className), null);
			astredirect.add(new LineHolder(line, col, new DuffAssign(refToClass)));
			localClassDef.astRedirect=astredirect;
		}
		
		return localClassDef.astRedirect.accept(this);
	}

	@Override
	public Object visit(TypeReturningExpression typeReturningExpression) {
		typeReturningExpression.type.accept(this);
		return typeReturningExpression.type;
	}
	
	private long defaultTransHandlerId=0;
	
	@Override
	public Object visit(TransBlock transBlock) {
		boolean shouldReturn = transBlock.getShouldBePresevedOnStack();

		int line = transBlock.getLine();
		int col = transBlock.getColumn();
		
		//ONLYT DO it if shouldret different
		defaultTransHandlerId++;
		if(transBlock.astRedirect == null || shouldReturn != transBlock.astRedirect.getShouldBePresevedOnStack()){
			Block workblock = new Block(line, col);
			//workblock.isolated=true;
			Type blockRetType = null;
			String toRetVar = null;
			if(shouldReturn){
				blockRetType = (Type)transBlock.blk.accept(this);
				if(!TypeCheckUtils.isValidType(blockRetType, true)){
					this.raiseError(line, col, "trans must return something");
					return ScopeAndTypeChecker.const_void;
				}
				toRetVar = "$transRet" + defaultTransHandlerId;
				AssignExisting ae = new AssignExisting(line, col, toRetVar, AssignStyleEnum.EQUALS, transBlock.blk);
				workblock.add(ae);
			}else{
				transBlock.blk.isolated=true;
				workblock.add(transBlock.blk);
			}
			
			String handleName = "$transH" + defaultTransHandlerId;	
		  		
	  		AssignExisting makeHandle = new AssignExisting(line, col, new RefName(line, col, handleName), AssignStyleEnum.EQUALS,  new New(line, col, new NamedType(line, col, "com.concurnas.bootstrap.runtime.transactions.TransactionHandler"), new FuncInvokeArgs(line, col), true ) );
	  		
	  		Block tryBlock = new Block(line, col);
	  		
	  		ArrayList<Expression> beginCall = new ArrayList<Expression>();
			beginCall.add(new RefName(line, col, handleName));
			beginCall.add(new FuncInvoke(line, col, "begin", new FuncInvokeArgs(line, col)));
	  		tryBlock.add(new LineHolder(line, col, new DuffAssign(line, col, new DotOperator(line, col, beginCall)) ));
	  		
	  		ArrayList<Expression> isdoneCall = new ArrayList<Expression>();
			isdoneCall.add(new RefName(line, col, handleName));
			isdoneCall.add(new FuncInvoke(line, col, "isComplete", new FuncInvokeArgs(line, col)));
	  		
			ArrayList<Expression> comitCall = new ArrayList<Expression>();
			comitCall.add(new RefName(line, col, handleName));
			comitCall.add(new FuncInvoke(line, col, "comit", new FuncInvokeArgs(line, col)));
			workblock.add(new LineHolder(line, col, new DuffAssign(line, col, new DotOperator(line, col, comitCall)) ));
	  		
	  		WhileBlock mainWhile = new WhileBlock(line, col, new NotExpression(line, col, new DotOperator(line, col, isdoneCall)), workblock);
	  		mainWhile.isTransWhileBlock = true;
	  		tryBlock.add(new LineHolder(line, col, mainWhile));
	  		
	  		
			ArrayList<Expression> abortFuncCall = new ArrayList<Expression>();
			abortFuncCall.add(new RefName(line, col, handleName));
			abortFuncCall.add(new FuncInvoke(line, col, "abort", new FuncInvokeArgs(line, col)));
			
			Block finBlock = new Block(line, col);
			finBlock.add(new LineHolder(line, col, new DuffAssign(line, col, new DotOperator(line, col, abortFuncCall)) ));
			  	
			ArrayList<CatchBlocks> catchblocks = new ArrayList<CatchBlocks>();
			
			/*ArrayList<Expression> printonExcep = new ArrayList<Expression>();
			printonExcep.add(new RefName(line, col, "e"));
			printonExcep.add(new FuncInvoke(line, col, "printStackTrace", new FuncInvokeArgs(line, col)));
			Block catchBlock = new Block(line, col);
			catchBlock.add(new LineHolder(line, col, new DuffAssign(line, col, new DotOperator(line, col, printonExcep)) ));
			catchblocks.add(new CatchBlocks(line, col, "e", new ArrayList<Type>(), catchBlock));*/
			
			
	  		TryCatch tcbody = new TryCatch(line, col, tryBlock, catchblocks, finBlock); 
	  		
	  		Block retBlock = new Block(line, col);
	  		retBlock.add(new LineHolder(line, col, makeHandle));
	  		
	  		if(shouldReturn){
	  			AssignNew assNew;
	  			if(TypeCheckUtils.hasRefLevels(blockRetType)){
	  				assNew = new AssignNew(null, line, col, toRetVar, blockRetType);//complains about not certainly set otherwise
	  			}else{
	  				assNew = new AssignNew(null, line, col, toRetVar, blockRetType, AssignStyleEnum.EQUALS, FunctionGenneratorUtils.defaultValueExpressionForType(line, col, blockRetType));//complains about not certainly set otherwise
	  			}
	  			
	  			retBlock.add(assNew);
	  		}
	  		
	  		retBlock.add(new LineHolder(line, col, tcbody));//$b.ret
	  		if(shouldReturn){
	  			retBlock.add(new DuffAssign(new RefName(line, col, toRetVar)));
	  		}
	  		
	  		transBlock.astRedirect = retBlock;
	  		transBlock.astRedirect.setShouldBePresevedOnStack(shouldReturn);
		}
		//Type ret = transBlock.blk.getTaggedType();
		Type ret = (Type)transBlock.astRedirect.accept(this);
		defaultTransHandlerId--;
		
		transBlock.setTaggedType(ret);
		transBlock.astRedirect.isolated=true;
		
		return ret;
	}

	@Override
	public Object visit(JustAlsoCaseExpression justAlsoCaseExpression){
		return null;
	}

	private final static int exprListPrintAmbigCutOffPoint = 15;
	private boolean calledInExprListExpandr;
	
	@Override
	public Object visit(ExpressionList expressionList) {
		int line = expressionList.getLine();
		int col = expressionList.getLine();
		
		if(expressionList.couldBeAnAssignmentDecl){
			if(expressionList.exprs.size() == 3){
				Expression third = expressionList.exprs.get(2);
				if(third instanceof ArrayDef ){//a String [3] poentially translatable to: a String[3]
					ArrayDef asAr = (ArrayDef)third;
					if(asAr.getArrayElements(this).size() == 1 || asAr.getArrayElements(this).size() == 0 ){
						
						int sz = -1;
						if(asAr.getArrayElements(this).size() == 0){
							sz = 1;
						}else{
							Expression firstAr = asAr.getArrayElements(this).get(0);//maybe bug here
							if(firstAr instanceof VarInt){
								sz = ((VarInt) firstAr).inter;
							}
						}
						
						if(sz > 0){
							NamedType asType = new NamedType(line, col, ((RefName)expressionList.exprs.get(1)).name);
							asType.setArrayLevels(sz);
							this.maskErrors(false);
							asType.accept(this);
							if(!this.maskedErrors()){//type takes priority
								AssignNew ass = new AssignNew(null, line, col, false, false, ((RefName)expressionList.exprs.get(0)).name, null, asType);
								expressionList.astRedirect = ass;
								return ass.accept(this);
							}
						}
					}
				}
			}
		}
		
		
		//what coudld it be?
		if(expressionList.exapnder == null){
			expressionList.exapnder = new ExpressionListExpander(expressionList.exprs);
		}
		boolean calledInExprListExpandrprev = calledInExprListExpandr;
		calledInExprListExpandr = true;
		Pair<Boolean, ArrayList<Expression>> foundAndchoices = expressionList.exapnder.getPossibilities(this);
		calledInExprListExpandr = calledInExprListExpandrprev;
		boolean found = foundAndchoices.getA();
		
		ArrayList<Expression> choices = foundAndchoices.getB();
		int sz = choices.size();
		if(!found){//nothing works
			if(choices.isEmpty()){
				this.raiseError(line, col, "No valid interpretation of expression list available");
				return null;
			}else{//we managed to process part of the list of items but not all
				if(sz <= exprListPrintAmbigCutOffPoint){
					StringBuilder sb = new StringBuilder();
					int szz = choices.size();
					for(int n=0; n < szz; n++){
						Expression choice = choices.get(n);
						PrintSourceVisitor visitor = new PrintSourceVisitor();
						choice.accept(visitor);
						if(n>0){
							sb.append("\n");
						}
						sb.append("-> " + visitor + " ...");
					}
					this.raiseError(line, col, "Unable to interpret entire expression list, best interpretations so far:\n" + sb);
					
				}else{
					this.raiseError(line, col, String.format("Unable to interpret entire expression list, more than %s partial interpretations possible", exprListPrintAmbigCutOffPoint));
				}
				
				return null;
			}
			
		}else {
			if(sz > 1){
				//print amibious ones out
				if(sz <= exprListPrintAmbigCutOffPoint){
					StringBuilder sb = new StringBuilder();
					int n=0;
					for(Expression choice : choices){
						PrintSourceVisitor visitor = new PrintSourceVisitor();
						choice.accept(visitor);
						if(n++ > 0){
							sb.append("\n");
						}
						
						sb.append("-> " + visitor );
					}
					this.raiseError(expressionList.getLine(), expressionList.getLine(), "Ambiguous expression list defined, more than one valid interpretation possible:\n" + sb);
					
				}else{
					this.raiseError(expressionList.getLine(), expressionList.getLine(), String.format("Ambiguous expression list defined, more than %s valid interpretations possible", exprListPrintAmbigCutOffPoint));
				}
				
				return null;
			}else{
				//just one great
				//if(null == expressionList.astRedirect){
				Node foundnode = (Node)choices.get(0);
				
				PrintSourceVisitor psv = new PrintSourceVisitor();
				foundnode.accept(psv);
				String newRep = psv.toString();
				
				if(expressionList.redirectedStringRep == null || !expressionList.redirectedStringRep.equals(newRep)){
					//only rewrite if done so aloready if the code redirects to something else new
					expressionList.astRedirect = foundnode;
					expressionList.redirectedStringRep = newRep;
				}
				
				this.maskErrors(true);
				Type what = (Type)expressionList.astRedirect.accept(this);
				ArrayList<CapMaskedErrs> caps = this.getmaskedErrors();
				
				if(caps.isEmpty()) {
					if(TypeCheckUtils.isVoidPrimativePure(what) && !expressionList.supressLastItemDoubleDotAttempt) {
						//we need a value returned but the expression returns a void, see if we can tweak last element to return self
						
						if(expressionList.astRedirect instanceof DotOperator) {
							DotOperator asDop = (DotOperator)expressionList.astRedirect;
							asDop.returnCalledOn.set(asDop.returnCalledOn.size()-1, true);
							what = (Type)expressionList.astRedirect.accept(this);
						}
						
					}
				}else {
					this.applyMaskedErrors(caps);
				}
				
				
				
				return expressionList.setTaggedType(what);
			}
		}
		
		
		//return expressionList.astRedirect.getTaggedType();//already been visisted
	}
	@Override
	public Object visit(Vectorized vectorized) {
		
		if(vectorized.expr instanceof Vectorized){
			this.raiseError(vectorized.getLine(), vectorized.getColumn(), "Expression to vectorize has already been vectorized");
		}
		
		Type ret = (Type)vectorized.expr.accept(this);
		if(null != ret) {
			boolean ok=true;
			if(vectorized.doubledot) {
				if(vectorized.expr instanceof ArrayRef) {
					if(((ArrayRef)vectorized.expr).vectDepth != null || ((ArrayRef)vectorized.expr).vectArgumentDepth != null){
						this.raiseError(vectorized.getLine(), vectorized.getColumn(), "Vectorized array references may not make use  of the double hat operator ^^ denoting self vectorization");
						ok=false;
					}
				}
			}
			
			if(ok) {
				ret = (Type)ret.copy();
				
				vectorized.validAtThisLocation=false;
				
				ret = TypeCheckUtils.getRefTypeToLocked(ret);
				
				if(!ret.hasArrayLevels() && !TypeCheckUtils.isList(this.getErrorRaiseableSupression(), ret, false)){
					this.raiseError(vectorized.getLine(), vectorized.getColumn(), "Only arrays and lists can be vectorized, not: " + ret);
				}

				ret.setVectorized(vectorized.doubledot?Vectorization.SELF:Vectorization.NORMAL);
			}
		}
		
		return vectorized.setTaggedType(ret);
	}
	
	
	public Type processVectorizedItem(int line, int col, HasDepth hasdepth, Expression expr, Expression toTry, boolean doubledot, boolean isVectFieldRef, boolean isConstructor, boolean isSafe) {
		if(expr instanceof Vectorized){
			this.raiseError(line, col, "Expression to vectorize has already been vectorized");
		}
		
		Type lhsType = (Type)expr.accept(this);
		
		if(!lhsType.hasArrayLevels() && !TypeCheckUtils.isList(this.getErrorRaiseableSupression(), lhsType, false)){
			this.raiseError(line, col, "Only array and lists can be vectorized");
		}
		
		//go find relevant function...
		
		Type rawType = TypeCheckUtils.extractVectType(lhsType);
		ArrayList<Pair<Boolean, NullStatus>> vectSttruct = TypeCheckUtils.getVectorizedStructure(ers, lhsType);
		ArrayList<Pair<Boolean, NullStatus>> foundlevels = new ArrayList<Pair<Boolean, NullStatus>>();
		
		this.currentDotOperatorTracker.push(new DotOperatorAndIndex(true));
		
		boolean isFuncRefInvoke = toTry instanceof RefName;
		Type retType=null;
		
		
		if(vectSttruct.isEmpty()) {
			foundlevels=null;
		}else {
			while(true){
				foundlevels.add(vectSttruct.remove(0));//vectorizing so must be at least one level in...
				
				Type tryMe = TypeCheckUtils.applyVectStruct(vectSttruct, rawType);
				tryMe.setVectorized(doubledot?Vectorization.SELF:Vectorization.NORMAL);
				
				this.maskErrors();
		
				this.dotOperatorLHS.push(tryMe);
				retType = (Type)toTry.accept(this);
				
				boolean errors = this.maskedErrors();
				
				if(isVectFieldRef) {
					RefName rn = (RefName)toTry;
					String getterName = FieldAccessRepointer.getterOrSetterName(rn, retType, true);
					
					FuncInvoke fi = new FuncInvoke(0,0, getterName);
					this.maskErrors(true);
					Type getterType = (Type)fi.accept(this);
					if(!this.maskedErrors()) {
						retType = getterType;
						errors=false;
					}
				}
				
				this.dotOperatorLHS.pop();

				boolean shouldbreak = false;
				if(!errors){
					shouldbreak=true;
				}
				else if(vectSttruct.isEmpty()) {
					foundlevels=null;
					shouldbreak=true;
				}
				
				if(shouldbreak) {
					FuncInvokeArgs fia = null;
					if(toTry instanceof New){
						fia = ((New)toTry).args;
					}else if(toTry instanceof FuncInvoke){
						fia = ((FuncInvoke)toTry).args;
					}else if(toTry instanceof FuncRefInvoke) {
						FuncRefInvoke fri = (FuncRefInvoke)toTry;
						fia = fri.getArgs();
					}
					
					if(fia != null) {
						int argLevels = -1;
						for(Expression item : fia.asnames) {
							if(item instanceof Vectorized) {
								argLevels = TypeCheckUtils.getVectorizedStructure(ers, item.getTaggedType()).size();
								break;
							}
						}
						
						if(argLevels > -1) {
							ArrayList<Pair<Boolean, NullStatus>> retvectSttruct = TypeCheckUtils.getVectorizedStructure(ers, retType);
							if(argLevels <= retvectSttruct.size()) {
								retType = TypeCheckUtils.applyVectStruct(retvectSttruct.subList(0, retvectSttruct.size() - argLevels), TypeCheckUtils.extractVectType(retType));
							}
						}
					}
					
					break;
				}
			}
		}
		
		this.currentDotOperatorTracker.pop();
		
		if(foundlevels == null){
			String msg;
			if(isFuncRefInvoke) {
				msg = "Unable to find field with matching name for vectorized argument: " +((RefName)toTry).name;
			}
			else {
				msg = String.format("Unable to find %s with matching signature for vectorized argument", isConstructor?"constructor":"method");
				if(toTry instanceof FuncInvoke) {
					msg += ": " +((FuncInvoke)toTry).funName;
				}
			}
			
			
			this.raiseError(line, col, msg);
			return null;
		}


		hasdepth.setDepth( new ArrayList<Pair<Boolean, NullStatus>>(foundlevels ));
		
		ArrayList<Pair<Boolean, NullStatus>> retvectSttruct = TypeCheckUtils.getVectorizedStructure(ers, retType);
		if(!retvectSttruct.isEmpty()) {
			foundlevels.addAll(retvectSttruct);
		}

//		hasdepth.setDepth( foundlevels );
		retType = TypeCheckUtils.applyVectStruct(foundlevels, TypeCheckUtils.extractVectType(retType));
		
		if(isSafe) {
			if(retType instanceof PrimativeType) {
				retType = TypeCheckUtils.boxTypeIfPrimative(retType, true);
				//if()
			}
		}
		
		return retType;
	}
	
	@Override
	public Object visit(VectorizedFuncInvoke vectorizedFuncInvoke) {
		Type got = processVectorizedItem(vectorizedFuncInvoke.getLine(), vectorizedFuncInvoke.getColumn(), vectorizedFuncInvoke, vectorizedFuncInvoke.expr, vectorizedFuncInvoke.funcInvoke, vectorizedFuncInvoke.doubledot, false, false, vectorizedFuncInvoke.nullsafe);
		return vectorizedFuncInvoke.setTaggedType(got);
	}
	
	@Override
	public Object visit(VectorizedFuncRef vectorizedFuncRef) {
		Type got = processVectorizedItem(vectorizedFuncRef.getLine(), vectorizedFuncRef.getColumn(), vectorizedFuncRef, vectorizedFuncRef.expr, vectorizedFuncRef.funcRef, vectorizedFuncRef.doubledot, false, false, vectorizedFuncRef.nullsafe);
		return vectorizedFuncRef.setTaggedType(got);
	}
	
	@Override
	public Object visit(VectorizedFieldRef vectorizedFieldRef) {
		Type got = processVectorizedItem(vectorizedFieldRef.getLine(), vectorizedFieldRef.getColumn(), vectorizedFieldRef, vectorizedFieldRef.expr, vectorizedFieldRef.name, vectorizedFieldRef.doubledot, true, false, vectorizedFieldRef.nullsafe);
		
		if(vectorizedFieldRef.doubledot) {
			this.raiseError(vectorizedFieldRef.getLine(), vectorizedFieldRef.getColumn(), "Only single ^ may be used for vectorized field operations");
		}
		
		return vectorizedFieldRef.setTaggedType(got);
	}
	
	@Override
	public Object visit(VectorizedNew vectorizedFieldRef) {
		Type got = processVectorizedItem(vectorizedFieldRef.getLine(), vectorizedFieldRef.getColumn(), vectorizedFieldRef, vectorizedFieldRef.lhs, vectorizedFieldRef.constru, vectorizedFieldRef.doubledot, false, true, vectorizedFieldRef.nullsafe);
		
		if(vectorizedFieldRef.doubledot) {
			this.raiseError(vectorizedFieldRef.getLine(), vectorizedFieldRef.getColumn(), "Only single ^ may be used for vectorized new operations");
		}
		
		return vectorizedFieldRef.setTaggedType(got);
	}
	
	
	
	@Override
	public Object visit(VectorizedArrayRef vectorizedFieldRef) {
		Type retSoFar = (Type)vectorizedFieldRef.expr.accept(this);
		
		ArrayList<Pair<Boolean, NullStatus>> struct = TypeCheckUtils.getVectorizedStructure(this.getErrorRaiseableSupression(), retSoFar);
		
		ArrayList<ArrayRefElement> allItems = vectorizedFieldRef.arrayLevelElements.flatten();

		if(vectorizedFieldRef.doubledot) {
			this.raiseError(vectorizedFieldRef.getLine(), vectorizedFieldRef.getColumn(), "Only single ^ may be used for vectorized array operations");
			return null;
		}
		
		
		if(struct.size() > allItems.size()) {
			Type rawTye = TypeCheckUtils.extractVectType(retSoFar);
			retSoFar = TypeCheckUtils.applyVectStruct(struct.subList(1, struct.size()), rawTye);
			
			Pair<ArrayList<Pair<Boolean, NullStatus>>, Type> evRsf = processArrayRefElements(vectorizedFieldRef.getLine(), vectorizedFieldRef.getColumn(), retSoFar, vectorizedFieldRef.arrayLevelElements, null);
			if(null == evRsf) {
				return null;
			}
			ArrayList<Pair<Boolean, NullStatus>> argumentsToRefGotVectorized = evRsf.getA();
			//retSoFar = Utils.removeGenericUpperBounds(evRsf.getB());
			
			Vectorized vect = new Vectorized(vectorizedFieldRef.expr);
			vect.validAtThisLocation=false;
			Type vfrType = (Type)vectorizedFieldRef.expr.getTaggedType().copy();
			vfrType.setVectorized(Vectorization.NORMAL);
			vect.setTaggedType(vfrType);
			
			//if(null == vectorizedFieldRef.astOverridearrayRef) {
				ArrayRefLevelElementsHolder copyHolder = vectorizedFieldRef.arrayLevelElements.clone();
				
				/*RangeExpression initialExtractor
				
				copyHolder.prepend(item);*/
				if(null == vectorizedFieldRef.astOverridearrayRef) {
					vectorizedFieldRef.astOverridearrayRef = new ArrayRef(vectorizedFieldRef.getLine(), vectorizedFieldRef.getColumn(), vect, copyHolder);
					
				}
				
				if(argumentsToRefGotVectorized != null) {
					if(argumentsToRefGotVectorized.size() > 1) {
						this.raiseError(vectorizedFieldRef.getLine(), vectorizedFieldRef.getColumn(), "The vectorized arguments of a vectorized array reference may have only one degree of dimentionality");
						return null;
					}
					vectorizedFieldRef.astOverridearrayRef.vectDepth = argumentsToRefGotVectorized;
				}
				vectorizedFieldRef.astOverridearrayRef.vectArgumentDepth = struct.subList(0, 1);
				
			//}
				Type resultant = (Type)vectorizedFieldRef.astOverridearrayRef.accept(this);
				if(argumentsToRefGotVectorized == null) {
					retSoFar = resultant;
				}else {
					vectorizedFieldRef.astOverridearrayRef.setTaggedType(retSoFar);
				}
				
			
		}else {
			this.raiseError(vectorizedFieldRef.getLine(), vectorizedFieldRef.getColumn(), String.format("Vectorized epxression must have more than: %s levels of dimentionality, it has: %s", struct.size() , allItems.size()));
			return null;
		}
		
		
		return vectorizedFieldRef.setTaggedType(retSoFar);
	}
	
	
	
	
	
	@Override
	public Object visit(MultiType multiType) {
		/*if(multiType.ignore) {
			return null;
		}*/
		
		if(!multiType.isValidAtThisLocation) {
			this.raiseError(multiType.getLine(), multiType.getColumn(), String.format("Multitype '%s' may not be used at this location", multiType));
		}
		
		ArrayList<Type> items = new ArrayList<Type>(multiType.multitype.size());
		for(Type subT : multiType.multitype) {
			subT = (Type)subT.accept(this);
			if(subT instanceof MultiType) {
				items.addAll(((MultiType)subT).multitype);
			}else {
				items.add(subT);
			}
		}
		multiType.multitype = items;
		
		
		return multiType;
	}
	
	/**
	 * 
	 * @return Given input constraints: true - vectorizable, false - not vectorizable, null - has no impact on vectorization (conforms to type etc)
	 * 			[should vect, is op overload, should skip next item]
	 */
	private Thruple<Boolean, Boolean, Boolean> isVectorizableType(int line, int col, ErrorRaiseable er, Type input, Type nextType, Expression nextExpr, String operatorOverlod, boolean canBeString, boolean canBeAny, boolean isUnary, boolean oneMustBeScalar) {
		Type originput = input;
		boolean isList = TypeCheckUtils.isList(er, input, false);
		boolean isFromVectListOrArray = false;
		int inputLevels = 0;
		boolean listOrArr= input.hasArrayLevels() || isList;
		
		if(input instanceof NamedType && operatorOverlod != null) {
			Thruple<Boolean, Boolean, Boolean> opOver = supressVectAsOpOVerload( line,  col,  operatorOverlod,  input,  nextExpr,  nextType,  isList,  isUnary, true);
			if(null != opOver) {//no vectorization here
				return new Thruple<Boolean, Boolean, Boolean>(false, false, false);
			}
		}
		
		if(listOrArr) {
			ArrayList<Type> comps = TypeCheckUtils.extractIntermediateVectTypes(ers, input, true);
			inputLevels = comps.size();
			input = comps.get(0);
			isFromVectListOrArray=true;
		}
		
		if(oneMustBeScalar && inputLevels != 0) {//if say, == operator then we must differ the lhs and rhs by one vect level only
			int nextLevels = -1;
			if(nextType != null ) {
				if(nextType instanceof VarNull) {
					return new Thruple<Boolean, Boolean, Boolean>(false, false, false);//no vectorization of this thing!
				}
				nextLevels = TypeCheckUtils.extractIntermediateVectTypes(ers, nextType, false).size();
			}
			
			if(nextLevels != -1) {
				if(nextLevels != 0){
					if(inputLevels != nextLevels) {//levels have to match for vect structure to work
						return new Thruple<Boolean, Boolean, Boolean>(false, false, false);//no vectorization of this thing!
					}
					
					boolean inputPrimWithVect = (originput instanceof PrimativeType || TypeCheckUtils.isBoxedType(input) ) &&  originput.isVectorized();
					boolean nextTypePrimWithVect = (nextType instanceof PrimativeType || TypeCheckUtils.isBoxedType(input)  ) && nextType.isVectorized();
					
					/*if(!(input instanceof PrimativeType || nextType instanceof PrimativeType)) {
						return new Thruple<Boolean, Boolean, Boolean>(false, false, false);//no vectorization of this thing!
					}*/
					if(!(inputPrimWithVect || nextTypePrimWithVect)) {
						return new Thruple<Boolean, Boolean, Boolean>(false, false, false);//no vectorization of this thing!
					}
				}
			}
		}
		
		if(input instanceof NamedType && operatorOverlod != null) {
			Thruple<Boolean, Boolean, Boolean> opOver = supressVectAsOpOVerload( line,  col,  operatorOverlod,  input,  nextExpr,  nextType,  isFromVectListOrArray,  isUnary, false);
			if(null != opOver) {
				return opOver;
			}
		}
		
		
		boolean typeConfirmsToContraints = false;
		if(canBeAny) {
			typeConfirmsToContraints=true;
		}else {
			if(canBeString && ScopeAndTypeChecker.const_string.equals(input)) {
				typeConfirmsToContraints= false;
			}
			else if(input instanceof PrimativeType || TypeCheckUtils.isBoxedType(input)) {
				typeConfirmsToContraints= true;
			}
		}
		
		if(isFromVectListOrArray) {
			if(typeConfirmsToContraints) {
				return new Thruple<Boolean, Boolean, Boolean>(true, false, false);
			}else {
				return new Thruple<Boolean, Boolean, Boolean>(null, false, false);
			}
		}else {
			if(typeConfirmsToContraints) {
				return new Thruple<Boolean, Boolean, Boolean>(null, false, false);
			}else {
				return new Thruple<Boolean, Boolean, Boolean>(false, false, false);
			}
		}
		
	}
	
	
	private Thruple<Boolean, Boolean, Boolean> supressVectAsOpOVerload(int line, int col, String operatorOverlod, Type input, Expression nextExpr, Type nextType, boolean isFromVectListOrArray, boolean isUnary, boolean exactMatchOnly){
		boolean isNull = nextExpr == null || nextExpr instanceof VarNull;
		
		if(isUnary || (!isNull && !nextType.isVectorized()) ) {//check for operator overloading
			if(isUnary) {
				if(isFromVectListOrArray){
					FuncInvoke fn = canBeOperatorOverloaded(input, new ArrayList<Type>(), null, operatorOverlod, new ArrayList<Expression>(), line, col, false, null, false, null);
					if(null != fn) {
						return new Thruple<Boolean, Boolean, Boolean>(true, false, true);//vectorize the likes of [MyClas(1) MyClas(2) MyClas(3)] ++. w/ MyClas impl ++
					}
				}
			}else {
				FuncInvoke fn = canBeOperatorOverloaded(input, nextType, operatorOverlod, nextExpr, line, col, null);
				if( null == fn && !exactMatchOnly) {//if input has int[][] - dont process
					ArrayList<Type> eTypes = TypeCheckUtils.extractIntermediateVectTypes(ers, nextType, false);
					
					for(Type toTry : eTypes) {
						if( null != canBeOperatorOverloaded(input, toTry, operatorOverlod, nextExpr, line, col, null)) {
							return new Thruple<Boolean, Boolean, Boolean>(true, !isFromVectListOrArray, false);//ok if input takes int[] or int
						}
					}
				}else if(isFromVectListOrArray && !exactMatchOnly){
					return new Thruple<Boolean, Boolean, Boolean>(true, false, true);//vectorize the likes of [MyClas(1) MyClas(2) MyClas(3)] + 10. w/ MyClas impl +
				}else if(null != fn && isFromVectListOrArray && exactMatchOnly) {
					return new Thruple<Boolean, Boolean, Boolean>(false, false, false);
				}
			}
		}
		return null;
	}
	
	/*@Override
	public Object visit(RangeExpression rangeExpression) {
		Type lhsType = (Type)rangeExpression.lhs.accept(this);
		Type rhsType = (Type)rangeExpression.rhs.accept(this);
		
		if(lhsType != null && rhsType != null) {
			boolean lhsOk = TypeCheckUtils.checkNumerical(this, lhsType, rangeExpression.lhs.getLine(), rangeExpression.lhs.getColumn(), false);
			boolean rhsOk = TypeCheckUtils.checkNumerical(this, rhsType, rangeExpression.rhs.getLine(), rangeExpression.rhs.getColumn(), false);
			
			if(lhsOk && rhsOk) {
				if( null == rangeExpression.astOverride) {
					int line = rangeExpression.getLine();
					int col = rangeExpression.getColumn();
					//ok now gennerate astredirect...
					Block blk = new Block(line, col);

					String rangeTp = "tmp$RangeTo";
					blk.add(new AssignNew(null, line, col, rangeTp, rhsType, AssignStyleEnum.EQUALS, rangeExpression.rhs));
					
					String tmpInc = "tmp$rangeToInc";
					blk.add(new AssignNew(null, line, col, tmpInc, lhsType, AssignStyleEnum.EQUALS, rangeExpression.lhs));
					
					Block blkForWhile = new Block(line, col);
					//blkForWhile.add( (new  DuffAssign(line, col, new RefName(tmpInc))));
					blkForWhile.add(new ContinueStatement(line, col, new PostfixOp(line, col, FactorPostFixEnum.PLUSPLUS, new RefName(tmpInc))));
					//blkForWhile.isolated = true;
					blkForWhile.setShouldBePresevedOnStack(true);
					
					EqReExpression lt = new EqReExpression(line, col, new RefName(tmpInc), GrandLogicalOperatorEnum.LT, new RefName(rangeTp));
					
					blk.add(new WhileBlock(line, col, lt, blkForWhile));

					blk.isolated = true;
					blk.setShouldBePresevedOnStack(true);
					rangeExpression.astOverride = blk;
				}
				
				return rangeExpression.setTaggedType((Type)rangeExpression.astOverride.accept(this));
			}else {
				this.raiseError(rangeExpression.getLine(), rangeExpression.getColumn(), String.format("Both left and right hand side of range operation must be numerical. Not: %s and %s", lhsType, rhsType));
			}
		}
		
		return null;
	}*/
	
	@Override
	public Object visit(ImpliInstance impliInstance) {
		return null;
	}

	@Override
	public Object visit(PrimativeType primativeType) {
		if(this.currentlyInFuncDef.isEmpty() || this.currentlyInFuncDef.peek().isGPUKernalOrFunction == null ) {
			if(primativeType.getPointer() != 0) {
				this.raiseError(primativeType.getLine(), primativeType.getColumn(), String.format("Pointers cannot be used outside of gpu functions or gpu kernels"));
			}
			
			if(primativeType.type == PrimativeTypeEnum.SIZE_T) {
				this.raiseError(primativeType.getLine(), primativeType.getColumn(), String.format("size_t cannot be used outside of gpu functions or gpu kernels"));
			}
			
		}
		
		return primativeType;
	}
	
	@Override
	public Object visit(PointerAddress pointerAddress) {
		if(this.currentlyInFuncDef.isEmpty() || this.currentlyInFuncDef.peek().isGPUKernalOrFunction == null) {
			this.raiseError(pointerAddress.getLine(), pointerAddress.getColumn(), "Pointer address operator & can only be used within gpu kernels or gpu functions");
		}
		
		Expression rhs = pointerAddress.rhs;
		
		boolean validrhs = false;
		if(rhs instanceof RefName) {
			validrhs=true;
		}else if(rhs instanceof ArrayRef) {
			validrhs= ((ArrayRef)rhs).expr instanceof RefName;
		}
		
		if(!validrhs) {
			this.raiseError(pointerAddress.getLine(), pointerAddress.getColumn(), "Invalid element on right hand side of pointer address operator &. Only a variable name or array reference on variable is permitted");
		}
		
		Type got = (Type) pointerAddress.rhs.accept(this);
		if(null != got) {
			got = (Type)got.copy();
			got.setPointer(got.getPointer() + 1);
			
			if(got.getGpuMemSpace() == null) {
				got.setGpuMemSpace(GPUVarQualifier.PRIVATE);
			}
			
		}
		
		
		return pointerAddress.setTaggedType(got);
	}
	
	
	
	@Override
	public Object visit(PointerUnref pointerAddress) {
		if(pointerAddress.rhs instanceof ArrayConstructor) {//disamiguate this case: *int[3] => (proc as: *new int[3] => *int[3])
			ArrayConstructor ac = (ArrayConstructor)pointerAddress.rhs;
			if(ac.type instanceof PrimativeType) {
				ac = (ArrayConstructor)ac.copy();
				ac.type.setPointer(pointerAddress.size);
				pointerAddress.astOverride = ac;
				return pointerAddress.astOverride.accept(this);
			}
		}
		
		if(this.currentlyInFuncDef.isEmpty() || this.currentlyInFuncDef.peek().isGPUKernalOrFunction == null) {
			StringBuilder sb = new StringBuilder("*");
			for(int n=0; n < pointerAddress.size; n++) {
				sb.append("*");
			}
			this.raiseError(pointerAddress.getLine(), pointerAddress.getColumn(), String.format("Pointer address dereferencing %s can only be used within gpu kernels or gpu functions", sb));
		}
		
		Type rhsType = (Type)pointerAddress.rhs.accept(this);
		if(null != rhsType) {
			int rhsSize = rhsType.getPointer();
			if(rhsSize != 0) {
				int newsize = rhsSize - pointerAddress.size;
				if(newsize< 0) {
					this.raiseError(pointerAddress.getLine(), pointerAddress.getColumn(), String.format("Attempting to dereference a pointer type with: %s levels by: %s levels", rhsSize, pointerAddress.size));
				}else {
					rhsType = (Type)rhsType.copy();
					rhsType.setPointer(newsize);
					
					if(rhsType.getGpuMemSpace() == null) {
						rhsType.setGpuMemSpace(GPUVarQualifier.PRIVATE);
					}
					
					return rhsType;
				}
			}else {
				this.raiseError(pointerAddress.getLine(), pointerAddress.getColumn(), String.format("Attempting to dereference type which is not a pointer: %s", rhsType));
			}
		}
		
		return null;
	}

	@Override
	public Object visit(JustLoad justLoad) {
		return null;//ignore, used in bytecode genneration only
	}
	
	private static HashMap<Integer, NamedType> tupleTypes = new HashMap<Integer, NamedType>();//lazy load since we use conc to define them

	
	private NamedType getTupleType(int line, int col, Integer itemCount) {
		NamedType ret;
		if(tupleTypes.containsKey(itemCount)) {
			ret = tupleTypes.get(itemCount);
		}else {
			String name = "com.concurnas.lang.tuples$Tuple";
			if(null != itemCount) {
				name+=itemCount;
			}
			
			try {
				Class<?> tupInst = Class.forName(name);
				ret = new NamedType(line, col, new ClassDefJava(tupInst));
			} catch (ClassNotFoundException e) {
				this.raiseError(line, col, String.format("Cannot find tuple class for: %s", name));
				return null;
			}
			tupleTypes.put(itemCount, ret);
		}
		return ret;
	}
	
	
	@Override
	public Object visit(TupleExpression tupleExpression) {
		int tupSize = tupleExpression.tupleElements.size();
		//List<Type> types = new ArrayList<Type>(tupSize);
		
		if(tupleExpression.tupleElements.contains(null)) {
			return null;
		}
		
		List<Type> types = tupleExpression.tupleElements.stream().map(a -> (Type)a.accept(this)).collect(Collectors.toList());
		
		if(types.stream().anyMatch(a -> !TypeCheckUtils.isValidType(a))) {
			this.raiseError(tupleExpression.getLine(), tupleExpression.getColumn(), "tuples cannot contain void");
			return null;//cannot process with invalud types
		}
		
		types = types.stream().map(a -> TypeCheckUtils.boxTypeIfPrimative((Type)a.accept(this), false)).collect(Collectors.toList());
		
		//tupleExpression.tupleElements.forEach(a -> types.add(TypeCheckUtils.boxTypeIfPrimative((Type)a.accept(this), false)));
		
		if(tupSize > 24) {
			this.raiseError(tupleExpression.getLine(), tupleExpression.getColumn(), String.format("Maxium number of elements for a tuple is: %s, provided tuple has: %s elements", 24, tupSize));
			return null;
		}
		
		NamedType tuple = getTupleType(tupleExpression.getLine(), tupleExpression.getColumn(), tupSize);
		if(null == tuple) {//err already
			return null;
		}
		tuple = tuple.copyTypeSpecific();

		ArrayList<Type> genTypes = new ArrayList<Type>(tupSize);
		types.forEach(a -> genTypes.add(a==null?null:(Type)a.copy()));
		//all valuid types

		tuple.setGenTypes(types);
		
		return tupleExpression.setTaggedType(tuple);
	}
	
	private static NamedType tupleNamedType = null;

	public static NamedType getTupleNamedType() {
		return getTupleNamedType(true);
	}
	
	
	public static NamedType getTupleNamedType(boolean throwsE) {
		if(tupleNamedType == null){
			try {
				tupleNamedType = new NamedType(new ClassDefJava(Class.forName("com.concurnas.lang.tuples$Tuple")));
			} catch (ClassNotFoundException e) {
				if(throwsE) {
					throw new RuntimeException(e);
				}
			}
		}
		return tupleNamedType;
	}
	
	@Override
	public Object visit(AssignTupleDeref assignTupleDeref) {
		//tidy up eq assign for new ans existing (convert new to existing if += used etc)
		//mock rhs expr?
		
		validateInjectAssignLocation(assignTupleDeref);//valid here?
		
		Type rhs = (Type)assignTupleDeref.expr.accept(this);
		rhs = TypeCheckUtils.getRefType(rhs);
		if(null == TypeCheckUtils.checkSubType(this.getErrorRaiseableSupression(), getTupleNamedType(), rhs)) {
			this.raiseError(assignTupleDeref.getLine(), assignTupleDeref.getColumn(), String.format("Right hand side of tuple decomposition assignment must be a tuple, not: %s", rhs));
		}else {
			//check size
			NamedType tupleType = (NamedType)rhs;
			ArrayList<Type> ttypes = tupleType.getGenericTypeElements();
			int expectedCnt = ttypes.size();
			if(assignTupleDeref.lhss.size() != expectedCnt) {
				this.raiseError(assignTupleDeref.getLine(), assignTupleDeref.getColumn(), String.format("Tuple decomposition assignment expected right hand side tuple with: %s elements, but got: %s", assignTupleDeref.lhss.size(), expectedCnt));
			}else {
				
				for(int n = 0; n < expectedCnt; n++) {
					Assign assignToProcess = assignTupleDeref.lhss.get(n);
					if(null != assignToProcess) {
						assignToProcess.setAssignStyleEnum(assignTupleDeref.eq);
						assignToProcess.setRHSExpression(new TypeReturningExpression(((Node)assignTupleDeref.expr).getLine(), ((Node)assignTupleDeref.expr).getColumn(), ttypes.get(n)));
						assignToProcess.accept(this);
					}
					
				}
			}
		}
		
		return null;
	}
	@Override
	public Object visit(AnonLambdaDef anonLambdaDef) {
		int line = anonLambdaDef.getLine();
		int col = anonLambdaDef.getColumn();
		if(anonLambdaDef.isFullyTyped()) {//types defined and no null
			//convert to lambda def
			FuncParams params = new FuncParams(line, col);
			
			for(Pair<String, Type> input : anonLambdaDef.getInputs()) {
				params.add(new FuncParam(line, col, input.getA(), input.getB(), false));
			}
			
			LambdaDef ld = new LambdaDef(line, col, null, params, anonLambdaDef.body, anonLambdaDef.retType, new ArrayList<Pair<String, NamedType>>());
			ld.setShouldBePresevedOnStack(true);
			anonLambdaDef.astRedirect = ld;
			return anonLambdaDef.astRedirect.accept(this);
		}else {
			if(!calledInExprListExpandr) {
				this.raiseError(line, col, "Unable to infer type for lambda function");
			}
			anonLambdaDef.body.setShouldBePresevedOnStack(true);
			
			FuncType ft = new FuncType(0,0);//stub
			
			this.maskErrors();
			
			ArrayList<Pair<String, Type>>  inputs = anonLambdaDef.getInputs();
			ArrayList<Type> inputTypes = new ArrayList<Type>(inputs.size());
			for(Pair<String, Type> input : inputs) {
				Type tt = input.getB();
				if(tt == null) {
					tt = ScopeAndTypeChecker.const_object;
				}else {
					tt.accept(this);
				}
				inputTypes.add(tt);
			}
			ft.inputs = inputTypes;
			
			Type returnType = anonLambdaDef.retType;
			if(null == returnType) {
				returnType = (Type)anonLambdaDef.body.accept(this);
				if(null == returnType) {
					returnType  = ScopeAndTypeChecker.const_object;
				}
			}else {
				returnType.accept(this);
			}
			ft.retType = returnType;
			
			this.maskedErrors();
			
			ft.anonLambdaSources = new ArrayList<AnonLambdaDefOrLambdaDef>();//bit of a hack
			ft.anonLambdaSources.add(anonLambdaDef);
			
			return anonLambdaDef.setTaggedType(ft);
		}
	}



	@Override
	public Object visit(com.concurnas.compiler.ast.ObjectProvider objectProvider) {
		
		//TODO: regerenate if dependant classes have changed signature
		
		if(objectProvider.failedGennerateClass) {//convert to classdef
			
			for(ClassDef prevGen : new ClassDef[] {objectProvider.astRedirectPrev, objectProvider.astRedirect} ) {
				if(prevGen != null) {//if we made one last time, double check that it's not ok now
					this.maskErrors();
					Object ret = prevGen.accept(this);
					if(!this.maskedErrors()) {
						objectProvider.astRedirect = prevGen;
						objectProvider.failedGennerateClass=false;
						return ret;
					}else {
						objectProvider.astRedirectPrev = objectProvider.astRedirect;
					}
				}
			}
			
			this.maskErrors(true);
			objectProvider.failedGennerateClass = new ProviderCreator(this, objectProvider).createCD();
			ArrayList<CapMaskedErrs> cap = this.getmaskedErrors();
			if(!cap.isEmpty()) {
				
				//System.err.println(cap + "\n\n");
				
				this.applyMaskedErrors(cap);
				objectProvider.astRedirect = null;
				//return null;
			}else {
				this.currentScopeFrame.removeClassDef(this.currentScopeFrame, objectProvider.astRedirect.getClassName());
			}
		}
		
		if(objectProvider.astRedirect == null) {
			return null;
		}else {
			this.maskErrors(true);
			
			/*PrintSourceVisitor psv = new PrintSourceVisitor();
			psv.visit(objectProvider.astRedirect);
			System.err.println(psv.toString());	*/		
			
			Object ret = objectProvider.astRedirect.accept(this);
			ArrayList<CapMaskedErrs> cap = this.getmaskedErrors();
			if(!cap.isEmpty()) {
				//objectProvider.failedGennerateClass=true;
				this.applyMaskedErrors(cap);
			}
			
			return ret;
		}
	}
	
	@Override
	public Object visit(ObjectProviderBlock objectProviderBlock) {
		return null;
	}
	@Override
	public Object visit(ObjectProviderLineDepToExpr objectProviderLineDepToExpr) {
		return null;
	}
	@Override
	public Object visit(ObjectProviderLineProvide objectProviderLineProvide) {
		return null;
	}
	
	
	///////////////////////nullables:
	
	private  class TestedNonNullAndNull {
		public HashMap<Pair<String, Boolean>, Set<RefName>> testedNotNull = new HashMap<Pair<String, Boolean>, Set<RefName>>();
		public HashMap<Pair<String, Boolean>, Set<RefName>> testedNull = new HashMap<Pair<String, Boolean>, Set<RefName>>();
		
		private void addItem(HashMap<Pair<String, Boolean>, Set<RefName>> map, RefName refname) {
			Pair<String, Boolean> key = makeRefNameTypeOverrideKey(refname);
			if(key != null) {
				Set<RefName> addTo;
				if(!map.containsKey(key)) {
					addTo = new HashSet<RefName>();
					map.put(key, addTo);
				}else {
					addTo = map.get(key);
				}
				addTo.add(refname);
			}
		}
		
		public void addTestedNotNull(RefName refname) {
			addItem(testedNotNull, refname);
		}
		
		public void addTestedNull(RefName refname) {
			addItem(testedNull, refname);
		}
		
		private TestedNonNullAndNull join(TestedNonNullAndNull another, boolean union) {
			TestedNonNullAndNull ret = new TestedNonNullAndNull();
			
			HashSet<Pair<String, Boolean>> nonNullKeysIntersect = new HashSet<Pair<String, Boolean>>(this.testedNotNull.keySet());
			if(union) {
				nonNullKeysIntersect.addAll(another.testedNotNull.keySet());
			}else {
				nonNullKeysIntersect.retainAll(another.testedNotNull.keySet());
			}
			
			for(Pair<String, Boolean> nonNullKey : nonNullKeysIntersect) {
				Set<RefName> addTo = new HashSet<RefName>();
				ret.testedNotNull.put(nonNullKey, addTo);
				
				if(another.testedNotNull.containsKey(nonNullKey)) {
					addTo.addAll(another.testedNotNull.get(nonNullKey));
				}
				if(this.testedNotNull.containsKey(nonNullKey)) {
					addTo.addAll(this.testedNotNull.get(nonNullKey));
				}
			}
			
			HashSet<Pair<String, Boolean>> nullKeysIntersect = new HashSet<Pair<String, Boolean>>(this.testedNull.keySet());
			
			if(union) {
				nullKeysIntersect.addAll(another.testedNull.keySet());
			}else {
				nullKeysIntersect.retainAll(another.testedNull.keySet());
			}
			
			for(Pair<String, Boolean> nullKey : nullKeysIntersect) {
				Set<RefName> addTo = new HashSet<RefName>();
				ret.testedNull.put(nullKey, addTo);

				if(another.testedNull.containsKey(nullKey)) {
					addTo.addAll(another.testedNull.get(nullKey));
				}
				if(this.testedNull.containsKey(nullKey)) {
					addTo.addAll(this.testedNull.get(nullKey));
				}
			}
			
			return ret;
		}
		
		public TestedNonNullAndNull intersection(TestedNonNullAndNull another) {
			return join(another, false);
		}
		
		public TestedNonNullAndNull union(TestedNonNullAndNull another) {
			return join(another, true);
		}

		public void addAll(TestedNonNullAndNull item) {
			testedNotNull = item.testedNotNull;
			testedNull = item.testedNull;
		}
		
		public void addAllNonNullToContainer(HashMap<Pair<String, Boolean>, NullStatus> cont) {
			for(Pair<String, Boolean> key : testedNotNull.keySet()) {
				if(!testedNull.containsKey(key)) {
					for(RefName refName : testedNotNull.get(key)) {
						Pair<String, Boolean> keyx = makeRefNameTypeOverrideKey(refName);
						if(keyx != null) {
							cont.put(keyx, NullStatus.NONNULL);
						}
						
					}
				}
			}
		}
		
		public void addAllNullToContainer(HashMap<Pair<String, Boolean>, NullStatus> cont) {
			for(Pair<String, Boolean> key : testedNull.keySet()) {
				if(!testedNotNull.containsKey(key)) {
					for(RefName refName : testedNull.get(key)) {
						Pair<String, Boolean> keyx = makeRefNameTypeOverrideKey(refName);
						if(keyx != null) {
							cont.put(keyx, NullStatus.NONNULL);
						}
					}
				}
			}
		}

		public TestedNonNullAndNull invert() {
			TestedNonNullAndNull ret = new TestedNonNullAndNull();
			ret.testedNull = this.testedNotNull;
			ret.testedNotNull = this.testedNull;
			return ret;
		}
	}
	
	private  class NullableFinder extends AbstractVisitor{
		
		private boolean typeIsNullable(Expression expr) {
			if(expr instanceof RedirectableExpression) {
				expr = ((RedirectableExpression)expr).exp;
			}
			
			if(expr instanceof RefName) {
				if(((RefName)expr).inferNonNullable) {
					return true;
				}
			}
			
			Type what = expr.getTaggedType();
			return what != null && what.getNullStatus() == NullStatus.NULLABLE;
		}
		
		@Override
		public TestedNonNullAndNull visit(EqReExpression equalityExpression) {
			super.visit(equalityExpression);
			//TODO: bug where if(xyz and thing <> null)...else{}//cannot assuming thing is not null in else block unless on own
			Expression lhsExpression = equalityExpression.head;
			boolean lhsVarNull = lhsExpression instanceof VarNull;
			boolean lhsNullable = typeIsNullable(lhsExpression);
			lhsExpression = maybeResolvesToRefName(lhsExpression);
			for(GrandLogicalElement e: equalityExpression.elements)
			{
				Expression rhsExpression = e.e2;
				boolean rhsVarNull = rhsExpression instanceof VarNull;
				boolean rhsNullable = typeIsNullable(rhsExpression);
				rhsExpression = maybeResolvesToRefName(rhsExpression);
				
				if((rhsNullable && lhsVarNull) || (lhsNullable && rhsVarNull)) {
					if(e.compOp == GrandLogicalOperatorEnum.NE || e.compOp == GrandLogicalOperatorEnum.REFNE) {//certainly not null!
						if(rhsNullable && rhsExpression instanceof RefName) {//rhs vartoadd to non nullable
							RefName asRef = (RefName)rhsExpression;
							asRef.inferNonNullable = true;
							nullStatuses.peek().addTestedNotNull(asRef);
						}else if(lhsExpression instanceof RefName) {//lhs vartoadd to non nullable
							RefName asRef = (RefName)lhsExpression;
							asRef.inferNonNullable = true;
							nullStatuses.peek().addTestedNotNull(asRef);
						}
					}else if(e.compOp == GrandLogicalOperatorEnum.EQ || e.compOp == GrandLogicalOperatorEnum.REFEQ) {//certainly null!
						if(rhsNullable && rhsExpression instanceof RefName) {//rhs vartoadd to non nullable
							RefName asRef = (RefName)rhsExpression;
							nullStatuses.peek().addTestedNull(asRef);
						}else if(lhsExpression instanceof RefName) {//lhs vartoadd to non nullable
							RefName asRef = (RefName)lhsExpression;
							nullStatuses.peek().addTestedNull(asRef);
						}
					}
					
				}
				
				lhsVarNull = rhsVarNull;
				lhsNullable = rhsNullable;
				lhsExpression = rhsExpression;
			}
			
			return null;
		}
		
		private Expression maybeResolvesToRefName(Expression rhs) {
			//refname or this.refname
			if(rhs instanceof DotOperator) {
				DotOperator asDot = (DotOperator)rhs;
				ArrayList<Expression> elems = asDot.getElements(this);
				if(elems.size() == 2) {
					Expression e1 = elems.get(0);
					Expression e2 = elems.get(1);
					if(e1 instanceof RefThis) {
						if(e2 instanceof RefName) {
							return e2;
						}
					}
				}
			}
			
			return rhs;
		}
		
		@Override
		public Object visit(AndExpression andExpression) {
			TestedNonNullAndNull item = processExpression(andExpression.head);
			for (Expression i : andExpression.things) {
				item = item.union(processExpression(i));
			}
			nullStatuses.peek().addAll(item);
			return null;
		}
		
		@Override
		public Object visit(OrExpression orExpression) {
			TestedNonNullAndNull item = processExpression(orExpression.head);
			for (Expression i : orExpression.things) {
				item = item.intersection(processExpression(i));
			}
			nullStatuses.peek().addAll(item);
			return null;
		}
		
		
		private TestedNonNullAndNull processExpression(Expression test) {
			TestedNonNullAndNull ret = null;
			if(test instanceof RefName) {
				RefName asRefName = (RefName)test;
				if( typeIsNullable(test)) {
					asRefName.inferNonNullable = true;
					HashMap<String, RefName> nonNull = new HashMap<String, RefName>();
					nonNull.put(asRefName.name, asRefName);
					ret = new TestedNonNullAndNull();
					ret.addTestedNotNull(asRefName);
				}else {
					ret = new TestedNonNullAndNull();
				}
			}else if(test instanceof RedirectableExpression) {
				ret = processExpression(((RedirectableExpression)test).exp);
			}else if(test instanceof DotOperator) {//shouldn't this process the previous keys to last?
				ret = processExpression(((DotOperator)test).getLastElement());
			}else if(test instanceof NotExpression){
				
				TestedNonNullAndNull toinvert = processExpression(((NotExpression)test).expr);
				
				ret= toinvert.invert();
				
			}else {
				ret = new TestedNonNullAndNull();
				nullStatuses.push(ret);
				test.accept(this);
				nullStatuses.pop();
			}
			
			return ret;
		}
		

		private Stack<TestedNonNullAndNull> nullStatuses = new Stack<TestedNonNullAndNull>();
		
		private TestedNonNullAndNull processTest(Expression test) {
			return processExpression(test);
		}
	}	
	
	private final NullableFinder nullableTypeLogic = new NullableFinder();
	
	private NullStatus inferredAs(Pair<String, Boolean> key) {
		NullStatus inferedAs = null;
		if(key != null) {
			for(int n = this.nullableOverwriteType.size() - 1;  n >=0; n--){
				HashMap<Pair<String, Boolean>, NullStatus> level = this.nullableOverwriteType.get(n);
				if(null != level && level.containsKey(key)){
					inferedAs = level.get(key);
					break;
				}
			}
		}
		return inferedAs;
	}
///////////////////////////////////////////// langauge extensions ///////////////////////////////

	

	private void registerUsing(String shortname, String longname, int line, int col)
	{
		if(shortname.indexOf('.') > -1 )
		{
			this.raiseError(line, col, String.format("Using mapped name of: '%s' cannot contain dots" , shortname));
			return;
		}
		
		//pretend we're an import statement here such that we will recieve a request to recompile when dependency changes (if at all)
		this.mainLoop.doesImportedNameResolveToSomething(longname, mc);
		
		if(this.currentScopeFrame.paThisIsModule && this.isREPL != null && this.isREPL.tliCache.topshortNameToLongUsing.containsKey(shortname)) {//allow redefinition
			//ok
		}else if(hasUsingBeenRegistered(shortname, true)) {
			this.raiseError(line, col, "Using name has already been declared: " + shortname + " as: " + longname);	
		}
		
		else
		{
			ClassDefJava inst = null;
			
			if(precompiledBytecodeExistsCache.containsKey(longname)) {
				inst = precompiledBytecodeExistsCache.get(longname);
			}else {
				ArrayList<Pair<ITEM_TYPE, Object>> resolved = this.mainLoop.reslolvePathToBytecode(longname, false, true);
				if(resolved != null && !resolved.isEmpty()) {
					//NESTED_CLASS, STATIC_CLASS
					for(Pair<ITEM_TYPE, Object> item : resolved) {
						if(item.getA() == ITEM_TYPE.NESTED_CLASS || item.getA() == ITEM_TYPE.STATIC_CLASS) {
							inst = (ClassDefJava)item.getB();
						}
					}
					
					if(inst != null) {
						Class<?> held = inst.getClassHeld();
						if(null==held || null == TypeCheckUtils.checkSubType(this.ers, getLanguageExtensionNT(), new NamedType(inst))){
							this.raiseError(line, col, String.format("Language extension to use: %s must implement trait: com.concurnas.lang.LangExt.LanguageExtension", longname));
							return;
						}

						boolean conok = true;
						
						
						
						try {
							Constructor<?> zeroarg =  held.getConstructor();
							conok = Modifier.isPublic(zeroarg.getModifiers());
						}catch(NoSuchMethodException nsme) {
							conok=false;
						}catch(Throwable e) {
							this.raiseError(line, col, String.format("Unable to load language extension: %s as: %s", longname,  Utils.stackTrackToString(e) ));
							conok=false;
						}
						
						if(!conok) {
							this.raiseError(line, col, String.format("Language extension to use: %s must provide a public zero argument constructor", longname));
							return;
						}
						
						
						precompiledBytecodeExistsCache.put(longname, inst);
					}
				}
			}
			
			if(null == inst) {
				this.raiseError(line, col, String.format("Using name: %s cannot be resolved to a class" , longname));
				return;
			}
			
			scopedshortNameToLongNameaaUsing.peek().put(shortname, inst);
			rawUsings.peek().add(shortname);
		}

	}
	
	public ClassDefJava getUsingRegistered(String shortname){
		for(Map<String, ClassDefJava> level : scopedshortNameToLongNameaaUsing)
		{
			if(level.containsKey(shortname)){
				return level.get(shortname);
			}
		}
		
		return null;
	}
	
	private static AtomicLong langExtClassCntId = new AtomicLong();
	
	@Override
	public Object visit(LangExt langExt) {
		String langExtName = langExt.name;
		int line = langExt.getLine();
		int col = langExt.getColumn();
		
		if(null == langExt.langExtCompiler) {
			if(null == langExt.id) {
				langExt.id = langExtClassCntId.getAndIncrement();
			}
			
			ClassDefJava usingas = getUsingRegistered(langExtName);
			
			if(usingas == null) {
				 this.raiseError(langExt.getLine(), langExt.getColumn(), String.format("Language extension: %s has not been imported for use", langExtName));
				 return ScopeAndTypeChecker.const_object;
			}
			
			
			Class<?> langExtCls = usingas.getClassHeld();
			
			SourceLocation loc = SourceLocation.EXPRESSION;
			if(this.currentScopeFrame.isClass()) {
				loc = SourceLocation.CLASS;
			}else if(this.currentScopeFrame.paThisIsModule) {
				loc = SourceLocation.TOPLEVEL;
			}
			
			SchedulerRunner scheduler;
			try {
				scheduler = this.mainLoop.getLangExtScheduler();
			}catch( Throwable e) {
				this.raiseError(line, col, String.format("Unable to create instance of: %s due to internal compiler error - scheduler for isolate unavailabe: %s", langExtName, Utils.stackTrackToString(e)));
				return ScopeAndTypeChecker.const_object;
			}
			
			LanguageExtensionRunner loader = new LanguageExtensionRunner(line, col, langExtName, loc, this.mainLoop.getLangExtClassLoader(), langExt.id, langExtCls, scheduler);

			boolean ok = loader.init(this);
			
			if(!ok) {
				return null;
			}
			
			langExt.langExtCompiler = loader;
		}
		
		if(!langExt.initalized) {
			langExt.initalized = langExt.langExtCompiler.initalizeLangExt(this, langExt.body);
			
			if(!langExt.initalized) {
				return ScopeAndTypeChecker.const_object;
			}
		}
		
		Context ctx = new Context(this);
		String sucess = langExt.langExtCompiler.iterateLangExt(this, ctx);
		
		if(langExt.processed == null || !langExt.processed.equals(sucess)) {
			//TODO: output code may be invalid
			try {
				langExt.astRedirectBlock = Utils.parseBlock(sucess, langExtName, langExt.getLine(), true);
				langExt.processed = sucess;
			}catch(RuntimeException re) {
				this.raiseError(line, col, String.format("Language extension: %s has produced invalid Concurnas code: %s\nInvalid code:\n%s", langExtName, re.getMessage(), sucess));
			}
		}
		
		if(langExt.astRedirectBlock != null) {
			langExt.astRedirectBlock.setShouldBePresevedOnStack(langExt.getShouldBePresevedOnStack());
			
			this.maskErrors(true);
			Type ret = null;
			for(LineHolder lh : langExt.astRedirectBlock.lines) {
				ret = (Type)lh.accept(this);
			}
			ArrayList<CapMaskedErrs> caps = this.getmaskedErrors();
			if(!caps.isEmpty()) {
				this.applyMaskedErrors(caps, langExtName + ": ");
				ret=ScopeAndTypeChecker.const_object;
			}
			
			
			return langExt.setTaggedType(ret);
		}
		
		return ScopeAndTypeChecker.const_object;//return object or void?
	}
	
}	
